{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport './media/tree.css';\nimport { dispose, Disposable, toDisposable, DisposableStore } from '../../../common/lifecycle.js';\nimport { List, mightProducePrintableCharacter, MouseController } from '../list/listWidget.js';\nimport { append, $, toggleClass, getDomNodePagePosition, removeClass, addClass, hasClass, createStyleSheet, clearNode } from '../../dom.js';\nimport { Event, Relay, Emitter, EventBufferer } from '../../../common/event.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { StaticDND, DragAndDropData } from '../../dnd.js';\nimport { range, equals, distinctES6 } from '../../../common/arrays.js';\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { domEvent } from '../../event.js';\nimport { fuzzyScore, FuzzyScore } from '../../../common/filters.js';\nimport { getVisibleState, isFilterResult } from './indexTreeModel.js';\nimport { localize } from '../../../../nls.js';\nimport { disposableTimeout } from '../../../common/async.js';\nimport { isMacintosh } from '../../../common/platform.js';\nimport { values } from '../../../common/map.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { SetMap } from '../../../common/collections.js';\n\nfunction asTreeDragAndDropData(data) {\n  if (data instanceof ElementsDragAndDropData) {\n    var nodes = data.elements;\n    return new ElementsDragAndDropData(nodes.map(function (node) {\n      return node.element;\n    }));\n  }\n\n  return data;\n}\n\nvar TreeNodeListDragAndDrop =\n/** @class */\nfunction () {\n  function TreeNodeListDragAndDrop(modelProvider, dnd) {\n    this.modelProvider = modelProvider;\n    this.dnd = dnd;\n    this.autoExpandDisposable = Disposable.None;\n  }\n\n  TreeNodeListDragAndDrop.prototype.getDragURI = function (node) {\n    return this.dnd.getDragURI(node.element);\n  };\n\n  TreeNodeListDragAndDrop.prototype.getDragLabel = function (nodes) {\n    if (this.dnd.getDragLabel) {\n      return this.dnd.getDragLabel(nodes.map(function (node) {\n        return node.element;\n      }));\n    }\n\n    return undefined;\n  };\n\n  TreeNodeListDragAndDrop.prototype.onDragStart = function (data, originalEvent) {\n    if (this.dnd.onDragStart) {\n      this.dnd.onDragStart(asTreeDragAndDropData(data), originalEvent);\n    }\n  };\n\n  TreeNodeListDragAndDrop.prototype.onDragOver = function (data, targetNode, targetIndex, originalEvent, raw) {\n    var _this = this;\n\n    if (raw === void 0) {\n      raw = true;\n    }\n\n    var result = this.dnd.onDragOver(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    var didChangeAutoExpandNode = this.autoExpandNode !== targetNode;\n\n    if (didChangeAutoExpandNode) {\n      this.autoExpandDisposable.dispose();\n      this.autoExpandNode = targetNode;\n    }\n\n    if (typeof targetNode === 'undefined') {\n      return result;\n    }\n\n    if (didChangeAutoExpandNode && typeof result !== 'boolean' && result.autoExpand) {\n      this.autoExpandDisposable = disposableTimeout(function () {\n        var model = _this.modelProvider();\n\n        var ref = model.getNodeLocation(targetNode);\n\n        if (model.isCollapsed(ref)) {\n          model.setCollapsed(ref, false);\n        }\n\n        _this.autoExpandNode = undefined;\n      }, 500);\n    }\n\n    if (typeof result === 'boolean' || !result.accept || typeof result.bubble === 'undefined') {\n      if (!raw) {\n        var accept = typeof result === 'boolean' ? result : result.accept;\n        var effect = typeof result === 'boolean' ? undefined : result.effect;\n        return {\n          accept: accept,\n          effect: effect,\n          feedback: [targetIndex]\n        };\n      }\n\n      return result;\n    }\n\n    if (result.bubble === 1\n    /* Up */\n    ) {\n        var parentNode = targetNode.parent;\n        var model_1 = this.modelProvider();\n        var parentIndex = parentNode && model_1.getListIndex(model_1.getNodeLocation(parentNode));\n        return this.onDragOver(data, parentNode, parentIndex, originalEvent, false);\n      }\n\n    var model = this.modelProvider();\n    var ref = model.getNodeLocation(targetNode);\n    var start = model.getListIndex(ref);\n    var length = model.getListRenderCount(ref);\n    return __assign({}, result, {\n      feedback: range(start, start + length)\n    });\n  };\n\n  TreeNodeListDragAndDrop.prototype.drop = function (data, targetNode, targetIndex, originalEvent) {\n    this.autoExpandDisposable.dispose();\n    this.autoExpandNode = undefined;\n    this.dnd.drop(asTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n  };\n\n  return TreeNodeListDragAndDrop;\n}();\n\nfunction asListOptions(modelProvider, options) {\n  return options && __assign({}, options, {\n    identityProvider: options.identityProvider && {\n      getId: function (el) {\n        return options.identityProvider.getId(el.element);\n      }\n    },\n    dnd: options.dnd && new TreeNodeListDragAndDrop(modelProvider, options.dnd),\n    multipleSelectionController: options.multipleSelectionController && {\n      isSelectionSingleChangeEvent: function (e) {\n        return options.multipleSelectionController.isSelectionSingleChangeEvent(__assign({}, e, {\n          element: e.element\n        }));\n      },\n      isSelectionRangeChangeEvent: function (e) {\n        return options.multipleSelectionController.isSelectionRangeChangeEvent(__assign({}, e, {\n          element: e.element\n        }));\n      }\n    },\n    accessibilityProvider: options.accessibilityProvider && {\n      getAriaLabel: function (e) {\n        return options.accessibilityProvider.getAriaLabel(e.element);\n      },\n      getAriaLevel: function (node) {\n        return node.depth;\n      }\n    },\n    keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && __assign({}, options.keyboardNavigationLabelProvider, {\n      getKeyboardNavigationLabel: function (node) {\n        return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(node.element);\n      }\n    }),\n    enableKeyboardNavigation: options.simpleKeyboardNavigation,\n    ariaProvider: {\n      getSetSize: function (node) {\n        return node.parent.visibleChildrenCount;\n      },\n      getPosInSet: function (node) {\n        return node.visibleChildIndex + 1;\n      }\n    }\n  });\n}\n\nvar ComposedTreeDelegate =\n/** @class */\nfunction () {\n  function ComposedTreeDelegate(delegate) {\n    this.delegate = delegate;\n  }\n\n  ComposedTreeDelegate.prototype.getHeight = function (element) {\n    return this.delegate.getHeight(element.element);\n  };\n\n  ComposedTreeDelegate.prototype.getTemplateId = function (element) {\n    return this.delegate.getTemplateId(element.element);\n  };\n\n  ComposedTreeDelegate.prototype.hasDynamicHeight = function (element) {\n    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(element.element);\n  };\n\n  ComposedTreeDelegate.prototype.setDynamicHeight = function (element, height) {\n    if (this.delegate.setDynamicHeight) {\n      this.delegate.setDynamicHeight(element.element, height);\n    }\n  };\n\n  return ComposedTreeDelegate;\n}();\n\nexport { ComposedTreeDelegate };\nexport var RenderIndentGuides;\n\n(function (RenderIndentGuides) {\n  RenderIndentGuides[\"None\"] = \"none\";\n  RenderIndentGuides[\"OnHover\"] = \"onHover\";\n  RenderIndentGuides[\"Always\"] = \"always\";\n})(RenderIndentGuides || (RenderIndentGuides = {}));\n\nvar EventCollection =\n/** @class */\nfunction () {\n  function EventCollection(onDidChange, _elements) {\n    var _this = this;\n\n    if (_elements === void 0) {\n      _elements = [];\n    }\n\n    this.onDidChange = onDidChange;\n    this._elements = _elements;\n    this.disposables = new DisposableStore();\n    onDidChange(function (e) {\n      return _this._elements = e;\n    }, null, this.disposables);\n  }\n\n  Object.defineProperty(EventCollection.prototype, \"elements\", {\n    get: function () {\n      return this._elements;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  EventCollection.prototype.dispose = function () {\n    this.disposables.dispose();\n  };\n\n  return EventCollection;\n}();\n\nvar TreeRenderer =\n/** @class */\nfunction () {\n  function TreeRenderer(renderer, onDidChangeCollapseState, activeNodes, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.renderer = renderer;\n    this.activeNodes = activeNodes;\n    this.renderedElements = new Map();\n    this.renderedNodes = new Map();\n    this.indent = TreeRenderer.DefaultIndent;\n    this._renderIndentGuides = RenderIndentGuides.None;\n    this.renderedIndentGuides = new SetMap();\n    this.activeIndentNodes = new Set();\n    this.indentGuidesDisposable = Disposable.None;\n    this.disposables = [];\n    this.templateId = renderer.templateId;\n    this.updateOptions(options);\n    Event.map(onDidChangeCollapseState, function (e) {\n      return e.node;\n    })(this.onDidChangeNodeTwistieState, this, this.disposables);\n\n    if (renderer.onDidChangeTwistieState) {\n      renderer.onDidChangeTwistieState(this.onDidChangeTwistieState, this, this.disposables);\n    }\n  }\n\n  TreeRenderer.prototype.updateOptions = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (typeof options.indent !== 'undefined') {\n      this.indent = clamp(options.indent, 0, 40);\n    }\n\n    if (typeof options.renderIndentGuides !== 'undefined') {\n      var renderIndentGuides = options.renderIndentGuides;\n\n      if (renderIndentGuides !== this._renderIndentGuides) {\n        this._renderIndentGuides = renderIndentGuides;\n\n        if (renderIndentGuides) {\n          var disposables = new DisposableStore();\n          this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, disposables);\n          this.indentGuidesDisposable = disposables;\n\n          this._onDidChangeActiveNodes(this.activeNodes.elements);\n        } else {\n          this.indentGuidesDisposable.dispose();\n        }\n      }\n    }\n  };\n\n  TreeRenderer.prototype.renderTemplate = function (container) {\n    var el = append(container, $('.monaco-tl-row'));\n    var indent = append(el, $('.monaco-tl-indent'));\n    var twistie = append(el, $('.monaco-tl-twistie'));\n    var contents = append(el, $('.monaco-tl-contents'));\n    var templateData = this.renderer.renderTemplate(contents);\n    return {\n      container: container,\n      indent: indent,\n      twistie: twistie,\n      indentGuidesDisposable: Disposable.None,\n      templateData: templateData\n    };\n  };\n\n  TreeRenderer.prototype.renderElement = function (node, index, templateData, height) {\n    if (typeof height === 'number') {\n      this.renderedNodes.set(node, {\n        templateData: templateData,\n        height: height\n      });\n      this.renderedElements.set(node.element, node);\n    }\n\n    var indent = TreeRenderer.DefaultIndent + (node.depth - 1) * this.indent;\n    templateData.twistie.style.marginLeft = indent + \"px\";\n    templateData.indent.style.width = indent + this.indent - 16 + \"px\";\n    this.renderTwistie(node, templateData);\n\n    if (typeof height === 'number') {\n      this.renderIndentGuides(node, templateData);\n    }\n\n    this.renderer.renderElement(node, index, templateData.templateData, height);\n  };\n\n  TreeRenderer.prototype.disposeElement = function (node, index, templateData, height) {\n    templateData.indentGuidesDisposable.dispose();\n\n    if (this.renderer.disposeElement) {\n      this.renderer.disposeElement(node, index, templateData.templateData, height);\n    }\n\n    if (typeof height === 'number') {\n      this.renderedNodes.delete(node);\n      this.renderedElements.delete(node.element);\n    }\n  };\n\n  TreeRenderer.prototype.disposeTemplate = function (templateData) {\n    this.renderer.disposeTemplate(templateData.templateData);\n  };\n\n  TreeRenderer.prototype.onDidChangeTwistieState = function (element) {\n    var node = this.renderedElements.get(element);\n\n    if (!node) {\n      return;\n    }\n\n    this.onDidChangeNodeTwistieState(node);\n  };\n\n  TreeRenderer.prototype.onDidChangeNodeTwistieState = function (node) {\n    var data = this.renderedNodes.get(node);\n\n    if (!data) {\n      return;\n    }\n\n    this.renderTwistie(node, data.templateData);\n\n    this._onDidChangeActiveNodes(this.activeNodes.elements);\n\n    this.renderIndentGuides(node, data.templateData);\n  };\n\n  TreeRenderer.prototype.renderTwistie = function (node, templateData) {\n    if (this.renderer.renderTwistie) {\n      this.renderer.renderTwistie(node.element, templateData.twistie);\n    }\n\n    toggleClass(templateData.twistie, 'collapsible', node.collapsible);\n    toggleClass(templateData.twistie, 'collapsed', node.collapsible && node.collapsed);\n\n    if (node.collapsible) {\n      templateData.container.setAttribute('aria-expanded', String(!node.collapsed));\n    } else {\n      templateData.container.removeAttribute('aria-expanded');\n    }\n  };\n\n  TreeRenderer.prototype.renderIndentGuides = function (target, templateData) {\n    var _this = this;\n\n    clearNode(templateData.indent);\n    templateData.indentGuidesDisposable.dispose();\n\n    if (this._renderIndentGuides === RenderIndentGuides.None) {\n      return;\n    }\n\n    var disposableStore = new DisposableStore();\n    var node = target;\n\n    var _loop_1 = function () {\n      var parent_1 = node.parent;\n      var guide = $('.indent-guide', {\n        style: \"width: \" + this_1.indent + \"px\"\n      });\n\n      if (this_1.activeIndentNodes.has(parent_1)) {\n        addClass(guide, 'active');\n      }\n\n      if (templateData.indent.childElementCount === 0) {\n        templateData.indent.appendChild(guide);\n      } else {\n        templateData.indent.insertBefore(guide, templateData.indent.firstElementChild);\n      }\n\n      this_1.renderedIndentGuides.add(parent_1, guide);\n      disposableStore.add(toDisposable(function () {\n        return _this.renderedIndentGuides.delete(parent_1, guide);\n      }));\n      node = parent_1;\n    };\n\n    var this_1 = this;\n\n    while (node.parent && node.parent.parent) {\n      _loop_1();\n    }\n\n    templateData.indentGuidesDisposable = disposableStore;\n  };\n\n  TreeRenderer.prototype._onDidChangeActiveNodes = function (nodes) {\n    var _this = this;\n\n    if (this._renderIndentGuides === RenderIndentGuides.None) {\n      return;\n    }\n\n    var set = new Set();\n    nodes.forEach(function (node) {\n      if (node.collapsible && node.children.length > 0 && !node.collapsed) {\n        set.add(node);\n      } else if (node.parent) {\n        set.add(node.parent);\n      }\n    });\n    this.activeIndentNodes.forEach(function (node) {\n      if (!set.has(node)) {\n        _this.renderedIndentGuides.forEach(node, function (line) {\n          return removeClass(line, 'active');\n        });\n      }\n    });\n    set.forEach(function (node) {\n      if (!_this.activeIndentNodes.has(node)) {\n        _this.renderedIndentGuides.forEach(node, function (line) {\n          return addClass(line, 'active');\n        });\n      }\n    });\n    this.activeIndentNodes = set;\n  };\n\n  TreeRenderer.prototype.dispose = function () {\n    this.renderedNodes.clear();\n    this.renderedElements.clear();\n    this.indentGuidesDisposable.dispose();\n    this.disposables = dispose(this.disposables);\n  };\n\n  TreeRenderer.DefaultIndent = 8;\n  return TreeRenderer;\n}();\n\nvar TypeFilter =\n/** @class */\nfunction () {\n  function TypeFilter(tree, keyboardNavigationLabelProvider, _filter) {\n    this.tree = tree;\n    this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n    this._filter = _filter;\n    this._totalCount = 0;\n    this._matchCount = 0;\n    this._pattern = '';\n    this._lowercasePattern = '';\n    this.disposables = [];\n    tree.onWillRefilter(this.reset, this, this.disposables);\n  }\n\n  Object.defineProperty(TypeFilter.prototype, \"totalCount\", {\n    get: function () {\n      return this._totalCount;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TypeFilter.prototype, \"matchCount\", {\n    get: function () {\n      return this._matchCount;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TypeFilter.prototype, \"pattern\", {\n    set: function (pattern) {\n      this._pattern = pattern;\n      this._lowercasePattern = pattern.toLowerCase();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TypeFilter.prototype.filter = function (element, parentVisibility) {\n    if (this._filter) {\n      var result = this._filter.filter(element, parentVisibility);\n\n      if (this.tree.options.simpleKeyboardNavigation) {\n        return result;\n      }\n\n      var visibility = void 0;\n\n      if (typeof result === 'boolean') {\n        visibility = result ? 1\n        /* Visible */\n        : 0\n        /* Hidden */\n        ;\n      } else if (isFilterResult(result)) {\n        visibility = getVisibleState(result.visibility);\n      } else {\n        visibility = result;\n      }\n\n      if (visibility === 0\n      /* Hidden */\n      ) {\n          return false;\n        }\n    }\n\n    this._totalCount++;\n\n    if (this.tree.options.simpleKeyboardNavigation || !this._pattern) {\n      this._matchCount++;\n      return {\n        data: FuzzyScore.Default,\n        visibility: true\n      };\n    }\n\n    var label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(element);\n    var labelStr = label && label.toString();\n\n    if (typeof labelStr === 'undefined') {\n      return {\n        data: FuzzyScore.Default,\n        visibility: true\n      };\n    }\n\n    var score = fuzzyScore(this._pattern, this._lowercasePattern, 0, labelStr, labelStr.toLowerCase(), 0, true);\n\n    if (!score) {\n      if (this.tree.options.filterOnType) {\n        return 2\n        /* Recurse */\n        ;\n      } else {\n        return {\n          data: FuzzyScore.Default,\n          visibility: true\n        };\n      } // DEMO: smarter filter ?\n      // return parentVisibility === TreeVisibility.Visible ? true : TreeVisibility.Recurse;\n\n    }\n\n    this._matchCount++;\n    return {\n      data: score,\n      visibility: true\n    };\n  };\n\n  TypeFilter.prototype.reset = function () {\n    this._totalCount = 0;\n    this._matchCount = 0;\n  };\n\n  TypeFilter.prototype.dispose = function () {\n    this.disposables = dispose(this.disposables);\n  };\n\n  return TypeFilter;\n}();\n\nvar TypeFilterController =\n/** @class */\nfunction () {\n  function TypeFilterController(tree, model, view, filter, keyboardNavigationLabelProvider) {\n    this.tree = tree;\n    this.view = view;\n    this.filter = filter;\n    this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n    this._enabled = false;\n    this._pattern = '';\n    this._empty = false;\n    this._onDidChangeEmptyState = new Emitter();\n    this.positionClassName = 'ne';\n    this.automaticKeyboardNavigation = true;\n    this.triggered = false;\n    this._onDidChangePattern = new Emitter();\n    this.enabledDisposables = [];\n    this.disposables = [];\n    this.domNode = $(\".monaco-list-type-filter.\" + this.positionClassName);\n    this.domNode.draggable = true;\n    domEvent(this.domNode, 'dragstart')(this.onDragStart, this, this.disposables);\n    this.messageDomNode = append(view.getHTMLElement(), $(\".monaco-list-type-filter-message\"));\n    this.labelDomNode = append(this.domNode, $('span.label'));\n    var controls = append(this.domNode, $('.controls'));\n    this._filterOnType = !!tree.options.filterOnType;\n    this.filterOnTypeDomNode = append(controls, $('input.filter'));\n    this.filterOnTypeDomNode.type = 'checkbox';\n    this.filterOnTypeDomNode.checked = this._filterOnType;\n    this.filterOnTypeDomNode.tabIndex = -1;\n    this.updateFilterOnTypeTitle();\n    domEvent(this.filterOnTypeDomNode, 'input')(this.onDidChangeFilterOnType, this, this.disposables);\n    this.clearDomNode = append(controls, $('button.clear'));\n    this.clearDomNode.tabIndex = -1;\n    this.clearDomNode.title = localize('clear', \"Clear\");\n    this.keyboardNavigationEventFilter = tree.options.keyboardNavigationEventFilter;\n    model.onDidSplice(this.onDidSpliceModel, this, this.disposables);\n    this.updateOptions(tree.options);\n  }\n\n  Object.defineProperty(TypeFilterController.prototype, \"enabled\", {\n    get: function () {\n      return this._enabled;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TypeFilterController.prototype, \"pattern\", {\n    get: function () {\n      return this._pattern;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TypeFilterController.prototype, \"filterOnType\", {\n    get: function () {\n      return this._filterOnType;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TypeFilterController.prototype.updateOptions = function (options) {\n    if (options.simpleKeyboardNavigation) {\n      this.disable();\n    } else {\n      this.enable();\n    }\n\n    if (typeof options.filterOnType !== 'undefined') {\n      this._filterOnType = !!options.filterOnType;\n      this.filterOnTypeDomNode.checked = this._filterOnType;\n    }\n\n    if (typeof options.automaticKeyboardNavigation !== 'undefined') {\n      this.automaticKeyboardNavigation = options.automaticKeyboardNavigation;\n    }\n\n    this.tree.refilter();\n    this.render();\n\n    if (!this.automaticKeyboardNavigation) {\n      this.onEventOrInput('');\n    }\n  };\n\n  TypeFilterController.prototype.enable = function () {\n    var _this = this;\n\n    if (this._enabled) {\n      return;\n    }\n\n    var isPrintableCharEvent = this.keyboardNavigationLabelProvider.mightProducePrintableCharacter ? function (e) {\n      return _this.keyboardNavigationLabelProvider.mightProducePrintableCharacter(e);\n    } : function (e) {\n      return mightProducePrintableCharacter(e);\n    };\n    var onKeyDown = Event.chain(domEvent(this.view.getHTMLElement(), 'keydown')).filter(function (e) {\n      return !isInputElement(e.target) || e.target === _this.filterOnTypeDomNode;\n    }).map(function (e) {\n      return new StandardKeyboardEvent(e);\n    }).filter(this.keyboardNavigationEventFilter || function () {\n      return true;\n    }).filter(function () {\n      return _this.automaticKeyboardNavigation || _this.triggered;\n    }).filter(function (e) {\n      return isPrintableCharEvent(e) || (_this.pattern.length > 0 || _this.triggered) && (e.keyCode === 9\n      /* Escape */\n      || e.keyCode === 1\n      /* Backspace */\n      ) && !e.altKey && !e.ctrlKey && !e.metaKey || e.keyCode === 1\n      /* Backspace */\n      && (isMacintosh ? e.altKey && !e.metaKey : e.ctrlKey) && !e.shiftKey;\n    }).forEach(function (e) {\n      e.stopPropagation();\n      e.preventDefault();\n    }).event;\n    var onClear = domEvent(this.clearDomNode, 'click');\n    Event.chain(Event.any(onKeyDown, onClear)).event(this.onEventOrInput, this, this.enabledDisposables);\n    this.filter.pattern = '';\n    this.tree.refilter();\n    this.render();\n    this._enabled = true;\n    this.triggered = false;\n  };\n\n  TypeFilterController.prototype.disable = function () {\n    if (!this._enabled) {\n      return;\n    }\n\n    this.domNode.remove();\n    this.enabledDisposables = dispose(this.enabledDisposables);\n    this.tree.refilter();\n    this.render();\n    this._enabled = false;\n    this.triggered = false;\n  };\n\n  TypeFilterController.prototype.onEventOrInput = function (e) {\n    if (typeof e === 'string') {\n      this.onInput(e);\n    } else if (e instanceof MouseEvent || e.keyCode === 9\n    /* Escape */\n    || e.keyCode === 1\n    /* Backspace */\n    && (isMacintosh ? e.altKey : e.ctrlKey)) {\n      this.onInput('');\n    } else if (e.keyCode === 1\n    /* Backspace */\n    ) {\n        this.onInput(this.pattern.length === 0 ? '' : this.pattern.substr(0, this.pattern.length - 1));\n      } else {\n      this.onInput(this.pattern + e.browserEvent.key);\n    }\n  };\n\n  TypeFilterController.prototype.onInput = function (pattern) {\n    var container = this.view.getHTMLElement();\n\n    if (pattern && !this.domNode.parentElement) {\n      container.append(this.domNode);\n    } else if (!pattern && this.domNode.parentElement) {\n      this.domNode.remove();\n      this.tree.domFocus();\n    }\n\n    this._pattern = pattern;\n\n    this._onDidChangePattern.fire(pattern);\n\n    this.filter.pattern = pattern;\n    this.tree.refilter();\n\n    if (pattern) {\n      this.tree.focusNext(0, true, undefined, function (node) {\n        return !FuzzyScore.isDefault(node.filterData);\n      });\n    }\n\n    var focus = this.tree.getFocus();\n\n    if (focus.length > 0) {\n      var element = focus[0];\n\n      if (this.tree.getRelativeTop(element) === null) {\n        this.tree.reveal(element, 0.5);\n      }\n    }\n\n    this.render();\n\n    if (!pattern) {\n      this.triggered = false;\n    }\n  };\n\n  TypeFilterController.prototype.onDragStart = function () {\n    var _this = this;\n\n    var container = this.view.getHTMLElement();\n    var left = getDomNodePagePosition(container).left;\n    var containerWidth = container.clientWidth;\n    var midContainerWidth = containerWidth / 2;\n    var width = this.domNode.clientWidth;\n    var disposables = [];\n    var positionClassName = this.positionClassName;\n\n    var updatePosition = function () {\n      switch (positionClassName) {\n        case 'nw':\n          _this.domNode.style.top = \"4px\";\n          _this.domNode.style.left = \"4px\";\n          break;\n\n        case 'ne':\n          _this.domNode.style.top = \"4px\";\n          _this.domNode.style.left = containerWidth - width - 6 + \"px\";\n          break;\n      }\n    };\n\n    var onDragOver = function (event) {\n      event.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)\n\n      var x = event.screenX - left;\n\n      if (event.dataTransfer) {\n        event.dataTransfer.dropEffect = 'none';\n      }\n\n      if (x < midContainerWidth) {\n        positionClassName = 'nw';\n      } else {\n        positionClassName = 'ne';\n      }\n\n      updatePosition();\n    };\n\n    var onDragEnd = function () {\n      _this.positionClassName = positionClassName;\n      _this.domNode.className = \"monaco-list-type-filter \" + _this.positionClassName;\n      _this.domNode.style.top = null;\n      _this.domNode.style.left = null;\n      dispose(disposables);\n    };\n\n    updatePosition();\n    removeClass(this.domNode, positionClassName);\n    addClass(this.domNode, 'dragging');\n    disposables.push(toDisposable(function () {\n      return removeClass(_this.domNode, 'dragging');\n    }));\n    domEvent(document, 'dragover')(onDragOver, null, disposables);\n    domEvent(this.domNode, 'dragend')(onDragEnd, null, disposables);\n    StaticDND.CurrentDragAndDropData = new DragAndDropData('vscode-ui');\n    disposables.push(toDisposable(function () {\n      return StaticDND.CurrentDragAndDropData = undefined;\n    }));\n  };\n\n  TypeFilterController.prototype.onDidSpliceModel = function () {\n    if (!this._enabled || this.pattern.length === 0) {\n      return;\n    }\n\n    this.tree.refilter();\n    this.render();\n  };\n\n  TypeFilterController.prototype.onDidChangeFilterOnType = function () {\n    this.tree.updateOptions({\n      filterOnType: this.filterOnTypeDomNode.checked\n    });\n    this.tree.refilter();\n    this.tree.domFocus();\n    this.render();\n    this.updateFilterOnTypeTitle();\n  };\n\n  TypeFilterController.prototype.updateFilterOnTypeTitle = function () {\n    if (this.filterOnType) {\n      this.filterOnTypeDomNode.title = localize('disable filter on type', \"Disable Filter on Type\");\n    } else {\n      this.filterOnTypeDomNode.title = localize('enable filter on type', \"Enable Filter on Type\");\n    }\n  };\n\n  TypeFilterController.prototype.render = function () {\n    var noMatches = this.filter.totalCount > 0 && this.filter.matchCount === 0;\n\n    if (this.pattern && this.tree.options.filterOnType && noMatches) {\n      this.messageDomNode.textContent = localize('empty', \"No elements found\");\n      this._empty = true;\n    } else {\n      this.messageDomNode.innerHTML = '';\n      this._empty = false;\n    }\n\n    toggleClass(this.domNode, 'no-matches', noMatches);\n    this.domNode.title = localize('found', \"Matched {0} out of {1} elements\", this.filter.matchCount, this.filter.totalCount);\n    this.labelDomNode.textContent = this.pattern.length > 16 ? '…' + this.pattern.substr(this.pattern.length - 16) : this.pattern;\n\n    this._onDidChangeEmptyState.fire(this._empty);\n  };\n\n  TypeFilterController.prototype.shouldAllowFocus = function (node) {\n    if (!this.enabled || !this.pattern || this.filterOnType) {\n      return true;\n    }\n\n    if (this.filter.totalCount > 0 && this.filter.matchCount <= 1) {\n      return true;\n    }\n\n    return !FuzzyScore.isDefault(node.filterData);\n  };\n\n  TypeFilterController.prototype.dispose = function () {\n    this.disable();\n\n    this._onDidChangePattern.dispose();\n\n    this.disposables = dispose(this.disposables);\n  };\n\n  return TypeFilterController;\n}();\n\nfunction isInputElement(e) {\n  return e.tagName === 'INPUT' || e.tagName === 'TEXTAREA';\n}\n\nfunction asTreeEvent(event) {\n  return {\n    elements: event.elements.map(function (node) {\n      return node.element;\n    }),\n    browserEvent: event.browserEvent\n  };\n}\n\nfunction dfs(node, fn) {\n  fn(node);\n  node.children.forEach(function (child) {\n    return dfs(child, fn);\n  });\n}\n/**\n * The trait concept needs to exist at the tree level, because collapsed\n * tree nodes will not be known by the list.\n */\n\n\nvar Trait =\n/** @class */\nfunction () {\n  function Trait(identityProvider) {\n    this.identityProvider = identityProvider;\n    this.nodes = [];\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n  }\n\n  Object.defineProperty(Trait.prototype, \"nodeSet\", {\n    get: function () {\n      if (!this._nodeSet) {\n        this._nodeSet = this.createNodeSet();\n      }\n\n      return this._nodeSet;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Trait.prototype.set = function (nodes, browserEvent) {\n    if (equals(this.nodes, nodes)) {\n      return;\n    }\n\n    this._set(nodes, false, browserEvent);\n  };\n\n  Trait.prototype._set = function (nodes, silent, browserEvent) {\n    this.nodes = nodes.slice();\n    this.elements = undefined;\n    this._nodeSet = undefined;\n\n    if (!silent) {\n      var that_1 = this;\n\n      this._onDidChange.fire({\n        get elements() {\n          return that_1.get();\n        },\n\n        browserEvent: browserEvent\n      });\n    }\n  };\n\n  Trait.prototype.get = function () {\n    if (!this.elements) {\n      this.elements = this.nodes.map(function (node) {\n        return node.element;\n      });\n    }\n\n    return this.elements.slice();\n  };\n\n  Trait.prototype.getNodes = function () {\n    return this.nodes;\n  };\n\n  Trait.prototype.has = function (node) {\n    return this.nodeSet.has(node);\n  };\n\n  Trait.prototype.onDidModelSplice = function (_a) {\n    var _this = this;\n\n    var insertedNodes = _a.insertedNodes,\n        deletedNodes = _a.deletedNodes;\n\n    if (!this.identityProvider) {\n      var set_1 = this.createNodeSet();\n\n      var visit_1 = function (node) {\n        return set_1.delete(node);\n      };\n\n      deletedNodes.forEach(function (node) {\n        return dfs(node, visit_1);\n      });\n      this.set(values(set_1));\n      return;\n    }\n\n    var deletedNodesIdSet = new Set();\n\n    var deletedNodesVisitor = function (node) {\n      return deletedNodesIdSet.add(_this.identityProvider.getId(node.element).toString());\n    };\n\n    deletedNodes.forEach(function (node) {\n      return dfs(node, deletedNodesVisitor);\n    });\n    var insertedNodesMap = new Map();\n\n    var insertedNodesVisitor = function (node) {\n      return insertedNodesMap.set(_this.identityProvider.getId(node.element).toString(), node);\n    };\n\n    insertedNodes.forEach(function (node) {\n      return dfs(node, insertedNodesVisitor);\n    });\n    var nodes = [];\n    var silent = true;\n\n    for (var _i = 0, _b = this.nodes; _i < _b.length; _i++) {\n      var node = _b[_i];\n      var id = this.identityProvider.getId(node.element).toString();\n      var wasDeleted = deletedNodesIdSet.has(id);\n\n      if (!wasDeleted) {\n        nodes.push(node);\n      } else {\n        var insertedNode = insertedNodesMap.get(id);\n\n        if (insertedNode) {\n          nodes.push(insertedNode);\n        } else {\n          silent = false;\n        }\n      }\n    }\n\n    this._set(nodes, silent);\n  };\n\n  Trait.prototype.createNodeSet = function () {\n    var set = new Set();\n\n    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n      var node = _a[_i];\n      set.add(node);\n    }\n\n    return set;\n  };\n\n  return Trait;\n}();\n\nvar TreeNodeListMouseController =\n/** @class */\nfunction (_super) {\n  __extends(TreeNodeListMouseController, _super);\n\n  function TreeNodeListMouseController(list, tree) {\n    var _this = _super.call(this, list) || this;\n\n    _this.tree = tree;\n    return _this;\n  }\n\n  TreeNodeListMouseController.prototype.onPointer = function (e) {\n    if (isInputElement(e.browserEvent.target)) {\n      return;\n    }\n\n    var node = e.element;\n\n    if (!node) {\n      return _super.prototype.onPointer.call(this, e);\n    }\n\n    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e)) {\n      return _super.prototype.onPointer.call(this, e);\n    }\n\n    var onTwistie = hasClass(e.browserEvent.target, 'monaco-tl-twistie');\n\n    if (!this.tree.openOnSingleClick && e.browserEvent.detail !== 2 && !onTwistie) {\n      return _super.prototype.onPointer.call(this, e);\n    }\n\n    var expandOnlyOnTwistieClick = false;\n\n    if (typeof this.tree.expandOnlyOnTwistieClick === 'function') {\n      expandOnlyOnTwistieClick = this.tree.expandOnlyOnTwistieClick(node.element);\n    } else {\n      expandOnlyOnTwistieClick = !!this.tree.expandOnlyOnTwistieClick;\n    }\n\n    if (expandOnlyOnTwistieClick && !onTwistie) {\n      return _super.prototype.onPointer.call(this, e);\n    }\n\n    var model = this.tree.model; // internal\n\n    var location = model.getNodeLocation(node);\n    var recursive = e.browserEvent.altKey;\n    model.setCollapsed(location, undefined, recursive);\n\n    if (expandOnlyOnTwistieClick && onTwistie) {\n      return;\n    }\n\n    _super.prototype.onPointer.call(this, e);\n  };\n\n  TreeNodeListMouseController.prototype.onDoubleClick = function (e) {\n    var onTwistie = hasClass(e.browserEvent.target, 'monaco-tl-twistie');\n\n    if (onTwistie) {\n      return;\n    }\n\n    _super.prototype.onDoubleClick.call(this, e);\n  };\n\n  return TreeNodeListMouseController;\n}(MouseController);\n/**\n * We use this List subclass to restore selection and focus as nodes\n * get rendered in the list, possibly due to a node expand() call.\n */\n\n\nvar TreeNodeList =\n/** @class */\nfunction (_super) {\n  __extends(TreeNodeList, _super);\n\n  function TreeNodeList(container, virtualDelegate, renderers, focusTrait, selectionTrait, options) {\n    var _this = _super.call(this, container, virtualDelegate, renderers, options) || this;\n\n    _this.focusTrait = focusTrait;\n    _this.selectionTrait = selectionTrait;\n    return _this;\n  }\n\n  TreeNodeList.prototype.createMouseController = function (options) {\n    return new TreeNodeListMouseController(this, options.tree);\n  };\n\n  TreeNodeList.prototype.splice = function (start, deleteCount, elements) {\n    var _this = this;\n\n    if (elements === void 0) {\n      elements = [];\n    }\n\n    _super.prototype.splice.call(this, start, deleteCount, elements);\n\n    if (elements.length === 0) {\n      return;\n    }\n\n    var additionalFocus = [];\n    var additionalSelection = [];\n    elements.forEach(function (node, index) {\n      if (_this.focusTrait.has(node)) {\n        additionalFocus.push(start + index);\n      }\n\n      if (_this.selectionTrait.has(node)) {\n        additionalSelection.push(start + index);\n      }\n    });\n\n    if (additionalFocus.length > 0) {\n      _super.prototype.setFocus.call(this, distinctES6(_super.prototype.getFocus.call(this).concat(additionalFocus)));\n    }\n\n    if (additionalSelection.length > 0) {\n      _super.prototype.setSelection.call(this, distinctES6(_super.prototype.getSelection.call(this).concat(additionalSelection)));\n    }\n  };\n\n  TreeNodeList.prototype.setFocus = function (indexes, browserEvent, fromAPI) {\n    var _this = this;\n\n    if (fromAPI === void 0) {\n      fromAPI = false;\n    }\n\n    _super.prototype.setFocus.call(this, indexes, browserEvent);\n\n    if (!fromAPI) {\n      this.focusTrait.set(indexes.map(function (i) {\n        return _this.element(i);\n      }), browserEvent);\n    }\n  };\n\n  TreeNodeList.prototype.setSelection = function (indexes, browserEvent, fromAPI) {\n    var _this = this;\n\n    if (fromAPI === void 0) {\n      fromAPI = false;\n    }\n\n    _super.prototype.setSelection.call(this, indexes, browserEvent);\n\n    if (!fromAPI) {\n      this.selectionTrait.set(indexes.map(function (i) {\n        return _this.element(i);\n      }), browserEvent);\n    }\n  };\n\n  return TreeNodeList;\n}(List);\n\nvar AbstractTree =\n/** @class */\nfunction () {\n  function AbstractTree(container, delegate, renderers, _options) {\n    var _a;\n\n    var _this = this;\n\n    if (_options === void 0) {\n      _options = {};\n    }\n\n    this._options = _options;\n    this.eventBufferer = new EventBufferer();\n    this.disposables = [];\n    this._onWillRefilter = new Emitter();\n    this.onWillRefilter = this._onWillRefilter.event;\n    this._onDidUpdateOptions = new Emitter();\n    var treeDelegate = new ComposedTreeDelegate(delegate);\n    var onDidChangeCollapseStateRelay = new Relay();\n    var onDidChangeActiveNodes = new Relay();\n    var activeNodes = new EventCollection(onDidChangeActiveNodes.event);\n    this.disposables.push(activeNodes);\n    this.renderers = renderers.map(function (r) {\n      return new TreeRenderer(r, onDidChangeCollapseStateRelay.event, activeNodes, _options);\n    });\n\n    (_a = this.disposables).push.apply(_a, this.renderers);\n\n    var filter;\n\n    if (_options.keyboardNavigationLabelProvider) {\n      filter = new TypeFilter(this, _options.keyboardNavigationLabelProvider, _options.filter);\n      _options = __assign({}, _options, {\n        filter: filter\n      }); // TODO need typescript help here\n\n      this.disposables.push(filter);\n    }\n\n    this.focus = new Trait(_options.identityProvider);\n    this.selection = new Trait(_options.identityProvider);\n    this.view = new TreeNodeList(container, treeDelegate, this.renderers, this.focus, this.selection, __assign({}, asListOptions(function () {\n      return _this.model;\n    }, _options), {\n      tree: this\n    }));\n    this.model = this.createModel(this.view, _options);\n    onDidChangeCollapseStateRelay.input = this.model.onDidChangeCollapseState;\n    this.model.onDidSplice(function (e) {\n      _this.focus.onDidModelSplice(e);\n\n      _this.selection.onDidModelSplice(e);\n    }, null, this.disposables);\n    onDidChangeActiveNodes.input = Event.map(Event.any(this.focus.onDidChange, this.selection.onDidChange, this.model.onDidSplice), function () {\n      return _this.focus.getNodes().concat(_this.selection.getNodes());\n    });\n\n    if (_options.keyboardSupport !== false) {\n      var onKeyDown = Event.chain(this.view.onKeyDown).filter(function (e) {\n        return !isInputElement(e.target);\n      }).map(function (e) {\n        return new StandardKeyboardEvent(e);\n      });\n      onKeyDown.filter(function (e) {\n        return e.keyCode === 15\n        /* LeftArrow */\n        ;\n      }).on(this.onLeftArrow, this, this.disposables);\n      onKeyDown.filter(function (e) {\n        return e.keyCode === 17\n        /* RightArrow */\n        ;\n      }).on(this.onRightArrow, this, this.disposables);\n      onKeyDown.filter(function (e) {\n        return e.keyCode === 10\n        /* Space */\n        ;\n      }).on(this.onSpace, this, this.disposables);\n    }\n\n    if (_options.keyboardNavigationLabelProvider) {\n      this.typeFilterController = new TypeFilterController(this, this.model, this.view, filter, _options.keyboardNavigationLabelProvider);\n\n      this.focusNavigationFilter = function (node) {\n        return _this.typeFilterController.shouldAllowFocus(node);\n      };\n\n      this.disposables.push(this.typeFilterController);\n    }\n\n    this.styleElement = createStyleSheet(this.view.getHTMLElement());\n    toggleClass(this.getHTMLElement(), 'always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n  }\n\n  Object.defineProperty(AbstractTree.prototype, \"onDidChangeFocus\", {\n    get: function () {\n      return this.eventBufferer.wrapEvent(this.focus.onDidChange);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AbstractTree.prototype, \"onDidChangeSelection\", {\n    get: function () {\n      return this.eventBufferer.wrapEvent(this.selection.onDidChange);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AbstractTree.prototype, \"onDidOpen\", {\n    get: function () {\n      return Event.map(this.view.onDidOpen, asTreeEvent);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AbstractTree.prototype, \"onDidFocus\", {\n    get: function () {\n      return this.view.onDidFocus;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AbstractTree.prototype, \"onDidChangeCollapseState\", {\n    get: function () {\n      return this.model.onDidChangeCollapseState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AbstractTree.prototype, \"openOnSingleClick\", {\n    get: function () {\n      return typeof this._options.openOnSingleClick === 'undefined' ? true : this._options.openOnSingleClick;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AbstractTree.prototype, \"expandOnlyOnTwistieClick\", {\n    get: function () {\n      return typeof this._options.expandOnlyOnTwistieClick === 'undefined' ? false : this._options.expandOnlyOnTwistieClick;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AbstractTree.prototype, \"onDidDispose\", {\n    get: function () {\n      return this.view.onDidDispose;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AbstractTree.prototype.updateOptions = function (optionsUpdate) {\n    if (optionsUpdate === void 0) {\n      optionsUpdate = {};\n    }\n\n    this._options = __assign({}, this._options, optionsUpdate);\n\n    for (var _i = 0, _a = this.renderers; _i < _a.length; _i++) {\n      var renderer = _a[_i];\n      renderer.updateOptions(optionsUpdate);\n    }\n\n    this.view.updateOptions({\n      enableKeyboardNavigation: this._options.simpleKeyboardNavigation,\n      automaticKeyboardNavigation: this._options.automaticKeyboardNavigation\n    });\n\n    if (this.typeFilterController) {\n      this.typeFilterController.updateOptions(this._options);\n    }\n\n    this._onDidUpdateOptions.fire(this._options);\n\n    toggleClass(this.getHTMLElement(), 'always', this._options.renderIndentGuides === RenderIndentGuides.Always);\n  };\n\n  Object.defineProperty(AbstractTree.prototype, \"options\", {\n    get: function () {\n      return this._options;\n    },\n    enumerable: true,\n    configurable: true\n  }); // Widget\n\n  AbstractTree.prototype.getHTMLElement = function () {\n    return this.view.getHTMLElement();\n  };\n\n  Object.defineProperty(AbstractTree.prototype, \"scrollTop\", {\n    get: function () {\n      return this.view.scrollTop;\n    },\n    set: function (scrollTop) {\n      this.view.scrollTop = scrollTop;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AbstractTree.prototype.domFocus = function () {\n    this.view.domFocus();\n  };\n\n  AbstractTree.prototype.layout = function (height, width) {\n    this.view.layout(height, width);\n  };\n\n  AbstractTree.prototype.style = function (styles) {\n    var suffix = \".\" + this.view.domId;\n    var content = [];\n\n    if (styles.treeIndentGuidesStroke) {\n      content.push(\".monaco-list\" + suffix + \":hover .monaco-tl-indent > .indent-guide, .monaco-list\" + suffix + \".always .monaco-tl-indent > .indent-guide  { border-color: \" + styles.treeIndentGuidesStroke.transparent(0.4) + \"; }\");\n      content.push(\".monaco-list\" + suffix + \" .monaco-tl-indent > .indent-guide.active { border-color: \" + styles.treeIndentGuidesStroke + \"; }\");\n    }\n\n    var newStyles = content.join('\\n');\n\n    if (newStyles !== this.styleElement.innerHTML) {\n      this.styleElement.innerHTML = newStyles;\n    }\n\n    this.view.style(styles);\n  }; // Tree\n\n\n  AbstractTree.prototype.getNode = function (location) {\n    return this.model.getNode(location);\n  };\n\n  AbstractTree.prototype.collapse = function (location, recursive) {\n    if (recursive === void 0) {\n      recursive = false;\n    }\n\n    return this.model.setCollapsed(location, true, recursive);\n  };\n\n  AbstractTree.prototype.expand = function (location, recursive) {\n    if (recursive === void 0) {\n      recursive = false;\n    }\n\n    return this.model.setCollapsed(location, false, recursive);\n  };\n\n  AbstractTree.prototype.isCollapsed = function (location) {\n    return this.model.isCollapsed(location);\n  };\n\n  AbstractTree.prototype.refilter = function () {\n    this._onWillRefilter.fire(undefined);\n\n    this.model.refilter();\n  };\n\n  AbstractTree.prototype.setSelection = function (elements, browserEvent) {\n    var _this = this;\n\n    var nodes = elements.map(function (e) {\n      return _this.model.getNode(e);\n    });\n    this.selection.set(nodes, browserEvent);\n    var indexes = elements.map(function (e) {\n      return _this.model.getListIndex(e);\n    }).filter(function (i) {\n      return i > -1;\n    });\n    this.view.setSelection(indexes, browserEvent, true);\n  };\n\n  AbstractTree.prototype.getSelection = function () {\n    return this.selection.get();\n  };\n\n  AbstractTree.prototype.setFocus = function (elements, browserEvent) {\n    var _this = this;\n\n    var nodes = elements.map(function (e) {\n      return _this.model.getNode(e);\n    });\n    this.focus.set(nodes, browserEvent);\n    var indexes = elements.map(function (e) {\n      return _this.model.getListIndex(e);\n    }).filter(function (i) {\n      return i > -1;\n    });\n    this.view.setFocus(indexes, browserEvent, true);\n  };\n\n  AbstractTree.prototype.focusNext = function (n, loop, browserEvent, filter) {\n    if (n === void 0) {\n      n = 1;\n    }\n\n    if (loop === void 0) {\n      loop = false;\n    }\n\n    if (filter === void 0) {\n      filter = this.focusNavigationFilter;\n    }\n\n    this.view.focusNext(n, loop, browserEvent, filter);\n  };\n\n  AbstractTree.prototype.getFocus = function () {\n    return this.focus.get();\n  };\n\n  AbstractTree.prototype.reveal = function (location, relativeTop) {\n    this.model.expandTo(location);\n    var index = this.model.getListIndex(location);\n\n    if (index === -1) {\n      return;\n    }\n\n    this.view.reveal(index, relativeTop);\n  };\n  /**\n   * Returns the relative position of an element rendered in the list.\n   * Returns `null` if the element isn't *entirely* in the visible viewport.\n   */\n\n\n  AbstractTree.prototype.getRelativeTop = function (location) {\n    var index = this.model.getListIndex(location);\n\n    if (index === -1) {\n      return null;\n    }\n\n    return this.view.getRelativeTop(index);\n  }; // List\n\n\n  AbstractTree.prototype.onLeftArrow = function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    var nodes = this.view.getFocusedElements();\n\n    if (nodes.length === 0) {\n      return;\n    }\n\n    var node = nodes[0];\n    var location = this.model.getNodeLocation(node);\n    var didChange = this.model.setCollapsed(location, true);\n\n    if (!didChange) {\n      var parentLocation = this.model.getParentNodeLocation(location);\n\n      if (parentLocation === null) {\n        return;\n      }\n\n      var parentListIndex = this.model.getListIndex(parentLocation);\n      this.view.reveal(parentListIndex);\n      this.view.setFocus([parentListIndex]);\n    }\n  };\n\n  AbstractTree.prototype.onRightArrow = function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    var nodes = this.view.getFocusedElements();\n\n    if (nodes.length === 0) {\n      return;\n    }\n\n    var node = nodes[0];\n    var location = this.model.getNodeLocation(node);\n    var didChange = this.model.setCollapsed(location, false);\n\n    if (!didChange) {\n      if (!node.children.some(function (child) {\n        return child.visible;\n      })) {\n        return;\n      }\n\n      var focusedIndex = this.view.getFocus()[0];\n      var firstChildIndex = focusedIndex + 1;\n      this.view.reveal(firstChildIndex);\n      this.view.setFocus([firstChildIndex]);\n    }\n  };\n\n  AbstractTree.prototype.onSpace = function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    var nodes = this.view.getFocusedElements();\n\n    if (nodes.length === 0) {\n      return;\n    }\n\n    var node = nodes[0];\n    var location = this.model.getNodeLocation(node);\n    var recursive = e.browserEvent.altKey;\n    this.model.setCollapsed(location, undefined, recursive);\n  };\n\n  AbstractTree.prototype.dispose = function () {\n    this.disposables = dispose(this.disposables);\n    this.view.dispose();\n  };\n\n  return AbstractTree;\n}();\n\nexport { AbstractTree };","map":null,"metadata":{},"sourceType":"module"}