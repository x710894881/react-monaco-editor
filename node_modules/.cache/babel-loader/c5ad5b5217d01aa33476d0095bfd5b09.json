{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { ViewPart } from '../../view/viewPart.js';\nimport { Position } from '../../../common/core/position.js';\nimport { TokenizationRegistry } from '../../../common/modes.js';\nimport { editorCursorForeground, editorOverviewRulerBorder } from '../../../common/view/editorColorRegistry.js';\n\nvar Settings =\n/** @class */\nfunction () {\n  function Settings(config, theme) {\n    this.lineHeight = config.editor.lineHeight;\n    this.pixelRatio = config.editor.pixelRatio;\n    this.overviewRulerLanes = config.editor.viewInfo.overviewRulerLanes;\n    this.renderBorder = config.editor.viewInfo.overviewRulerBorder;\n    var borderColor = theme.getColor(editorOverviewRulerBorder);\n    this.borderColor = borderColor ? borderColor.toString() : null;\n    this.hideCursor = config.editor.viewInfo.hideCursorInOverviewRuler;\n    var cursorColor = theme.getColor(editorCursorForeground);\n    this.cursorColor = cursorColor ? cursorColor.transparent(0.7).toString() : null;\n    this.themeType = theme.type;\n    var minimapEnabled = config.editor.viewInfo.minimap.enabled;\n    var minimapSide = config.editor.viewInfo.minimap.side;\n    var backgroundColor = minimapEnabled ? TokenizationRegistry.getDefaultBackground() : null;\n\n    if (backgroundColor === null || minimapSide === 'left') {\n      this.backgroundColor = null;\n    } else {\n      this.backgroundColor = Color.Format.CSS.formatHex(backgroundColor);\n    }\n\n    var position = config.editor.layoutInfo.overviewRuler;\n    this.top = position.top;\n    this.right = position.right;\n    this.domWidth = position.width;\n    this.domHeight = position.height;\n    this.canvasWidth = this.domWidth * this.pixelRatio | 0;\n    this.canvasHeight = this.domHeight * this.pixelRatio | 0;\n\n    var _a = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes),\n        x = _a[0],\n        w = _a[1];\n\n    this.x = x;\n    this.w = w;\n  }\n\n  Settings.prototype._initLanes = function (canvasLeftOffset, canvasWidth, laneCount) {\n    var remainingWidth = canvasWidth - canvasLeftOffset;\n\n    if (laneCount >= 3) {\n      var leftWidth = Math.floor(remainingWidth / 3);\n      var rightWidth = Math.floor(remainingWidth / 3);\n      var centerWidth = remainingWidth - leftWidth - rightWidth;\n      var leftOffset = canvasLeftOffset;\n      var centerOffset = leftOffset + leftWidth;\n      var rightOffset = leftOffset + leftWidth + centerWidth;\n      return [[0, leftOffset, centerOffset, leftOffset, rightOffset, leftOffset, centerOffset, leftOffset], [0, leftWidth, centerWidth, leftWidth + centerWidth, rightWidth, leftWidth + centerWidth + rightWidth, centerWidth + rightWidth, leftWidth + centerWidth + rightWidth]];\n    } else if (laneCount === 2) {\n      var leftWidth = Math.floor(remainingWidth / 2);\n      var rightWidth = remainingWidth - leftWidth;\n      var leftOffset = canvasLeftOffset;\n      var rightOffset = leftOffset + leftWidth;\n      return [[0, leftOffset, leftOffset, leftOffset, rightOffset, leftOffset, leftOffset, leftOffset], [0, leftWidth, leftWidth, leftWidth, rightWidth, leftWidth + rightWidth, leftWidth + rightWidth, leftWidth + rightWidth]];\n    } else {\n      var offset = canvasLeftOffset;\n      var width = remainingWidth;\n      return [[0, offset, offset, offset, offset, offset, offset, offset], [0, width, width, width, width, width, width, width]];\n    }\n  };\n\n  Settings.prototype.equals = function (other) {\n    return this.lineHeight === other.lineHeight && this.pixelRatio === other.pixelRatio && this.overviewRulerLanes === other.overviewRulerLanes && this.renderBorder === other.renderBorder && this.borderColor === other.borderColor && this.hideCursor === other.hideCursor && this.cursorColor === other.cursorColor && this.themeType === other.themeType && this.backgroundColor === other.backgroundColor && this.top === other.top && this.right === other.right && this.domWidth === other.domWidth && this.domHeight === other.domHeight && this.canvasWidth === other.canvasWidth && this.canvasHeight === other.canvasHeight;\n  };\n\n  return Settings;\n}();\n\nvar DecorationsOverviewRuler =\n/** @class */\nfunction (_super) {\n  __extends(DecorationsOverviewRuler, _super);\n\n  function DecorationsOverviewRuler(context) {\n    var _this = _super.call(this, context) || this;\n\n    _this._domNode = createFastDomNode(document.createElement('canvas'));\n\n    _this._domNode.setClassName('decorationsOverviewRuler');\n\n    _this._domNode.setPosition('absolute');\n\n    _this._domNode.setLayerHinting(true);\n\n    _this._domNode.setAttribute('aria-hidden', 'true');\n\n    _this._updateSettings(false);\n\n    _this._tokensColorTrackerListener = TokenizationRegistry.onDidChange(function (e) {\n      if (e.changedColorMap) {\n        _this._updateSettings(true);\n      }\n    });\n    _this._cursorPositions = [];\n    return _this;\n  }\n\n  DecorationsOverviewRuler.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._tokensColorTrackerListener.dispose();\n  };\n\n  DecorationsOverviewRuler.prototype._updateSettings = function (renderNow) {\n    var newSettings = new Settings(this._context.configuration, this._context.theme);\n\n    if (this._settings && this._settings.equals(newSettings)) {\n      // nothing to do\n      return false;\n    }\n\n    this._settings = newSettings;\n\n    this._domNode.setTop(this._settings.top);\n\n    this._domNode.setRight(this._settings.right);\n\n    this._domNode.setWidth(this._settings.domWidth);\n\n    this._domNode.setHeight(this._settings.domHeight);\n\n    this._domNode.domNode.width = this._settings.canvasWidth;\n    this._domNode.domNode.height = this._settings.canvasHeight;\n\n    if (renderNow) {\n      this._render();\n    }\n\n    return true;\n  }; // ---- begin view event handlers\n\n\n  DecorationsOverviewRuler.prototype.onConfigurationChanged = function (e) {\n    return this._updateSettings(false);\n  };\n\n  DecorationsOverviewRuler.prototype.onCursorStateChanged = function (e) {\n    this._cursorPositions = [];\n\n    for (var i = 0, len = e.selections.length; i < len; i++) {\n      this._cursorPositions[i] = e.selections[i].getPosition();\n    }\n\n    this._cursorPositions.sort(Position.compare);\n\n    return true;\n  };\n\n  DecorationsOverviewRuler.prototype.onDecorationsChanged = function (e) {\n    return true;\n  };\n\n  DecorationsOverviewRuler.prototype.onFlushed = function (e) {\n    return true;\n  };\n\n  DecorationsOverviewRuler.prototype.onScrollChanged = function (e) {\n    return e.scrollHeightChanged;\n  };\n\n  DecorationsOverviewRuler.prototype.onZonesChanged = function (e) {\n    return true;\n  };\n\n  DecorationsOverviewRuler.prototype.onThemeChanged = function (e) {\n    // invalidate color cache\n    this._context.model.invalidateOverviewRulerColorCache();\n\n    return this._updateSettings(false);\n  }; // ---- end view event handlers\n\n\n  DecorationsOverviewRuler.prototype.getDomNode = function () {\n    return this._domNode.domNode;\n  };\n\n  DecorationsOverviewRuler.prototype.prepareRender = function (ctx) {// Nothing to read\n  };\n\n  DecorationsOverviewRuler.prototype.render = function (editorCtx) {\n    this._render();\n  };\n\n  DecorationsOverviewRuler.prototype._render = function () {\n    var canvasWidth = this._settings.canvasWidth;\n    var canvasHeight = this._settings.canvasHeight;\n    var lineHeight = this._settings.lineHeight;\n    var viewLayout = this._context.viewLayout;\n\n    var outerHeight = this._context.viewLayout.getScrollHeight();\n\n    var heightRatio = canvasHeight / outerHeight;\n\n    var decorations = this._context.model.getAllOverviewRulerDecorations(this._context.theme);\n\n    var minDecorationHeight = 6\n    /* MIN_DECORATION_HEIGHT */\n    * this._settings.pixelRatio | 0;\n    var halfMinDecorationHeight = minDecorationHeight / 2 | 0;\n\n    var canvasCtx = this._domNode.domNode.getContext('2d');\n\n    if (this._settings.backgroundColor === null) {\n      canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);\n    } else {\n      canvasCtx.fillStyle = this._settings.backgroundColor;\n      canvasCtx.fillRect(0, 0, canvasWidth, canvasHeight);\n    }\n\n    var x = this._settings.x;\n    var w = this._settings.w; // Avoid flickering by always rendering the colors in the same order\n    // colors that don't use transparency will be sorted last (they start with #)\n\n    var colors = Object.keys(decorations);\n    colors.sort();\n\n    for (var cIndex = 0, cLen = colors.length; cIndex < cLen; cIndex++) {\n      var color = colors[cIndex];\n      var colorDecorations = decorations[color];\n      canvasCtx.fillStyle = color;\n      var prevLane = 0;\n      var prevY1 = 0;\n      var prevY2 = 0;\n\n      for (var i = 0, len = colorDecorations.length; i < len; i++) {\n        var lane = colorDecorations[3 * i];\n        var startLineNumber = colorDecorations[3 * i + 1];\n        var endLineNumber = colorDecorations[3 * i + 2];\n        var y1 = viewLayout.getVerticalOffsetForLineNumber(startLineNumber) * heightRatio | 0;\n        var y2 = (viewLayout.getVerticalOffsetForLineNumber(endLineNumber) + lineHeight) * heightRatio | 0;\n        var height = y2 - y1;\n\n        if (height < minDecorationHeight) {\n          var yCenter = (y1 + y2) / 2 | 0;\n\n          if (yCenter < halfMinDecorationHeight) {\n            yCenter = halfMinDecorationHeight;\n          } else if (yCenter + halfMinDecorationHeight > canvasHeight) {\n            yCenter = canvasHeight - halfMinDecorationHeight;\n          }\n\n          y1 = yCenter - halfMinDecorationHeight;\n          y2 = yCenter + halfMinDecorationHeight;\n        }\n\n        if (y1 > prevY2 + 1 || lane !== prevLane) {\n          // flush prev\n          if (i !== 0) {\n            canvasCtx.fillRect(x[prevLane], prevY1, w[prevLane], prevY2 - prevY1);\n          }\n\n          prevLane = lane;\n          prevY1 = y1;\n          prevY2 = y2;\n        } else {\n          // merge into prev\n          if (y2 > prevY2) {\n            prevY2 = y2;\n          }\n        }\n      }\n\n      canvasCtx.fillRect(x[prevLane], prevY1, w[prevLane], prevY2 - prevY1);\n    } // Draw cursors\n\n\n    if (!this._settings.hideCursor && this._settings.cursorColor) {\n      var cursorHeight = 2 * this._settings.pixelRatio | 0;\n      var halfCursorHeight = cursorHeight / 2 | 0;\n      var cursorX = this._settings.x[7\n      /* Full */\n      ];\n      var cursorW = this._settings.w[7\n      /* Full */\n      ];\n      canvasCtx.fillStyle = this._settings.cursorColor;\n      var prevY1 = -100;\n      var prevY2 = -100;\n\n      for (var i = 0, len = this._cursorPositions.length; i < len; i++) {\n        var cursor = this._cursorPositions[i];\n        var yCenter = viewLayout.getVerticalOffsetForLineNumber(cursor.lineNumber) * heightRatio | 0;\n\n        if (yCenter < halfCursorHeight) {\n          yCenter = halfCursorHeight;\n        } else if (yCenter + halfCursorHeight > canvasHeight) {\n          yCenter = canvasHeight - halfCursorHeight;\n        }\n\n        var y1 = yCenter - halfCursorHeight;\n        var y2 = y1 + cursorHeight;\n\n        if (y1 > prevY2 + 1) {\n          // flush prev\n          if (i !== 0) {\n            canvasCtx.fillRect(cursorX, prevY1, cursorW, prevY2 - prevY1);\n          }\n\n          prevY1 = y1;\n          prevY2 = y2;\n        } else {\n          // merge into prev\n          if (y2 > prevY2) {\n            prevY2 = y2;\n          }\n        }\n      }\n\n      canvasCtx.fillRect(cursorX, prevY1, cursorW, prevY2 - prevY1);\n    }\n\n    if (this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0) {\n      canvasCtx.beginPath();\n      canvasCtx.lineWidth = 1;\n      canvasCtx.strokeStyle = this._settings.borderColor;\n      canvasCtx.moveTo(0, 0);\n      canvasCtx.lineTo(0, canvasHeight);\n      canvasCtx.stroke();\n      canvasCtx.moveTo(0, 0);\n      canvasCtx.lineTo(canvasWidth, 0);\n      canvasCtx.stroke();\n    }\n  };\n\n  return DecorationsOverviewRuler;\n}(ViewPart);\n\nexport { DecorationsOverviewRuler };","map":null,"metadata":{},"sourceType":"module"}