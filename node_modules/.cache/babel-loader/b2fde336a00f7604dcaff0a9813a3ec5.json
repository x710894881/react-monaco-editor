{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as nodes from '../parser/cssNodes.js';\nimport { Symbols } from '../parser/cssSymbolScope.js';\nimport * as languageFacts from '../languageFacts/facts.js';\nimport * as strings from '../utils/strings.js';\nimport { Position, CompletionItemKind, Range, TextEdit, InsertTextFormat } from '../../vscode-languageserver-types/main.js';\nimport * as nls from '../../../fillers/vscode-nls.js';\nvar localize = nls.loadMessageBundle();\nvar SnippetFormat = InsertTextFormat.Snippet;\n\nvar CSSCompletion =\n/** @class */\nfunction () {\n  function CSSCompletion(variablePrefix) {\n    if (variablePrefix === void 0) {\n      variablePrefix = null;\n    }\n\n    this.completionParticipants = [];\n    this.valueTypes = [nodes.NodeType.Identifier, nodes.NodeType.Value, nodes.NodeType.StringLiteral, nodes.NodeType.URILiteral, nodes.NodeType.NumericValue, nodes.NodeType.HexColorValue, nodes.NodeType.VariableName, nodes.NodeType.Prio];\n    this.variablePrefix = variablePrefix;\n  }\n\n  CSSCompletion.prototype.getSymbolContext = function () {\n    if (!this.symbolContext) {\n      this.symbolContext = new Symbols(this.styleSheet);\n    }\n\n    return this.symbolContext;\n  };\n\n  CSSCompletion.prototype.setCompletionParticipants = function (registeredCompletionParticipants) {\n    this.completionParticipants = registeredCompletionParticipants || [];\n  };\n\n  CSSCompletion.prototype.doComplete = function (document, position, styleSheet) {\n    this.offset = document.offsetAt(position);\n    this.position = position;\n    this.currentWord = getCurrentWord(document, this.offset);\n    this.defaultReplaceRange = Range.create(Position.create(this.position.line, this.position.character - this.currentWord.length), this.position);\n    this.textDocument = document;\n    this.styleSheet = styleSheet;\n\n    try {\n      var result = {\n        isIncomplete: false,\n        items: []\n      };\n      this.nodePath = nodes.getNodePath(this.styleSheet, this.offset);\n\n      for (var i = this.nodePath.length - 1; i >= 0; i--) {\n        var node = this.nodePath[i];\n\n        if (node instanceof nodes.Property) {\n          this.getCompletionsForDeclarationProperty(node.getParent(), result);\n        } else if (node instanceof nodes.Expression) {\n          if (node.parent instanceof nodes.Interpolation) {\n            this.getVariableProposals(null, result);\n          } else {\n            this.getCompletionsForExpression(node, result);\n          }\n        } else if (node instanceof nodes.SimpleSelector) {\n          var parentRef = node.findAParent(nodes.NodeType.ExtendsReference, nodes.NodeType.Ruleset);\n\n          if (parentRef) {\n            if (parentRef.type === nodes.NodeType.ExtendsReference) {\n              this.getCompletionsForExtendsReference(parentRef, node, result);\n            } else {\n              var parentRuleSet = parentRef;\n              this.getCompletionsForSelector(parentRuleSet, parentRuleSet && parentRuleSet.isNested(), result);\n            }\n          }\n        } else if (node instanceof nodes.FunctionArgument) {\n          this.getCompletionsForFunctionArgument(node, node.getParent(), result);\n        } else if (node instanceof nodes.Declarations) {\n          this.getCompletionsForDeclarations(node, result);\n        } else if (node instanceof nodes.VariableDeclaration) {\n          this.getCompletionsForVariableDeclaration(node, result);\n        } else if (node instanceof nodes.RuleSet) {\n          this.getCompletionsForRuleSet(node, result);\n        } else if (node instanceof nodes.Interpolation) {\n          this.getCompletionsForInterpolation(node, result);\n        } else if (node instanceof nodes.FunctionDeclaration) {\n          this.getCompletionsForFunctionDeclaration(node, result);\n        } else if (node instanceof nodes.MixinReference) {\n          this.getCompletionsForMixinReference(node, result);\n        } else if (node instanceof nodes.Function) {\n          this.getCompletionsForFunctionArgument(null, node, result);\n        } else if (node instanceof nodes.Supports) {\n          this.getCompletionsForSupports(node, result);\n        } else if (node instanceof nodes.SupportsCondition) {\n          this.getCompletionsForSupportsCondition(node, result);\n        } else if (node instanceof nodes.ExtendsReference) {\n          this.getCompletionsForExtendsReference(node, null, result);\n        } else if (node.type === nodes.NodeType.URILiteral) {\n          this.getCompletionForUriLiteralValue(node, result);\n        } else if (node.type === nodes.NodeType.StringLiteral && node.parent.type === nodes.NodeType.Import) {\n          this.getCompletionForImportPath(node, result);\n        } else if (node.parent === null) {\n          this.getCompletionForTopLevel(result); // } else if (node instanceof nodes.Variable) {\n          // this.getCompletionsForVariableDeclaration()\n        } else {\n          continue;\n        }\n\n        if (result.items.length > 0 || this.offset > node.offset) {\n          return this.finalize(result);\n        }\n      }\n\n      this.getCompletionsForStylesheet(result);\n\n      if (result.items.length === 0) {\n        if (this.variablePrefix && this.currentWord.indexOf(this.variablePrefix) === 0) {\n          this.getVariableProposals(null, result);\n        }\n      }\n\n      return this.finalize(result);\n    } finally {\n      // don't hold on any state, clear symbolContext\n      this.position = null;\n      this.currentWord = null;\n      this.textDocument = null;\n      this.styleSheet = null;\n      this.symbolContext = null;\n      this.defaultReplaceRange = null;\n      this.nodePath = null;\n    }\n  };\n\n  CSSCompletion.prototype.finalize = function (result) {\n    var needsSortText = result.items.some(function (i) {\n      return !!i.sortText;\n    });\n\n    if (needsSortText) {\n      for (var _i = 0, _a = result.items; _i < _a.length; _i++) {\n        var i = _a[_i];\n\n        if (!i.sortText) {\n          i.sortText = 'd';\n        }\n      }\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.findInNodePath = function () {\n    var types = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      types[_i] = arguments[_i];\n    }\n\n    for (var i = this.nodePath.length - 1; i >= 0; i--) {\n      var node = this.nodePath[i];\n\n      if (types.indexOf(node.type) !== -1) {\n        return node;\n      }\n    }\n\n    return null;\n  };\n\n  CSSCompletion.prototype.getCompletionsForDeclarationProperty = function (declaration, result) {\n    return this.getPropertyProposals(declaration, result);\n  };\n\n  CSSCompletion.prototype.getPropertyProposals = function (declaration, result) {\n    var _this = this;\n\n    var properties = languageFacts.cssDataManager.getProperties();\n    properties.forEach(function (entry) {\n      var range;\n      var insertText;\n      var retrigger = false;\n\n      if (declaration) {\n        range = _this.getCompletionRange(declaration.getProperty());\n        insertText = entry.name;\n\n        if (!isDefined(declaration.colonPosition)) {\n          insertText += ': ';\n          retrigger = true;\n        }\n      } else {\n        range = _this.getCompletionRange(null);\n        insertText = entry.name + ': ';\n        retrigger = true;\n      }\n\n      var item = {\n        label: entry.name,\n        documentation: languageFacts.getEntryDescription(entry),\n        textEdit: TextEdit.replace(range, insertText),\n        kind: CompletionItemKind.Property\n      };\n\n      if (!entry.restrictions) {\n        retrigger = false;\n      }\n\n      if (retrigger) {\n        item.command = {\n          title: 'Suggest',\n          command: 'editor.action.triggerSuggest'\n        };\n      }\n\n      if (strings.startsWith(entry.name, '-')) {\n        item.sortText = 'x';\n      }\n\n      result.items.push(item);\n    });\n    this.completionParticipants.forEach(function (participant) {\n      if (participant.onCssProperty) {\n        participant.onCssProperty({\n          propertyName: _this.currentWord,\n          range: _this.defaultReplaceRange\n        });\n      }\n    });\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionsForDeclarationValue = function (node, result) {\n    var _this = this;\n\n    var propertyName = node.getFullPropertyName();\n    var entry = languageFacts.cssDataManager.getProperty(propertyName);\n    var existingNode = node.getValue();\n\n    while (existingNode && existingNode.hasChildren()) {\n      existingNode = existingNode.findChildAtOffset(this.offset, false);\n    }\n\n    this.completionParticipants.forEach(function (participant) {\n      if (participant.onCssPropertyValue) {\n        participant.onCssPropertyValue({\n          propertyName: propertyName,\n          propertyValue: _this.currentWord,\n          range: _this.getCompletionRange(existingNode)\n        });\n      }\n    });\n\n    if (entry) {\n      if (entry.restrictions) {\n        for (var _i = 0, _a = entry.restrictions; _i < _a.length; _i++) {\n          var restriction = _a[_i];\n\n          switch (restriction) {\n            case 'color':\n              this.getColorProposals(entry, existingNode, result);\n              break;\n\n            case 'position':\n              this.getPositionProposals(entry, existingNode, result);\n              break;\n\n            case 'repeat':\n              this.getRepeatStyleProposals(entry, existingNode, result);\n              break;\n\n            case 'line-style':\n              this.getLineStyleProposals(entry, existingNode, result);\n              break;\n\n            case 'line-width':\n              this.getLineWidthProposals(entry, existingNode, result);\n              break;\n\n            case 'geometry-box':\n              this.getGeometryBoxProposals(entry, existingNode, result);\n              break;\n\n            case 'box':\n              this.getBoxProposals(entry, existingNode, result);\n              break;\n\n            case 'image':\n              this.getImageProposals(entry, existingNode, result);\n              break;\n\n            case 'timing-function':\n              this.getTimingFunctionProposals(entry, existingNode, result);\n              break;\n\n            case 'shape':\n              this.getBasicShapeProposals(entry, existingNode, result);\n              break;\n          }\n        }\n      }\n\n      this.getValueEnumProposals(entry, existingNode, result);\n      this.getCSSWideKeywordProposals(entry, existingNode, result);\n      this.getUnitProposals(entry, existingNode, result);\n    } else {\n      var existingValues = collectValues(this.styleSheet, node);\n\n      for (var _b = 0, _c = existingValues.getEntries(); _b < _c.length; _b++) {\n        var existingValue = _c[_b];\n        result.items.push({\n          label: existingValue,\n          textEdit: TextEdit.replace(this.getCompletionRange(existingNode), existingValue),\n          kind: CompletionItemKind.Value\n        });\n      }\n    }\n\n    this.getVariableProposals(existingNode, result);\n    this.getTermProposals(entry, existingNode, result);\n    return result;\n  };\n\n  CSSCompletion.prototype.getValueEnumProposals = function (entry, existingNode, result) {\n    if (entry.values) {\n      for (var _i = 0, _a = entry.values; _i < _a.length; _i++) {\n        var value = _a[_i];\n\n        if (languageFacts.supportedInMoreThanOneBrowser(value)) {\n          var insertString = value.name;\n          var insertTextFormat = void 0;\n\n          if (strings.endsWith(insertString, ')')) {\n            var from = insertString.lastIndexOf('(');\n\n            if (from !== -1) {\n              insertString = insertString.substr(0, from) + '($1)';\n              insertTextFormat = SnippetFormat;\n            }\n          }\n\n          var item = {\n            label: value.name,\n            documentation: languageFacts.getEntryDescription(value),\n            textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertString),\n            kind: CompletionItemKind.Value,\n            insertTextFormat: insertTextFormat\n          };\n          result.items.push(item);\n        }\n      }\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getCSSWideKeywordProposals = function (entry, existingNode, result) {\n    for (var keywords in languageFacts.cssWideKeywords) {\n      result.items.push({\n        label: keywords,\n        documentation: languageFacts.cssWideKeywords[keywords],\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), keywords),\n        kind: CompletionItemKind.Value\n      });\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionsForInterpolation = function (node, result) {\n    if (this.offset >= node.offset + 2) {\n      this.getVariableProposals(null, result);\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getVariableProposals = function (existingNode, result) {\n    var symbols = this.getSymbolContext().findSymbolsAtOffset(this.offset, nodes.ReferenceType.Variable);\n\n    for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {\n      var symbol = symbols_1[_i];\n      var insertText = strings.startsWith(symbol.name, '--') ? \"var(\" + symbol.name + \")\" : symbol.name;\n      var suggest = {\n        label: symbol.name,\n        documentation: symbol.value ? strings.getLimitedString(symbol.value) : symbol.value,\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),\n        kind: CompletionItemKind.Variable,\n        sortText: 'z'\n      };\n\n      if (symbol.node.type === nodes.NodeType.FunctionParameter) {\n        var mixinNode = symbol.node.getParent();\n\n        if (mixinNode.type === nodes.NodeType.MixinDeclaration) {\n          suggest.detail = localize('completion.argument', 'argument from \\'{0}\\'', mixinNode.getName());\n        }\n      }\n\n      result.items.push(suggest);\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getVariableProposalsForCSSVarFunction = function (result) {\n    var symbols = this.getSymbolContext().findSymbolsAtOffset(this.offset, nodes.ReferenceType.Variable);\n    symbols = symbols.filter(function (symbol) {\n      return strings.startsWith(symbol.name, '--');\n    });\n\n    for (var _i = 0, symbols_2 = symbols; _i < symbols_2.length; _i++) {\n      var symbol = symbols_2[_i];\n      result.items.push({\n        label: symbol.name,\n        documentation: symbol.value ? strings.getLimitedString(symbol.value) : symbol.value,\n        textEdit: TextEdit.replace(this.getCompletionRange(null), symbol.name),\n        kind: CompletionItemKind.Variable\n      });\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getUnitProposals = function (entry, existingNode, result) {\n    var currentWord = '0';\n\n    if (this.currentWord.length > 0) {\n      var numMatch = this.currentWord.match(/^-?\\d[\\.\\d+]*/);\n\n      if (numMatch) {\n        currentWord = numMatch[0];\n        result.isIncomplete = currentWord.length === this.currentWord.length;\n      }\n    } else if (this.currentWord.length === 0) {\n      result.isIncomplete = true;\n    }\n\n    if (existingNode && existingNode.parent && existingNode.parent.type === nodes.NodeType.Term) {\n      existingNode = existingNode.getParent(); // include the unary operator\n    }\n\n    if (entry.restrictions) {\n      for (var _i = 0, _a = entry.restrictions; _i < _a.length; _i++) {\n        var restriction = _a[_i];\n        var units = languageFacts.units[restriction];\n\n        if (units) {\n          for (var _b = 0, units_1 = units; _b < units_1.length; _b++) {\n            var unit = units_1[_b];\n            var insertText = currentWord + unit;\n            result.items.push({\n              label: insertText,\n              textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),\n              kind: CompletionItemKind.Unit\n            });\n          }\n        }\n      }\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionRange = function (existingNode) {\n    if (existingNode && existingNode.offset <= this.offset) {\n      var end = existingNode.end !== -1 ? this.textDocument.positionAt(existingNode.end) : this.position;\n      return Range.create(this.textDocument.positionAt(existingNode.offset), end);\n    }\n\n    return this.defaultReplaceRange;\n  };\n\n  CSSCompletion.prototype.getColorProposals = function (entry, existingNode, result) {\n    for (var color in languageFacts.colors) {\n      result.items.push({\n        label: color,\n        documentation: languageFacts.colors[color],\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), color),\n        kind: CompletionItemKind.Color\n      });\n    }\n\n    for (var color in languageFacts.colorKeywords) {\n      result.items.push({\n        label: color,\n        documentation: languageFacts.colorKeywords[color],\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), color),\n        kind: CompletionItemKind.Value\n      });\n    }\n\n    var colorValues = new Set();\n    this.styleSheet.acceptVisitor(new ColorValueCollector(colorValues, this.offset));\n\n    for (var _i = 0, _a = colorValues.getEntries(); _i < _a.length; _i++) {\n      var color = _a[_i];\n      result.items.push({\n        label: color,\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), color),\n        kind: CompletionItemKind.Color\n      });\n    }\n\n    var _loop_1 = function (p) {\n      var tabStop = 1;\n\n      var replaceFunction = function (match, p1) {\n        return '${' + tabStop++ + ':' + p1 + '}';\n      };\n\n      var insertText = p.func.replace(/\\[?\\$(\\w+)\\]?/g, replaceFunction);\n      result.items.push({\n        label: p.func.substr(0, p.func.indexOf('(')),\n        detail: p.func,\n        documentation: p.desc,\n        textEdit: TextEdit.replace(this_1.getCompletionRange(existingNode), insertText),\n        insertTextFormat: SnippetFormat,\n        kind: CompletionItemKind.Function\n      });\n    };\n\n    var this_1 = this;\n\n    for (var _b = 0, _c = languageFacts.colorFunctions; _b < _c.length; _b++) {\n      var p = _c[_b];\n\n      _loop_1(p);\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getPositionProposals = function (entry, existingNode, result) {\n    for (var position in languageFacts.positionKeywords) {\n      result.items.push({\n        label: position,\n        documentation: languageFacts.positionKeywords[position],\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), position),\n        kind: CompletionItemKind.Value\n      });\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getRepeatStyleProposals = function (entry, existingNode, result) {\n    for (var repeat in languageFacts.repeatStyleKeywords) {\n      result.items.push({\n        label: repeat,\n        documentation: languageFacts.repeatStyleKeywords[repeat],\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), repeat),\n        kind: CompletionItemKind.Value\n      });\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getLineStyleProposals = function (entry, existingNode, result) {\n    for (var lineStyle in languageFacts.lineStyleKeywords) {\n      result.items.push({\n        label: lineStyle,\n        documentation: languageFacts.lineStyleKeywords[lineStyle],\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), lineStyle),\n        kind: CompletionItemKind.Value\n      });\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getLineWidthProposals = function (entry, existingNode, result) {\n    for (var _i = 0, _a = languageFacts.lineWidthKeywords; _i < _a.length; _i++) {\n      var lineWidth = _a[_i];\n      result.items.push({\n        label: lineWidth,\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), lineWidth),\n        kind: CompletionItemKind.Value\n      });\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getGeometryBoxProposals = function (entry, existingNode, result) {\n    for (var box in languageFacts.geometryBoxKeywords) {\n      result.items.push({\n        label: box,\n        documentation: languageFacts.geometryBoxKeywords[box],\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), box),\n        kind: CompletionItemKind.Value\n      });\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getBoxProposals = function (entry, existingNode, result) {\n    for (var box in languageFacts.boxKeywords) {\n      result.items.push({\n        label: box,\n        documentation: languageFacts.boxKeywords[box],\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), box),\n        kind: CompletionItemKind.Value\n      });\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getImageProposals = function (entry, existingNode, result) {\n    for (var image in languageFacts.imageFunctions) {\n      var insertText = moveCursorInsideParenthesis(image);\n      result.items.push({\n        label: image,\n        documentation: languageFacts.imageFunctions[image],\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),\n        kind: CompletionItemKind.Function,\n        insertTextFormat: image !== insertText ? SnippetFormat : void 0\n      });\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getTimingFunctionProposals = function (entry, existingNode, result) {\n    for (var timing in languageFacts.transitionTimingFunctions) {\n      var insertText = moveCursorInsideParenthesis(timing);\n      result.items.push({\n        label: timing,\n        documentation: languageFacts.transitionTimingFunctions[timing],\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),\n        kind: CompletionItemKind.Function,\n        insertTextFormat: timing !== insertText ? SnippetFormat : void 0\n      });\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getBasicShapeProposals = function (entry, existingNode, result) {\n    for (var shape in languageFacts.basicShapeFunctions) {\n      var insertText = moveCursorInsideParenthesis(shape);\n      result.items.push({\n        label: shape,\n        documentation: languageFacts.basicShapeFunctions[shape],\n        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),\n        kind: CompletionItemKind.Function,\n        insertTextFormat: shape !== insertText ? SnippetFormat : void 0\n      });\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionsForStylesheet = function (result) {\n    var node = this.styleSheet.findFirstChildBeforeOffset(this.offset);\n\n    if (!node) {\n      return this.getCompletionForTopLevel(result);\n    }\n\n    if (node instanceof nodes.RuleSet) {\n      return this.getCompletionsForRuleSet(node, result);\n    }\n\n    if (node instanceof nodes.Supports) {\n      return this.getCompletionsForSupports(node, result);\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionForTopLevel = function (result) {\n    var _this = this;\n\n    languageFacts.cssDataManager.getAtDirectives().forEach(function (entry) {\n      result.items.push({\n        label: entry.name,\n        textEdit: TextEdit.replace(_this.getCompletionRange(null), entry.name),\n        documentation: languageFacts.getEntryDescription(entry),\n        kind: CompletionItemKind.Keyword\n      });\n    });\n    this.getCompletionsForSelector(null, false, result);\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionsForRuleSet = function (ruleSet, result) {\n    var declarations = ruleSet.getDeclarations();\n    var isAfter = declarations && declarations.endsWith('}') && this.offset >= declarations.end;\n\n    if (isAfter) {\n      return this.getCompletionForTopLevel(result);\n    }\n\n    var isInSelectors = !declarations || this.offset <= declarations.offset;\n\n    if (isInSelectors) {\n      return this.getCompletionsForSelector(ruleSet, ruleSet.isNested(), result);\n    }\n\n    return this.getCompletionsForDeclarations(ruleSet.getDeclarations(), result);\n  };\n\n  CSSCompletion.prototype.getCompletionsForSelector = function (ruleSet, isNested, result) {\n    var _this = this;\n\n    var existingNode = this.findInNodePath(nodes.NodeType.PseudoSelector, nodes.NodeType.IdentifierSelector, nodes.NodeType.ClassSelector, nodes.NodeType.ElementNameSelector);\n\n    if (!existingNode && this.offset - this.currentWord.length > 0 && this.textDocument.getText()[this.offset - this.currentWord.length - 1] === ':') {\n      // after the ':' of a pseudo selector, no node generated for just ':'\n      this.currentWord = ':' + this.currentWord;\n      this.defaultReplaceRange = Range.create(Position.create(this.position.line, this.position.character - this.currentWord.length), this.position);\n    }\n\n    var pseudoClasses = languageFacts.cssDataManager.getPseudoClasses();\n    pseudoClasses.forEach(function (entry) {\n      var insertText = moveCursorInsideParenthesis(entry.name);\n      var item = {\n        label: entry.name,\n        textEdit: TextEdit.replace(_this.getCompletionRange(existingNode), insertText),\n        documentation: languageFacts.getEntryDescription(entry),\n        kind: CompletionItemKind.Function,\n        insertTextFormat: entry.name !== insertText ? SnippetFormat : void 0\n      };\n\n      if (strings.startsWith(entry.name, ':-')) {\n        item.sortText = 'x';\n      }\n\n      result.items.push(item);\n    });\n    var pseudoElements = languageFacts.cssDataManager.getPseudoElements();\n    pseudoElements.forEach(function (entry) {\n      var insertText = moveCursorInsideParenthesis(entry.name);\n      var item = {\n        label: entry.name,\n        textEdit: TextEdit.replace(_this.getCompletionRange(existingNode), insertText),\n        documentation: languageFacts.getEntryDescription(entry),\n        kind: CompletionItemKind.Function,\n        insertTextFormat: entry.name !== insertText ? SnippetFormat : void 0\n      };\n\n      if (strings.startsWith(entry.name, '::-')) {\n        item.sortText = 'x';\n      }\n\n      result.items.push(item);\n    });\n\n    if (!isNested) {\n      // show html tags only for top level\n      for (var _i = 0, _a = languageFacts.html5Tags; _i < _a.length; _i++) {\n        var entry = _a[_i];\n        result.items.push({\n          label: entry,\n          textEdit: TextEdit.replace(this.getCompletionRange(existingNode), entry),\n          kind: CompletionItemKind.Keyword\n        });\n      }\n\n      for (var _b = 0, _c = languageFacts.svgElements; _b < _c.length; _b++) {\n        var entry = _c[_b];\n        result.items.push({\n          label: entry,\n          textEdit: TextEdit.replace(this.getCompletionRange(existingNode), entry),\n          kind: CompletionItemKind.Keyword\n        });\n      }\n    }\n\n    var visited = {};\n    visited[this.currentWord] = true;\n    var textProvider = this.styleSheet.getTextProvider();\n    this.styleSheet.accept(function (n) {\n      if (n.type === nodes.NodeType.SimpleSelector && n.length > 0) {\n        var selector = textProvider(n.offset, n.length);\n\n        if (selector.charAt(0) === '.' && !visited[selector]) {\n          visited[selector] = true;\n          result.items.push({\n            label: selector,\n            textEdit: TextEdit.replace(_this.getCompletionRange(existingNode), selector),\n            kind: CompletionItemKind.Keyword\n          });\n        }\n\n        return false;\n      }\n\n      return true;\n    });\n\n    if (ruleSet && ruleSet.isNested()) {\n      var selector = ruleSet.getSelectors().findFirstChildBeforeOffset(this.offset);\n\n      if (selector && ruleSet.getSelectors().getChildren().indexOf(selector) === 0) {\n        this.getPropertyProposals(null, result);\n      }\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionsForDeclarations = function (declarations, result) {\n    if (!declarations || this.offset === declarations.offset) {\n      // incomplete nodes\n      return result;\n    }\n\n    var node = declarations.findFirstChildBeforeOffset(this.offset);\n\n    if (!node) {\n      return this.getCompletionsForDeclarationProperty(null, result);\n    }\n\n    if (node instanceof nodes.AbstractDeclaration) {\n      var declaration = node;\n\n      if (!isDefined(declaration.colonPosition) || this.offset <= declaration.colonPosition) {\n        // complete property\n        return this.getCompletionsForDeclarationProperty(declaration, result);\n      } else if (isDefined(declaration.semicolonPosition) && declaration.semicolonPosition < this.offset) {\n        if (this.offset === declaration.semicolonPosition + 1) {\n          return result; // don't show new properties right after semicolon (see Bug 15421:[intellisense] [css] Be less aggressive when manually typing CSS)\n        } // complete next property\n\n\n        return this.getCompletionsForDeclarationProperty(null, result);\n      }\n\n      if (declaration instanceof nodes.Declaration) {\n        // complete value\n        return this.getCompletionsForDeclarationValue(declaration, result);\n      }\n    } else if (node instanceof nodes.ExtendsReference) {\n      this.getCompletionsForExtendsReference(node, null, result);\n    } else if (this.currentWord && this.currentWord[0] === '@') {\n      this.getCompletionsForDeclarationProperty(null, result);\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionsForVariableDeclaration = function (declaration, result) {\n    if (this.offset > declaration.colonPosition) {\n      this.getVariableProposals(declaration.getValue(), result);\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionsForExpression = function (expression, result) {\n    if (expression.getParent() instanceof nodes.FunctionArgument) {\n      this.getCompletionsForFunctionArgument(expression.getParent(), expression.getParent().getParent(), result);\n      return result;\n    }\n\n    var declaration = expression.findParent(nodes.NodeType.Declaration);\n\n    if (!declaration) {\n      this.getTermProposals(null, null, result);\n      return result;\n    }\n\n    var node = expression.findChildAtOffset(this.offset, true);\n\n    if (!node) {\n      return this.getCompletionsForDeclarationValue(declaration, result);\n    }\n\n    if (node instanceof nodes.NumericValue || node instanceof nodes.Identifier) {\n      return this.getCompletionsForDeclarationValue(declaration, result);\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionsForFunctionArgument = function (arg, func, result) {\n    if (func.getIdentifier().getText() === 'var') {\n      if (!func.getArguments().hasChildren() || func.getArguments().getChild(0) === arg) {\n        this.getVariableProposalsForCSSVarFunction(result);\n      }\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionsForFunctionDeclaration = function (decl, result) {\n    var declarations = decl.getDeclarations();\n\n    if (declarations && this.offset > declarations.offset && this.offset < declarations.end) {\n      this.getTermProposals(null, null, result);\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionsForMixinReference = function (ref, result) {\n    var allMixins = this.getSymbolContext().findSymbolsAtOffset(this.offset, nodes.ReferenceType.Mixin);\n\n    for (var _i = 0, allMixins_1 = allMixins; _i < allMixins_1.length; _i++) {\n      var mixinSymbol = allMixins_1[_i];\n\n      if (mixinSymbol.node instanceof nodes.MixinDeclaration) {\n        result.items.push(this.makeTermProposal(mixinSymbol, mixinSymbol.node.getParameters(), null));\n      }\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getTermProposals = function (entry, existingNode, result) {\n    var allFunctions = this.getSymbolContext().findSymbolsAtOffset(this.offset, nodes.ReferenceType.Function);\n\n    for (var _i = 0, allFunctions_1 = allFunctions; _i < allFunctions_1.length; _i++) {\n      var functionSymbol = allFunctions_1[_i];\n\n      if (functionSymbol.node instanceof nodes.FunctionDeclaration) {\n        result.items.push(this.makeTermProposal(functionSymbol, functionSymbol.node.getParameters(), existingNode));\n      }\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.makeTermProposal = function (symbol, parameters, existingNode) {\n    var decl = symbol.node;\n    var params = parameters.getChildren().map(function (c) {\n      return c instanceof nodes.FunctionParameter ? c.getName() : c.getText();\n    });\n    var insertText = symbol.name + '(' + params.map(function (p, index) {\n      return '${' + (index + 1) + ':' + p + '}';\n    }).join(', ') + ')';\n    return {\n      label: symbol.name,\n      detail: symbol.name + '(' + params.join(', ') + ')',\n      textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),\n      insertTextFormat: SnippetFormat,\n      kind: CompletionItemKind.Function,\n      sortText: 'z'\n    };\n  };\n\n  CSSCompletion.prototype.getCompletionsForSupportsCondition = function (supportsCondition, result) {\n    var child = supportsCondition.findFirstChildBeforeOffset(this.offset);\n\n    if (child) {\n      if (child instanceof nodes.Declaration) {\n        if (!isDefined(child.colonPosition || this.offset <= child.colonPosition)) {\n          return this.getCompletionsForDeclarationProperty(child, result);\n        } else {\n          return this.getCompletionsForDeclarationValue(child, result);\n        }\n      } else if (child instanceof nodes.SupportsCondition) {\n        return this.getCompletionsForSupportsCondition(child, result);\n      }\n    }\n\n    if (isDefined(supportsCondition.lParent) && this.offset > supportsCondition.lParent && (!isDefined(supportsCondition.rParent) || this.offset <= supportsCondition.rParent)) {\n      return this.getCompletionsForDeclarationProperty(null, result);\n    }\n\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionsForSupports = function (supports, result) {\n    var declarations = supports.getDeclarations();\n    var inInCondition = !declarations || this.offset <= declarations.offset;\n\n    if (inInCondition) {\n      var child = supports.findFirstChildBeforeOffset(this.offset);\n\n      if (child instanceof nodes.SupportsCondition) {\n        return this.getCompletionsForSupportsCondition(child, result);\n      }\n\n      return result;\n    }\n\n    return this.getCompletionForTopLevel(result);\n  };\n\n  CSSCompletion.prototype.getCompletionsForExtendsReference = function (extendsRef, existingNode, result) {\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionForUriLiteralValue = function (uriLiteralNode, result) {\n    var uriValue;\n    var position;\n    var range; // No children, empty value\n\n    if (uriLiteralNode.getChildren().length === 0) {\n      uriValue = '';\n      position = this.position;\n      var emptyURIValuePosition = this.textDocument.positionAt(uriLiteralNode.offset + 'url('.length);\n      range = Range.create(emptyURIValuePosition, emptyURIValuePosition);\n    } else {\n      var uriValueNode = uriLiteralNode.getChild(0);\n      uriValue = uriValueNode.getText();\n      position = this.position;\n      range = this.getCompletionRange(uriValueNode);\n    }\n\n    this.completionParticipants.forEach(function (participant) {\n      if (participant.onCssURILiteralValue) {\n        participant.onCssURILiteralValue({\n          uriValue: uriValue,\n          position: position,\n          range: range\n        });\n      }\n    });\n    return result;\n  };\n\n  CSSCompletion.prototype.getCompletionForImportPath = function (importPathNode, result) {\n    var _this = this;\n\n    this.completionParticipants.forEach(function (participant) {\n      if (participant.onCssImportPath) {\n        participant.onCssImportPath({\n          pathValue: importPathNode.getText(),\n          position: _this.position,\n          range: _this.getCompletionRange(importPathNode)\n        });\n      }\n    });\n    return result;\n  };\n\n  return CSSCompletion;\n}();\n\nexport { CSSCompletion };\n\nvar Set =\n/** @class */\nfunction () {\n  function Set() {\n    this.entries = {};\n  }\n\n  Set.prototype.add = function (entry) {\n    this.entries[entry] = true;\n  };\n\n  Set.prototype.getEntries = function () {\n    return Object.keys(this.entries);\n  };\n\n  return Set;\n}();\n\nfunction moveCursorInsideParenthesis(text) {\n  return text.replace(/\\(\\)$/, \"($1)\");\n}\n\nfunction collectValues(styleSheet, declaration) {\n  var fullPropertyName = declaration.getFullPropertyName();\n  var entries = new Set();\n\n  function visitValue(node) {\n    if (node instanceof nodes.Identifier || node instanceof nodes.NumericValue || node instanceof nodes.HexColorValue) {\n      entries.add(node.getText());\n    }\n\n    return true;\n  }\n\n  function matchesProperty(decl) {\n    var propertyName = decl.getFullPropertyName();\n    return fullPropertyName === propertyName;\n  }\n\n  function vistNode(node) {\n    if (node instanceof nodes.Declaration && node !== declaration) {\n      if (matchesProperty(node)) {\n        var value = node.getValue();\n\n        if (value) {\n          value.accept(visitValue);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  styleSheet.accept(vistNode);\n  return entries;\n}\n\nvar ColorValueCollector =\n/** @class */\nfunction () {\n  function ColorValueCollector(entries, currentOffset) {\n    this.entries = entries;\n    this.currentOffset = currentOffset; // nothing to do\n  }\n\n  ColorValueCollector.prototype.visitNode = function (node) {\n    if (node instanceof nodes.HexColorValue || node instanceof nodes.Function && languageFacts.isColorConstructor(node)) {\n      if (this.currentOffset < node.offset || node.end < this.currentOffset) {\n        this.entries.add(node.getText());\n      }\n    }\n\n    return true;\n  };\n\n  return ColorValueCollector;\n}();\n\nfunction isDefined(obj) {\n  return typeof obj !== 'undefined';\n}\n\nfunction getCurrentWord(document, offset) {\n  var i = offset - 1;\n  var text = document.getText();\n\n  while (i >= 0 && ' \\t\\n\\r\":{[()]},*>+'.indexOf(text.charAt(i)) === -1) {\n    i--;\n  }\n\n  return text.substring(i + 1, offset);\n}","map":null,"metadata":{},"sourceType":"module"}