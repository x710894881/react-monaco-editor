{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as strings from '../../../../base/common/strings.js';\nimport * as browser from '../../../../base/browser/browser.js';\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { matchesFuzzy } from '../../../../base/common/filters.js';\nimport { QuickOpenEntryGroup, QuickOpenModel } from '../../../../base/parts/quickopen/browser/quickOpenModel.js';\nimport { registerEditorAction } from '../../../browser/editorExtensions.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { BaseEditorQuickOpenAction } from './editorQuickOpen.js';\nimport { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.js';\nimport { QuickCommandNLS } from '../../../common/standaloneStrings.js';\n\nvar EditorActionCommandEntry =\n/** @class */\nfunction (_super) {\n  __extends(EditorActionCommandEntry, _super);\n\n  function EditorActionCommandEntry(key, keyAriaLabel, highlights, action, editor) {\n    var _this = _super.call(this) || this;\n\n    _this.key = key;\n    _this.keyAriaLabel = keyAriaLabel;\n\n    _this.setHighlights(highlights);\n\n    _this.action = action;\n    _this.editor = editor;\n    return _this;\n  }\n\n  EditorActionCommandEntry.prototype.getLabel = function () {\n    return this.action.label;\n  };\n\n  EditorActionCommandEntry.prototype.getAriaLabel = function () {\n    if (this.keyAriaLabel) {\n      return strings.format(QuickCommandNLS.ariaLabelEntryWithKey, this.getLabel(), this.keyAriaLabel);\n    }\n\n    return strings.format(QuickCommandNLS.ariaLabelEntry, this.getLabel());\n  };\n\n  EditorActionCommandEntry.prototype.getGroupLabel = function () {\n    return this.key;\n  };\n\n  EditorActionCommandEntry.prototype.run = function (mode, context) {\n    var _this = this;\n\n    if (mode === 1\n    /* OPEN */\n    ) {\n        // Use a timeout to give the quick open widget a chance to close itself first\n        setTimeout(function () {\n          // Some actions are enabled only when editor has focus\n          _this.editor.focus();\n\n          try {\n            var promise = _this.action.run() || Promise.resolve();\n            promise.then(undefined, onUnexpectedError);\n          } catch (error) {\n            onUnexpectedError(error);\n          }\n        }, 50);\n        return true;\n      }\n\n    return false;\n  };\n\n  return EditorActionCommandEntry;\n}(QuickOpenEntryGroup);\n\nexport { EditorActionCommandEntry };\n\nvar QuickCommandAction =\n/** @class */\nfunction (_super) {\n  __extends(QuickCommandAction, _super);\n\n  function QuickCommandAction() {\n    return _super.call(this, QuickCommandNLS.quickCommandActionInput, {\n      id: 'editor.action.quickCommand',\n      label: QuickCommandNLS.quickCommandActionLabel,\n      alias: 'Command Palette',\n      precondition: undefined,\n      kbOpts: {\n        kbExpr: EditorContextKeys.focus,\n        primary: browser.isIE ? 512\n        /* Alt */\n        | 59\n        /* F1 */\n        : 59\n        /* F1 */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      },\n      menuOpts: {\n        group: 'z_commands',\n        order: 1\n      }\n    }) || this;\n  }\n\n  QuickCommandAction.prototype.run = function (accessor, editor) {\n    var _this = this;\n\n    var keybindingService = accessor.get(IKeybindingService);\n\n    this._show(this.getController(editor), {\n      getModel: function (value) {\n        return new QuickOpenModel(_this._editorActionsToEntries(keybindingService, editor, value));\n      },\n      getAutoFocus: function (searchValue) {\n        return {\n          autoFocusFirstEntry: true,\n          autoFocusPrefixMatch: searchValue\n        };\n      }\n    });\n  };\n\n  QuickCommandAction.prototype._sort = function (elementA, elementB) {\n    var elementAName = (elementA.getLabel() || '').toLowerCase();\n    var elementBName = (elementB.getLabel() || '').toLowerCase();\n    return elementAName.localeCompare(elementBName);\n  };\n\n  QuickCommandAction.prototype._editorActionsToEntries = function (keybindingService, editor, searchValue) {\n    var actions = editor.getSupportedActions();\n    var entries = [];\n\n    for (var _i = 0, actions_1 = actions; _i < actions_1.length; _i++) {\n      var action = actions_1[_i];\n      var keybinding = keybindingService.lookupKeybinding(action.id);\n\n      if (action.label) {\n        var highlights = matchesFuzzy(searchValue, action.label);\n\n        if (highlights) {\n          entries.push(new EditorActionCommandEntry(keybinding ? keybinding.getLabel() || '' : '', keybinding ? keybinding.getAriaLabel() || '' : '', highlights, action, editor));\n        }\n      }\n    } // Sort by name\n\n\n    entries = entries.sort(this._sort);\n    return entries;\n  };\n\n  return QuickCommandAction;\n}(BaseEditorQuickOpenAction);\n\nexport { QuickCommandAction };\nregisterEditorAction(QuickCommandAction);","map":null,"metadata":{},"sourceType":"module"}