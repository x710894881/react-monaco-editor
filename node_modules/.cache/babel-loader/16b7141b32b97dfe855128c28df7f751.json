{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../modes.js';\n\nvar LineTokens =\n/** @class */\nfunction () {\n  function LineTokens(tokens, text) {\n    this._tokens = tokens;\n    this._tokensCount = this._tokens.length >>> 1;\n    this._text = text;\n  }\n\n  LineTokens.prototype.equals = function (other) {\n    if (other instanceof LineTokens) {\n      return this.slicedEquals(other, 0, this._tokensCount);\n    }\n\n    return false;\n  };\n\n  LineTokens.prototype.slicedEquals = function (other, sliceFromTokenIndex, sliceTokenCount) {\n    if (this._text !== other._text) {\n      return false;\n    }\n\n    if (this._tokensCount !== other._tokensCount) {\n      return false;\n    }\n\n    var from = sliceFromTokenIndex << 1;\n    var to = from + (sliceTokenCount << 1);\n\n    for (var i = from; i < to; i++) {\n      if (this._tokens[i] !== other._tokens[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  LineTokens.prototype.getLineContent = function () {\n    return this._text;\n  };\n\n  LineTokens.prototype.getCount = function () {\n    return this._tokensCount;\n  };\n\n  LineTokens.prototype.getStartOffset = function (tokenIndex) {\n    if (tokenIndex > 0) {\n      return this._tokens[tokenIndex - 1 << 1];\n    }\n\n    return 0;\n  };\n\n  LineTokens.prototype.getLanguageId = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getLanguageId(metadata);\n  };\n\n  LineTokens.prototype.getStandardTokenType = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getTokenType(metadata);\n  };\n\n  LineTokens.prototype.getForeground = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getForeground(metadata);\n  };\n\n  LineTokens.prototype.getClassName = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getClassNameFromMetadata(metadata);\n  };\n\n  LineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n  };\n\n  LineTokens.prototype.getEndOffset = function (tokenIndex) {\n    return this._tokens[tokenIndex << 1];\n  };\n  /**\n   * Find the token containing offset `offset`.\n   * @param offset The search offset\n   * @return The index of the token containing the offset.\n   */\n\n\n  LineTokens.prototype.findTokenIndexAtOffset = function (offset) {\n    return LineTokens.findIndexInTokensArray(this._tokens, offset);\n  };\n\n  LineTokens.prototype.inflate = function () {\n    return this;\n  };\n\n  LineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaOffset) {\n    return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);\n  };\n\n  LineTokens.convertToEndOffset = function (tokens, lineTextLength) {\n    var tokenCount = tokens.length >>> 1;\n    var lastTokenIndex = tokenCount - 1;\n\n    for (var tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n      tokens[tokenIndex << 1] = tokens[tokenIndex + 1 << 1];\n    }\n\n    tokens[lastTokenIndex << 1] = lineTextLength;\n  };\n\n  LineTokens.findIndexInTokensArray = function (tokens, desiredIndex) {\n    if (tokens.length <= 2) {\n      return 0;\n    }\n\n    var low = 0;\n    var high = (tokens.length >>> 1) - 1;\n\n    while (low < high) {\n      var mid = low + Math.floor((high - low) / 2);\n      var endOffset = tokens[mid << 1];\n\n      if (endOffset === desiredIndex) {\n        return mid + 1;\n      } else if (endOffset < desiredIndex) {\n        low = mid + 1;\n      } else if (endOffset > desiredIndex) {\n        high = mid;\n      }\n    }\n\n    return low;\n  };\n\n  return LineTokens;\n}();\n\nexport { LineTokens };\n\nvar SlicedLineTokens =\n/** @class */\nfunction () {\n  function SlicedLineTokens(source, startOffset, endOffset, deltaOffset) {\n    this._source = source;\n    this._startOffset = startOffset;\n    this._endOffset = endOffset;\n    this._deltaOffset = deltaOffset;\n    this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n    this._tokensCount = 0;\n\n    for (var i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n      var tokenStartOffset = source.getStartOffset(i);\n\n      if (tokenStartOffset >= endOffset) {\n        break;\n      }\n\n      this._tokensCount++;\n    }\n  }\n\n  SlicedLineTokens.prototype.equals = function (other) {\n    if (other instanceof SlicedLineTokens) {\n      return this._startOffset === other._startOffset && this._endOffset === other._endOffset && this._deltaOffset === other._deltaOffset && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount);\n    }\n\n    return false;\n  };\n\n  SlicedLineTokens.prototype.getCount = function () {\n    return this._tokensCount;\n  };\n\n  SlicedLineTokens.prototype.getForeground = function (tokenIndex) {\n    return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n  };\n\n  SlicedLineTokens.prototype.getEndOffset = function (tokenIndex) {\n    var tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n\n    return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n  };\n\n  SlicedLineTokens.prototype.getClassName = function (tokenIndex) {\n    return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n  };\n\n  SlicedLineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {\n    return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n  };\n\n  SlicedLineTokens.prototype.findTokenIndexAtOffset = function (offset) {\n    return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n  };\n\n  return SlicedLineTokens;\n}();\n\nexport { SlicedLineTokens };","map":null,"metadata":{},"sourceType":"module"}