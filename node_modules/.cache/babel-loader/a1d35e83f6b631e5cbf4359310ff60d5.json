{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { fuzzyScore, fuzzyScoreGracefulAggressive, FuzzyScore, anyScore } from '../../../base/common/filters.js';\nimport { EDITOR_DEFAULTS } from '../../common/config/editorOptions.js';\nimport { compareIgnoreCase } from '../../../base/common/strings.js';\n\nvar LineContext =\n/** @class */\nfunction () {\n  function LineContext(leadingLineContent, characterCountDelta) {\n    this.leadingLineContent = leadingLineContent;\n    this.characterCountDelta = characterCountDelta;\n  }\n\n  return LineContext;\n}();\n\nexport { LineContext };\n\nvar CompletionModel =\n/** @class */\nfunction () {\n  function CompletionModel(items, column, lineContext, wordDistance, options) {\n    if (options === void 0) {\n      options = EDITOR_DEFAULTS.contribInfo.suggest;\n    }\n\n    this._snippetCompareFn = CompletionModel._compareCompletionItems;\n    this._items = items;\n    this._column = column;\n    this._wordDistance = wordDistance;\n    this._options = options;\n    this._refilterKind = 1\n    /* All */\n    ;\n    this._lineContext = lineContext;\n\n    if (options.snippets === 'top') {\n      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\n    } else if (options.snippets === 'bottom') {\n      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\n    }\n  }\n\n  Object.defineProperty(CompletionModel.prototype, \"lineContext\", {\n    get: function () {\n      return this._lineContext;\n    },\n    set: function (value) {\n      if (this._lineContext.leadingLineContent !== value.leadingLineContent || this._lineContext.characterCountDelta !== value.characterCountDelta) {\n        this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2\n        /* Incr */\n        : 1\n        /* All */\n        ;\n        this._lineContext = value;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompletionModel.prototype, \"items\", {\n    get: function () {\n      this._ensureCachedState();\n\n      return this._filteredItems;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompletionModel.prototype, \"incomplete\", {\n    get: function () {\n      this._ensureCachedState();\n\n      return this._isIncomplete;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CompletionModel.prototype.adopt = function (except) {\n    var res = new Array();\n\n    for (var i = 0; i < this._items.length;) {\n      if (!except.has(this._items[i].provider)) {\n        res.push(this._items[i]); // unordered removed\n\n        this._items[i] = this._items[this._items.length - 1];\n\n        this._items.pop();\n      } else {\n        // continue with next item\n        i++;\n      }\n    }\n\n    this._refilterKind = 1\n    /* All */\n    ;\n    return res;\n  };\n\n  Object.defineProperty(CompletionModel.prototype, \"stats\", {\n    get: function () {\n      this._ensureCachedState();\n\n      return this._stats;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CompletionModel.prototype._ensureCachedState = function () {\n    if (this._refilterKind !== 0\n    /* Nothing */\n    ) {\n        this._createCachedState();\n      }\n  };\n\n  CompletionModel.prototype._createCachedState = function () {\n    this._isIncomplete = new Set();\n    this._stats = {\n      suggestionCount: 0,\n      snippetCount: 0,\n      textCount: 0\n    };\n    var _a = this._lineContext,\n        leadingLineContent = _a.leadingLineContent,\n        characterCountDelta = _a.characterCountDelta;\n    var word = '';\n    var wordLow = ''; // incrementally filter less\n\n    var source = this._refilterKind === 1\n    /* All */\n    ? this._items : this._filteredItems;\n    var target = []; // picks a score function based on the number of\n    // items that we have to score/filter and based on the\n    // user-configuration\n\n    var scoreFn = !this._options.filterGraceful || source.length > 2000 ? fuzzyScore : fuzzyScoreGracefulAggressive;\n\n    for (var i = 0; i < source.length; i++) {\n      var item = source[i]; // collect those supports that signaled having\n      // an incomplete result\n\n      if (item.container.incomplete) {\n        this._isIncomplete.add(item.provider);\n      } // 'word' is that remainder of the current line that we\n      // filter and score against. In theory each suggestion uses a\n      // different word, but in practice not - that's why we cache\n\n\n      var overwriteBefore = item.position.column - item.completion.range.startColumn;\n      var wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\n\n      if (word.length !== wordLen) {\n        word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n        wordLow = word.toLowerCase();\n      } // remember the word against which this item was\n      // scored\n\n\n      item.word = word;\n\n      if (wordLen === 0) {\n        // when there is nothing to score against, don't\n        // event try to do. Use a const rank and rely on\n        // the fallback-sort using the initial sort order.\n        // use a score of `-100` because that is out of the\n        // bound of values `fuzzyScore` will return\n        item.score = FuzzyScore.Default;\n      } else {\n        // skip word characters that are whitespace until\n        // we have hit the replace range (overwriteBefore)\n        var wordPos = 0;\n\n        while (wordPos < overwriteBefore) {\n          var ch = word.charCodeAt(wordPos);\n\n          if (ch === 32\n          /* Space */\n          || ch === 9\n          /* Tab */\n          ) {\n              wordPos += 1;\n            } else {\n            break;\n          }\n        }\n\n        if (wordPos >= wordLen) {\n          // the wordPos at which scoring starts is the whole word\n          // and therefore the same rules as not having a word apply\n          item.score = FuzzyScore.Default;\n        } else if (typeof item.completion.filterText === 'string') {\n          // when there is a `filterText` it must match the `word`.\n          // if it matches we check with the label to compute highlights\n          // and if that doesn't yield a result we have no highlights,\n          // despite having the match\n          var match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, false);\n\n          if (!match) {\n            continue; // NO match\n          }\n\n          if (compareIgnoreCase(item.completion.filterText, item.completion.label) === 0) {\n            // filterText and label are actually the same -> use good highlights\n            item.score = match;\n          } else {\n            // re-run the scorer on the label in the hope of a result BUT use the rank\n            // of the filterText-match\n            item.score = anyScore(word, wordLow, wordPos, item.completion.label, item.labelLow, 0);\n            item.score[0] = match[0]; // use score from filterText\n          }\n        } else {\n          // by default match `word` against the `label`\n          var match = scoreFn(word, wordLow, wordPos, item.completion.label, item.labelLow, 0, false);\n\n          if (!match) {\n            continue; // NO match\n          }\n\n          item.score = match;\n        }\n      }\n\n      item.idx = i;\n      item.distance = this._wordDistance.distance(item.position, item.completion);\n      target.push(item); // update stats\n\n      this._stats.suggestionCount++;\n\n      switch (item.completion.kind) {\n        case 25\n        /* Snippet */\n        :\n          this._stats.snippetCount++;\n          break;\n\n        case 18\n        /* Text */\n        :\n          this._stats.textCount++;\n          break;\n      }\n    }\n\n    this._filteredItems = target.sort(this._snippetCompareFn);\n    this._refilterKind = 0\n    /* Nothing */\n    ;\n  };\n\n  CompletionModel._compareCompletionItems = function (a, b) {\n    if (a.score[0] > b.score[0]) {\n      return -1;\n    } else if (a.score[0] < b.score[0]) {\n      return 1;\n    } else if (a.distance < b.distance) {\n      return -1;\n    } else if (a.distance > b.distance) {\n      return 1;\n    } else if (a.idx < b.idx) {\n      return -1;\n    } else if (a.idx > b.idx) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  CompletionModel._compareCompletionItemsSnippetsDown = function (a, b) {\n    if (a.completion.kind !== b.completion.kind) {\n      if (a.completion.kind === 25\n      /* Snippet */\n      ) {\n          return 1;\n        } else if (b.completion.kind === 25\n      /* Snippet */\n      ) {\n          return -1;\n        }\n    }\n\n    return CompletionModel._compareCompletionItems(a, b);\n  };\n\n  CompletionModel._compareCompletionItemsSnippetsUp = function (a, b) {\n    if (a.completion.kind !== b.completion.kind) {\n      if (a.completion.kind === 25\n      /* Snippet */\n      ) {\n          return -1;\n        } else if (b.completion.kind === 25\n      /* Snippet */\n      ) {\n          return 1;\n        }\n    }\n\n    return CompletionModel._compareCompletionItems(a, b);\n  };\n\n  return CompletionModel;\n}();\n\nexport { CompletionModel };","map":null,"metadata":{},"sourceType":"module"}