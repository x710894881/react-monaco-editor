{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Color } from '../../../base/common/color.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS } from '../config/editorOptions.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TokenizationRegistry } from '../modes.js';\nimport { tokenizeLineToHTML } from '../modes/textToHtmlTokenizer.js';\nimport { MinimapTokensColorTracker } from '../view/minimapCharRenderer.js';\nimport * as viewEvents from '../view/viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { CharacterHardWrappingLineMapperFactory } from './characterHardWrappingLineMapper.js';\nimport { IdentityLinesCollection, SplitLinesCollection } from './splitLinesCollection.js';\nimport { MinimapLinesRenderingData, ViewLineRenderingData } from './viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nvar USE_IDENTITY_LINES_COLLECTION = true;\n\nvar ViewModel =\n/** @class */\nfunction (_super) {\n  __extends(ViewModel, _super);\n\n  function ViewModel(editorId, configuration, model, scheduleAtNextAnimationFrame) {\n    var _this = _super.call(this) || this;\n\n    _this.editorId = editorId;\n    _this.configuration = configuration;\n    _this.model = model;\n    _this._tokenizeViewportSoon = _this._register(new RunOnceScheduler(function () {\n      return _this.tokenizeViewport();\n    }, 50));\n    _this.hasFocus = false;\n    _this.viewportStartLine = -1;\n    _this.viewportStartLineTrackedRange = null;\n    _this.viewportStartLineDelta = 0;\n\n    if (USE_IDENTITY_LINES_COLLECTION && _this.model.isTooLargeForTokenization()) {\n      _this.lines = new IdentityLinesCollection(_this.model);\n    } else {\n      var conf = _this.configuration.editor;\n      var hardWrappingLineMapperFactory = new CharacterHardWrappingLineMapperFactory(conf.wrappingInfo.wordWrapBreakBeforeCharacters, conf.wrappingInfo.wordWrapBreakAfterCharacters, conf.wrappingInfo.wordWrapBreakObtrusiveCharacters);\n      _this.lines = new SplitLinesCollection(_this.model, hardWrappingLineMapperFactory, _this.model.getOptions().tabSize, conf.wrappingInfo.wrappingColumn, conf.fontInfo.typicalFullwidthCharacterWidth / conf.fontInfo.typicalHalfwidthCharacterWidth, conf.wrappingInfo.wrappingIndent);\n    }\n\n    _this.coordinatesConverter = _this.lines.createCoordinatesConverter();\n    _this.viewLayout = _this._register(new ViewLayout(_this.configuration, _this.getLineCount(), scheduleAtNextAnimationFrame));\n\n    _this._register(_this.viewLayout.onDidScroll(function (e) {\n      if (e.scrollTopChanged) {\n        _this._tokenizeViewportSoon.schedule();\n      }\n\n      try {\n        var eventsCollector = _this._beginEmit();\n\n        eventsCollector.emit(new viewEvents.ViewScrollChangedEvent(e));\n      } finally {\n        _this._endEmit();\n      }\n    }));\n\n    _this.decorations = new ViewModelDecorations(_this.editorId, _this.model, _this.configuration, _this.lines, _this.coordinatesConverter);\n\n    _this._registerModelEvents();\n\n    _this._register(_this.configuration.onDidChange(function (e) {\n      try {\n        var eventsCollector = _this._beginEmit();\n\n        _this._onConfigurationChanged(eventsCollector, e);\n      } finally {\n        _this._endEmit();\n      }\n    }));\n\n    _this._register(MinimapTokensColorTracker.getInstance().onDidChange(function () {\n      try {\n        var eventsCollector = _this._beginEmit();\n\n        eventsCollector.emit(new viewEvents.ViewTokensColorsChangedEvent());\n      } finally {\n        _this._endEmit();\n      }\n    }));\n\n    return _this;\n  }\n\n  ViewModel.prototype.dispose = function () {\n    // First remove listeners, as disposing the lines might end up sending\n    // model decoration changed events ... and we no longer care about them ...\n    _super.prototype.dispose.call(this);\n\n    this.decorations.dispose();\n    this.lines.dispose();\n    this.viewportStartLineTrackedRange = this.model._setTrackedRange(this.viewportStartLineTrackedRange, null, 1\n    /* NeverGrowsWhenTypingAtEdges */\n    );\n  };\n\n  ViewModel.prototype.tokenizeViewport = function () {\n    var linesViewportData = this.viewLayout.getLinesViewportData();\n    var startPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(linesViewportData.startLineNumber, 1));\n    var endPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(linesViewportData.endLineNumber, 1));\n    this.model.tokenizeViewport(startPosition.lineNumber, endPosition.lineNumber);\n  };\n\n  ViewModel.prototype.setHasFocus = function (hasFocus) {\n    this.hasFocus = hasFocus;\n  };\n\n  ViewModel.prototype._onConfigurationChanged = function (eventsCollector, e) {\n    // We might need to restore the current centered view range, so save it (if available)\n    var previousViewportStartModelPosition = null;\n\n    if (this.viewportStartLine !== -1) {\n      var previousViewportStartViewPosition = new Position(this.viewportStartLine, this.getLineMinColumn(this.viewportStartLine));\n      previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n    }\n\n    var restorePreviousViewportStart = false;\n    var conf = this.configuration.editor;\n\n    if (this.lines.setWrappingSettings(conf.wrappingInfo.wrappingIndent, conf.wrappingInfo.wrappingColumn, conf.fontInfo.typicalFullwidthCharacterWidth / conf.fontInfo.typicalHalfwidthCharacterWidth)) {\n      eventsCollector.emit(new viewEvents.ViewFlushedEvent());\n      eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());\n      eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());\n      this.decorations.onLineMappingChanged();\n      this.viewLayout.onFlushed(this.getLineCount());\n\n      if (this.viewLayout.getCurrentScrollTop() !== 0) {\n        // Never change the scroll position from 0 to something else...\n        restorePreviousViewportStart = true;\n      }\n    }\n\n    if (e.readOnly) {\n      // Must read again all decorations due to readOnly filtering\n      this.decorations.reset();\n      eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());\n    }\n\n    eventsCollector.emit(new viewEvents.ViewConfigurationChangedEvent(e));\n    this.viewLayout.onConfigurationChanged(e);\n\n    if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n      var viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n      var viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n      this.viewLayout.setScrollPositionNow({\n        scrollTop: viewPositionTop + this.viewportStartLineDelta\n      });\n    }\n  };\n\n  ViewModel.prototype._registerModelEvents = function () {\n    var _this = this;\n\n    this._register(this.model.onDidChangeRawContentFast(function (e) {\n      try {\n        var eventsCollector = _this._beginEmit();\n\n        var hadOtherModelChange = false;\n        var hadModelLineChangeThatChangedLineMapping = false;\n        var changes = e.changes;\n        var versionId = e.versionId;\n\n        for (var j = 0, lenJ = changes.length; j < lenJ; j++) {\n          var change = changes[j];\n\n          switch (change.changeType) {\n            case 1\n            /* Flush */\n            :\n              {\n                _this.lines.onModelFlushed();\n\n                eventsCollector.emit(new viewEvents.ViewFlushedEvent());\n\n                _this.decorations.reset();\n\n                _this.viewLayout.onFlushed(_this.getLineCount());\n\n                hadOtherModelChange = true;\n                break;\n              }\n\n            case 3\n            /* LinesDeleted */\n            :\n              {\n                var linesDeletedEvent = _this.lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n\n                if (linesDeletedEvent !== null) {\n                  eventsCollector.emit(linesDeletedEvent);\n\n                  _this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                }\n\n                hadOtherModelChange = true;\n                break;\n              }\n\n            case 4\n            /* LinesInserted */\n            :\n              {\n                var linesInsertedEvent = _this.lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, change.detail);\n\n                if (linesInsertedEvent !== null) {\n                  eventsCollector.emit(linesInsertedEvent);\n\n                  _this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                }\n\n                hadOtherModelChange = true;\n                break;\n              }\n\n            case 2\n            /* LineChanged */\n            :\n              {\n                var _a = _this.lines.onModelLineChanged(versionId, change.lineNumber, change.detail),\n                    lineMappingChanged = _a[0],\n                    linesChangedEvent = _a[1],\n                    linesInsertedEvent = _a[2],\n                    linesDeletedEvent = _a[3];\n\n                hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n\n                if (linesChangedEvent) {\n                  eventsCollector.emit(linesChangedEvent);\n                }\n\n                if (linesInsertedEvent) {\n                  eventsCollector.emit(linesInsertedEvent);\n\n                  _this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                }\n\n                if (linesDeletedEvent) {\n                  eventsCollector.emit(linesDeletedEvent);\n\n                  _this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                }\n\n                break;\n              }\n\n            case 5\n            /* EOLChanged */\n            :\n              {\n                // Nothing to do. The new version will be accepted below\n                break;\n              }\n          }\n        }\n\n        _this.lines.acceptVersionId(versionId);\n\n        _this.viewLayout.onHeightMaybeChanged();\n\n        if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n          eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());\n          eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());\n\n          _this.decorations.onLineMappingChanged();\n        }\n      } finally {\n        _this._endEmit();\n      } // Update the configuration and reset the centered view line\n\n\n      _this.viewportStartLine = -1;\n\n      _this.configuration.setMaxLineNumber(_this.model.getLineCount()); // Recover viewport\n\n\n      if (!_this.hasFocus && _this.model.getAttachedEditorCount() >= 2 && _this.viewportStartLineTrackedRange) {\n        var modelRange = _this.model._getTrackedRange(_this.viewportStartLineTrackedRange);\n\n        if (modelRange) {\n          var viewPosition = _this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n\n          var viewPositionTop = _this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n\n          _this.viewLayout.setScrollPositionNow({\n            scrollTop: viewPositionTop + _this.viewportStartLineDelta\n          });\n        }\n      }\n    }));\n\n    this._register(this.model.onDidChangeTokens(function (e) {\n      var viewRanges = [];\n\n      for (var j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n        var modelRange = e.ranges[j];\n\n        var viewStartLineNumber = _this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n\n        var viewEndLineNumber = _this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, _this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n\n        viewRanges[j] = {\n          fromLineNumber: viewStartLineNumber,\n          toLineNumber: viewEndLineNumber\n        };\n      }\n\n      try {\n        var eventsCollector = _this._beginEmit();\n\n        eventsCollector.emit(new viewEvents.ViewTokensChangedEvent(viewRanges));\n      } finally {\n        _this._endEmit();\n      }\n\n      if (e.tokenizationSupportChanged) {\n        _this._tokenizeViewportSoon.schedule();\n      }\n    }));\n\n    this._register(this.model.onDidChangeLanguageConfiguration(function (e) {\n      try {\n        var eventsCollector = _this._beginEmit();\n\n        eventsCollector.emit(new viewEvents.ViewLanguageConfigurationEvent());\n      } finally {\n        _this._endEmit();\n      }\n    }));\n\n    this._register(this.model.onDidChangeOptions(function (e) {\n      // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n      if (_this.lines.setTabSize(_this.model.getOptions().tabSize)) {\n        _this.decorations.onLineMappingChanged();\n\n        _this.viewLayout.onFlushed(_this.getLineCount());\n\n        try {\n          var eventsCollector = _this._beginEmit();\n\n          eventsCollector.emit(new viewEvents.ViewFlushedEvent());\n          eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());\n          eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());\n        } finally {\n          _this._endEmit();\n        }\n      }\n    }));\n\n    this._register(this.model.onDidChangeDecorations(function (e) {\n      _this.decorations.onModelDecorationsChanged();\n\n      try {\n        var eventsCollector = _this._beginEmit();\n\n        eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());\n      } finally {\n        _this._endEmit();\n      }\n    }));\n  };\n\n  ViewModel.prototype.setHiddenAreas = function (ranges) {\n    try {\n      var eventsCollector = this._beginEmit();\n\n      var lineMappingChanged = this.lines.setHiddenAreas(ranges);\n\n      if (lineMappingChanged) {\n        eventsCollector.emit(new viewEvents.ViewFlushedEvent());\n        eventsCollector.emit(new viewEvents.ViewLineMappingChangedEvent());\n        eventsCollector.emit(new viewEvents.ViewDecorationsChangedEvent());\n        this.decorations.onLineMappingChanged();\n        this.viewLayout.onFlushed(this.getLineCount());\n        this.viewLayout.onHeightMaybeChanged();\n      }\n    } finally {\n      this._endEmit();\n    }\n  };\n\n  ViewModel.prototype.getVisibleRanges = function () {\n    var visibleViewRange = this.getCompletelyVisibleViewRange();\n    var visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n    var hiddenAreas = this.lines.getHiddenAreas();\n\n    if (hiddenAreas.length === 0) {\n      return [visibleRange];\n    }\n\n    var result = [],\n        resultLen = 0;\n    var startLineNumber = visibleRange.startLineNumber;\n    var startColumn = visibleRange.startColumn;\n    var endLineNumber = visibleRange.endLineNumber;\n    var endColumn = visibleRange.endColumn;\n\n    for (var i = 0, len = hiddenAreas.length; i < len; i++) {\n      var hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n      var hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n\n      if (hiddenEndLineNumber < startLineNumber) {\n        continue;\n      }\n\n      if (hiddenStartLineNumber > endLineNumber) {\n        continue;\n      }\n\n      if (startLineNumber < hiddenStartLineNumber) {\n        result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n      }\n\n      startLineNumber = hiddenEndLineNumber + 1;\n      startColumn = 1;\n    }\n\n    if (startLineNumber < endLineNumber || startLineNumber === endLineNumber && startColumn < endColumn) {\n      result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n\n    return result;\n  };\n\n  ViewModel.prototype.getCompletelyVisibleViewRange = function () {\n    var partialData = this.viewLayout.getLinesViewportData();\n    var startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n    var endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n  };\n\n  ViewModel.prototype.getCompletelyVisibleViewRangeAtScrollTop = function (scrollTop) {\n    var partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n    var startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n    var endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n  };\n\n  ViewModel.prototype.saveState = function () {\n    var compatViewState = this.viewLayout.saveState();\n    var scrollTop = compatViewState.scrollTop;\n    var firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n    var firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n    var firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n    return {\n      scrollLeft: compatViewState.scrollLeft,\n      firstPosition: firstPosition,\n      firstPositionDeltaTop: firstPositionDeltaTop\n    };\n  };\n\n  ViewModel.prototype.reduceRestoreState = function (state) {\n    if (typeof state.firstPosition === 'undefined') {\n      // This is a view state serialized by an older version\n      return this._reduceRestoreStateCompatibility(state);\n    }\n\n    var modelPosition = this.model.validatePosition(state.firstPosition);\n    var viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n    var scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n    return {\n      scrollLeft: state.scrollLeft,\n      scrollTop: scrollTop\n    };\n  };\n\n  ViewModel.prototype._reduceRestoreStateCompatibility = function (state) {\n    return {\n      scrollLeft: state.scrollLeft,\n      scrollTop: state.scrollTopWithoutViewZones\n    };\n  };\n\n  ViewModel.prototype.getTabSize = function () {\n    return this.model.getOptions().tabSize;\n  };\n\n  ViewModel.prototype.getOptions = function () {\n    return this.model.getOptions();\n  };\n\n  ViewModel.prototype.getLineCount = function () {\n    return this.lines.getViewLineCount();\n  };\n  /**\n   * Gives a hint that a lot of requests are about to come in for these line numbers.\n   */\n\n\n  ViewModel.prototype.setViewport = function (startLineNumber, endLineNumber, centeredLineNumber) {\n    this.lines.warmUpLookupCache(startLineNumber, endLineNumber);\n    this.viewportStartLine = startLineNumber;\n    var position = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, this.getLineMinColumn(startLineNumber)));\n    this.viewportStartLineTrackedRange = this.model._setTrackedRange(this.viewportStartLineTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1\n    /* NeverGrowsWhenTypingAtEdges */\n    );\n    var viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n    var scrollTop = this.viewLayout.getCurrentScrollTop();\n    this.viewportStartLineDelta = scrollTop - viewportStartLineTop;\n  };\n\n  ViewModel.prototype.getActiveIndentGuide = function (lineNumber, minLineNumber, maxLineNumber) {\n    return this.lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n  };\n\n  ViewModel.prototype.getLinesIndentGuides = function (startLineNumber, endLineNumber) {\n    return this.lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n  };\n\n  ViewModel.prototype.getLineContent = function (lineNumber) {\n    return this.lines.getViewLineContent(lineNumber);\n  };\n\n  ViewModel.prototype.getLineLength = function (lineNumber) {\n    return this.lines.getViewLineLength(lineNumber);\n  };\n\n  ViewModel.prototype.getLineMinColumn = function (lineNumber) {\n    return this.lines.getViewLineMinColumn(lineNumber);\n  };\n\n  ViewModel.prototype.getLineMaxColumn = function (lineNumber) {\n    return this.lines.getViewLineMaxColumn(lineNumber);\n  };\n\n  ViewModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {\n    var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n    if (result === -1) {\n      return 0;\n    }\n\n    return result + 1;\n  };\n\n  ViewModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {\n    var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n    if (result === -1) {\n      return 0;\n    }\n\n    return result + 2;\n  };\n\n  ViewModel.prototype.getDecorationsInViewport = function (visibleRange) {\n    return this.decorations.getDecorationsViewportData(visibleRange).decorations;\n  };\n\n  ViewModel.prototype.getViewLineRenderingData = function (visibleRange, lineNumber) {\n    var mightContainRTL = this.model.mightContainRTL();\n    var mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n    var tabSize = this.getTabSize();\n    var lineData = this.lines.getViewLineData(lineNumber);\n    var allInlineDecorations = this.decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n    var inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n    return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize);\n  };\n\n  ViewModel.prototype.getViewLineData = function (lineNumber) {\n    return this.lines.getViewLineData(lineNumber);\n  };\n\n  ViewModel.prototype.getMinimapLinesRenderingData = function (startLineNumber, endLineNumber, needed) {\n    var result = this.lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n    return new MinimapLinesRenderingData(this.getTabSize(), result);\n  };\n\n  ViewModel.prototype.getAllOverviewRulerDecorations = function (theme) {\n    return this.lines.getAllOverviewRulerDecorations(this.editorId, this.configuration.editor.readOnly, theme);\n  };\n\n  ViewModel.prototype.invalidateOverviewRulerColorCache = function () {\n    var decorations = this.model.getOverviewRulerDecorations();\n\n    for (var _i = 0, decorations_1 = decorations; _i < decorations_1.length; _i++) {\n      var decoration = decorations_1[_i];\n      var opts = decoration.options.overviewRuler;\n\n      if (opts) {\n        opts.invalidateCachedColor();\n      }\n    }\n  };\n\n  ViewModel.prototype.invalidateMinimapColorCache = function () {\n    var decorations = this.model.getAllDecorations();\n\n    for (var _i = 0, decorations_2 = decorations; _i < decorations_2.length; _i++) {\n      var decoration = decorations_2[_i];\n      var opts = decoration.options.minimap;\n\n      if (opts) {\n        opts.invalidateCachedColor();\n      }\n    }\n  };\n\n  ViewModel.prototype.getValueInRange = function (range, eol) {\n    var modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n    return this.model.getValueInRange(modelRange, eol);\n  };\n\n  ViewModel.prototype.getModelLineMaxColumn = function (modelLineNumber) {\n    return this.model.getLineMaxColumn(modelLineNumber);\n  };\n\n  ViewModel.prototype.validateModelPosition = function (position) {\n    return this.model.validatePosition(position);\n  };\n\n  ViewModel.prototype.validateModelRange = function (range) {\n    return this.model.validateRange(range);\n  };\n\n  ViewModel.prototype.deduceModelPositionRelativeToViewPosition = function (viewAnchorPosition, deltaOffset, lineFeedCnt) {\n    var modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n\n    if (this.model.getEOL().length === 2) {\n      // This model uses CRLF, so the delta must take that into account\n      if (deltaOffset < 0) {\n        deltaOffset -= lineFeedCnt;\n      } else {\n        deltaOffset += lineFeedCnt;\n      }\n    }\n\n    var modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n    var resultOffset = modelAnchorOffset + deltaOffset;\n    return this.model.getPositionAt(resultOffset);\n  };\n\n  ViewModel.prototype.getEOL = function () {\n    return this.model.getEOL();\n  };\n\n  ViewModel.prototype.getPlainTextToCopy = function (ranges, emptySelectionClipboard, forceCRLF) {\n    var _this = this;\n\n    var newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n    ranges = ranges.slice(0);\n    ranges.sort(Range.compareRangesUsingStarts);\n    var nonEmptyRanges = ranges.filter(function (r) {\n      return !r.isEmpty();\n    });\n\n    if (nonEmptyRanges.length === 0) {\n      if (!emptySelectionClipboard) {\n        return '';\n      }\n\n      var modelLineNumbers = ranges.map(function (r) {\n        var viewLineStart = new Position(r.startLineNumber, 1);\n        return _this.coordinatesConverter.convertViewPositionToModelPosition(viewLineStart).lineNumber;\n      });\n      var result_1 = '';\n\n      for (var i = 0; i < modelLineNumbers.length; i++) {\n        if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n          continue;\n        }\n\n        result_1 += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n      }\n\n      return result_1;\n    }\n\n    var result = [];\n\n    for (var _i = 0, nonEmptyRanges_1 = nonEmptyRanges; _i < nonEmptyRanges_1.length; _i++) {\n      var nonEmptyRange = nonEmptyRanges_1[_i];\n      result.push(this.getValueInRange(nonEmptyRange, forceCRLF ? 2\n      /* CRLF */\n      : 0\n      /* TextDefined */\n      ));\n    }\n\n    return result.length === 1 ? result[0] : result;\n  };\n\n  ViewModel.prototype.getHTMLToCopy = function (viewRanges, emptySelectionClipboard) {\n    if (this.model.getLanguageIdentifier().id === 1\n    /* PlainText */\n    ) {\n        return null;\n      }\n\n    if (viewRanges.length !== 1) {\n      // no multiple selection support at this time\n      return null;\n    }\n\n    var range = this.coordinatesConverter.convertViewRangeToModelRange(viewRanges[0]);\n\n    if (range.isEmpty()) {\n      if (!emptySelectionClipboard) {\n        // nothing to copy\n        return null;\n      }\n\n      var lineNumber = range.startLineNumber;\n      range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n    }\n\n    var fontInfo = this.configuration.editor.fontInfo;\n\n    var colorMap = this._getColorMap();\n\n    var fontFamily = fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily ? fontInfo.fontFamily : \"'\" + fontInfo.fontFamily + \"', \" + EDITOR_FONT_DEFAULTS.fontFamily;\n    return \"<div style=\\\"\" + (\"color: \" + colorMap[1\n    /* DefaultForeground */\n    ] + \";\") + (\"background-color: \" + colorMap[2\n    /* DefaultBackground */\n    ] + \";\") + (\"font-family: \" + fontFamily + \";\") + (\"font-weight: \" + fontInfo.fontWeight + \";\") + (\"font-size: \" + fontInfo.fontSize + \"px;\") + (\"line-height: \" + fontInfo.lineHeight + \"px;\") + \"white-space: pre;\" + \"\\\">\" + this._getHTMLToCopy(range, colorMap) + '</div>';\n  };\n\n  ViewModel.prototype._getHTMLToCopy = function (modelRange, colorMap) {\n    var startLineNumber = modelRange.startLineNumber;\n    var startColumn = modelRange.startColumn;\n    var endLineNumber = modelRange.endLineNumber;\n    var endColumn = modelRange.endColumn;\n    var tabSize = this.getTabSize();\n    var result = '';\n\n    for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      var lineTokens = this.model.getLineTokens(lineNumber);\n      var lineContent = lineTokens.getLineContent();\n      var startOffset = lineNumber === startLineNumber ? startColumn - 1 : 0;\n      var endOffset = lineNumber === endLineNumber ? endColumn - 1 : lineContent.length;\n\n      if (lineContent === '') {\n        result += '<br>';\n      } else {\n        result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize);\n      }\n    }\n\n    return result;\n  };\n\n  ViewModel.prototype._getColorMap = function () {\n    var colorMap = TokenizationRegistry.getColorMap();\n    var result = ['#000000'];\n\n    if (colorMap) {\n      for (var i = 1, len = colorMap.length; i < len; i++) {\n        result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n      }\n    }\n\n    return result;\n  };\n\n  return ViewModel;\n}(viewEvents.ViewEventEmitter);\n\nexport { ViewModel };","map":null,"metadata":{},"sourceType":"module"}