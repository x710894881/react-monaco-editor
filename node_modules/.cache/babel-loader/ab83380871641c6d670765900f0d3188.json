{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\n\nvar BlockCommentCommand =\n/** @class */\nfunction () {\n  function BlockCommentCommand(selection) {\n    this._selection = selection;\n    this._usedEndToken = null;\n  }\n\n  BlockCommentCommand._haystackHasNeedleAtOffset = function (haystack, needle, offset) {\n    if (offset < 0) {\n      return false;\n    }\n\n    var needleLength = needle.length;\n    var haystackLength = haystack.length;\n\n    if (offset + needleLength > haystackLength) {\n      return false;\n    }\n\n    for (var i = 0; i < needleLength; i++) {\n      var codeA = haystack.charCodeAt(offset + i);\n      var codeB = needle.charCodeAt(i);\n\n      if (codeA === codeB) {\n        continue;\n      }\n\n      if (codeA >= 65\n      /* A */\n      && codeA <= 90\n      /* Z */\n      && codeA + 32 === codeB) {\n        // codeA is upper-case variant of codeB\n        continue;\n      }\n\n      if (codeB >= 65\n      /* A */\n      && codeB <= 90\n      /* Z */\n      && codeB + 32 === codeA) {\n        // codeB is upper-case variant of codeA\n        continue;\n      }\n\n      return false;\n    }\n\n    return true;\n  };\n\n  BlockCommentCommand.prototype._createOperationsForBlockComment = function (selection, startToken, endToken, model, builder) {\n    var startLineNumber = selection.startLineNumber;\n    var startColumn = selection.startColumn;\n    var endLineNumber = selection.endLineNumber;\n    var endColumn = selection.endColumn;\n    var startLineText = model.getLineContent(startLineNumber);\n    var endLineText = model.getLineContent(endLineNumber);\n    var startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);\n    var endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);\n\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      if (startLineNumber === endLineNumber) {\n        var lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);\n\n        if (lineBetweenTokens.indexOf(endToken) >= 0) {\n          // force to add a block comment\n          startTokenIndex = -1;\n          endTokenIndex = -1;\n        }\n      } else {\n        var startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);\n        var endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);\n\n        if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {\n          // force to add a block comment\n          startTokenIndex = -1;\n          endTokenIndex = -1;\n        }\n      }\n    }\n\n    var ops;\n\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      // Consider spaces as part of the comment tokens\n      if (startTokenIndex + startToken.length < startLineText.length) {\n        if (startLineText.charCodeAt(startTokenIndex + startToken.length) === 32\n        /* Space */\n        ) {\n            // Pretend the start token contains a trailing space\n            startToken = startToken + ' ';\n          }\n      }\n\n      if (endTokenIndex > 0) {\n        if (endLineText.charCodeAt(endTokenIndex - 1) === 32\n        /* Space */\n        ) {\n            // Pretend the end token contains a leading space\n            endToken = ' ' + endToken;\n            endTokenIndex -= 1;\n          }\n      }\n\n      ops = BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n    } else {\n      ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken);\n      this._usedEndToken = ops.length === 1 ? endToken : null;\n    }\n\n    for (var _i = 0, ops_1 = ops; _i < ops_1.length; _i++) {\n      var op = ops_1[_i];\n      builder.addTrackedEditOperation(op.range, op.text);\n    }\n  };\n\n  BlockCommentCommand._createRemoveBlockCommentOperations = function (r, startToken, endToken) {\n    var res = [];\n\n    if (!Range.isEmpty(r)) {\n      // Remove block comment start\n      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn))); // Remove block comment end\n\n      res.push(EditOperation.delete(new Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));\n    } else {\n      // Remove both continuously\n      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));\n    }\n\n    return res;\n  };\n\n  BlockCommentCommand._createAddBlockCommentOperations = function (r, startToken, endToken) {\n    var res = [];\n\n    if (!Range.isEmpty(r)) {\n      // Insert block comment start\n      res.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + ' ')); // Insert block comment end\n\n      res.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), ' ' + endToken));\n    } else {\n      // Insert both continuously\n      res.push(EditOperation.replace(new Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + '  ' + endToken));\n    }\n\n    return res;\n  };\n\n  BlockCommentCommand.prototype.getEditOperations = function (model, builder) {\n    var startLineNumber = this._selection.startLineNumber;\n    var startColumn = this._selection.startColumn;\n    model.tokenizeIfCheap(startLineNumber);\n    var languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);\n    var config = LanguageConfigurationRegistry.getComments(languageId);\n\n    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n      // Mode does not support block comments\n      return;\n    }\n\n    this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, model, builder);\n  };\n\n  BlockCommentCommand.prototype.computeCursorState = function (model, helper) {\n    var inverseEditOperations = helper.getInverseEditOperations();\n\n    if (inverseEditOperations.length === 2) {\n      var startTokenEditOperation = inverseEditOperations[0];\n      var endTokenEditOperation = inverseEditOperations[1];\n      return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);\n    } else {\n      var srcRange = inverseEditOperations[0].range;\n      var deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0; // minus 1 space before endToken\n\n      return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);\n    }\n  };\n\n  return BlockCommentCommand;\n}();\n\nexport { BlockCommentCommand };","map":null,"metadata":{},"sourceType":"module"}