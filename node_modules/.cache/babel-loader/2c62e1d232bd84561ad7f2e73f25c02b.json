{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { LRUCache, TernarySearchTree } from '../../../base/common/map.js';\nimport { IStorageService, WillSaveStateReason } from '../../../platform/storage/common/storage.js';\nimport { completionKindFromString } from '../../common/modes.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\n\nvar Memory =\n/** @class */\nfunction () {\n  function Memory() {}\n\n  Memory.prototype.select = function (model, pos, items) {\n    if (items.length === 0) {\n      return 0;\n    }\n\n    var topScore = items[0].score[0];\n\n    for (var i = 1; i < items.length; i++) {\n      var _a = items[i],\n          score = _a.score,\n          suggestion = _a.completion;\n\n      if (score[0] !== topScore) {\n        // stop when leaving the group of top matches\n        break;\n      }\n\n      if (suggestion.preselect) {\n        // stop when seeing an auto-select-item\n        return i;\n      }\n    }\n\n    return 0;\n  };\n\n  return Memory;\n}();\n\nexport { Memory };\n\nvar NoMemory =\n/** @class */\nfunction (_super) {\n  __extends(NoMemory, _super);\n\n  function NoMemory() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  NoMemory.prototype.memorize = function (model, pos, item) {// no-op\n  };\n\n  NoMemory.prototype.toJSON = function () {\n    return undefined;\n  };\n\n  NoMemory.prototype.fromJSON = function () {//\n  };\n\n  return NoMemory;\n}(Memory);\n\nexport { NoMemory };\n\nvar LRUMemory =\n/** @class */\nfunction (_super) {\n  __extends(LRUMemory, _super);\n\n  function LRUMemory() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._cache = new LRUCache(300, 0.66);\n    _this._seq = 0;\n    return _this;\n  }\n\n  LRUMemory.prototype.memorize = function (model, pos, item) {\n    var label = item.completion.label;\n    var key = model.getLanguageIdentifier().language + \"/\" + label;\n\n    this._cache.set(key, {\n      touch: this._seq++,\n      type: item.completion.kind,\n      insertText: item.completion.insertText\n    });\n  };\n\n  LRUMemory.prototype.select = function (model, pos, items) {\n    if (items.length === 0) {\n      return 0;\n    }\n\n    var lineSuffix = model.getLineContent(pos.lineNumber).substr(pos.column - 10, pos.column - 1);\n\n    if (/\\s$/.test(lineSuffix)) {\n      return _super.prototype.select.call(this, model, pos, items);\n    }\n\n    var topScore = items[0].score[0];\n    var indexPreselect = -1;\n    var indexRecency = -1;\n    var seq = -1;\n\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].score[0] !== topScore) {\n        // consider only top items\n        break;\n      }\n\n      var key = model.getLanguageIdentifier().language + \"/\" + items[i].completion.label;\n\n      var item = this._cache.peek(key);\n\n      if (item && item.touch > seq && item.type === items[i].completion.kind && item.insertText === items[i].completion.insertText) {\n        seq = item.touch;\n        indexRecency = i;\n      }\n\n      if (items[i].completion.preselect && indexPreselect === -1) {\n        // stop when seeing an auto-select-item\n        return indexPreselect = i;\n      }\n    }\n\n    if (indexRecency !== -1) {\n      return indexRecency;\n    } else if (indexPreselect !== -1) {\n      return indexPreselect;\n    } else {\n      return 0;\n    }\n  };\n\n  LRUMemory.prototype.toJSON = function () {\n    var data = [];\n\n    this._cache.forEach(function (value, key) {\n      data.push([key, value]);\n    });\n\n    return data;\n  };\n\n  LRUMemory.prototype.fromJSON = function (data) {\n    this._cache.clear();\n\n    var seq = 0;\n\n    for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n      var _a = data_1[_i],\n          key = _a[0],\n          value = _a[1];\n      value.touch = seq;\n      value.type = typeof value.type === 'number' ? value.type : completionKindFromString(value.type);\n\n      this._cache.set(key, value);\n    }\n\n    this._seq = this._cache.size;\n  };\n\n  return LRUMemory;\n}(Memory);\n\nexport { LRUMemory };\n\nvar PrefixMemory =\n/** @class */\nfunction (_super) {\n  __extends(PrefixMemory, _super);\n\n  function PrefixMemory() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._trie = TernarySearchTree.forStrings();\n    _this._seq = 0;\n    return _this;\n  }\n\n  PrefixMemory.prototype.memorize = function (model, pos, item) {\n    var word = model.getWordUntilPosition(pos).word;\n    var key = model.getLanguageIdentifier().language + \"/\" + word;\n\n    this._trie.set(key, {\n      type: item.completion.kind,\n      insertText: item.completion.insertText,\n      touch: this._seq++\n    });\n  };\n\n  PrefixMemory.prototype.select = function (model, pos, items) {\n    var word = model.getWordUntilPosition(pos).word;\n\n    if (!word) {\n      return _super.prototype.select.call(this, model, pos, items);\n    }\n\n    var key = model.getLanguageIdentifier().language + \"/\" + word;\n\n    var item = this._trie.get(key);\n\n    if (!item) {\n      item = this._trie.findSubstr(key);\n    }\n\n    if (item) {\n      for (var i = 0; i < items.length; i++) {\n        var _a = items[i].completion,\n            kind = _a.kind,\n            insertText = _a.insertText;\n\n        if (kind === item.type && insertText === item.insertText) {\n          return i;\n        }\n      }\n    }\n\n    return _super.prototype.select.call(this, model, pos, items);\n  };\n\n  PrefixMemory.prototype.toJSON = function () {\n    var entries = [];\n\n    this._trie.forEach(function (value, key) {\n      return entries.push([key, value]);\n    }); // sort by last recently used (touch), then\n    // take the top 200 item and normalize their\n    // touch\n\n\n    entries.sort(function (a, b) {\n      return -(a[1].touch - b[1].touch);\n    }).forEach(function (value, i) {\n      return value[1].touch = i;\n    });\n    return entries.slice(0, 200);\n  };\n\n  PrefixMemory.prototype.fromJSON = function (data) {\n    this._trie.clear();\n\n    if (data.length > 0) {\n      this._seq = data[0][1].touch + 1;\n\n      for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {\n        var _a = data_2[_i],\n            key = _a[0],\n            value = _a[1];\n        value.type = typeof value.type === 'number' ? value.type : completionKindFromString(value.type);\n\n        this._trie.set(key, value);\n      }\n    }\n  };\n\n  return PrefixMemory;\n}(Memory);\n\nexport { PrefixMemory };\n\nvar SuggestMemoryService =\n/** @class */\nfunction (_super) {\n  __extends(SuggestMemoryService, _super);\n\n  function SuggestMemoryService(_storageService, _configService) {\n    var _this = _super.call(this) || this;\n\n    _this._storageService = _storageService;\n    _this._configService = _configService;\n    _this._storagePrefix = 'suggest/memories';\n\n    var update = function () {\n      var mode = _this._configService.getValue('editor.suggestSelection');\n\n      var share = _this._configService.getValue('editor.suggest.shareSuggestSelections');\n\n      _this._update(mode, share, false);\n    };\n\n    _this._persistSoon = _this._register(new RunOnceScheduler(function () {\n      return _this._saveState();\n    }, 500));\n\n    _this._register(_storageService.onWillSaveState(function (e) {\n      if (e.reason === WillSaveStateReason.SHUTDOWN) {\n        _this._saveState();\n      }\n    }));\n\n    _this._register(_this._configService.onDidChangeConfiguration(function (e) {\n      if (e.affectsConfiguration('editor.suggestSelection') || e.affectsConfiguration('editor.suggest.shareSuggestSelections')) {\n        update();\n      }\n    }));\n\n    _this._register(_this._storageService.onDidChangeStorage(function (e) {\n      if (e.scope === 0\n      /* GLOBAL */\n      && e.key.indexOf(_this._storagePrefix) === 0) {\n        if (!document.hasFocus()) {\n          // windows that aren't focused have to drop their current\n          // storage value and accept what's stored now\n          _this._update(_this._mode, _this._shareMem, true);\n        }\n      }\n    }));\n\n    update();\n    return _this;\n  }\n\n  SuggestMemoryService.prototype._update = function (mode, shareMem, force) {\n    if (!force && this._mode === mode && this._shareMem === shareMem) {\n      return;\n    }\n\n    this._shareMem = shareMem;\n    this._mode = mode;\n    this._strategy = mode === 'recentlyUsedByPrefix' ? new PrefixMemory() : mode === 'recentlyUsed' ? new LRUMemory() : new NoMemory();\n\n    try {\n      var scope = shareMem ? 0\n      /* GLOBAL */\n      : 1\n      /* WORKSPACE */\n      ;\n\n      var raw = this._storageService.get(this._storagePrefix + \"/\" + this._mode, scope);\n\n      if (raw) {\n        this._strategy.fromJSON(JSON.parse(raw));\n      }\n    } catch (e) {// things can go wrong with JSON...\n    }\n  };\n\n  SuggestMemoryService.prototype.memorize = function (model, pos, item) {\n    this._strategy.memorize(model, pos, item);\n\n    this._persistSoon.schedule();\n  };\n\n  SuggestMemoryService.prototype.select = function (model, pos, items) {\n    return this._strategy.select(model, pos, items);\n  };\n\n  SuggestMemoryService.prototype._saveState = function () {\n    var raw = JSON.stringify(this._strategy);\n    var scope = this._shareMem ? 0\n    /* GLOBAL */\n    : 1\n    /* WORKSPACE */\n    ;\n\n    this._storageService.store(this._storagePrefix + \"/\" + this._mode, raw, scope);\n  };\n\n  SuggestMemoryService = __decorate([__param(0, IStorageService), __param(1, IConfigurationService)], SuggestMemoryService);\n  return SuggestMemoryService;\n}(Disposable);\n\nexport { SuggestMemoryService };\nexport var ISuggestMemoryService = createDecorator('ISuggestMemories');\nregisterSingleton(ISuggestMemoryService, SuggestMemoryService, true);","map":null,"metadata":{},"sourceType":"module"}