{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position, CompletionItemKind, Range, TextEdit, InsertTextFormat } from '../../vscode-languageserver-types/main.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { ScannerState, TokenType } from '../htmlLanguageTypes.js';\nimport { entities } from '../parser/htmlEntities.js';\nimport * as nls from '../../../fillers/vscode-nls.js';\nimport { isLetterOrDigit, endsWith, startsWith } from '../utils/strings.js';\nimport { getAllDataProviders } from '../languageFacts/builtinDataProviders.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\nvar localize = nls.loadMessageBundle();\n\nvar HTMLCompletion =\n/** @class */\nfunction () {\n  function HTMLCompletion() {\n    this.completionParticipants = [];\n  }\n\n  HTMLCompletion.prototype.setCompletionParticipants = function (registeredCompletionParticipants) {\n    this.completionParticipants = registeredCompletionParticipants || [];\n  };\n\n  HTMLCompletion.prototype.doComplete = function (document, position, htmlDocument, settings) {\n    var result = {\n      isIncomplete: false,\n      items: []\n    };\n    var completionParticipants = this.completionParticipants;\n    var dataProviders = getAllDataProviders().filter(function (p) {\n      return p.isApplicable(document.languageId) && (!settings || settings[p.getId()] !== false);\n    });\n    var text = document.getText();\n    var offset = document.offsetAt(position);\n    var node = htmlDocument.findNodeBefore(offset);\n\n    if (!node) {\n      return result;\n    }\n\n    var scanner = createScanner(text, node.start);\n    var currentTag = '';\n    var currentAttributeName;\n\n    function getReplaceRange(replaceStart, replaceEnd) {\n      if (replaceEnd === void 0) {\n        replaceEnd = offset;\n      }\n\n      if (replaceStart > offset) {\n        replaceStart = offset;\n      }\n\n      return {\n        start: document.positionAt(replaceStart),\n        end: document.positionAt(replaceEnd)\n      };\n    }\n\n    function collectOpenTagSuggestions(afterOpenBracket, tagNameEnd) {\n      var range = getReplaceRange(afterOpenBracket, tagNameEnd);\n      dataProviders.forEach(function (provider) {\n        provider.provideTags().forEach(function (tag) {\n          result.items.push({\n            label: tag.name,\n            kind: CompletionItemKind.Property,\n            documentation: tag.description,\n            textEdit: TextEdit.replace(range, tag.name),\n            insertTextFormat: InsertTextFormat.PlainText\n          });\n        });\n      });\n      return result;\n    }\n\n    function getLineIndent(offset) {\n      var start = offset;\n\n      while (start > 0) {\n        var ch = text.charAt(start - 1);\n\n        if (\"\\n\\r\".indexOf(ch) >= 0) {\n          return text.substring(start, offset);\n        }\n\n        if (!isWhiteSpace(ch)) {\n          return null;\n        }\n\n        start--;\n      }\n\n      return text.substring(0, offset);\n    }\n\n    function collectCloseTagSuggestions(afterOpenBracket, inOpenTag, tagNameEnd) {\n      if (tagNameEnd === void 0) {\n        tagNameEnd = offset;\n      }\n\n      var range = getReplaceRange(afterOpenBracket, tagNameEnd);\n      var closeTag = isFollowedBy(text, tagNameEnd, ScannerState.WithinEndTag, TokenType.EndTagClose) ? '' : '>';\n      var curr = node;\n\n      if (inOpenTag) {\n        curr = curr.parent; // don't suggest the own tag, it's not yet open\n      }\n\n      while (curr) {\n        var tag = curr.tag;\n\n        if (tag && (!curr.closed || curr.endTagStart && curr.endTagStart > offset)) {\n          var item = {\n            label: '/' + tag,\n            kind: CompletionItemKind.Property,\n            filterText: '/' + tag + closeTag,\n            textEdit: TextEdit.replace(range, '/' + tag + closeTag),\n            insertTextFormat: InsertTextFormat.PlainText\n          };\n          var startIndent = getLineIndent(curr.start);\n          var endIndent = getLineIndent(afterOpenBracket - 1);\n\n          if (startIndent !== null && endIndent !== null && startIndent !== endIndent) {\n            var insertText = startIndent + '</' + tag + closeTag;\n            item.textEdit = TextEdit.replace(getReplaceRange(afterOpenBracket - 1 - endIndent.length), insertText);\n            item.filterText = endIndent + '</' + tag + closeTag;\n          }\n\n          result.items.push(item);\n          return result;\n        }\n\n        curr = curr.parent;\n      }\n\n      if (inOpenTag) {\n        return result;\n      }\n\n      dataProviders.forEach(function (provider) {\n        provider.provideTags().forEach(function (tag) {\n          result.items.push({\n            label: '/' + tag.name,\n            kind: CompletionItemKind.Property,\n            documentation: tag.description,\n            filterText: '/' + tag + closeTag,\n            textEdit: TextEdit.replace(range, '/' + tag + closeTag),\n            insertTextFormat: InsertTextFormat.PlainText\n          });\n        });\n      });\n      return result;\n    }\n\n    function collectAutoCloseTagSuggestion(tagCloseEnd, tag) {\n      if (settings && settings.hideAutoCompleteProposals) {\n        return result;\n      }\n\n      if (!isVoidElement(tag)) {\n        var pos = document.positionAt(tagCloseEnd);\n        result.items.push({\n          label: '</' + tag + '>',\n          kind: CompletionItemKind.Property,\n          filterText: '</' + tag + '>',\n          textEdit: TextEdit.insert(pos, '$0</' + tag + '>'),\n          insertTextFormat: InsertTextFormat.Snippet\n        });\n      }\n\n      return result;\n    }\n\n    function collectTagSuggestions(tagStart, tagEnd) {\n      collectOpenTagSuggestions(tagStart, tagEnd);\n      collectCloseTagSuggestions(tagStart, true, tagEnd);\n      return result;\n    }\n\n    function collectAttributeNameSuggestions(nameStart, nameEnd) {\n      if (nameEnd === void 0) {\n        nameEnd = offset;\n      }\n\n      var replaceEnd = offset;\n\n      while (replaceEnd < nameEnd && text[replaceEnd] !== '<') {\n        // < is a valid attribute name character, but we rather assume the attribute name ends. See #23236.\n        replaceEnd++;\n      }\n\n      var range = getReplaceRange(nameStart, replaceEnd);\n      var value = isFollowedBy(text, nameEnd, ScannerState.AfterAttributeName, TokenType.DelimiterAssign) ? '' : '=\"$1\"';\n      var tag = currentTag.toLowerCase();\n      var seenAttributes = Object.create(null);\n      dataProviders.forEach(function (provider) {\n        provider.provideAttributes(tag).forEach(function (attr) {\n          if (seenAttributes[attr.name]) {\n            return;\n          }\n\n          seenAttributes[attr.name] = true;\n          var codeSnippet = attr.name;\n          var command;\n\n          if (attr.valueSet !== 'v' && value.length) {\n            codeSnippet = codeSnippet + value;\n\n            if (attr.valueSet) {\n              command = {\n                title: 'Suggest',\n                command: 'editor.action.triggerSuggest'\n              };\n            }\n          }\n\n          result.items.push({\n            label: attr.name,\n            kind: attr.valueSet === 'handler' ? CompletionItemKind.Function : CompletionItemKind.Value,\n            documentation: attr.description,\n            textEdit: TextEdit.replace(range, codeSnippet),\n            insertTextFormat: InsertTextFormat.Snippet,\n            command: command\n          });\n        });\n      });\n      collectDataAttributesSuggestions(range, seenAttributes);\n      return result;\n    }\n\n    function collectDataAttributesSuggestions(range, seenAttributes) {\n      var dataAttr = 'data-';\n      var dataAttributes = {};\n      dataAttributes[dataAttr] = dataAttr + \"$1=\\\"$2\\\"\";\n\n      function addNodeDataAttributes(node) {\n        node.attributeNames.forEach(function (attr) {\n          if (startsWith(attr, dataAttr) && !dataAttributes[attr] && !seenAttributes[attr]) {\n            dataAttributes[attr] = attr + '=\"$1\"';\n          }\n        });\n        node.children.forEach(function (child) {\n          return addNodeDataAttributes(child);\n        });\n      }\n\n      if (htmlDocument) {\n        htmlDocument.roots.forEach(function (root) {\n          return addNodeDataAttributes(root);\n        });\n      }\n\n      Object.keys(dataAttributes).forEach(function (attr) {\n        return result.items.push({\n          label: attr,\n          kind: CompletionItemKind.Value,\n          textEdit: TextEdit.replace(range, dataAttributes[attr]),\n          insertTextFormat: InsertTextFormat.Snippet\n        });\n      });\n    }\n\n    function collectAttributeValueSuggestions(valueStart, valueEnd) {\n      if (valueEnd === void 0) {\n        valueEnd = offset;\n      }\n\n      var range;\n      var addQuotes;\n      var valuePrefix;\n\n      if (offset > valueStart && offset <= valueEnd && isQuote(text[valueStart])) {\n        // inside quoted attribute\n        var valueContentStart = valueStart + 1;\n        var valueContentEnd = valueEnd; // valueEnd points to the char after quote, which encloses the replace range\n\n        if (valueEnd > valueStart && text[valueEnd - 1] === text[valueStart]) {\n          valueContentEnd--;\n        }\n\n        var wsBefore = getWordStart(text, offset, valueContentStart);\n        var wsAfter = getWordEnd(text, offset, valueContentEnd);\n        range = getReplaceRange(wsBefore, wsAfter);\n        valuePrefix = offset >= valueContentStart && offset <= valueContentEnd ? text.substring(valueContentStart, offset) : '';\n        addQuotes = false;\n      } else {\n        range = getReplaceRange(valueStart, valueEnd);\n        valuePrefix = text.substring(valueStart, offset);\n        addQuotes = true;\n      }\n\n      var tag = currentTag.toLowerCase();\n      var attribute = currentAttributeName.toLowerCase();\n\n      if (completionParticipants.length > 0) {\n        var fullRange = getReplaceRange(valueStart, valueEnd);\n\n        for (var _i = 0, completionParticipants_1 = completionParticipants; _i < completionParticipants_1.length; _i++) {\n          var participant = completionParticipants_1[_i];\n\n          if (participant.onHtmlAttributeValue) {\n            participant.onHtmlAttributeValue({\n              document: document,\n              position: position,\n              tag: tag,\n              attribute: attribute,\n              value: valuePrefix,\n              range: fullRange\n            });\n          }\n        }\n      }\n\n      dataProviders.forEach(function (provider) {\n        provider.provideValues(tag, attribute).forEach(function (value) {\n          var insertText = addQuotes ? '\"' + value.name + '\"' : value.name;\n          result.items.push({\n            label: value.name,\n            filterText: insertText,\n            kind: CompletionItemKind.Unit,\n            textEdit: TextEdit.replace(range, insertText),\n            insertTextFormat: InsertTextFormat.PlainText\n          });\n        });\n      });\n      collectCharacterEntityProposals();\n      return result;\n    }\n\n    function scanNextForEndPos(nextToken) {\n      if (offset === scanner.getTokenEnd()) {\n        token = scanner.scan();\n\n        if (token === nextToken && scanner.getTokenOffset() === offset) {\n          return scanner.getTokenEnd();\n        }\n      }\n\n      return offset;\n    }\n\n    function collectInsideContent() {\n      for (var _i = 0, completionParticipants_2 = completionParticipants; _i < completionParticipants_2.length; _i++) {\n        var participant = completionParticipants_2[_i];\n\n        if (participant.onHtmlContent) {\n          participant.onHtmlContent({\n            document: document,\n            position: position\n          });\n        }\n      }\n\n      return collectCharacterEntityProposals();\n    }\n\n    function collectCharacterEntityProposals() {\n      // character entities\n      var k = offset - 1;\n      var characterStart = position.character;\n\n      while (k >= 0 && isLetterOrDigit(text, k)) {\n        k--;\n        characterStart--;\n      }\n\n      if (k >= 0 && text[k] === '&') {\n        var range = Range.create(Position.create(position.line, characterStart - 1), position);\n\n        for (var entity in entities) {\n          if (endsWith(entity, ';')) {\n            var label = '&' + entity;\n            result.items.push({\n              label: label,\n              kind: CompletionItemKind.Keyword,\n              documentation: localize('entity.propose', \"Character entity representing '\" + entities[entity] + \"'\"),\n              textEdit: TextEdit.replace(range, label),\n              insertTextFormat: InsertTextFormat.PlainText\n            });\n          }\n        }\n      }\n\n      return result;\n    }\n\n    function suggestDoctype(replaceStart, replaceEnd) {\n      var range = getReplaceRange(replaceStart, replaceEnd);\n      result.items.push({\n        label: '!DOCTYPE',\n        kind: CompletionItemKind.Property,\n        documentation: 'A preamble for an HTML document.',\n        textEdit: TextEdit.replace(range, '!DOCTYPE html>'),\n        insertTextFormat: InsertTextFormat.PlainText\n      });\n    }\n\n    var token = scanner.scan();\n\n    while (token !== TokenType.EOS && scanner.getTokenOffset() <= offset) {\n      switch (token) {\n        case TokenType.StartTagOpen:\n          if (scanner.getTokenEnd() === offset) {\n            var endPos = scanNextForEndPos(TokenType.StartTag);\n\n            if (position.line === 0) {\n              suggestDoctype(offset, endPos);\n            }\n\n            return collectTagSuggestions(offset, endPos);\n          }\n\n          break;\n\n        case TokenType.StartTag:\n          if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n            return collectOpenTagSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n          }\n\n          currentTag = scanner.getTokenText();\n          break;\n\n        case TokenType.AttributeName:\n          if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n            return collectAttributeNameSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n          }\n\n          currentAttributeName = scanner.getTokenText();\n          break;\n\n        case TokenType.DelimiterAssign:\n          if (scanner.getTokenEnd() === offset) {\n            var endPos = scanNextForEndPos(TokenType.AttributeValue);\n            return collectAttributeValueSuggestions(offset, endPos);\n          }\n\n          break;\n\n        case TokenType.AttributeValue:\n          if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n            return collectAttributeValueSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n          }\n\n          break;\n\n        case TokenType.Whitespace:\n          if (offset <= scanner.getTokenEnd()) {\n            switch (scanner.getScannerState()) {\n              case ScannerState.AfterOpeningStartTag:\n                var startPos = scanner.getTokenOffset();\n                var endTagPos = scanNextForEndPos(TokenType.StartTag);\n                return collectTagSuggestions(startPos, endTagPos);\n\n              case ScannerState.WithinTag:\n              case ScannerState.AfterAttributeName:\n                return collectAttributeNameSuggestions(scanner.getTokenEnd());\n\n              case ScannerState.BeforeAttributeValue:\n                return collectAttributeValueSuggestions(scanner.getTokenEnd());\n\n              case ScannerState.AfterOpeningEndTag:\n                return collectCloseTagSuggestions(scanner.getTokenOffset() - 1, false);\n\n              case ScannerState.WithinContent:\n                return collectInsideContent();\n            }\n          }\n\n          break;\n\n        case TokenType.EndTagOpen:\n          if (offset <= scanner.getTokenEnd()) {\n            var afterOpenBracket = scanner.getTokenOffset() + 1;\n            var endOffset = scanNextForEndPos(TokenType.EndTag);\n            return collectCloseTagSuggestions(afterOpenBracket, false, endOffset);\n          }\n\n          break;\n\n        case TokenType.EndTag:\n          if (offset <= scanner.getTokenEnd()) {\n            var start = scanner.getTokenOffset() - 1;\n\n            while (start >= 0) {\n              var ch = text.charAt(start);\n\n              if (ch === '/') {\n                return collectCloseTagSuggestions(start, false, scanner.getTokenEnd());\n              } else if (!isWhiteSpace(ch)) {\n                break;\n              }\n\n              start--;\n            }\n          }\n\n          break;\n\n        case TokenType.StartTagClose:\n          if (offset <= scanner.getTokenEnd()) {\n            if (currentTag) {\n              return collectAutoCloseTagSuggestion(scanner.getTokenEnd(), currentTag);\n            }\n          }\n\n          break;\n\n        case TokenType.Content:\n          if (offset <= scanner.getTokenEnd()) {\n            return collectInsideContent();\n          }\n\n          break;\n\n        default:\n          if (offset <= scanner.getTokenEnd()) {\n            return result;\n          }\n\n          break;\n      }\n\n      token = scanner.scan();\n    }\n\n    return result;\n  };\n\n  HTMLCompletion.prototype.doTagComplete = function (document, position, htmlDocument) {\n    var offset = document.offsetAt(position);\n\n    if (offset <= 0) {\n      return null;\n    }\n\n    var char = document.getText().charAt(offset - 1);\n\n    if (char === '>') {\n      var node = htmlDocument.findNodeBefore(offset);\n\n      if (node && node.tag && !isVoidElement(node.tag) && node.start < offset && (!node.endTagStart || node.endTagStart > offset)) {\n        var scanner = createScanner(document.getText(), node.start);\n        var token = scanner.scan();\n\n        while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {\n          if (token === TokenType.StartTagClose && scanner.getTokenEnd() === offset) {\n            return \"$0</\" + node.tag + \">\";\n          }\n\n          token = scanner.scan();\n        }\n      }\n    } else if (char === '/') {\n      var node = htmlDocument.findNodeBefore(offset);\n\n      while (node && node.closed) {\n        node = node.parent;\n      }\n\n      if (node && node.tag) {\n        var scanner = createScanner(document.getText(), node.start);\n        var token = scanner.scan();\n\n        while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {\n          if (token === TokenType.EndTagOpen && scanner.getTokenEnd() === offset) {\n            return node.tag + \">\";\n          }\n\n          token = scanner.scan();\n        }\n      }\n    }\n\n    return null;\n  };\n\n  return HTMLCompletion;\n}();\n\nexport { HTMLCompletion };\n\nfunction isQuote(s) {\n  return /^[\"']*$/.test(s);\n}\n\nfunction isWhiteSpace(s) {\n  return /^\\s*$/.test(s);\n}\n\nfunction isFollowedBy(s, offset, intialState, expectedToken) {\n  var scanner = createScanner(s, offset, intialState);\n  var token = scanner.scan();\n\n  while (token === TokenType.Whitespace) {\n    token = scanner.scan();\n  }\n\n  return token === expectedToken;\n}\n\nfunction getWordStart(s, offset, limit) {\n  while (offset > limit && !isWhiteSpace(s[offset - 1])) {\n    offset--;\n  }\n\n  return offset;\n}\n\nfunction getWordEnd(s, offset, limit) {\n  while (offset < limit && !isWhiteSpace(s[offset])) {\n    offset++;\n  }\n\n  return offset;\n}","map":null,"metadata":{},"sourceType":"module"}