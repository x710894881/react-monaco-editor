{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}(); // NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/tree/43dd49c9782848c25e5b03448c8a0f923f13c158\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\nimport * as process from './process.js';\nvar CHAR_UPPERCASE_A = 65;\n/* A */\n\nvar CHAR_LOWERCASE_A = 97;\n/* a */\n\nvar CHAR_UPPERCASE_Z = 90;\n/* Z */\n\nvar CHAR_LOWERCASE_Z = 122;\n/* z */\n\nvar CHAR_DOT = 46;\n/* . */\n\nvar CHAR_FORWARD_SLASH = 47;\n/* / */\n\nvar CHAR_BACKWARD_SLASH = 92;\n/* \\ */\n\nvar CHAR_COLON = 58;\n/* : */\n\nvar CHAR_QUESTION_MARK = 63;\n/* ? */\n\nvar ErrorInvalidArgType =\n/** @class */\nfunction (_super) {\n  __extends(ErrorInvalidArgType, _super);\n\n  function ErrorInvalidArgType(name, expected, actual) {\n    var _this = this; // determiner: 'must be' or 'must not be'\n\n\n    var determiner;\n\n    if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n\n    var type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n    var msg = \"The \\\"\" + name + \"\\\" \" + type + \" \" + determiner + \" of type \" + expected;\n    msg += \". Received type \" + typeof actual;\n    _this = _super.call(this, msg) || this;\n    _this.code = 'ERR_INVALID_ARG_TYPE';\n    return _this;\n  }\n\n  return ErrorInvalidArgType;\n}(Error);\n\nfunction validateString(value, name) {\n  if (typeof value !== 'string') {\n    throw new ErrorInvalidArgType(name, 'string', value);\n  }\n}\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n} // Resolves . and .. elements in a path with directory names\n\n\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {// NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf(separator);\n\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += separator + \"..\";\n          } else {\n            res = '..';\n          }\n\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += separator + path.slice(lastSlash + 1, i);\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n\n        lastSegmentLength = i - lastSlash - 1;\n      }\n\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n\n  if (!dir) {\n    return base;\n  }\n\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n\n  return dir + sep + base;\n}\n\nexport var win32 = {\n  // path.resolve([from ...], to)\n  resolve: function () {\n    var pathSegments = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      pathSegments[_i] = arguments[_i];\n    }\n\n    var resolvedDevice = '';\n    var resolvedTail = '';\n    var resolvedAbsolute = false;\n\n    for (var i = pathSegments.length - 1; i >= -1; i--) {\n      var path = void 0;\n\n      if (i >= 0) {\n        path = pathSegments[i];\n      } else if (!resolvedDevice) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive, or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points, because UNC paths are always absolute.\n        path = process.env['=' + resolvedDevice] || process.cwd(); // Verify that a cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n\n        if (path === undefined || path.slice(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\\\') {\n          path = resolvedDevice + '\\\\';\n        }\n      }\n\n      validateString(path, 'path'); // Skip empty entries\n\n      if (path.length === 0) {\n        continue;\n      }\n\n      var len = path.length;\n      var rootEnd = 0;\n      var device = '';\n      var isAbsolute = false;\n      var code = path.charCodeAt(0); // Try to match a root\n\n      if (len > 1) {\n        if (isPathSeparator(code)) {\n          // Possible UNC root\n          // If we started with a separator, we know we at least have an\n          // absolute path of some kind (UNC or otherwise)\n          isAbsolute = true;\n\n          if (isPathSeparator(path.charCodeAt(1))) {\n            // Matched double path separator at beginning\n            var j = 2;\n            var last = j; // Match 1 or more non-path separators\n\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) {\n                break;\n              }\n            }\n\n            if (j < len && j !== last) {\n              var firstPart = path.slice(last, j); // Matched!\n\n              last = j; // Match 1 or more path separators\n\n              for (; j < len; ++j) {\n                if (!isPathSeparator(path.charCodeAt(j))) {\n                  break;\n                }\n              }\n\n              if (j < len && j !== last) {\n                // Matched!\n                last = j; // Match 1 or more non-path separators\n\n                for (; j < len; ++j) {\n                  if (isPathSeparator(path.charCodeAt(j))) {\n                    break;\n                  }\n                }\n\n                if (j === len) {\n                  // We matched a UNC root only\n                  device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\n                  rootEnd = j;\n                } else if (j !== last) {\n                  // We matched a UNC root with leftovers\n                  device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n                  rootEnd = j;\n                }\n              }\n            }\n          } else {\n            rootEnd = 1;\n          }\n        } else if (isWindowsDeviceRoot(code)) {\n          // Possible device root\n          if (path.charCodeAt(1) === CHAR_COLON) {\n            device = path.slice(0, 2);\n            rootEnd = 2;\n\n            if (len > 2) {\n              if (isPathSeparator(path.charCodeAt(2))) {\n                // Treat separator following drive name as an absolute path\n                // indicator\n                isAbsolute = true;\n                rootEnd = 3;\n              }\n            }\n          }\n        }\n      } else if (isPathSeparator(code)) {\n        // `path` contains just a path separator\n        rootEnd = 1;\n        isAbsolute = true;\n      }\n\n      if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n        // This path points to another device so it is not applicable\n        continue;\n      }\n\n      if (resolvedDevice.length === 0 && device.length > 0) {\n        resolvedDevice = device;\n      }\n\n      if (!resolvedAbsolute) {\n        resolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\n        resolvedAbsolute = isAbsolute;\n      }\n\n      if (resolvedDevice.length > 0 && resolvedAbsolute) {\n        break;\n      }\n    } // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n    // Normalize the tail path\n\n\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\n    return resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail || '.';\n  },\n  normalize: function (path) {\n    validateString(path, 'path');\n    var len = path.length;\n\n    if (len === 0) {\n      return '.';\n    }\n\n    var rootEnd = 0;\n    var device;\n    var isAbsolute = false;\n    var code = path.charCodeAt(0); // Try to match a root\n\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n        // If we started with a separator, we know we at least have an absolute\n        // path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j; // Match 1 or more non-path separators\n\n          for (; j < len; ++j) {\n            if (isPathSeparator(path.charCodeAt(j))) {\n              break;\n            }\n          }\n\n          if (j < len && j !== last) {\n            var firstPart = path.slice(last, j); // Matched!\n\n            last = j; // Match 1 or more path separators\n\n            for (; j < len; ++j) {\n              if (!isPathSeparator(path.charCodeAt(j))) {\n                break;\n              }\n            }\n\n            if (j < len && j !== last) {\n              // Matched!\n              last = j; // Match 1 or more non-path separators\n\n              for (; j < len; ++j) {\n                if (isPathSeparator(path.charCodeAt(j))) {\n                  break;\n                }\n              }\n\n              if (j === len) {\n                // We matched a UNC root only\n                // Return the normalized version of the UNC root since there\n                // is nothing left to process\n                return '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n                device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          device = path.slice(0, 2);\n          rootEnd = 2;\n\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              // Treat separator following drive name as an absolute path\n              // indicator\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator, exit early to avoid unnecessary\n      // work\n      return '\\\\';\n    }\n\n    var tail;\n\n    if (rootEnd < len) {\n      tail = normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator);\n    } else {\n      tail = '';\n    }\n\n    if (tail.length === 0 && !isAbsolute) {\n      tail = '.';\n    }\n\n    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n      tail += '\\\\';\n    }\n\n    if (device === undefined) {\n      if (isAbsolute) {\n        if (tail.length > 0) {\n          return '\\\\' + tail;\n        } else {\n          return '\\\\';\n        }\n      } else if (tail.length > 0) {\n        return tail;\n      } else {\n        return '';\n      }\n    } else if (isAbsolute) {\n      if (tail.length > 0) {\n        return device + '\\\\' + tail;\n      } else {\n        return device + '\\\\';\n      }\n    } else if (tail.length > 0) {\n      return device + tail;\n    } else {\n      return device;\n    }\n  },\n  isAbsolute: function (path) {\n    validateString(path, 'path');\n    var len = path.length;\n\n    if (len === 0) {\n      return false;\n    }\n\n    var code = path.charCodeAt(0);\n\n    if (isPathSeparator(code)) {\n      return true;\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n      if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n        if (isPathSeparator(path.charCodeAt(2))) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  },\n  join: function () {\n    var paths = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      paths[_i] = arguments[_i];\n    }\n\n    if (paths.length === 0) {\n      return '.';\n    }\n\n    var joined;\n    var firstPart;\n\n    for (var i = 0; i < paths.length; ++i) {\n      var arg = paths[i];\n      validateString(arg, 'path');\n\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = firstPart = arg;\n        } else {\n          joined += '\\\\' + arg;\n        }\n      }\n    }\n\n    if (joined === undefined) {\n      return '.';\n    } // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for an UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at an UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as an UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\n\n    var needsReplace = true;\n    var slashCount = 0;\n\n    if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n      ++slashCount;\n      var firstLen = firstPart.length;\n\n      if (firstLen > 1) {\n        if (isPathSeparator(firstPart.charCodeAt(1))) {\n          ++slashCount;\n\n          if (firstLen > 2) {\n            if (isPathSeparator(firstPart.charCodeAt(2))) {\n              ++slashCount;\n            } else {\n              // We matched a UNC path in the first part\n              needsReplace = false;\n            }\n          }\n        }\n      }\n    }\n\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      for (; slashCount < joined.length; ++slashCount) {\n        if (!isPathSeparator(joined.charCodeAt(slashCount))) {\n          break;\n        }\n      } // Replace the slashes if needed\n\n\n      if (slashCount >= 2) {\n        joined = '\\\\' + joined.slice(slashCount);\n      }\n    }\n\n    return win32.normalize(joined);\n  },\n  // It will solve the relative path from `from` to `to`, for instance:\n  //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n  //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  relative: function (from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to) {\n      return '';\n    }\n\n    var fromOrig = win32.resolve(from);\n    var toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig) {\n      return '';\n    }\n\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n\n    if (from === to) {\n      return '';\n    } // Trim any leading backslashes\n\n\n    var fromStart = 0;\n\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) {\n        break;\n      }\n    } // Trim trailing backslashes (applicable to UNC paths only)\n\n\n    var fromEnd = from.length;\n\n    for (; fromEnd - 1 > fromStart; --fromEnd) {\n      if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) {\n        break;\n      }\n    }\n\n    var fromLen = fromEnd - fromStart; // Trim any leading backslashes\n\n    var toStart = 0;\n\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) {\n        break;\n      }\n    } // Trim trailing backslashes (applicable to UNC paths only)\n\n\n    var toEnd = to.length;\n\n    for (; toEnd - 1 > toStart; --toEnd) {\n      if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) {\n        break;\n      }\n    }\n\n    var toLen = toEnd - toStart; // Compare paths to find the longest common path from root\n\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n            return toOrig.slice(toStart + i + 1);\n          } else if (i === 2) {\n            // We get here if `from` is the device root.\n            // For example: from='C:\\\\'; to='C:\\\\foo'\n            return toOrig.slice(toStart + i);\n          }\n        }\n\n        if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n            lastCommonSep = i;\n          } else if (i === 2) {\n            // We get here if `to` is the device root.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n            lastCommonSep = 3;\n          }\n        }\n\n        break;\n      }\n\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n\n      if (fromCode !== toCode) {\n        break;\n      } else if (fromCode === CHAR_BACKWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    } // We found a mismatch before the first common path separator was seen, so\n    // return the original `to`.\n\n\n    if (i !== length && lastCommonSep === -1) {\n      return toOrig;\n    }\n\n    var out = '';\n\n    if (lastCommonSep === -1) {\n      lastCommonSep = 0;\n    } // Generate the relative path based on the path difference between `to` and\n    // `from`\n\n\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n        if (out.length === 0) {\n          out += '..';\n        } else {\n          out += '\\\\..';\n        }\n      }\n    } // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n\n\n    if (out.length > 0) {\n      return out + toOrig.slice(toStart + lastCommonSep, toEnd);\n    } else {\n      toStart += lastCommonSep;\n\n      if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n        ++toStart;\n      }\n\n      return toOrig.slice(toStart, toEnd);\n    }\n  },\n  toNamespacedPath: function (path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string') {\n      return path;\n    }\n\n    if (path.length === 0) {\n      return '';\n    }\n\n    var resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length >= 3) {\n      if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n        // Possible UNC root\n        if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n          var code = resolvedPath.charCodeAt(2);\n\n          if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n            // Matched non-long UNC root, convert the path to a long UNC path\n            return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\n          }\n        }\n      } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n        // Possible device root\n        if (resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n          // Matched device root, convert the path to a long UNC path\n          return '\\\\\\\\?\\\\' + resolvedPath;\n        }\n      }\n    }\n\n    return path;\n  },\n  dirname: function (path) {\n    validateString(path, 'path');\n    var len = path.length;\n\n    if (len === 0) {\n      return '.';\n    }\n\n    var rootEnd = -1;\n    var end = -1;\n    var matchedSlash = true;\n    var offset = 0;\n    var code = path.charCodeAt(0); // Try to match a root\n\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n        rootEnd = offset = 1;\n\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j; // Match 1 or more non-path separators\n\n          for (; j < len; ++j) {\n            if (isPathSeparator(path.charCodeAt(j))) {\n              break;\n            }\n          }\n\n          if (j < len && j !== last) {\n            // Matched!\n            last = j; // Match 1 or more path separators\n\n            for (; j < len; ++j) {\n              if (!isPathSeparator(path.charCodeAt(j))) {\n                break;\n              }\n            }\n\n            if (j < len && j !== last) {\n              // Matched!\n              last = j; // Match 1 or more non-path separators\n\n              for (; j < len; ++j) {\n                if (isPathSeparator(path.charCodeAt(j))) {\n                  break;\n                }\n              }\n\n              if (j === len) {\n                // We matched a UNC root only\n                return path;\n              }\n\n              if (j !== last) {\n                // We matched a UNC root with leftovers\n                // Offset by 1 to include the separator after the UNC root to\n                // treat it as a \"normal root\" on top of a (UNC) root\n                rootEnd = offset = j + 1;\n              }\n            }\n          }\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          rootEnd = offset = 2;\n\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              rootEnd = offset = 3;\n            }\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work\n      return path;\n    }\n\n    for (var i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1) {\n        return '.';\n      } else {\n        end = rootEnd;\n      }\n    }\n\n    return path.slice(0, end);\n  },\n  basename: function (path, ext) {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n\n    validateString(path, 'path');\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i; // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2) {\n      var drive = path.charCodeAt(0);\n\n      if (isWindowsDeviceRoot(drive)) {\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          start = 2;\n        }\n      }\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) {\n        return '';\n      }\n\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n\n      for (i = path.length - 1; i >= start; --i) {\n        var code = path.charCodeAt(i);\n\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= start; --i) {\n        if (isPathSeparator(path.charCodeAt(i))) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) {\n        return '';\n      }\n\n      return path.slice(start, end);\n    }\n  },\n  extname: function (path) {\n    validateString(path, 'path');\n    var start = 0;\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n\n    var preDotState = 0; // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {\n      start = startPart = 2;\n    }\n\n    for (var i = path.length - 1; i >= start; --i) {\n      var code = path.charCodeAt(i);\n\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n\n    return path.slice(startDot, end);\n  },\n  format: function (pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n    }\n\n    return _format('\\\\', pathObject);\n  },\n  parse: function (path) {\n    validateString(path, 'path');\n    var ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n\n    if (path.length === 0) {\n      return ret;\n    }\n\n    var len = path.length;\n    var rootEnd = 0;\n    var code = path.charCodeAt(0); // Try to match a root\n\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n        rootEnd = 1;\n\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j; // Match 1 or more non-path separators\n\n          for (; j < len; ++j) {\n            if (isPathSeparator(path.charCodeAt(j))) {\n              break;\n            }\n          }\n\n          if (j < len && j !== last) {\n            // Matched!\n            last = j; // Match 1 or more path separators\n\n            for (; j < len; ++j) {\n              if (!isPathSeparator(path.charCodeAt(j))) {\n                break;\n              }\n            }\n\n            if (j < len && j !== last) {\n              // Matched!\n              last = j; // Match 1 or more non-path separators\n\n              for (; j < len; ++j) {\n                if (isPathSeparator(path.charCodeAt(j))) {\n                  break;\n                }\n              }\n\n              if (j === len) {\n                // We matched a UNC root only\n                rootEnd = j;\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n                rootEnd = j + 1;\n              }\n            }\n          }\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          rootEnd = 2;\n\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              if (len === 3) {\n                // `path` contains just a drive root, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path;\n                return ret;\n              }\n\n              rootEnd = 3;\n            }\n          } else {\n            // `path` contains just a drive root, exit early to avoid\n            // unnecessary work\n            ret.root = ret.dir = path;\n            return ret;\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work\n      ret.root = ret.dir = path;\n      return ret;\n    }\n\n    if (rootEnd > 0) {\n      ret.root = path.slice(0, rootEnd);\n    }\n\n    var startDot = -1;\n    var startPart = rootEnd;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n\n    var preDotState = 0; // Get non-dir info\n\n    for (; i >= rootEnd; --i) {\n      code = path.charCodeAt(i);\n\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      ret.name = path.slice(startPart, startDot);\n      ret.base = path.slice(startPart, end);\n      ret.ext = path.slice(startDot, end);\n    } // If the directory is the root, use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\n\n    if (startPart > 0 && startPart !== rootEnd) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else {\n      ret.dir = ret.root;\n    }\n\n    return ret;\n  },\n  sep: '\\\\',\n  delimiter: ';',\n  win32: null,\n  posix: null\n};\nexport var posix = {\n  // path.resolve([from ...], to)\n  resolve: function () {\n    var pathSegments = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      pathSegments[_i] = arguments[_i];\n    }\n\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n\n    for (var i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path = void 0;\n\n      if (i >= 0) {\n        path = pathSegments[i];\n      } else {\n        path = process.cwd();\n      }\n\n      validateString(path, 'path'); // Skip empty entries\n\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    } // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n    // Normalize the path\n\n\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0) {\n        return '/' + resolvedPath;\n      } else {\n        return '/';\n      }\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n  normalize: function (path) {\n    validateString(path, 'path');\n\n    if (path.length === 0) {\n      return '.';\n    }\n\n    var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH; // Normalize the path\n\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n    if (path.length === 0 && !isAbsolute) {\n      path = '.';\n    }\n\n    if (path.length > 0 && trailingSeparator) {\n      path += '/';\n    }\n\n    if (isAbsolute) {\n      return '/' + path;\n    }\n\n    return path;\n  },\n  isAbsolute: function (path) {\n    validateString(path, 'path');\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n  join: function () {\n    var paths = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      paths[_i] = arguments[_i];\n    }\n\n    if (paths.length === 0) {\n      return '.';\n    }\n\n    var joined;\n\n    for (var i = 0; i < paths.length; ++i) {\n      var arg = arguments[i];\n      validateString(arg, 'path');\n\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg;\n        } else {\n          joined += '/' + arg;\n        }\n      }\n    }\n\n    if (joined === undefined) {\n      return '.';\n    }\n\n    return posix.normalize(joined);\n  },\n  relative: function (from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to) {\n      return '';\n    }\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) {\n      return '';\n    } // Trim any leading backslashes\n\n\n    var fromStart = 1;\n\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) {\n        break;\n      }\n    }\n\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart; // Trim any leading backslashes\n\n    var toStart = 1;\n\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) {\n        break;\n      }\n    }\n\n    var toEnd = to.length;\n    var toLen = toEnd - toStart; // Compare paths to find the longest common path from root\n\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n\n        break;\n      }\n\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n\n      if (fromCode !== toCode) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n\n    var out = ''; // Generate the relative path based on the path difference between `to`\n    // and `from`\n\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (out.length === 0) {\n          out += '..';\n        } else {\n          out += '/..';\n        }\n      }\n    } // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n\n\n    if (out.length > 0) {\n      return out + to.slice(toStart + lastCommonSep);\n    } else {\n      toStart += lastCommonSep;\n\n      if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) {\n        ++toStart;\n      }\n\n      return to.slice(toStart);\n    }\n  },\n  toNamespacedPath: function (path) {\n    // Non-op on posix systems\n    return path;\n  },\n  dirname: function (path) {\n    validateString(path, 'path');\n\n    if (path.length === 0) {\n      return '.';\n    }\n\n    var hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    var end = -1;\n    var matchedSlash = true;\n\n    for (var i = path.length - 1; i >= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      return hasRoot ? '/' : '.';\n    }\n\n    if (hasRoot && end === 1) {\n      return '//';\n    }\n\n    return path.slice(0, end);\n  },\n  basename: function (path, ext) {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n\n    validateString(path, 'path');\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) {\n        return '';\n      }\n\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) {\n        return '';\n      }\n\n      return path.slice(start, end);\n    }\n  },\n  extname: function (path) {\n    validateString(path, 'path');\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n\n    var preDotState = 0;\n\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n\n    return path.slice(startDot, end);\n  },\n  format: function (pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n    }\n\n    return _format('/', pathObject);\n  },\n  parse: function (path) {\n    validateString(path, 'path');\n    var ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n\n    if (path.length === 0) {\n      return ret;\n    }\n\n    var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    var start;\n\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n\n    var preDotState = 0; // Get non-dir info\n\n    for (; i >= start; --i) {\n      var code = path.charCodeAt(i);\n\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) {\n          ret.base = ret.name = path.slice(1, end);\n        } else {\n          ret.base = ret.name = path.slice(startPart, end);\n        }\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = '/';\n    }\n\n    return ret;\n  },\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nexport var normalize = process.platform === 'win32' ? win32.normalize : posix.normalize;\nexport var join = process.platform === 'win32' ? win32.join : posix.join;\nexport var relative = process.platform === 'win32' ? win32.relative : posix.relative;\nexport var dirname = process.platform === 'win32' ? win32.dirname : posix.dirname;\nexport var basename = process.platform === 'win32' ? win32.basename : posix.basename;\nexport var extname = process.platform === 'win32' ? win32.extname : posix.extname;\nexport var sep = process.platform === 'win32' ? win32.sep : posix.sep;","map":null,"metadata":{},"sourceType":"module"}