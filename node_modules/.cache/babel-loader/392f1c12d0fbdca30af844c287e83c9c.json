{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { groupBy } from '../../../base/common/arrays.js';\nimport { dispose } from '../../../base/common/lifecycle.js';\nimport { getLeadingWhitespace } from '../../../base/common/strings.js';\nimport './snippetSession.css';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { ModelDecorationOptions } from '../../common/model/textModel.js';\nimport { IClipboardService } from '../../../platform/clipboard/common/clipboardService.js';\nimport { IWorkspaceContextService } from '../../../platform/workspace/common/workspace.js';\nimport { optional } from '../../../platform/instantiation/common/instantiation.js';\nimport { Choice, Placeholder, SnippetParser, Text } from './snippetParser.js';\nimport { ClipboardBasedVariableResolver, CompositeSnippetVariableResolver, ModelBasedVariableResolver, SelectionBasedVariableResolver, TimeBasedVariableResolver, CommentBasedVariableResolver, WorkspaceBasedVariableResolver } from './snippetVariables.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\nimport * as colors from '../../../platform/theme/common/colorRegistry.js';\nimport { ILabelService } from '../../../platform/label/common/label.js';\nregisterThemingParticipant(function (theme, collector) {\n  function getColorGraceful(name) {\n    var color = theme.getColor(name);\n    return color ? color.toString() : 'transparent';\n  }\n\n  collector.addRule(\".monaco-editor .snippet-placeholder { background-color: \" + getColorGraceful(colors.snippetTabstopHighlightBackground) + \"; outline-color: \" + getColorGraceful(colors.snippetTabstopHighlightBorder) + \"; }\");\n  collector.addRule(\".monaco-editor .finish-snippet-placeholder { background-color: \" + getColorGraceful(colors.snippetFinalTabstopHighlightBackground) + \"; outline-color: \" + getColorGraceful(colors.snippetFinalTabstopHighlightBorder) + \"; }\");\n});\n\nvar OneSnippet =\n/** @class */\nfunction () {\n  function OneSnippet(editor, snippet, offset) {\n    this._nestingLevel = 1;\n    this._editor = editor;\n    this._snippet = snippet;\n    this._offset = offset;\n    this._placeholderGroups = groupBy(snippet.placeholders, Placeholder.compareByIndex);\n    this._placeholderGroupsIdx = -1;\n  }\n\n  OneSnippet.prototype.dispose = function () {\n    if (this._placeholderDecorations) {\n      var toRemove_1 = [];\n\n      this._placeholderDecorations.forEach(function (handle) {\n        return toRemove_1.push(handle);\n      });\n\n      this._editor.deltaDecorations(toRemove_1, []);\n    }\n\n    this._placeholderGroups.length = 0;\n  };\n\n  OneSnippet.prototype._initDecorations = function () {\n    var _this = this;\n\n    if (this._placeholderDecorations) {\n      // already initialized\n      return;\n    }\n\n    this._placeholderDecorations = new Map();\n\n    var model = this._editor.getModel();\n\n    this._editor.changeDecorations(function (accessor) {\n      // create a decoration for each placeholder\n      for (var _i = 0, _a = _this._snippet.placeholders; _i < _a.length; _i++) {\n        var placeholder = _a[_i];\n\n        var placeholderOffset = _this._snippet.offset(placeholder);\n\n        var placeholderLen = _this._snippet.fullLen(placeholder);\n\n        var range = Range.fromPositions(model.getPositionAt(_this._offset + placeholderOffset), model.getPositionAt(_this._offset + placeholderOffset + placeholderLen));\n        var options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n        var handle = accessor.addDecoration(range, options);\n\n        _this._placeholderDecorations.set(placeholder, handle);\n      }\n    });\n  };\n\n  OneSnippet.prototype.move = function (fwd) {\n    var _this = this;\n\n    if (!this._editor.hasModel()) {\n      return [];\n    }\n\n    this._initDecorations(); // Transform placeholder text if necessary\n\n\n    if (this._placeholderGroupsIdx >= 0) {\n      var operations = [];\n\n      for (var _i = 0, _a = this._placeholderGroups[this._placeholderGroupsIdx]; _i < _a.length; _i++) {\n        var placeholder = _a[_i]; // Check if the placeholder has a transformation\n\n        if (placeholder.transform) {\n          var id = this._placeholderDecorations.get(placeholder);\n\n          var range = this._editor.getModel().getDecorationRange(id);\n\n          var currentValue = this._editor.getModel().getValueInRange(range);\n\n          operations.push(EditOperation.replaceMove(range, placeholder.transform.resolve(currentValue)));\n        }\n      }\n\n      if (operations.length > 0) {\n        this._editor.executeEdits('snippet.placeholderTransform', operations);\n      }\n    }\n\n    var couldSkipThisPlaceholder = false;\n\n    if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n      this._placeholderGroupsIdx += 1;\n      couldSkipThisPlaceholder = true;\n    } else if (fwd === false && this._placeholderGroupsIdx > 0) {\n      this._placeholderGroupsIdx -= 1;\n      couldSkipThisPlaceholder = true;\n    } else {// the selection of the current placeholder might\n      // not acurate any more -> simply restore it\n    }\n\n    var newSelections = this._editor.getModel().changeDecorations(function (accessor) {\n      var activePlaceholders = new Set(); // change stickiness to always grow when typing at its edges\n      // because these decorations represent the currently active\n      // tabstop.\n      // Special case #1: reaching the final tabstop\n      // Special case #2: placeholders enclosing active placeholders\n\n      var selections = [];\n\n      for (var _i = 0, _a = _this._placeholderGroups[_this._placeholderGroupsIdx]; _i < _a.length; _i++) {\n        var placeholder = _a[_i];\n\n        var id = _this._placeholderDecorations.get(placeholder);\n\n        var range = _this._editor.getModel().getDecorationRange(id);\n\n        selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)); // consider to skip this placeholder index when the decoration\n        // range is empty but when the placeholder wasn't. that's a strong\n        // hint that the placeholder has been deleted. (all placeholder must match this)\n\n        couldSkipThisPlaceholder = couldSkipThisPlaceholder && _this._hasPlaceholderBeenCollapsed(placeholder);\n        accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n        activePlaceholders.add(placeholder);\n\n        for (var _b = 0, _c = _this._snippet.enclosingPlaceholders(placeholder); _b < _c.length; _b++) {\n          var enclosingPlaceholder = _c[_b];\n\n          var id_1 = _this._placeholderDecorations.get(enclosingPlaceholder);\n\n          accessor.changeDecorationOptions(id_1, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n          activePlaceholders.add(enclosingPlaceholder);\n        }\n      } // change stickness to never grow when typing at its edges\n      // so that in-active tabstops never grow\n\n\n      _this._placeholderDecorations.forEach(function (id, placeholder) {\n        if (!activePlaceholders.has(placeholder)) {\n          accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n        }\n      });\n\n      return selections;\n    });\n\n    return !couldSkipThisPlaceholder ? newSelections : this.move(fwd);\n  };\n\n  OneSnippet.prototype._hasPlaceholderBeenCollapsed = function (placeholder) {\n    // A placeholder is empty when it wasn't empty when authored but\n    // when its tracking decoration is empty. This also applies to all\n    // potential parent placeholders\n    var marker = placeholder;\n\n    while (marker) {\n      if (marker instanceof Placeholder) {\n        var id = this._placeholderDecorations.get(marker);\n\n        var range = this._editor.getModel().getDecorationRange(id);\n\n        if (range.isEmpty() && marker.toString().length > 0) {\n          return true;\n        }\n      }\n\n      marker = marker.parent;\n    }\n\n    return false;\n  };\n\n  Object.defineProperty(OneSnippet.prototype, \"isAtFirstPlaceholder\", {\n    get: function () {\n      return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OneSnippet.prototype, \"isAtLastPlaceholder\", {\n    get: function () {\n      return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OneSnippet.prototype, \"hasPlaceholder\", {\n    get: function () {\n      return this._snippet.placeholders.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  OneSnippet.prototype.computePossibleSelections = function () {\n    var result = new Map();\n\n    for (var _i = 0, _a = this._placeholderGroups; _i < _a.length; _i++) {\n      var placeholdersWithEqualIndex = _a[_i];\n      var ranges = void 0;\n\n      for (var _b = 0, placeholdersWithEqualIndex_1 = placeholdersWithEqualIndex; _b < placeholdersWithEqualIndex_1.length; _b++) {\n        var placeholder = placeholdersWithEqualIndex_1[_b];\n\n        if (placeholder.isFinalTabstop) {\n          // ignore those\n          break;\n        }\n\n        if (!ranges) {\n          ranges = [];\n          result.set(placeholder.index, ranges);\n        }\n\n        var id = this._placeholderDecorations.get(placeholder);\n\n        var range = this._editor.getModel().getDecorationRange(id);\n\n        if (!range) {\n          // one of the placeholder lost its decoration and\n          // therefore we bail out and pretend the placeholder\n          // (with its mirrors) doesn't exist anymore.\n          result.delete(placeholder.index);\n          break;\n        }\n\n        ranges.push(range);\n      }\n    }\n\n    return result;\n  };\n\n  Object.defineProperty(OneSnippet.prototype, \"choice\", {\n    get: function () {\n      return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  OneSnippet.prototype.merge = function (others) {\n    var _this = this;\n\n    var model = this._editor.getModel();\n\n    this._nestingLevel *= 10;\n\n    this._editor.changeDecorations(function (accessor) {\n      // For each active placeholder take one snippet and merge it\n      // in that the placeholder (can be many for `$1foo$1foo`). Because\n      // everything is sorted by editor selection we can simply remove\n      // elements from the beginning of the array\n      for (var _i = 0, _a = _this._placeholderGroups[_this._placeholderGroupsIdx]; _i < _a.length; _i++) {\n        var placeholder = _a[_i];\n        var nested = others.shift();\n        console.assert(!nested._placeholderDecorations); // Massage placeholder-indicies of the nested snippet to be\n        // sorted right after the insertion point. This ensures we move\n        // through the placeholders in the correct order\n\n        var indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\n\n        for (var _b = 0, _c = nested._snippet.placeholderInfo.all; _b < _c.length; _b++) {\n          var nestedPlaceholder = _c[_b];\n\n          if (nestedPlaceholder.isFinalTabstop) {\n            nestedPlaceholder.index = placeholder.index + (indexLastPlaceholder + 1) / _this._nestingLevel;\n          } else {\n            nestedPlaceholder.index = placeholder.index + nestedPlaceholder.index / _this._nestingLevel;\n          }\n        }\n\n        _this._snippet.replace(placeholder, nested._snippet.children); // Remove the placeholder at which position are inserting\n        // the snippet and also remove its decoration.\n\n\n        var id = _this._placeholderDecorations.get(placeholder);\n\n        accessor.removeDecoration(id);\n\n        _this._placeholderDecorations.delete(placeholder); // For each *new* placeholder we create decoration to monitor\n        // how and if it grows/shrinks.\n\n\n        for (var _d = 0, _e = nested._snippet.placeholders; _d < _e.length; _d++) {\n          var placeholder_1 = _e[_d];\n\n          var placeholderOffset = nested._snippet.offset(placeholder_1);\n\n          var placeholderLen = nested._snippet.fullLen(placeholder_1);\n\n          var range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\n          var handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n\n          _this._placeholderDecorations.set(placeholder_1, handle);\n        }\n      } // Last, re-create the placeholder groups by sorting placeholders by their index.\n\n\n      _this._placeholderGroups = groupBy(_this._snippet.placeholders, Placeholder.compareByIndex);\n    });\n  };\n\n  OneSnippet._decor = {\n    active: ModelDecorationOptions.register({\n      stickiness: 0\n      /* AlwaysGrowsWhenTypingAtEdges */\n      ,\n      className: 'snippet-placeholder'\n    }),\n    inactive: ModelDecorationOptions.register({\n      stickiness: 1\n      /* NeverGrowsWhenTypingAtEdges */\n      ,\n      className: 'snippet-placeholder'\n    }),\n    activeFinal: ModelDecorationOptions.register({\n      stickiness: 1\n      /* NeverGrowsWhenTypingAtEdges */\n      ,\n      className: 'finish-snippet-placeholder'\n    }),\n    inactiveFinal: ModelDecorationOptions.register({\n      stickiness: 1\n      /* NeverGrowsWhenTypingAtEdges */\n      ,\n      className: 'finish-snippet-placeholder'\n    })\n  };\n  return OneSnippet;\n}();\n\nexport { OneSnippet };\nvar _defaultOptions = {\n  overwriteBefore: 0,\n  overwriteAfter: 0,\n  adjustWhitespace: true,\n  clipboardText: undefined\n};\n\nvar SnippetSession =\n/** @class */\nfunction () {\n  function SnippetSession(editor, template, options) {\n    if (options === void 0) {\n      options = _defaultOptions;\n    }\n\n    this._templateMerges = [];\n    this._snippets = [];\n    this._editor = editor;\n    this._template = template;\n    this._options = options;\n  }\n\n  SnippetSession.adjustWhitespace = function (model, position, snippet) {\n    var line = model.getLineContent(position.lineNumber);\n    var lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);\n    snippet.walk(function (marker) {\n      if (marker instanceof Text && !(marker.parent instanceof Choice)) {\n        // adjust indentation of text markers, except for choise elements\n        // which get adjusted when being selected\n        var lines = marker.value.split(/\\r\\n|\\r|\\n/);\n\n        for (var i = 1; i < lines.length; i++) {\n          var templateLeadingWhitespace = getLeadingWhitespace(lines[i]);\n          lines[i] = model.normalizeIndentation(lineLeadingWhitespace + templateLeadingWhitespace) + lines[i].substr(templateLeadingWhitespace.length);\n        }\n\n        var newValue = lines.join(model.getEOL());\n\n        if (newValue !== marker.value) {\n          marker.parent.replace(marker, [new Text(newValue)]);\n        }\n      }\n\n      return true;\n    });\n  };\n\n  SnippetSession.adjustSelection = function (model, selection, overwriteBefore, overwriteAfter) {\n    if (overwriteBefore !== 0 || overwriteAfter !== 0) {\n      // overwrite[Before|After] is compute using the position, not the whole\n      // selection. therefore we adjust the selection around that position\n      var positionLineNumber = selection.positionLineNumber,\n          positionColumn = selection.positionColumn;\n      var positionColumnBefore = positionColumn - overwriteBefore;\n      var positionColumnAfter = positionColumn + overwriteAfter;\n      var range = model.validateRange({\n        startLineNumber: positionLineNumber,\n        startColumn: positionColumnBefore,\n        endLineNumber: positionLineNumber,\n        endColumn: positionColumnAfter\n      });\n      selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\n    }\n\n    return selection;\n  };\n\n  SnippetSession.createEditsAndSnippets = function (editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText) {\n    var edits = [];\n    var snippets = [];\n\n    if (!editor.hasModel()) {\n      return {\n        edits: edits,\n        snippets: snippets\n      };\n    }\n\n    var model = editor.getModel();\n    var workspaceService = editor.invokeWithinContext(function (accessor) {\n      return accessor.get(IWorkspaceContextService, optional);\n    });\n    var modelBasedVariableResolver = editor.invokeWithinContext(function (accessor) {\n      return new ModelBasedVariableResolver(accessor.get(ILabelService, optional), model);\n    });\n    var clipboardService = editor.invokeWithinContext(function (accessor) {\n      return accessor.get(IClipboardService, optional);\n    });\n    clipboardText = clipboardText || clipboardService && clipboardService.readTextSync();\n    var delta = 0; // know what text the overwrite[Before|After] extensions\n    // of the primary curser have selected because only when\n    // secondary selections extend to the same text we can grow them\n\n    var firstBeforeText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n    var firstAfterText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), 0, overwriteAfter)); // remember the first non-whitespace column to decide if\n    // `keepWhitespace` should be overruled for secondary selections\n\n    var firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber); // sort selections by their start position but remeber\n    // the original index. that allows you to create correct\n    // offset-based selection logic without changing the\n    // primary selection\n\n    var indexedSelections = editor.getSelections().map(function (selection, idx) {\n      return {\n        selection: selection,\n        idx: idx\n      };\n    }).sort(function (a, b) {\n      return Range.compareRangesUsingStarts(a.selection, b.selection);\n    });\n\n    for (var _i = 0, indexedSelections_1 = indexedSelections; _i < indexedSelections_1.length; _i++) {\n      var _a = indexedSelections_1[_i],\n          selection = _a.selection,\n          idx = _a.idx; // extend selection with the `overwriteBefore` and `overwriteAfter` and then\n      // compare if this matches the extensions of the primary selection\n\n      var extensionBefore = SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);\n      var extensionAfter = SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);\n\n      if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n        extensionBefore = selection;\n      }\n\n      if (firstAfterText !== model.getValueInRange(extensionAfter)) {\n        extensionAfter = selection;\n      } // merge the before and after selection into one\n\n\n      var snippetSelection = selection.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn).setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n      var snippet = new SnippetParser().parse(template, true, enforceFinalTabstop); // adjust the template string to match the indentation and\n      // whitespace rules of this insert location (can be different for each cursor)\n      // happens when being asked for (default) or when this is a secondary\n      // cursor and the leading whitespace is different\n\n      var start = snippetSelection.getStartPosition();\n\n      if (adjustWhitespace || idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber)) {\n        SnippetSession.adjustWhitespace(model, start, snippet);\n      }\n\n      snippet.resolveVariables(new CompositeSnippetVariableResolver([modelBasedVariableResolver, new ClipboardBasedVariableResolver(clipboardText, idx, indexedSelections.length), new SelectionBasedVariableResolver(model, selection), new CommentBasedVariableResolver(model), new TimeBasedVariableResolver(), new WorkspaceBasedVariableResolver(workspaceService)]));\n      var offset = model.getOffsetAt(start) + delta;\n      delta += snippet.toString().length - model.getValueLengthInRange(snippetSelection); // store snippets with the index of their originating selection.\n      // that ensures the primiary cursor stays primary despite not being\n      // the one with lowest start position\n\n      edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());\n      snippets[idx] = new OneSnippet(editor, snippet, offset);\n    }\n\n    return {\n      edits: edits,\n      snippets: snippets\n    };\n  };\n\n  SnippetSession.prototype.dispose = function () {\n    dispose(this._snippets);\n  };\n\n  SnippetSession.prototype._logInfo = function () {\n    return \"template=\\\"\" + this._template + \"\\\", merged_templates=\\\"\" + this._templateMerges.join(' -> ') + \"\\\"\";\n  };\n\n  SnippetSession.prototype.insert = function () {\n    var _this = this;\n\n    if (!this._editor.hasModel()) {\n      return;\n    } // make insert edit and start with first selections\n\n\n    var _a = SnippetSession.createEditsAndSnippets(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText),\n        edits = _a.edits,\n        snippets = _a.snippets;\n\n    this._snippets = snippets;\n\n    this._editor.executeEdits('snippet', edits, function (undoEdits) {\n      if (_this._snippets[0].hasPlaceholder) {\n        return _this._move(true);\n      } else {\n        return undoEdits.map(function (edit) {\n          return Selection.fromPositions(edit.range.getEndPosition());\n        });\n      }\n    });\n\n    this._editor.revealRange(this._editor.getSelections()[0]);\n  };\n\n  SnippetSession.prototype.merge = function (template, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = _defaultOptions;\n    }\n\n    if (!this._editor.hasModel()) {\n      return;\n    }\n\n    this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n\n    var _a = SnippetSession.createEditsAndSnippets(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText),\n        edits = _a.edits,\n        snippets = _a.snippets;\n\n    this._editor.executeEdits('snippet', edits, function (undoEdits) {\n      for (var _i = 0, _a = _this._snippets; _i < _a.length; _i++) {\n        var snippet = _a[_i];\n        snippet.merge(snippets);\n      }\n\n      console.assert(snippets.length === 0);\n\n      if (_this._snippets[0].hasPlaceholder) {\n        return _this._move(undefined);\n      } else {\n        return undoEdits.map(function (edit) {\n          return Selection.fromPositions(edit.range.getEndPosition());\n        });\n      }\n    });\n  };\n\n  SnippetSession.prototype.next = function () {\n    var newSelections = this._move(true);\n\n    this._editor.setSelections(newSelections);\n\n    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n  };\n\n  SnippetSession.prototype.prev = function () {\n    var newSelections = this._move(false);\n\n    this._editor.setSelections(newSelections);\n\n    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n  };\n\n  SnippetSession.prototype._move = function (fwd) {\n    var selections = [];\n\n    for (var _i = 0, _a = this._snippets; _i < _a.length; _i++) {\n      var snippet = _a[_i];\n      var oneSelection = snippet.move(fwd);\n      selections.push.apply(selections, oneSelection);\n    }\n\n    return selections;\n  };\n\n  Object.defineProperty(SnippetSession.prototype, \"isAtFirstPlaceholder\", {\n    get: function () {\n      return this._snippets[0].isAtFirstPlaceholder;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SnippetSession.prototype, \"isAtLastPlaceholder\", {\n    get: function () {\n      return this._snippets[0].isAtLastPlaceholder;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SnippetSession.prototype, \"hasPlaceholder\", {\n    get: function () {\n      return this._snippets[0].hasPlaceholder;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SnippetSession.prototype, \"choice\", {\n    get: function () {\n      return this._snippets[0].choice;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SnippetSession.prototype.isSelectionWithinPlaceholders = function () {\n    if (!this.hasPlaceholder) {\n      return false;\n    }\n\n    var selections = this._editor.getSelections();\n\n    if (selections.length < this._snippets.length) {\n      // this means we started snippet mode with N\n      // selections and have M (N > M) selections.\n      // So one snippet is without selection -> cancel\n      return false;\n    }\n\n    var allPossibleSelections = new Map();\n\n    var _loop_1 = function (snippet) {\n      var possibleSelections = snippet.computePossibleSelections(); // for the first snippet find the placeholder (and its ranges)\n      // that contain at least one selection. for all remaining snippets\n      // the same placeholder (and their ranges) must be used.\n\n      if (allPossibleSelections.size === 0) {\n        possibleSelections.forEach(function (ranges, index) {\n          ranges.sort(Range.compareRangesUsingStarts);\n\n          for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {\n            var selection = selections_1[_i];\n\n            if (ranges[0].containsRange(selection)) {\n              allPossibleSelections.set(index, []);\n              break;\n            }\n          }\n        });\n      }\n\n      if (allPossibleSelections.size === 0) {\n        return {\n          value: false\n        };\n      } // add selections from 'this' snippet so that we know all\n      // selections for this placeholder\n\n\n      allPossibleSelections.forEach(function (array, index) {\n        array.push.apply(array, possibleSelections.get(index));\n      });\n    };\n\n    for (var _i = 0, _a = this._snippets; _i < _a.length; _i++) {\n      var snippet = _a[_i];\n\n      var state_1 = _loop_1(snippet);\n\n      if (typeof state_1 === \"object\") return state_1.value;\n    } // sort selections (and later placeholder-ranges). then walk both\n    // arrays and make sure the placeholder-ranges contain the corresponding\n    // selection\n\n\n    selections.sort(Range.compareRangesUsingStarts);\n    allPossibleSelections.forEach(function (ranges, index) {\n      if (ranges.length !== selections.length) {\n        allPossibleSelections.delete(index);\n        return;\n      }\n\n      ranges.sort(Range.compareRangesUsingStarts);\n\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].containsRange(selections[i])) {\n          allPossibleSelections.delete(index);\n          return;\n        }\n      }\n    }); // from all possible selections we have deleted those\n    // that don't match with the current selection. if we don't\n    // have any left, we don't have a selection anymore\n\n    return allPossibleSelections.size > 0;\n  };\n\n  return SnippetSession;\n}();\n\nexport { SnippetSession };","map":null,"metadata":{},"sourceType":"module"}