{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as dom from '../../../base/browser/dom.js';\nimport { EventType, Gesture } from '../../../base/browser/touch.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { MouseHandler } from './mouseHandler.js';\nimport { EditorMouseEvent } from '../editorDom.js';\n\nfunction gestureChangeEventMerger(lastEvent, currentEvent) {\n  var r = {\n    translationY: currentEvent.translationY,\n    translationX: currentEvent.translationX\n  };\n\n  if (lastEvent) {\n    r.translationY += lastEvent.translationY;\n    r.translationX += lastEvent.translationX;\n  }\n\n  return r;\n}\n/**\n * Basically IE10 and IE11\n */\n\n\nvar MsPointerHandler =\n/** @class */\nfunction (_super) {\n  __extends(MsPointerHandler, _super);\n\n  function MsPointerHandler(context, viewController, viewHelper) {\n    var _this = _super.call(this, context, viewController, viewHelper) || this;\n\n    _this.viewHelper.linesContentDomNode.style.msTouchAction = 'none';\n    _this.viewHelper.linesContentDomNode.style.msContentZooming = 'none'; // TODO@Alex -> this expects that the view is added in 100 ms, might not be the case\n    // This handler should be added when the dom node is in the dom tree\n\n    _this._installGestureHandlerTimeout = window.setTimeout(function () {\n      _this._installGestureHandlerTimeout = -1;\n\n      if (window.MSGesture) {\n        var touchGesture_1 = new MSGesture();\n        var penGesture_1 = new MSGesture();\n        touchGesture_1.target = _this.viewHelper.linesContentDomNode;\n        penGesture_1.target = _this.viewHelper.linesContentDomNode;\n\n        _this.viewHelper.linesContentDomNode.addEventListener('MSPointerDown', function (e) {\n          // Circumvent IE11 breaking change in e.pointerType & TypeScript's stale definitions\n          var pointerType = e.pointerType;\n\n          if (pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) {\n            _this._lastPointerType = 'mouse';\n            return;\n          } else if (pointerType === (e.MSPOINTER_TYPE_TOUCH || 'touch')) {\n            _this._lastPointerType = 'touch';\n            touchGesture_1.addPointer(e.pointerId);\n          } else {\n            _this._lastPointerType = 'pen';\n            penGesture_1.addPointer(e.pointerId);\n          }\n        });\n\n        _this._register(dom.addDisposableThrottledListener(_this.viewHelper.linesContentDomNode, 'MSGestureChange', function (e) {\n          return _this._onGestureChange(e);\n        }, gestureChangeEventMerger));\n\n        _this._register(dom.addDisposableListener(_this.viewHelper.linesContentDomNode, 'MSGestureTap', function (e) {\n          return _this._onCaptureGestureTap(e);\n        }, true));\n      }\n    }, 100);\n    _this._lastPointerType = 'mouse';\n    return _this;\n  }\n\n  MsPointerHandler.prototype._onMouseDown = function (e) {\n    if (this._lastPointerType === 'mouse') {\n      _super.prototype._onMouseDown.call(this, e);\n    }\n  };\n\n  MsPointerHandler.prototype._onCaptureGestureTap = function (rawEvent) {\n    var _this = this;\n\n    var e = new EditorMouseEvent(rawEvent, this.viewHelper.viewDomNode);\n\n    var t = this._createMouseTarget(e, false);\n\n    if (t.position) {\n      this.viewController.moveTo(t.position);\n    } // IE does not want to focus when coming in from the browser's address bar\n\n\n    if (e.browserEvent.fromElement) {\n      e.preventDefault();\n      this.viewHelper.focusTextArea();\n    } else {\n      // TODO@Alex -> cancel this is focus is lost\n      setTimeout(function () {\n        _this.viewHelper.focusTextArea();\n      });\n    }\n  };\n\n  MsPointerHandler.prototype._onGestureChange = function (e) {\n    this._context.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);\n  };\n\n  MsPointerHandler.prototype.dispose = function () {\n    window.clearTimeout(this._installGestureHandlerTimeout);\n\n    _super.prototype.dispose.call(this);\n  };\n\n  return MsPointerHandler;\n}(MouseHandler);\n/**\n * Basically Edge but should be modified to handle any pointerEnabled, even without support of MSGesture\n */\n\n\nvar StandardPointerHandler =\n/** @class */\nfunction (_super) {\n  __extends(StandardPointerHandler, _super);\n\n  function StandardPointerHandler(context, viewController, viewHelper) {\n    var _this = _super.call(this, context, viewController, viewHelper) || this;\n\n    _this.viewHelper.linesContentDomNode.style.touchAction = 'none'; // TODO@Alex -> this expects that the view is added in 100 ms, might not be the case\n    // This handler should be added when the dom node is in the dom tree\n\n    _this._installGestureHandlerTimeout = window.setTimeout(function () {\n      _this._installGestureHandlerTimeout = -1; // TODO@Alex: replace the usage of MSGesture here with something that works across all browsers\n\n      if (window.MSGesture) {\n        var touchGesture_2 = new MSGesture();\n        var penGesture_2 = new MSGesture();\n        touchGesture_2.target = _this.viewHelper.linesContentDomNode;\n        penGesture_2.target = _this.viewHelper.linesContentDomNode;\n\n        _this.viewHelper.linesContentDomNode.addEventListener('pointerdown', function (e) {\n          var pointerType = e.pointerType;\n\n          if (pointerType === 'mouse') {\n            _this._lastPointerType = 'mouse';\n            return;\n          } else if (pointerType === 'touch') {\n            _this._lastPointerType = 'touch';\n            touchGesture_2.addPointer(e.pointerId);\n          } else {\n            _this._lastPointerType = 'pen';\n            penGesture_2.addPointer(e.pointerId);\n          }\n        });\n\n        _this._register(dom.addDisposableThrottledListener(_this.viewHelper.linesContentDomNode, 'MSGestureChange', function (e) {\n          return _this._onGestureChange(e);\n        }, gestureChangeEventMerger));\n\n        _this._register(dom.addDisposableListener(_this.viewHelper.linesContentDomNode, 'MSGestureTap', function (e) {\n          return _this._onCaptureGestureTap(e);\n        }, true));\n      }\n    }, 100);\n    _this._lastPointerType = 'mouse';\n    return _this;\n  }\n\n  StandardPointerHandler.prototype._onMouseDown = function (e) {\n    if (this._lastPointerType === 'mouse') {\n      _super.prototype._onMouseDown.call(this, e);\n    }\n  };\n\n  StandardPointerHandler.prototype._onCaptureGestureTap = function (rawEvent) {\n    var _this = this;\n\n    var e = new EditorMouseEvent(rawEvent, this.viewHelper.viewDomNode);\n\n    var t = this._createMouseTarget(e, false);\n\n    if (t.position) {\n      this.viewController.moveTo(t.position);\n    } // IE does not want to focus when coming in from the browser's address bar\n\n\n    if (e.browserEvent.fromElement) {\n      e.preventDefault();\n      this.viewHelper.focusTextArea();\n    } else {\n      // TODO@Alex -> cancel this is focus is lost\n      setTimeout(function () {\n        _this.viewHelper.focusTextArea();\n      });\n    }\n  };\n\n  StandardPointerHandler.prototype._onGestureChange = function (e) {\n    this._context.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);\n  };\n\n  StandardPointerHandler.prototype.dispose = function () {\n    window.clearTimeout(this._installGestureHandlerTimeout);\n\n    _super.prototype.dispose.call(this);\n  };\n\n  return StandardPointerHandler;\n}(MouseHandler);\n\nvar TouchHandler =\n/** @class */\nfunction (_super) {\n  __extends(TouchHandler, _super);\n\n  function TouchHandler(context, viewController, viewHelper) {\n    var _this = _super.call(this, context, viewController, viewHelper) || this;\n\n    Gesture.addTarget(_this.viewHelper.linesContentDomNode);\n\n    _this._register(dom.addDisposableListener(_this.viewHelper.linesContentDomNode, EventType.Tap, function (e) {\n      return _this.onTap(e);\n    }));\n\n    _this._register(dom.addDisposableListener(_this.viewHelper.linesContentDomNode, EventType.Change, function (e) {\n      return _this.onChange(e);\n    }));\n\n    _this._register(dom.addDisposableListener(_this.viewHelper.linesContentDomNode, EventType.Contextmenu, function (e) {\n      return _this._onContextMenu(new EditorMouseEvent(e, _this.viewHelper.viewDomNode), false);\n    }));\n\n    return _this;\n  }\n\n  TouchHandler.prototype.onTap = function (event) {\n    event.preventDefault();\n    this.viewHelper.focusTextArea();\n\n    var target = this._createMouseTarget(new EditorMouseEvent(event, this.viewHelper.viewDomNode), false);\n\n    if (target.position) {\n      this.viewController.moveTo(target.position);\n    }\n  };\n\n  TouchHandler.prototype.onChange = function (e) {\n    this._context.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);\n  };\n\n  return TouchHandler;\n}(MouseHandler);\n\nvar PointerHandler =\n/** @class */\nfunction (_super) {\n  __extends(PointerHandler, _super);\n\n  function PointerHandler(context, viewController, viewHelper) {\n    var _this = _super.call(this) || this;\n\n    if (window.navigator.msPointerEnabled) {\n      _this.handler = _this._register(new MsPointerHandler(context, viewController, viewHelper));\n    } else if (window.TouchEvent) {\n      _this.handler = _this._register(new TouchHandler(context, viewController, viewHelper));\n    } else if (window.navigator.pointerEnabled || window.PointerEvent) {\n      _this.handler = _this._register(new StandardPointerHandler(context, viewController, viewHelper));\n    } else {\n      _this.handler = _this._register(new MouseHandler(context, viewController, viewHelper));\n    }\n\n    return _this;\n  }\n\n  PointerHandler.prototype.getTargetAtClientPoint = function (clientX, clientY) {\n    return this.handler.getTargetAtClientPoint(clientX, clientY);\n  };\n\n  return PointerHandler;\n}(Disposable);\n\nexport { PointerHandler };","map":null,"metadata":{},"sourceType":"module"}