{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\n\nvar ContextKeyExpr =\n/** @class */\nfunction () {\n  function ContextKeyExpr() {}\n\n  ContextKeyExpr.has = function (key) {\n    return ContextKeyDefinedExpr.create(key);\n  };\n\n  ContextKeyExpr.equals = function (key, value) {\n    return ContextKeyEqualsExpr.create(key, value);\n  };\n\n  ContextKeyExpr.regex = function (key, value) {\n    return ContextKeyRegexExpr.create(key, value);\n  };\n\n  ContextKeyExpr.not = function (key) {\n    return ContextKeyNotExpr.create(key);\n  };\n\n  ContextKeyExpr.and = function () {\n    var expr = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      expr[_i] = arguments[_i];\n    }\n\n    return ContextKeyAndExpr.create(expr);\n  };\n\n  ContextKeyExpr.or = function () {\n    var expr = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      expr[_i] = arguments[_i];\n    }\n\n    return ContextKeyOrExpr.create(expr);\n  };\n\n  ContextKeyExpr.deserialize = function (serialized, strict) {\n    if (strict === void 0) {\n      strict = false;\n    }\n\n    if (!serialized) {\n      return undefined;\n    }\n\n    return this._deserializeOrExpression(serialized, strict);\n  };\n\n  ContextKeyExpr._deserializeOrExpression = function (serialized, strict) {\n    var _this = this;\n\n    var pieces = serialized.split('||');\n    return ContextKeyOrExpr.create(pieces.map(function (p) {\n      return _this._deserializeAndExpression(p, strict);\n    }));\n  };\n\n  ContextKeyExpr._deserializeAndExpression = function (serialized, strict) {\n    var _this = this;\n\n    var pieces = serialized.split('&&');\n    return ContextKeyAndExpr.create(pieces.map(function (p) {\n      return _this._deserializeOne(p, strict);\n    }));\n  };\n\n  ContextKeyExpr._deserializeOne = function (serializedOne, strict) {\n    serializedOne = serializedOne.trim();\n\n    if (serializedOne.indexOf('!=') >= 0) {\n      var pieces = serializedOne.split('!=');\n      return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n    }\n\n    if (serializedOne.indexOf('==') >= 0) {\n      var pieces = serializedOne.split('==');\n      return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n    }\n\n    if (serializedOne.indexOf('=~') >= 0) {\n      var pieces = serializedOne.split('=~');\n      return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n    }\n\n    if (/^\\!\\s*/.test(serializedOne)) {\n      return ContextKeyNotExpr.create(serializedOne.substr(1).trim());\n    }\n\n    return ContextKeyDefinedExpr.create(serializedOne);\n  };\n\n  ContextKeyExpr._deserializeValue = function (serializedValue, strict) {\n    serializedValue = serializedValue.trim();\n\n    if (serializedValue === 'true') {\n      return true;\n    }\n\n    if (serializedValue === 'false') {\n      return false;\n    }\n\n    var m = /^'([^']*)'$/.exec(serializedValue);\n\n    if (m) {\n      return m[1].trim();\n    }\n\n    return serializedValue;\n  };\n\n  ContextKeyExpr._deserializeRegexValue = function (serializedValue, strict) {\n    if (isFalsyOrWhitespace(serializedValue)) {\n      if (strict) {\n        throw new Error('missing regexp-value for =~-expression');\n      } else {\n        console.warn('missing regexp-value for =~-expression');\n      }\n\n      return null;\n    }\n\n    var start = serializedValue.indexOf('/');\n    var end = serializedValue.lastIndexOf('/');\n\n    if (start === end || start < 0\n    /* || to < 0 */\n    ) {\n        if (strict) {\n          throw new Error(\"bad regexp-value '\" + serializedValue + \"', missing /-enclosure\");\n        } else {\n          console.warn(\"bad regexp-value '\" + serializedValue + \"', missing /-enclosure\");\n        }\n\n        return null;\n      }\n\n    var value = serializedValue.slice(start + 1, end);\n    var caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n\n    try {\n      return new RegExp(value, caseIgnoreFlag);\n    } catch (e) {\n      if (strict) {\n        throw new Error(\"bad regexp-value '\" + serializedValue + \"', parse error: \" + e);\n      } else {\n        console.warn(\"bad regexp-value '\" + serializedValue + \"', parse error: \" + e);\n      }\n\n      return null;\n    }\n  };\n\n  return ContextKeyExpr;\n}();\n\nexport { ContextKeyExpr };\n\nfunction cmp(a, b) {\n  var aType = a.getType();\n  var bType = b.getType();\n\n  if (aType !== bType) {\n    return aType - bType;\n  }\n\n  switch (aType) {\n    case 1\n    /* Defined */\n    :\n      return a.cmp(b);\n\n    case 2\n    /* Not */\n    :\n      return a.cmp(b);\n\n    case 3\n    /* Equals */\n    :\n      return a.cmp(b);\n\n    case 4\n    /* NotEquals */\n    :\n      return a.cmp(b);\n\n    case 6\n    /* Regex */\n    :\n      return a.cmp(b);\n\n    case 7\n    /* NotRegex */\n    :\n      return a.cmp(b);\n\n    case 5\n    /* And */\n    :\n      return a.cmp(b);\n\n    default:\n      throw new Error('Unknown ContextKeyExpr!');\n  }\n}\n\nvar ContextKeyDefinedExpr =\n/** @class */\nfunction () {\n  function ContextKeyDefinedExpr(key) {\n    this.key = key;\n  }\n\n  ContextKeyDefinedExpr.create = function (key) {\n    return new ContextKeyDefinedExpr(key);\n  };\n\n  ContextKeyDefinedExpr.prototype.getType = function () {\n    return 1\n    /* Defined */\n    ;\n  };\n\n  ContextKeyDefinedExpr.prototype.cmp = function (other) {\n    if (this.key < other.key) {\n      return -1;\n    }\n\n    if (this.key > other.key) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  ContextKeyDefinedExpr.prototype.equals = function (other) {\n    if (other instanceof ContextKeyDefinedExpr) {\n      return this.key === other.key;\n    }\n\n    return false;\n  };\n\n  ContextKeyDefinedExpr.prototype.evaluate = function (context) {\n    return !!context.getValue(this.key);\n  };\n\n  ContextKeyDefinedExpr.prototype.keys = function () {\n    return [this.key];\n  };\n\n  ContextKeyDefinedExpr.prototype.negate = function () {\n    return ContextKeyNotExpr.create(this.key);\n  };\n\n  return ContextKeyDefinedExpr;\n}();\n\nexport { ContextKeyDefinedExpr };\n\nvar ContextKeyEqualsExpr =\n/** @class */\nfunction () {\n  function ContextKeyEqualsExpr(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  ContextKeyEqualsExpr.create = function (key, value) {\n    if (typeof value === 'boolean') {\n      if (value) {\n        return ContextKeyDefinedExpr.create(key);\n      }\n\n      return ContextKeyNotExpr.create(key);\n    }\n\n    return new ContextKeyEqualsExpr(key, value);\n  };\n\n  ContextKeyEqualsExpr.prototype.getType = function () {\n    return 3\n    /* Equals */\n    ;\n  };\n\n  ContextKeyEqualsExpr.prototype.cmp = function (other) {\n    if (this.key < other.key) {\n      return -1;\n    }\n\n    if (this.key > other.key) {\n      return 1;\n    }\n\n    if (this.value < other.value) {\n      return -1;\n    }\n\n    if (this.value > other.value) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  ContextKeyEqualsExpr.prototype.equals = function (other) {\n    if (other instanceof ContextKeyEqualsExpr) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  };\n\n  ContextKeyEqualsExpr.prototype.evaluate = function (context) {\n    /* tslint:disable:triple-equals */\n    // Intentional ==\n    return context.getValue(this.key) == this.value;\n    /* tslint:enable:triple-equals */\n  };\n\n  ContextKeyEqualsExpr.prototype.keys = function () {\n    return [this.key];\n  };\n\n  ContextKeyEqualsExpr.prototype.negate = function () {\n    return ContextKeyNotEqualsExpr.create(this.key, this.value);\n  };\n\n  return ContextKeyEqualsExpr;\n}();\n\nexport { ContextKeyEqualsExpr };\n\nvar ContextKeyNotEqualsExpr =\n/** @class */\nfunction () {\n  function ContextKeyNotEqualsExpr(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  ContextKeyNotEqualsExpr.create = function (key, value) {\n    if (typeof value === 'boolean') {\n      if (value) {\n        return ContextKeyNotExpr.create(key);\n      }\n\n      return ContextKeyDefinedExpr.create(key);\n    }\n\n    return new ContextKeyNotEqualsExpr(key, value);\n  };\n\n  ContextKeyNotEqualsExpr.prototype.getType = function () {\n    return 4\n    /* NotEquals */\n    ;\n  };\n\n  ContextKeyNotEqualsExpr.prototype.cmp = function (other) {\n    if (this.key < other.key) {\n      return -1;\n    }\n\n    if (this.key > other.key) {\n      return 1;\n    }\n\n    if (this.value < other.value) {\n      return -1;\n    }\n\n    if (this.value > other.value) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  ContextKeyNotEqualsExpr.prototype.equals = function (other) {\n    if (other instanceof ContextKeyNotEqualsExpr) {\n      return this.key === other.key && this.value === other.value;\n    }\n\n    return false;\n  };\n\n  ContextKeyNotEqualsExpr.prototype.evaluate = function (context) {\n    /* tslint:disable:triple-equals */\n    // Intentional !=\n    return context.getValue(this.key) != this.value;\n    /* tslint:enable:triple-equals */\n  };\n\n  ContextKeyNotEqualsExpr.prototype.keys = function () {\n    return [this.key];\n  };\n\n  ContextKeyNotEqualsExpr.prototype.negate = function () {\n    return ContextKeyEqualsExpr.create(this.key, this.value);\n  };\n\n  return ContextKeyNotEqualsExpr;\n}();\n\nexport { ContextKeyNotEqualsExpr };\n\nvar ContextKeyNotExpr =\n/** @class */\nfunction () {\n  function ContextKeyNotExpr(key) {\n    this.key = key;\n  }\n\n  ContextKeyNotExpr.create = function (key) {\n    return new ContextKeyNotExpr(key);\n  };\n\n  ContextKeyNotExpr.prototype.getType = function () {\n    return 2\n    /* Not */\n    ;\n  };\n\n  ContextKeyNotExpr.prototype.cmp = function (other) {\n    if (this.key < other.key) {\n      return -1;\n    }\n\n    if (this.key > other.key) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  ContextKeyNotExpr.prototype.equals = function (other) {\n    if (other instanceof ContextKeyNotExpr) {\n      return this.key === other.key;\n    }\n\n    return false;\n  };\n\n  ContextKeyNotExpr.prototype.evaluate = function (context) {\n    return !context.getValue(this.key);\n  };\n\n  ContextKeyNotExpr.prototype.keys = function () {\n    return [this.key];\n  };\n\n  ContextKeyNotExpr.prototype.negate = function () {\n    return ContextKeyDefinedExpr.create(this.key);\n  };\n\n  return ContextKeyNotExpr;\n}();\n\nexport { ContextKeyNotExpr };\n\nvar ContextKeyRegexExpr =\n/** @class */\nfunction () {\n  function ContextKeyRegexExpr(key, regexp) {\n    this.key = key;\n    this.regexp = regexp; //\n  }\n\n  ContextKeyRegexExpr.create = function (key, regexp) {\n    return new ContextKeyRegexExpr(key, regexp);\n  };\n\n  ContextKeyRegexExpr.prototype.getType = function () {\n    return 6\n    /* Regex */\n    ;\n  };\n\n  ContextKeyRegexExpr.prototype.cmp = function (other) {\n    if (this.key < other.key) {\n      return -1;\n    }\n\n    if (this.key > other.key) {\n      return 1;\n    }\n\n    var thisSource = this.regexp ? this.regexp.source : '';\n    var otherSource = other.regexp ? other.regexp.source : '';\n\n    if (thisSource < otherSource) {\n      return -1;\n    }\n\n    if (thisSource > otherSource) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  ContextKeyRegexExpr.prototype.equals = function (other) {\n    if (other instanceof ContextKeyRegexExpr) {\n      var thisSource = this.regexp ? this.regexp.source : '';\n      var otherSource = other.regexp ? other.regexp.source : '';\n      return this.key === other.key && thisSource === otherSource;\n    }\n\n    return false;\n  };\n\n  ContextKeyRegexExpr.prototype.evaluate = function (context) {\n    var value = context.getValue(this.key);\n    return this.regexp ? this.regexp.test(value) : false;\n  };\n\n  ContextKeyRegexExpr.prototype.keys = function () {\n    return [this.key];\n  };\n\n  ContextKeyRegexExpr.prototype.negate = function () {\n    return ContextKeyNotRegexExpr.create(this);\n  };\n\n  return ContextKeyRegexExpr;\n}();\n\nexport { ContextKeyRegexExpr };\n\nvar ContextKeyNotRegexExpr =\n/** @class */\nfunction () {\n  function ContextKeyNotRegexExpr(_actual) {\n    this._actual = _actual; //\n  }\n\n  ContextKeyNotRegexExpr.create = function (actual) {\n    return new ContextKeyNotRegexExpr(actual);\n  };\n\n  ContextKeyNotRegexExpr.prototype.getType = function () {\n    return 7\n    /* NotRegex */\n    ;\n  };\n\n  ContextKeyNotRegexExpr.prototype.cmp = function (other) {\n    return this._actual.cmp(other._actual);\n  };\n\n  ContextKeyNotRegexExpr.prototype.equals = function (other) {\n    if (other instanceof ContextKeyNotRegexExpr) {\n      return this._actual.equals(other._actual);\n    }\n\n    return false;\n  };\n\n  ContextKeyNotRegexExpr.prototype.evaluate = function (context) {\n    return !this._actual.evaluate(context);\n  };\n\n  ContextKeyNotRegexExpr.prototype.keys = function () {\n    return this._actual.keys();\n  };\n\n  ContextKeyNotRegexExpr.prototype.negate = function () {\n    return this._actual;\n  };\n\n  return ContextKeyNotRegexExpr;\n}();\n\nexport { ContextKeyNotRegexExpr };\n\nvar ContextKeyAndExpr =\n/** @class */\nfunction () {\n  function ContextKeyAndExpr(expr) {\n    this.expr = expr;\n  }\n\n  ContextKeyAndExpr.create = function (_expr) {\n    var expr = ContextKeyAndExpr._normalizeArr(_expr);\n\n    if (expr.length === 0) {\n      return undefined;\n    }\n\n    if (expr.length === 1) {\n      return expr[0];\n    }\n\n    return new ContextKeyAndExpr(expr);\n  };\n\n  ContextKeyAndExpr.prototype.getType = function () {\n    return 5\n    /* And */\n    ;\n  };\n\n  ContextKeyAndExpr.prototype.cmp = function (other) {\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n\n    for (var i = 0, len = this.expr.length; i < len; i++) {\n      var r = cmp(this.expr[i], other.expr[i]);\n\n      if (r !== 0) {\n        return r;\n      }\n    }\n\n    return 0;\n  };\n\n  ContextKeyAndExpr.prototype.equals = function (other) {\n    if (other instanceof ContextKeyAndExpr) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n\n      for (var i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  ContextKeyAndExpr.prototype.evaluate = function (context) {\n    for (var i = 0, len = this.expr.length; i < len; i++) {\n      if (!this.expr[i].evaluate(context)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ContextKeyAndExpr._normalizeArr = function (arr) {\n    var expr = [];\n\n    if (arr) {\n      for (var i = 0, len = arr.length; i < len; i++) {\n        var e = arr[i];\n\n        if (!e) {\n          continue;\n        }\n\n        if (e instanceof ContextKeyAndExpr) {\n          expr = expr.concat(e.expr);\n          continue;\n        }\n\n        if (e instanceof ContextKeyOrExpr) {\n          // Not allowed, because we don't have parens!\n          throw new Error(\"It is not allowed to have an or expression here due to lack of parens!\");\n        }\n\n        expr.push(e);\n      }\n\n      expr.sort(cmp);\n    }\n\n    return expr;\n  };\n\n  ContextKeyAndExpr.prototype.keys = function () {\n    var result = [];\n\n    for (var _i = 0, _a = this.expr; _i < _a.length; _i++) {\n      var expr = _a[_i];\n      result.push.apply(result, expr.keys());\n    }\n\n    return result;\n  };\n\n  ContextKeyAndExpr.prototype.negate = function () {\n    var result = [];\n\n    for (var _i = 0, _a = this.expr; _i < _a.length; _i++) {\n      var expr = _a[_i];\n      result.push(expr.negate());\n    }\n\n    return ContextKeyOrExpr.create(result);\n  };\n\n  return ContextKeyAndExpr;\n}();\n\nexport { ContextKeyAndExpr };\n\nvar ContextKeyOrExpr =\n/** @class */\nfunction () {\n  function ContextKeyOrExpr(expr) {\n    this.expr = expr;\n  }\n\n  ContextKeyOrExpr.create = function (_expr) {\n    var expr = ContextKeyOrExpr._normalizeArr(_expr);\n\n    if (expr.length === 0) {\n      return undefined;\n    }\n\n    if (expr.length === 1) {\n      return expr[0];\n    }\n\n    return new ContextKeyOrExpr(expr);\n  };\n\n  ContextKeyOrExpr.prototype.getType = function () {\n    return 8\n    /* Or */\n    ;\n  };\n\n  ContextKeyOrExpr.prototype.equals = function (other) {\n    if (other instanceof ContextKeyOrExpr) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n\n      for (var i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  ContextKeyOrExpr.prototype.evaluate = function (context) {\n    for (var i = 0, len = this.expr.length; i < len; i++) {\n      if (this.expr[i].evaluate(context)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  ContextKeyOrExpr._normalizeArr = function (arr) {\n    var expr = [];\n\n    if (arr) {\n      for (var i = 0, len = arr.length; i < len; i++) {\n        var e = arr[i];\n\n        if (!e) {\n          continue;\n        }\n\n        if (e instanceof ContextKeyOrExpr) {\n          expr = expr.concat(e.expr);\n          continue;\n        }\n\n        expr.push(e);\n      }\n\n      expr.sort(cmp);\n    }\n\n    return expr;\n  };\n\n  ContextKeyOrExpr.prototype.keys = function () {\n    var result = [];\n\n    for (var _i = 0, _a = this.expr; _i < _a.length; _i++) {\n      var expr = _a[_i];\n      result.push.apply(result, expr.keys());\n    }\n\n    return result;\n  };\n\n  ContextKeyOrExpr.prototype.negate = function () {\n    var result = [];\n\n    for (var _i = 0, _a = this.expr; _i < _a.length; _i++) {\n      var expr = _a[_i];\n      result.push(expr.negate());\n    }\n\n    var terminals = function (node) {\n      if (node instanceof ContextKeyOrExpr) {\n        return node.expr;\n      }\n\n      return [node];\n    }; // We don't support parens, so here we distribute the AND over the OR terminals\n    // We always take the first 2 AND pairs and distribute them\n\n\n    while (result.length > 1) {\n      var LEFT = result.shift();\n      var RIGHT = result.shift();\n      var all = [];\n\n      for (var _b = 0, _c = terminals(LEFT); _b < _c.length; _b++) {\n        var left = _c[_b];\n\n        for (var _d = 0, _e = terminals(RIGHT); _d < _e.length; _d++) {\n          var right = _e[_d];\n          all.push(ContextKeyExpr.and(left, right));\n        }\n      }\n\n      result.unshift(ContextKeyExpr.or.apply(ContextKeyExpr, all));\n    }\n\n    return result[0];\n  };\n\n  return ContextKeyOrExpr;\n}();\n\nexport { ContextKeyOrExpr };\n\nvar RawContextKey =\n/** @class */\nfunction (_super) {\n  __extends(RawContextKey, _super);\n\n  function RawContextKey(key, defaultValue) {\n    var _this = _super.call(this, key) || this;\n\n    _this._defaultValue = defaultValue;\n    return _this;\n  }\n\n  RawContextKey.prototype.bindTo = function (target) {\n    return target.createKey(this.key, this._defaultValue);\n  };\n\n  RawContextKey.prototype.getValue = function (target) {\n    return target.getContextKeyValue(this.key);\n  };\n\n  RawContextKey.prototype.toNegated = function () {\n    return ContextKeyExpr.not(this.key);\n  };\n\n  return RawContextKey;\n}(ContextKeyDefinedExpr);\n\nexport { RawContextKey };\nexport var IContextKeyService = createDecorator('contextKeyService');\nexport var SET_CONTEXT_COMMAND_ID = 'setContext';","map":null,"metadata":{},"sourceType":"module"}