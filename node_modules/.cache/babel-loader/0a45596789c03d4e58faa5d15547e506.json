{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { getOrDefault } from '../../../common/objects.js';\nimport { dispose, Disposable, toDisposable } from '../../../common/lifecycle.js';\nimport { Gesture, EventType as TouchEventType } from '../../touch.js';\nimport * as DOM from '../../dom.js';\nimport { Event, Emitter } from '../../../common/event.js';\nimport { domEvent } from '../../event.js';\nimport { ScrollableElement } from '../scrollbar/scrollableElement.js';\nimport { RangeMap, shift } from './rangeMap.js';\nimport { RowCache } from './rowCache.js';\nimport { isWindows } from '../../../common/platform.js';\nimport * as browser from '../../browser.js';\nimport { memoize } from '../../../common/decorators.js';\nimport { Range } from '../../../common/range.js';\nimport { equals, distinct } from '../../../common/arrays.js';\nimport { DataTransfers, StaticDND } from '../../dnd.js';\nimport { disposableTimeout, Delayer } from '../../../common/async.js';\nvar DefaultOptions = {\n  useShadows: true,\n  verticalScrollMode: 1\n  /* Auto */\n  ,\n  setRowLineHeight: true,\n  supportDynamicHeights: false,\n  dnd: {\n    getDragElements: function (e) {\n      return [e];\n    },\n    getDragURI: function () {\n      return null;\n    },\n    onDragStart: function () {},\n    onDragOver: function () {\n      return false;\n    },\n    drop: function () {}\n  },\n  horizontalScrolling: false\n};\n\nvar ElementsDragAndDropData =\n/** @class */\nfunction () {\n  function ElementsDragAndDropData(elements) {\n    this.elements = elements;\n  }\n\n  ElementsDragAndDropData.prototype.update = function () {};\n\n  ElementsDragAndDropData.prototype.getData = function () {\n    return this.elements;\n  };\n\n  return ElementsDragAndDropData;\n}();\n\nexport { ElementsDragAndDropData };\n\nvar ExternalElementsDragAndDropData =\n/** @class */\nfunction () {\n  function ExternalElementsDragAndDropData(elements) {\n    this.elements = elements;\n  }\n\n  ExternalElementsDragAndDropData.prototype.update = function () {};\n\n  ExternalElementsDragAndDropData.prototype.getData = function () {\n    return this.elements;\n  };\n\n  return ExternalElementsDragAndDropData;\n}();\n\nexport { ExternalElementsDragAndDropData };\n\nvar DesktopDragAndDropData =\n/** @class */\nfunction () {\n  function DesktopDragAndDropData() {\n    this.types = [];\n    this.files = [];\n  }\n\n  DesktopDragAndDropData.prototype.update = function (dataTransfer) {\n    var _a;\n\n    if (dataTransfer.types) {\n      (_a = this.types).splice.apply(_a, [0, this.types.length].concat(dataTransfer.types));\n    }\n\n    if (dataTransfer.files) {\n      this.files.splice(0, this.files.length);\n\n      for (var i = 0; i < dataTransfer.files.length; i++) {\n        var file = dataTransfer.files.item(i);\n\n        if (file && (file.size || file.type)) {\n          this.files.push(file);\n        }\n      }\n    }\n  };\n\n  DesktopDragAndDropData.prototype.getData = function () {\n    return {\n      types: this.types,\n      files: this.files\n    };\n  };\n\n  return DesktopDragAndDropData;\n}();\n\nexport { DesktopDragAndDropData };\n\nfunction equalsDragFeedback(f1, f2) {\n  if (Array.isArray(f1) && Array.isArray(f2)) {\n    return equals(f1, f2);\n  }\n\n  return f1 === f2;\n}\n\nvar ListView =\n/** @class */\nfunction () {\n  function ListView(container, virtualDelegate, renderers, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = DefaultOptions;\n    }\n\n    this.virtualDelegate = virtualDelegate;\n    this.domId = \"list_id_\" + ++ListView.InstanceCount;\n    this.renderers = new Map();\n    this.renderWidth = 0;\n    this._scrollHeight = 0;\n    this.scrollableElementUpdateDisposable = null;\n    this.scrollableElementWidthDelayer = new Delayer(50);\n    this.splicing = false;\n    this.dragOverAnimationStopDisposable = Disposable.None;\n    this.dragOverMouseY = 0;\n    this.canUseTranslate3d = undefined;\n    this.canDrop = false;\n    this.currentDragFeedbackDisposable = Disposable.None;\n    this.onDragLeaveTimeout = Disposable.None;\n    this._onDidChangeContentHeight = new Emitter();\n\n    if (options.horizontalScrolling && options.supportDynamicHeights) {\n      throw new Error('Horizontal scrolling and dynamic heights not supported simultaneously');\n    }\n\n    this.items = [];\n    this.itemId = 0;\n    this.rangeMap = new RangeMap();\n\n    for (var _i = 0, renderers_1 = renderers; _i < renderers_1.length; _i++) {\n      var renderer = renderers_1[_i];\n      this.renderers.set(renderer.templateId, renderer);\n    }\n\n    this.cache = new RowCache(this.renderers);\n    this.lastRenderTop = 0;\n    this.lastRenderHeight = 0;\n    this.domNode = document.createElement('div');\n    this.domNode.className = 'monaco-list';\n    DOM.addClass(this.domNode, this.domId);\n    this.domNode.tabIndex = 0;\n    DOM.toggleClass(this.domNode, 'mouse-support', typeof options.mouseSupport === 'boolean' ? options.mouseSupport : true);\n    this.horizontalScrolling = getOrDefault(options, function (o) {\n      return o.horizontalScrolling;\n    }, DefaultOptions.horizontalScrolling);\n    DOM.toggleClass(this.domNode, 'horizontal-scrolling', this.horizontalScrolling);\n    this.additionalScrollHeight = typeof options.additionalScrollHeight === 'undefined' ? 0 : options.additionalScrollHeight;\n    this.ariaProvider = options.ariaProvider || {\n      getSetSize: function (e, i, length) {\n        return length;\n      },\n      getPosInSet: function (_, index) {\n        return index + 1;\n      }\n    };\n    this.rowsContainer = document.createElement('div');\n    this.rowsContainer.className = 'monaco-list-rows';\n    Gesture.addTarget(this.rowsContainer);\n    this.scrollableElement = new ScrollableElement(this.rowsContainer, {\n      alwaysConsumeMouseWheel: true,\n      horizontal: this.horizontalScrolling ? 1\n      /* Auto */\n      : 2\n      /* Hidden */\n      ,\n      vertical: getOrDefault(options, function (o) {\n        return o.verticalScrollMode;\n      }, DefaultOptions.verticalScrollMode),\n      useShadows: getOrDefault(options, function (o) {\n        return o.useShadows;\n      }, DefaultOptions.useShadows)\n    });\n    this.domNode.appendChild(this.scrollableElement.getDomNode());\n    container.appendChild(this.domNode);\n    this.disposables = [this.rangeMap, this.scrollableElement, this.cache];\n    this.scrollableElement.onScroll(this.onScroll, this, this.disposables);\n    domEvent(this.rowsContainer, TouchEventType.Change)(this.onTouchChange, this, this.disposables); // Prevent the monaco-scrollable-element from scrolling\n    // https://github.com/Microsoft/vscode/issues/44181\n\n    domEvent(this.scrollableElement.getDomNode(), 'scroll')(function (e) {\n      return e.target.scrollTop = 0;\n    }, null, this.disposables);\n    Event.map(domEvent(this.domNode, 'dragover'), function (e) {\n      return _this.toDragEvent(e);\n    })(this.onDragOver, this, this.disposables);\n    Event.map(domEvent(this.domNode, 'drop'), function (e) {\n      return _this.toDragEvent(e);\n    })(this.onDrop, this, this.disposables);\n    domEvent(this.domNode, 'dragleave')(this.onDragLeave, this, this.disposables);\n    domEvent(window, 'dragend')(this.onDragEnd, this, this.disposables);\n    this.setRowLineHeight = getOrDefault(options, function (o) {\n      return o.setRowLineHeight;\n    }, DefaultOptions.setRowLineHeight);\n    this.supportDynamicHeights = getOrDefault(options, function (o) {\n      return o.supportDynamicHeights;\n    }, DefaultOptions.supportDynamicHeights);\n    this.dnd = getOrDefault(options, function (o) {\n      return o.dnd;\n    }, DefaultOptions.dnd);\n    this.layout();\n  }\n\n  Object.defineProperty(ListView.prototype, \"contentHeight\", {\n    get: function () {\n      return this.rangeMap.size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ListView.prototype.splice = function (start, deleteCount, elements) {\n    if (elements === void 0) {\n      elements = [];\n    }\n\n    if (this.splicing) {\n      throw new Error('Can\\'t run recursive splices.');\n    }\n\n    this.splicing = true;\n\n    try {\n      return this._splice(start, deleteCount, elements);\n    } finally {\n      this.splicing = false;\n\n      this._onDidChangeContentHeight.fire(this.contentHeight);\n    }\n  };\n\n  ListView.prototype._splice = function (start, deleteCount, elements) {\n    var _a;\n\n    var _this = this;\n\n    if (elements === void 0) {\n      elements = [];\n    }\n\n    var previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);\n    var deleteRange = {\n      start: start,\n      end: start + deleteCount\n    };\n    var removeRange = Range.intersect(previousRenderRange, deleteRange);\n\n    for (var i = removeRange.start; i < removeRange.end; i++) {\n      this.removeItemFromDOM(i);\n    }\n\n    var previousRestRange = {\n      start: start + deleteCount,\n      end: this.items.length\n    };\n    var previousRenderedRestRange = Range.intersect(previousRestRange, previousRenderRange);\n    var previousUnrenderedRestRanges = Range.relativeComplement(previousRestRange, previousRenderRange);\n    var inserted = elements.map(function (element) {\n      return {\n        id: String(_this.itemId++),\n        element: element,\n        templateId: _this.virtualDelegate.getTemplateId(element),\n        size: _this.virtualDelegate.getHeight(element),\n        width: undefined,\n        hasDynamicHeight: !!_this.virtualDelegate.hasDynamicHeight && _this.virtualDelegate.hasDynamicHeight(element),\n        lastDynamicHeightWidth: undefined,\n        row: null,\n        uri: undefined,\n        dropTarget: false,\n        dragStartDisposable: Disposable.None\n      };\n    });\n    var deleted; // TODO@joao: improve this optimization to catch even more cases\n\n    if (start === 0 && deleteCount >= this.items.length) {\n      this.rangeMap = new RangeMap();\n      this.rangeMap.splice(0, 0, inserted);\n      this.items = inserted;\n      deleted = [];\n    } else {\n      this.rangeMap.splice(start, deleteCount, inserted);\n      deleted = (_a = this.items).splice.apply(_a, [start, deleteCount].concat(inserted));\n    }\n\n    var delta = elements.length - deleteCount;\n    var renderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);\n    var renderedRestRange = shift(previousRenderedRestRange, delta);\n    var updateRange = Range.intersect(renderRange, renderedRestRange);\n\n    for (var i = updateRange.start; i < updateRange.end; i++) {\n      this.updateItemInDOM(this.items[i], i);\n    }\n\n    var removeRanges = Range.relativeComplement(renderedRestRange, renderRange);\n\n    for (var _i = 0, removeRanges_1 = removeRanges; _i < removeRanges_1.length; _i++) {\n      var range = removeRanges_1[_i];\n\n      for (var i = range.start; i < range.end; i++) {\n        this.removeItemFromDOM(i);\n      }\n    }\n\n    var unrenderedRestRanges = previousUnrenderedRestRanges.map(function (r) {\n      return shift(r, delta);\n    });\n    var elementsRange = {\n      start: start,\n      end: start + elements.length\n    };\n    var insertRanges = [elementsRange].concat(unrenderedRestRanges).map(function (r) {\n      return Range.intersect(renderRange, r);\n    });\n    var beforeElement = this.getNextToLastElement(insertRanges);\n\n    for (var _b = 0, insertRanges_1 = insertRanges; _b < insertRanges_1.length; _b++) {\n      var range = insertRanges_1[_b];\n\n      for (var i = range.start; i < range.end; i++) {\n        this.insertItemInDOM(i, beforeElement);\n      }\n    }\n\n    this.eventuallyUpdateScrollDimensions();\n\n    if (this.supportDynamicHeights) {\n      this._rerender(this.scrollTop, this.renderHeight);\n    }\n\n    return deleted.map(function (i) {\n      return i.element;\n    });\n  };\n\n  ListView.prototype.eventuallyUpdateScrollDimensions = function () {\n    var _this = this;\n\n    this._scrollHeight = this.contentHeight;\n    this.rowsContainer.style.height = this._scrollHeight + \"px\";\n\n    if (!this.scrollableElementUpdateDisposable) {\n      this.scrollableElementUpdateDisposable = DOM.scheduleAtNextAnimationFrame(function () {\n        _this.scrollableElement.setScrollDimensions({\n          scrollHeight: _this.scrollHeight\n        });\n\n        _this.updateScrollWidth();\n\n        _this.scrollableElementUpdateDisposable = null;\n      });\n    }\n  };\n\n  ListView.prototype.eventuallyUpdateScrollWidth = function () {\n    var _this = this;\n\n    if (!this.horizontalScrolling) {\n      return;\n    }\n\n    this.scrollableElementWidthDelayer.trigger(function () {\n      return _this.updateScrollWidth();\n    });\n  };\n\n  ListView.prototype.updateScrollWidth = function () {\n    if (!this.horizontalScrolling) {\n      return;\n    }\n\n    if (this.items.length === 0) {\n      this.scrollableElement.setScrollDimensions({\n        scrollWidth: 0\n      });\n    }\n\n    var scrollWidth = 0;\n\n    for (var _i = 0, _a = this.items; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      if (typeof item.width !== 'undefined') {\n        scrollWidth = Math.max(scrollWidth, item.width);\n      }\n    }\n\n    this.scrollWidth = scrollWidth;\n    this.scrollableElement.setScrollDimensions({\n      scrollWidth: scrollWidth + 10\n    });\n  };\n\n  ListView.prototype.rerender = function () {\n    if (!this.supportDynamicHeights) {\n      return;\n    }\n\n    for (var _i = 0, _a = this.items; _i < _a.length; _i++) {\n      var item = _a[_i];\n      item.lastDynamicHeightWidth = undefined;\n    }\n\n    this._rerender(this.lastRenderTop, this.lastRenderHeight);\n  };\n\n  Object.defineProperty(ListView.prototype, \"length\", {\n    get: function () {\n      return this.items.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ListView.prototype, \"renderHeight\", {\n    get: function () {\n      var scrollDimensions = this.scrollableElement.getScrollDimensions();\n      return scrollDimensions.height;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ListView.prototype.element = function (index) {\n    return this.items[index].element;\n  };\n\n  ListView.prototype.domElement = function (index) {\n    var row = this.items[index].row;\n    return row && row.domNode;\n  };\n\n  ListView.prototype.elementHeight = function (index) {\n    return this.items[index].size;\n  };\n\n  ListView.prototype.elementTop = function (index) {\n    return this.rangeMap.positionAt(index);\n  };\n\n  ListView.prototype.indexAt = function (position) {\n    return this.rangeMap.indexAt(position);\n  };\n\n  ListView.prototype.indexAfter = function (position) {\n    return this.rangeMap.indexAfter(position);\n  };\n\n  ListView.prototype.layout = function (height, width) {\n    var scrollDimensions = {\n      height: typeof height === 'number' ? height : DOM.getContentHeight(this.domNode)\n    };\n\n    if (this.scrollableElementUpdateDisposable) {\n      this.scrollableElementUpdateDisposable.dispose();\n      this.scrollableElementUpdateDisposable = null;\n      scrollDimensions.scrollHeight = this.scrollHeight;\n    }\n\n    this.scrollableElement.setScrollDimensions(scrollDimensions);\n\n    if (typeof width !== 'undefined') {\n      this.renderWidth = width;\n\n      if (this.supportDynamicHeights) {\n        this._rerender(this.scrollTop, this.renderHeight);\n      }\n\n      if (this.horizontalScrolling) {\n        this.scrollableElement.setScrollDimensions({\n          width: typeof width === 'number' ? width : DOM.getContentWidth(this.domNode)\n        });\n      }\n    }\n  }; // Render\n\n\n  ListView.prototype.render = function (renderTop, renderHeight, renderLeft, scrollWidth) {\n    var previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);\n    var renderRange = this.getRenderRange(renderTop, renderHeight);\n    var rangesToInsert = Range.relativeComplement(renderRange, previousRenderRange);\n    var rangesToRemove = Range.relativeComplement(previousRenderRange, renderRange);\n    var beforeElement = this.getNextToLastElement(rangesToInsert);\n\n    for (var _i = 0, rangesToInsert_1 = rangesToInsert; _i < rangesToInsert_1.length; _i++) {\n      var range = rangesToInsert_1[_i];\n\n      for (var i = range.start; i < range.end; i++) {\n        this.insertItemInDOM(i, beforeElement);\n      }\n    }\n\n    for (var _a = 0, rangesToRemove_1 = rangesToRemove; _a < rangesToRemove_1.length; _a++) {\n      var range = rangesToRemove_1[_a];\n\n      for (var i = range.start; i < range.end; i++) {\n        this.removeItemFromDOM(i);\n      }\n    }\n\n    var canUseTranslate3d = !isWindows && !browser.isFirefox && browser.getZoomLevel() === 0;\n\n    if (canUseTranslate3d) {\n      var transform = \"translate3d(-\" + renderLeft + \"px, -\" + renderTop + \"px, 0px)\";\n      this.rowsContainer.style.transform = transform;\n      this.rowsContainer.style.webkitTransform = transform;\n\n      if (canUseTranslate3d !== this.canUseTranslate3d) {\n        this.rowsContainer.style.left = '0';\n        this.rowsContainer.style.top = '0';\n      }\n    } else {\n      this.rowsContainer.style.left = \"-\" + renderLeft + \"px\";\n      this.rowsContainer.style.top = \"-\" + renderTop + \"px\";\n\n      if (canUseTranslate3d !== this.canUseTranslate3d) {\n        this.rowsContainer.style.transform = '';\n        this.rowsContainer.style.webkitTransform = '';\n      }\n    }\n\n    if (this.horizontalScrolling) {\n      this.rowsContainer.style.width = Math.max(scrollWidth, this.renderWidth) + \"px\";\n    }\n\n    this.canUseTranslate3d = canUseTranslate3d;\n    this.lastRenderTop = renderTop;\n    this.lastRenderHeight = renderHeight;\n  }; // DOM operations\n\n\n  ListView.prototype.insertItemInDOM = function (index, beforeElement) {\n    var _this = this;\n\n    var item = this.items[index];\n\n    if (!item.row) {\n      item.row = this.cache.alloc(item.templateId);\n      var role = this.ariaProvider.getRole ? this.ariaProvider.getRole(item.element) : 'treeitem';\n      item.row.domNode.setAttribute('role', role);\n      var checked = this.ariaProvider.isChecked ? this.ariaProvider.isChecked(item.element) : undefined;\n\n      if (typeof checked !== 'undefined') {\n        item.row.domNode.setAttribute('aria-checked', String(checked));\n      }\n    }\n\n    if (!item.row.domNode.parentElement) {\n      if (beforeElement) {\n        this.rowsContainer.insertBefore(item.row.domNode, beforeElement);\n      } else {\n        this.rowsContainer.appendChild(item.row.domNode);\n      }\n    }\n\n    this.updateItemInDOM(item, index);\n    var renderer = this.renderers.get(item.templateId);\n\n    if (!renderer) {\n      throw new Error(\"No renderer found for template id \" + item.templateId);\n    }\n\n    if (renderer) {\n      renderer.renderElement(item.element, index, item.row.templateData, item.size);\n    }\n\n    var uri = this.dnd.getDragURI(item.element);\n    item.dragStartDisposable.dispose();\n    item.row.domNode.draggable = !!uri;\n\n    if (uri) {\n      var onDragStart = domEvent(item.row.domNode, 'dragstart');\n      item.dragStartDisposable = onDragStart(function (event) {\n        return _this.onDragStart(item.element, uri, event);\n      });\n    }\n\n    if (this.horizontalScrolling) {\n      this.measureItemWidth(item);\n      this.eventuallyUpdateScrollWidth();\n    }\n  };\n\n  ListView.prototype.measureItemWidth = function (item) {\n    if (!item.row || !item.row.domNode) {\n      return;\n    }\n\n    item.row.domNode.style.width = 'fit-content';\n    item.width = DOM.getContentWidth(item.row.domNode);\n    var style = window.getComputedStyle(item.row.domNode);\n\n    if (style.paddingLeft) {\n      item.width += parseFloat(style.paddingLeft);\n    }\n\n    if (style.paddingRight) {\n      item.width += parseFloat(style.paddingRight);\n    }\n\n    item.row.domNode.style.width = '';\n  };\n\n  ListView.prototype.updateItemInDOM = function (item, index) {\n    item.row.domNode.style.top = this.elementTop(index) + \"px\";\n    item.row.domNode.style.height = item.size + \"px\";\n\n    if (this.setRowLineHeight) {\n      item.row.domNode.style.lineHeight = item.size + \"px\";\n    }\n\n    item.row.domNode.setAttribute('data-index', \"\" + index);\n    item.row.domNode.setAttribute('data-last-element', index === this.length - 1 ? 'true' : 'false');\n    item.row.domNode.setAttribute('aria-setsize', String(this.ariaProvider.getSetSize(item.element, index, this.length)));\n    item.row.domNode.setAttribute('aria-posinset', String(this.ariaProvider.getPosInSet(item.element, index)));\n    item.row.domNode.setAttribute('id', this.getElementDomId(index));\n    DOM.toggleClass(item.row.domNode, 'drop-target', item.dropTarget);\n  };\n\n  ListView.prototype.removeItemFromDOM = function (index) {\n    var item = this.items[index];\n    item.dragStartDisposable.dispose();\n    var renderer = this.renderers.get(item.templateId);\n\n    if (renderer && renderer.disposeElement) {\n      renderer.disposeElement(item.element, index, item.row.templateData, item.size);\n    }\n\n    this.cache.release(item.row);\n    item.row = null;\n\n    if (this.horizontalScrolling) {\n      this.eventuallyUpdateScrollWidth();\n    }\n  };\n\n  ListView.prototype.getScrollTop = function () {\n    var scrollPosition = this.scrollableElement.getScrollPosition();\n    return scrollPosition.scrollTop;\n  };\n\n  ListView.prototype.setScrollTop = function (scrollTop) {\n    if (this.scrollableElementUpdateDisposable) {\n      this.scrollableElementUpdateDisposable.dispose();\n      this.scrollableElementUpdateDisposable = null;\n      this.scrollableElement.setScrollDimensions({\n        scrollHeight: this.scrollHeight\n      });\n    }\n\n    this.scrollableElement.setScrollPosition({\n      scrollTop: scrollTop\n    });\n  };\n\n  Object.defineProperty(ListView.prototype, \"scrollTop\", {\n    get: function () {\n      return this.getScrollTop();\n    },\n    set: function (scrollTop) {\n      this.setScrollTop(scrollTop);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ListView.prototype, \"scrollHeight\", {\n    get: function () {\n      return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.additionalScrollHeight;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ListView.prototype, \"onMouseClick\", {\n    // Events\n    get: function () {\n      var _this = this;\n\n      return Event.map(domEvent(this.domNode, 'click'), function (e) {\n        return _this.toMouseEvent(e);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ListView.prototype, \"onMouseDblClick\", {\n    get: function () {\n      var _this = this;\n\n      return Event.map(domEvent(this.domNode, 'dblclick'), function (e) {\n        return _this.toMouseEvent(e);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ListView.prototype, \"onMouseMiddleClick\", {\n    get: function () {\n      var _this = this;\n\n      return Event.filter(Event.map(domEvent(this.domNode, 'auxclick'), function (e) {\n        return _this.toMouseEvent(e);\n      }), function (e) {\n        return e.browserEvent.button === 1;\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ListView.prototype, \"onMouseDown\", {\n    get: function () {\n      var _this = this;\n\n      return Event.map(domEvent(this.domNode, 'mousedown'), function (e) {\n        return _this.toMouseEvent(e);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ListView.prototype, \"onContextMenu\", {\n    get: function () {\n      var _this = this;\n\n      return Event.map(domEvent(this.domNode, 'contextmenu'), function (e) {\n        return _this.toMouseEvent(e);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ListView.prototype, \"onTouchStart\", {\n    get: function () {\n      var _this = this;\n\n      return Event.map(domEvent(this.domNode, 'touchstart'), function (e) {\n        return _this.toTouchEvent(e);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ListView.prototype, \"onTap\", {\n    get: function () {\n      var _this = this;\n\n      return Event.map(domEvent(this.rowsContainer, TouchEventType.Tap), function (e) {\n        return _this.toGestureEvent(e);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ListView.prototype.toMouseEvent = function (browserEvent) {\n    var index = this.getItemIndexFromEventTarget(browserEvent.target || null);\n    var item = typeof index === 'undefined' ? undefined : this.items[index];\n    var element = item && item.element;\n    return {\n      browserEvent: browserEvent,\n      index: index,\n      element: element\n    };\n  };\n\n  ListView.prototype.toTouchEvent = function (browserEvent) {\n    var index = this.getItemIndexFromEventTarget(browserEvent.target || null);\n    var item = typeof index === 'undefined' ? undefined : this.items[index];\n    var element = item && item.element;\n    return {\n      browserEvent: browserEvent,\n      index: index,\n      element: element\n    };\n  };\n\n  ListView.prototype.toGestureEvent = function (browserEvent) {\n    var index = this.getItemIndexFromEventTarget(browserEvent.initialTarget || null);\n    var item = typeof index === 'undefined' ? undefined : this.items[index];\n    var element = item && item.element;\n    return {\n      browserEvent: browserEvent,\n      index: index,\n      element: element\n    };\n  };\n\n  ListView.prototype.toDragEvent = function (browserEvent) {\n    var index = this.getItemIndexFromEventTarget(browserEvent.target || null);\n    var item = typeof index === 'undefined' ? undefined : this.items[index];\n    var element = item && item.element;\n    return {\n      browserEvent: browserEvent,\n      index: index,\n      element: element\n    };\n  };\n\n  ListView.prototype.onScroll = function (e) {\n    try {\n      this.render(e.scrollTop, e.height, e.scrollLeft, e.scrollWidth);\n\n      if (this.supportDynamicHeights) {\n        this._rerender(e.scrollTop, e.height);\n      }\n    } catch (err) {\n      console.error('Got bad scroll event:', e);\n      throw err;\n    }\n  };\n\n  ListView.prototype.onTouchChange = function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    this.scrollTop -= event.translationY;\n  }; // DND\n\n\n  ListView.prototype.onDragStart = function (element, uri, event) {\n    if (!event.dataTransfer) {\n      return;\n    }\n\n    var elements = this.dnd.getDragElements(element);\n    event.dataTransfer.effectAllowed = 'copyMove';\n    event.dataTransfer.setData(DataTransfers.RESOURCES, JSON.stringify([uri]));\n\n    if (event.dataTransfer.setDragImage) {\n      var label = void 0;\n\n      if (this.dnd.getDragLabel) {\n        label = this.dnd.getDragLabel(elements);\n      }\n\n      if (typeof label === 'undefined') {\n        label = String(elements.length);\n      }\n\n      var dragImage_1 = DOM.$('.monaco-drag-image');\n      dragImage_1.textContent = label;\n      document.body.appendChild(dragImage_1);\n      event.dataTransfer.setDragImage(dragImage_1, -10, -10);\n      setTimeout(function () {\n        return document.body.removeChild(dragImage_1);\n      }, 0);\n    }\n\n    this.currentDragData = new ElementsDragAndDropData(elements);\n    StaticDND.CurrentDragAndDropData = new ExternalElementsDragAndDropData(elements);\n\n    if (this.dnd.onDragStart) {\n      this.dnd.onDragStart(this.currentDragData, event);\n    }\n  };\n\n  ListView.prototype.onDragOver = function (event) {\n    var _this = this;\n\n    event.browserEvent.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)\n\n    this.onDragLeaveTimeout.dispose();\n\n    if (StaticDND.CurrentDragAndDropData && StaticDND.CurrentDragAndDropData.getData() === 'vscode-ui') {\n      return false;\n    }\n\n    this.setupDragAndDropScrollTopAnimation(event.browserEvent);\n\n    if (!event.browserEvent.dataTransfer) {\n      return false;\n    } // Drag over from outside\n\n\n    if (!this.currentDragData) {\n      if (StaticDND.CurrentDragAndDropData) {\n        // Drag over from another list\n        this.currentDragData = StaticDND.CurrentDragAndDropData;\n      } else {\n        // Drag over from the desktop\n        if (!event.browserEvent.dataTransfer.types) {\n          return false;\n        }\n\n        this.currentDragData = new DesktopDragAndDropData();\n      }\n    }\n\n    var result = this.dnd.onDragOver(this.currentDragData, event.element, event.index, event.browserEvent);\n    this.canDrop = typeof result === 'boolean' ? result : result.accept;\n\n    if (!this.canDrop) {\n      this.currentDragFeedback = undefined;\n      this.currentDragFeedbackDisposable.dispose();\n      return false;\n    }\n\n    event.browserEvent.dataTransfer.dropEffect = typeof result !== 'boolean' && result.effect === 0\n    /* Copy */\n    ? 'copy' : 'move';\n    var feedback;\n\n    if (typeof result !== 'boolean' && result.feedback) {\n      feedback = result.feedback;\n    } else {\n      if (typeof event.index === 'undefined') {\n        feedback = [-1];\n      } else {\n        feedback = [event.index];\n      }\n    } // sanitize feedback list\n\n\n    feedback = distinct(feedback).filter(function (i) {\n      return i >= -1 && i < _this.length;\n    }).sort();\n    feedback = feedback[0] === -1 ? [-1] : feedback;\n\n    if (feedback.length === 0) {\n      throw new Error('Invalid empty feedback list');\n    }\n\n    if (equalsDragFeedback(this.currentDragFeedback, feedback)) {\n      return true;\n    }\n\n    this.currentDragFeedback = feedback;\n    this.currentDragFeedbackDisposable.dispose();\n\n    if (feedback[0] === -1) {\n      // entire list feedback\n      DOM.addClass(this.domNode, 'drop-target');\n      this.currentDragFeedbackDisposable = toDisposable(function () {\n        return DOM.removeClass(_this.domNode, 'drop-target');\n      });\n    } else {\n      for (var _i = 0, feedback_1 = feedback; _i < feedback_1.length; _i++) {\n        var index = feedback_1[_i];\n        var item = this.items[index];\n        item.dropTarget = true;\n\n        if (item.row && item.row.domNode) {\n          DOM.addClass(item.row.domNode, 'drop-target');\n        }\n      }\n\n      this.currentDragFeedbackDisposable = toDisposable(function () {\n        for (var _i = 0, feedback_2 = feedback; _i < feedback_2.length; _i++) {\n          var index = feedback_2[_i];\n          var item = _this.items[index];\n          item.dropTarget = false;\n\n          if (item.row && item.row.domNode) {\n            DOM.removeClass(item.row.domNode, 'drop-target');\n          }\n        }\n      });\n    }\n\n    return true;\n  };\n\n  ListView.prototype.onDragLeave = function () {\n    var _this = this;\n\n    this.onDragLeaveTimeout.dispose();\n    this.onDragLeaveTimeout = disposableTimeout(function () {\n      return _this.clearDragOverFeedback();\n    }, 100);\n  };\n\n  ListView.prototype.onDrop = function (event) {\n    if (!this.canDrop) {\n      return;\n    }\n\n    var dragData = this.currentDragData;\n    this.teardownDragAndDropScrollTopAnimation();\n    this.clearDragOverFeedback();\n    this.currentDragData = undefined;\n    StaticDND.CurrentDragAndDropData = undefined;\n\n    if (!dragData || !event.browserEvent.dataTransfer) {\n      return;\n    }\n\n    event.browserEvent.preventDefault();\n    dragData.update(event.browserEvent.dataTransfer);\n    this.dnd.drop(dragData, event.element, event.index, event.browserEvent);\n  };\n\n  ListView.prototype.onDragEnd = function () {\n    this.canDrop = false;\n    this.teardownDragAndDropScrollTopAnimation();\n    this.clearDragOverFeedback();\n    this.currentDragData = undefined;\n    StaticDND.CurrentDragAndDropData = undefined;\n  };\n\n  ListView.prototype.clearDragOverFeedback = function () {\n    this.currentDragFeedback = undefined;\n    this.currentDragFeedbackDisposable.dispose();\n    this.currentDragFeedbackDisposable = Disposable.None;\n  }; // DND scroll top animation\n\n\n  ListView.prototype.setupDragAndDropScrollTopAnimation = function (event) {\n    var _this = this;\n\n    if (!this.dragOverAnimationDisposable) {\n      var viewTop = DOM.getTopLeftOffset(this.domNode).top;\n      this.dragOverAnimationDisposable = DOM.animate(this.animateDragAndDropScrollTop.bind(this, viewTop));\n    }\n\n    this.dragOverAnimationStopDisposable.dispose();\n    this.dragOverAnimationStopDisposable = disposableTimeout(function () {\n      if (_this.dragOverAnimationDisposable) {\n        _this.dragOverAnimationDisposable.dispose();\n\n        _this.dragOverAnimationDisposable = undefined;\n      }\n    }, 1000);\n    this.dragOverMouseY = event.pageY;\n  };\n\n  ListView.prototype.animateDragAndDropScrollTop = function (viewTop) {\n    if (this.dragOverMouseY === undefined) {\n      return;\n    }\n\n    var diff = this.dragOverMouseY - viewTop;\n    var upperLimit = this.renderHeight - 35;\n\n    if (diff < 35) {\n      this.scrollTop += Math.max(-14, Math.floor(0.3 * (diff - 35)));\n    } else if (diff > upperLimit) {\n      this.scrollTop += Math.min(14, Math.floor(0.3 * (diff - upperLimit)));\n    }\n  };\n\n  ListView.prototype.teardownDragAndDropScrollTopAnimation = function () {\n    this.dragOverAnimationStopDisposable.dispose();\n\n    if (this.dragOverAnimationDisposable) {\n      this.dragOverAnimationDisposable.dispose();\n      this.dragOverAnimationDisposable = undefined;\n    }\n  }; // Util\n\n\n  ListView.prototype.getItemIndexFromEventTarget = function (target) {\n    var element = target;\n\n    while (element instanceof HTMLElement && element !== this.rowsContainer) {\n      var rawIndex = element.getAttribute('data-index');\n\n      if (rawIndex) {\n        var index = Number(rawIndex);\n\n        if (!isNaN(index)) {\n          return index;\n        }\n      }\n\n      element = element.parentElement;\n    }\n\n    return undefined;\n  };\n\n  ListView.prototype.getRenderRange = function (renderTop, renderHeight) {\n    return {\n      start: this.rangeMap.indexAt(renderTop),\n      end: this.rangeMap.indexAfter(renderTop + renderHeight - 1)\n    };\n  };\n  /**\n   * Given a stable rendered state, checks every rendered element whether it needs\n   * to be probed for dynamic height. Adjusts scroll height and top if necessary.\n   */\n\n\n  ListView.prototype._rerender = function (renderTop, renderHeight) {\n    var previousRenderRange = this.getRenderRange(renderTop, renderHeight); // Let's remember the second element's position, this helps in scrolling up\n    // and preserving a linear upwards scroll movement\n\n    var anchorElementIndex;\n    var anchorElementTopDelta;\n\n    if (renderTop === this.elementTop(previousRenderRange.start)) {\n      anchorElementIndex = previousRenderRange.start;\n      anchorElementTopDelta = 0;\n    } else if (previousRenderRange.end - previousRenderRange.start > 1) {\n      anchorElementIndex = previousRenderRange.start + 1;\n      anchorElementTopDelta = this.elementTop(anchorElementIndex) - renderTop;\n    }\n\n    var heightDiff = 0;\n\n    while (true) {\n      var renderRange = this.getRenderRange(renderTop, renderHeight);\n      var didChange = false;\n\n      for (var i = renderRange.start; i < renderRange.end; i++) {\n        var diff = this.probeDynamicHeight(i);\n\n        if (diff !== 0) {\n          this.rangeMap.splice(i, 1, [this.items[i]]);\n        }\n\n        heightDiff += diff;\n        didChange = didChange || diff !== 0;\n      }\n\n      if (!didChange) {\n        if (heightDiff !== 0) {\n          this.eventuallyUpdateScrollDimensions();\n        }\n\n        var unrenderRanges = Range.relativeComplement(previousRenderRange, renderRange);\n\n        for (var _i = 0, unrenderRanges_1 = unrenderRanges; _i < unrenderRanges_1.length; _i++) {\n          var range = unrenderRanges_1[_i];\n\n          for (var i = range.start; i < range.end; i++) {\n            if (this.items[i].row) {\n              this.removeItemFromDOM(i);\n            }\n          }\n        }\n\n        var renderRanges = Range.relativeComplement(renderRange, previousRenderRange);\n\n        for (var _a = 0, renderRanges_1 = renderRanges; _a < renderRanges_1.length; _a++) {\n          var range = renderRanges_1[_a];\n\n          for (var i = range.start; i < range.end; i++) {\n            var afterIndex = i + 1;\n            var beforeRow = afterIndex < this.items.length ? this.items[afterIndex].row : null;\n            var beforeElement = beforeRow ? beforeRow.domNode : null;\n            this.insertItemInDOM(i, beforeElement);\n          }\n        }\n\n        for (var i = renderRange.start; i < renderRange.end; i++) {\n          if (this.items[i].row) {\n            this.updateItemInDOM(this.items[i], i);\n          }\n        }\n\n        if (typeof anchorElementIndex === 'number') {\n          this.scrollTop = this.elementTop(anchorElementIndex) - anchorElementTopDelta;\n        }\n\n        this._onDidChangeContentHeight.fire(this.contentHeight);\n\n        return;\n      }\n    }\n  };\n\n  ListView.prototype.probeDynamicHeight = function (index) {\n    var item = this.items[index];\n\n    if (!item.hasDynamicHeight || item.lastDynamicHeightWidth === this.renderWidth) {\n      return 0;\n    }\n\n    var size = item.size;\n    var row = this.cache.alloc(item.templateId);\n    row.domNode.style.height = '';\n    this.rowsContainer.appendChild(row.domNode);\n    var renderer = this.renderers.get(item.templateId);\n\n    if (renderer) {\n      renderer.renderElement(item.element, index, row.templateData, undefined);\n\n      if (renderer.disposeElement) {\n        renderer.disposeElement(item.element, index, row.templateData, undefined);\n      }\n    }\n\n    item.size = row.domNode.offsetHeight;\n\n    if (this.virtualDelegate.setDynamicHeight) {\n      this.virtualDelegate.setDynamicHeight(item.element, item.size);\n    }\n\n    item.lastDynamicHeightWidth = this.renderWidth;\n    this.rowsContainer.removeChild(row.domNode);\n    this.cache.release(row);\n    return item.size - size;\n  };\n\n  ListView.prototype.getNextToLastElement = function (ranges) {\n    var lastRange = ranges[ranges.length - 1];\n\n    if (!lastRange) {\n      return null;\n    }\n\n    var nextToLastItem = this.items[lastRange.end];\n\n    if (!nextToLastItem) {\n      return null;\n    }\n\n    if (!nextToLastItem.row) {\n      return null;\n    }\n\n    return nextToLastItem.row.domNode;\n  };\n\n  ListView.prototype.getElementDomId = function (index) {\n    return this.domId + \"_\" + index;\n  }; // Dispose\n\n\n  ListView.prototype.dispose = function () {\n    if (this.items) {\n      for (var _i = 0, _a = this.items; _i < _a.length; _i++) {\n        var item = _a[_i];\n\n        if (item.row) {\n          var renderer = this.renderers.get(item.row.templateId);\n\n          if (renderer) {\n            renderer.disposeTemplate(item.row.templateData);\n          }\n        }\n      }\n\n      this.items = [];\n    }\n\n    if (this.domNode && this.domNode.parentNode) {\n      this.domNode.parentNode.removeChild(this.domNode);\n    }\n\n    this.disposables = dispose(this.disposables);\n  };\n\n  ListView.InstanceCount = 0;\n\n  __decorate([memoize], ListView.prototype, \"onMouseClick\", null);\n\n  __decorate([memoize], ListView.prototype, \"onMouseDblClick\", null);\n\n  __decorate([memoize], ListView.prototype, \"onMouseMiddleClick\", null);\n\n  __decorate([memoize], ListView.prototype, \"onMouseDown\", null);\n\n  __decorate([memoize], ListView.prototype, \"onContextMenu\", null);\n\n  __decorate([memoize], ListView.prototype, \"onTouchStart\", null);\n\n  __decorate([memoize], ListView.prototype, \"onTap\", null);\n\n  return ListView;\n}();\n\nexport { ListView };","map":null,"metadata":{},"sourceType":"module"}