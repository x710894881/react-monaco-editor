{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { RunOnceScheduler, createCancelablePromise, disposableTimeout } from '../../../base/common/async.js';\nimport { onUnexpectedError, onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { toDisposable, DisposableStore, dispose } from '../../../base/common/lifecycle.js';\nimport { StableEditorScrollState } from '../../browser/core/editorState.js';\nimport { registerEditorContribution } from '../../browser/editorExtensions.js';\nimport { CodeLensProviderRegistry } from '../../common/modes.js';\nimport { getCodeLensData } from './codelens.js';\nimport { CodeLensWidget, CodeLensHelper } from './codelensWidget.js';\nimport { ICommandService } from '../../../platform/commands/common/commands.js';\nimport { INotificationService } from '../../../platform/notification/common/notification.js';\nimport { ICodeLensCache } from './codeLensCache.js';\n\nvar CodeLensContribution =\n/** @class */\nfunction () {\n  function CodeLensContribution(_editor, _commandService, _notificationService, _codeLensCache) {\n    var _this = this;\n\n    this._editor = _editor;\n    this._commandService = _commandService;\n    this._notificationService = _notificationService;\n    this._codeLensCache = _codeLensCache;\n    this._globalToDispose = new DisposableStore();\n    this._localToDispose = new DisposableStore();\n    this._lenses = [];\n    this._oldCodeLensModels = new DisposableStore();\n    this._modelChangeCounter = 0;\n    this._isEnabled = this._editor.getConfiguration().contribInfo.codeLens;\n\n    this._globalToDispose.add(this._editor.onDidChangeModel(function () {\n      return _this._onModelChange();\n    }));\n\n    this._globalToDispose.add(this._editor.onDidChangeModelLanguage(function () {\n      return _this._onModelChange();\n    }));\n\n    this._globalToDispose.add(this._editor.onDidChangeConfiguration(function () {\n      var prevIsEnabled = _this._isEnabled;\n      _this._isEnabled = _this._editor.getConfiguration().contribInfo.codeLens;\n\n      if (prevIsEnabled !== _this._isEnabled) {\n        _this._onModelChange();\n      }\n    }));\n\n    this._globalToDispose.add(CodeLensProviderRegistry.onDidChange(this._onModelChange, this));\n\n    this._onModelChange();\n  }\n\n  CodeLensContribution.prototype.dispose = function () {\n    this._localDispose();\n\n    this._globalToDispose.dispose();\n\n    this._oldCodeLensModels.dispose();\n\n    dispose(this._currentCodeLensModel);\n  };\n\n  CodeLensContribution.prototype._localDispose = function () {\n    if (this._currentFindCodeLensSymbolsPromise) {\n      this._currentFindCodeLensSymbolsPromise.cancel();\n\n      this._currentFindCodeLensSymbolsPromise = undefined;\n      this._modelChangeCounter++;\n    }\n\n    if (this._currentResolveCodeLensSymbolsPromise) {\n      this._currentResolveCodeLensSymbolsPromise.cancel();\n\n      this._currentResolveCodeLensSymbolsPromise = undefined;\n    }\n\n    this._localToDispose.clear();\n\n    this._oldCodeLensModels.clear();\n\n    dispose(this._currentCodeLensModel);\n  };\n\n  CodeLensContribution.prototype.getId = function () {\n    return CodeLensContribution.ID;\n  };\n\n  CodeLensContribution.prototype._onModelChange = function () {\n    var _this = this;\n\n    this._localDispose();\n\n    var model = this._editor.getModel();\n\n    if (!model) {\n      return;\n    }\n\n    if (!this._isEnabled) {\n      return;\n    }\n\n    var cachedLenses = this._codeLensCache.get(model);\n\n    if (cachedLenses) {\n      this._renderCodeLensSymbols(cachedLenses);\n    }\n\n    if (!CodeLensProviderRegistry.has(model)) {\n      // no provider -> return but check with\n      // cached lenses. they expire after 30 seconds\n      if (cachedLenses) {\n        this._localToDispose.add(disposableTimeout(function () {\n          var cachedLensesNow = _this._codeLensCache.get(model);\n\n          if (cachedLenses === cachedLensesNow) {\n            _this._codeLensCache.delete(model);\n\n            _this._onModelChange();\n          }\n        }, 30 * 1000));\n      }\n\n      return;\n    }\n\n    for (var _i = 0, _a = CodeLensProviderRegistry.all(model); _i < _a.length; _i++) {\n      var provider = _a[_i];\n\n      if (typeof provider.onDidChange === 'function') {\n        var registration = provider.onDidChange(function () {\n          return scheduler.schedule();\n        });\n\n        this._localToDispose.add(registration);\n      }\n    }\n\n    var detectVisibleLenses = this._detectVisibleLenses = new RunOnceScheduler(function () {\n      return _this._onViewportChanged();\n    }, 250);\n    var scheduler = new RunOnceScheduler(function () {\n      var counterValue = ++_this._modelChangeCounter;\n\n      if (_this._currentFindCodeLensSymbolsPromise) {\n        _this._currentFindCodeLensSymbolsPromise.cancel();\n      }\n\n      _this._currentFindCodeLensSymbolsPromise = createCancelablePromise(function (token) {\n        return getCodeLensData(model, token);\n      });\n\n      _this._currentFindCodeLensSymbolsPromise.then(function (result) {\n        if (counterValue === _this._modelChangeCounter) {\n          // only the last one wins\n          if (_this._currentCodeLensModel) {\n            _this._oldCodeLensModels.add(_this._currentCodeLensModel);\n          }\n\n          _this._currentCodeLensModel = result; // cache model to reduce flicker\n\n          _this._codeLensCache.put(model, result); // render lenses\n\n\n          _this._renderCodeLensSymbols(result);\n\n          detectVisibleLenses.schedule();\n        }\n      }, onUnexpectedError);\n    }, 250);\n\n    this._localToDispose.add(scheduler);\n\n    this._localToDispose.add(detectVisibleLenses);\n\n    this._localToDispose.add(this._editor.onDidChangeModelContent(function () {\n      _this._editor.changeDecorations(function (decorationsAccessor) {\n        _this._editor.changeViewZones(function (viewZonesAccessor) {\n          var toDispose = [];\n          var lastLensLineNumber = -1;\n\n          _this._lenses.forEach(function (lens) {\n            if (!lens.isValid() || lastLensLineNumber === lens.getLineNumber()) {\n              // invalid -> lens collapsed, attach range doesn't exist anymore\n              // line_number -> lenses should never be on the same line\n              toDispose.push(lens);\n            } else {\n              lens.update(viewZonesAccessor);\n              lastLensLineNumber = lens.getLineNumber();\n            }\n          });\n\n          var helper = new CodeLensHelper();\n          toDispose.forEach(function (l) {\n            l.dispose(helper, viewZonesAccessor);\n\n            _this._lenses.splice(_this._lenses.indexOf(l), 1);\n          });\n          helper.commit(decorationsAccessor);\n        });\n      }); // Compute new `visible` code lenses\n\n\n      detectVisibleLenses.schedule(); // Ask for all references again\n\n      scheduler.schedule();\n    }));\n\n    this._localToDispose.add(this._editor.onDidScrollChange(function (e) {\n      if (e.scrollTopChanged && _this._lenses.length > 0) {\n        detectVisibleLenses.schedule();\n      }\n    }));\n\n    this._localToDispose.add(this._editor.onDidLayoutChange(function () {\n      detectVisibleLenses.schedule();\n    }));\n\n    this._localToDispose.add(toDisposable(function () {\n      if (_this._editor.getModel()) {\n        var scrollState = StableEditorScrollState.capture(_this._editor);\n\n        _this._editor.changeDecorations(function (decorationsAccessor) {\n          _this._editor.changeViewZones(function (viewZonesAccessor) {\n            _this._disposeAllLenses(decorationsAccessor, viewZonesAccessor);\n          });\n        });\n\n        scrollState.restore(_this._editor);\n      } else {\n        // No accessors available\n        _this._disposeAllLenses(undefined, undefined);\n      }\n    }));\n\n    this._localToDispose.add(this._editor.onDidChangeConfiguration(function (e) {\n      if (e.fontInfo) {\n        for (var _i = 0, _a = _this._lenses; _i < _a.length; _i++) {\n          var lens = _a[_i];\n          lens.updateHeight();\n        }\n      }\n    }));\n\n    this._localToDispose.add(this._editor.onMouseUp(function (e) {\n      var _a;\n\n      if (e.target.type === 9\n      /* CONTENT_WIDGET */\n      && e.target.element && e.target.element.tagName === 'A') {\n        for (var _i = 0, _b = _this._lenses; _i < _b.length; _i++) {\n          var lens = _b[_i];\n          var command = lens.getCommand(e.target.element);\n\n          if (command) {\n            (_a = _this._commandService).executeCommand.apply(_a, [command.id].concat(command.arguments || [])).catch(function (err) {\n              return _this._notificationService.error(err);\n            });\n\n            break;\n          }\n        }\n      }\n    }));\n\n    scheduler.schedule();\n  };\n\n  CodeLensContribution.prototype._disposeAllLenses = function (decChangeAccessor, viewZoneChangeAccessor) {\n    var helper = new CodeLensHelper();\n\n    this._lenses.forEach(function (lens) {\n      return lens.dispose(helper, viewZoneChangeAccessor);\n    });\n\n    if (decChangeAccessor) {\n      helper.commit(decChangeAccessor);\n    }\n\n    this._lenses = [];\n  };\n\n  CodeLensContribution.prototype._renderCodeLensSymbols = function (symbols) {\n    var _this = this;\n\n    if (!this._editor.hasModel()) {\n      return;\n    }\n\n    var maxLineNumber = this._editor.getModel().getLineCount();\n\n    var groups = [];\n    var lastGroup;\n\n    for (var _i = 0, _a = symbols.lenses; _i < _a.length; _i++) {\n      var symbol = _a[_i];\n      var line = symbol.symbol.range.startLineNumber;\n\n      if (line < 1 || line > maxLineNumber) {\n        // invalid code lens\n        continue;\n      } else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {\n        // on same line as previous\n        lastGroup.push(symbol);\n      } else {\n        // on later line as previous\n        lastGroup = [symbol];\n        groups.push(lastGroup);\n      }\n    }\n\n    var scrollState = StableEditorScrollState.capture(this._editor);\n\n    this._editor.changeDecorations(function (decorationsAccessor) {\n      _this._editor.changeViewZones(function (viewZoneAccessor) {\n        var helper = new CodeLensHelper();\n        var codeLensIndex = 0;\n        var groupsIndex = 0;\n\n        while (groupsIndex < groups.length && codeLensIndex < _this._lenses.length) {\n          var symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;\n\n          var codeLensLineNumber = _this._lenses[codeLensIndex].getLineNumber();\n\n          if (codeLensLineNumber < symbolsLineNumber) {\n            _this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);\n\n            _this._lenses.splice(codeLensIndex, 1);\n          } else if (codeLensLineNumber === symbolsLineNumber) {\n            _this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);\n\n            groupsIndex++;\n            codeLensIndex++;\n          } else {\n            _this._lenses.splice(codeLensIndex, 0, new CodeLensWidget(groups[groupsIndex], _this._editor, helper, viewZoneAccessor, function () {\n              return _this._detectVisibleLenses && _this._detectVisibleLenses.schedule();\n            }));\n\n            codeLensIndex++;\n            groupsIndex++;\n          }\n        } // Delete extra code lenses\n\n\n        while (codeLensIndex < _this._lenses.length) {\n          _this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);\n\n          _this._lenses.splice(codeLensIndex, 1);\n        } // Create extra symbols\n\n\n        while (groupsIndex < groups.length) {\n          _this._lenses.push(new CodeLensWidget(groups[groupsIndex], _this._editor, helper, viewZoneAccessor, function () {\n            return _this._detectVisibleLenses && _this._detectVisibleLenses.schedule();\n          }));\n\n          groupsIndex++;\n        }\n\n        helper.commit(decorationsAccessor);\n      });\n    });\n\n    scrollState.restore(this._editor);\n  };\n\n  CodeLensContribution.prototype._onViewportChanged = function () {\n    var _this = this;\n\n    if (this._currentResolveCodeLensSymbolsPromise) {\n      this._currentResolveCodeLensSymbolsPromise.cancel();\n\n      this._currentResolveCodeLensSymbolsPromise = undefined;\n    }\n\n    var model = this._editor.getModel();\n\n    if (!model) {\n      return;\n    }\n\n    var toResolve = [];\n    var lenses = [];\n\n    this._lenses.forEach(function (lens) {\n      var request = lens.computeIfNecessary(model);\n\n      if (request) {\n        toResolve.push(request);\n        lenses.push(lens);\n      }\n    });\n\n    if (toResolve.length === 0) {\n      return;\n    }\n\n    this._currentResolveCodeLensSymbolsPromise = createCancelablePromise(function (token) {\n      var promises = toResolve.map(function (request, i) {\n        var resolvedSymbols = new Array(request.length);\n        var promises = request.map(function (request, i) {\n          if (!request.symbol.command && typeof request.provider.resolveCodeLens === 'function') {\n            return Promise.resolve(request.provider.resolveCodeLens(model, request.symbol, token)).then(function (symbol) {\n              resolvedSymbols[i] = symbol;\n            }, onUnexpectedExternalError);\n          } else {\n            resolvedSymbols[i] = request.symbol;\n            return Promise.resolve(undefined);\n          }\n        });\n        return Promise.all(promises).then(function () {\n          if (!token.isCancellationRequested) {\n            lenses[i].updateCommands(resolvedSymbols);\n          }\n        });\n      });\n      return Promise.all(promises);\n    });\n\n    this._currentResolveCodeLensSymbolsPromise.then(function () {\n      _this._oldCodeLensModels.clear(); // dispose old models once we have updated the UI with the current model\n\n\n      _this._currentResolveCodeLensSymbolsPromise = undefined;\n    }, function (err) {\n      onUnexpectedError(err); // can also be cancellation!\n\n      _this._currentResolveCodeLensSymbolsPromise = undefined;\n    });\n  };\n\n  CodeLensContribution.ID = 'css.editor.codeLens';\n  CodeLensContribution = __decorate([__param(1, ICommandService), __param(2, INotificationService), __param(3, ICodeLensCache)], CodeLensContribution);\n  return CodeLensContribution;\n}();\n\nexport { CodeLensContribution };\nregisterEditorContribution(CodeLensContribution);","map":null,"metadata":{},"sourceType":"module"}