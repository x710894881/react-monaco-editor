{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { equals } from '../../../base/common/arrays.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { first } from '../../../base/common/collections.js';\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { DocumentSymbolProviderRegistry } from '../../common/modes.js';\n\nvar TreeElement =\n/** @class */\nfunction () {\n  function TreeElement() {}\n\n  TreeElement.prototype.remove = function () {\n    if (this.parent) {\n      delete this.parent.children[this.id];\n    }\n  };\n\n  TreeElement.findId = function (candidate, container) {\n    // complex id-computation which contains the origin/extension,\n    // the parent path, and some dedupe logic when names collide\n    var candidateId;\n\n    if (typeof candidate === 'string') {\n      candidateId = container.id + \"/\" + candidate;\n    } else {\n      candidateId = container.id + \"/\" + candidate.name;\n\n      if (container.children[candidateId] !== undefined) {\n        candidateId = container.id + \"/\" + candidate.name + \"_\" + candidate.range.startLineNumber + \"_\" + candidate.range.startColumn;\n      }\n    }\n\n    var id = candidateId;\n\n    for (var i = 0; container.children[id] !== undefined; i++) {\n      id = candidateId + \"_\" + i;\n    }\n\n    return id;\n  };\n\n  TreeElement.empty = function (element) {\n    for (var _key in element.children) {\n      return false;\n    }\n\n    return true;\n  };\n\n  return TreeElement;\n}();\n\nexport { TreeElement };\n\nvar OutlineElement =\n/** @class */\nfunction (_super) {\n  __extends(OutlineElement, _super);\n\n  function OutlineElement(id, parent, symbol) {\n    var _this = _super.call(this) || this;\n\n    _this.id = id;\n    _this.parent = parent;\n    _this.symbol = symbol;\n    _this.children = Object.create(null);\n    return _this;\n  }\n\n  return OutlineElement;\n}(TreeElement);\n\nexport { OutlineElement };\n\nvar OutlineGroup =\n/** @class */\nfunction (_super) {\n  __extends(OutlineGroup, _super);\n\n  function OutlineGroup(id, parent, provider, providerIndex) {\n    var _this = _super.call(this) || this;\n\n    _this.id = id;\n    _this.parent = parent;\n    _this.provider = provider;\n    _this.providerIndex = providerIndex;\n    _this.children = Object.create(null);\n    return _this;\n  }\n\n  return OutlineGroup;\n}(TreeElement);\n\nexport { OutlineGroup };\n\nvar MovingAverage =\n/** @class */\nfunction () {\n  function MovingAverage() {\n    this._n = 1;\n    this._val = 0;\n  }\n\n  MovingAverage.prototype.update = function (value) {\n    this._val = this._val + (value - this._val) / this._n;\n    this._n += 1;\n    return this;\n  };\n\n  return MovingAverage;\n}();\n\nvar OutlineModel =\n/** @class */\nfunction (_super) {\n  __extends(OutlineModel, _super);\n\n  function OutlineModel(textModel) {\n    var _this = _super.call(this) || this;\n\n    _this.textModel = textModel;\n    _this.id = 'root';\n    _this.parent = undefined;\n    _this._groups = Object.create(null);\n    _this.children = Object.create(null);\n    _this.id = 'root';\n    _this.parent = undefined;\n    return _this;\n  }\n\n  OutlineModel.create = function (textModel, token) {\n    var _this = this;\n\n    var key = this._keys.for(textModel, true);\n\n    var data = OutlineModel._requests.get(key);\n\n    if (!data) {\n      var source = new CancellationTokenSource();\n      data = {\n        promiseCnt: 0,\n        source: source,\n        promise: OutlineModel._create(textModel, source.token),\n        model: undefined\n      };\n\n      OutlineModel._requests.set(key, data); // keep moving average of request durations\n\n\n      var now_1 = Date.now();\n      data.promise.then(function () {\n        var key = _this._keys.for(textModel, false);\n\n        var avg = _this._requestDurations.get(key);\n\n        if (!avg) {\n          avg = new MovingAverage();\n\n          _this._requestDurations.set(key, avg);\n        }\n\n        avg.update(Date.now() - now_1);\n      });\n    }\n\n    if (data.model) {\n      // resolved -> return data\n      return Promise.resolve(data.model);\n    } // increase usage counter\n\n\n    data.promiseCnt += 1;\n    token.onCancellationRequested(function () {\n      // last -> cancel provider request, remove cached promise\n      if (--data.promiseCnt === 0) {\n        data.source.cancel();\n\n        OutlineModel._requests.delete(key);\n      }\n    });\n    return new Promise(function (resolve, reject) {\n      data.promise.then(function (model) {\n        data.model = model;\n        resolve(model);\n      }, function (err) {\n        OutlineModel._requests.delete(key);\n\n        reject(err);\n      });\n    });\n  };\n\n  OutlineModel._create = function (textModel, token) {\n    var cts = new CancellationTokenSource(token);\n    var result = new OutlineModel(textModel);\n    var provider = DocumentSymbolProviderRegistry.ordered(textModel);\n    var promises = provider.map(function (provider, index) {\n      var id = TreeElement.findId(\"provider_\" + index, result);\n      var group = new OutlineGroup(id, result, provider, index);\n      return Promise.resolve(provider.provideDocumentSymbols(result.textModel, cts.token)).then(function (result) {\n        for (var _i = 0, _a = result || []; _i < _a.length; _i++) {\n          var info = _a[_i];\n\n          OutlineModel._makeOutlineElement(info, group);\n        }\n\n        return group;\n      }, function (err) {\n        onUnexpectedExternalError(err);\n        return group;\n      }).then(function (group) {\n        if (!TreeElement.empty(group)) {\n          result._groups[id] = group;\n        } else {\n          group.remove();\n        }\n      });\n    });\n    var listener = DocumentSymbolProviderRegistry.onDidChange(function () {\n      var newProvider = DocumentSymbolProviderRegistry.ordered(textModel);\n\n      if (!equals(newProvider, provider)) {\n        cts.cancel();\n      }\n    });\n    return Promise.all(promises).then(function () {\n      if (cts.token.isCancellationRequested && !token.isCancellationRequested) {\n        return OutlineModel._create(textModel, token);\n      } else {\n        return result._compact();\n      }\n    }).finally(function () {\n      listener.dispose();\n    });\n  };\n\n  OutlineModel._makeOutlineElement = function (info, container) {\n    var id = TreeElement.findId(info, container);\n    var res = new OutlineElement(id, container, info);\n\n    if (info.children) {\n      for (var _i = 0, _a = info.children; _i < _a.length; _i++) {\n        var childInfo = _a[_i];\n\n        OutlineModel._makeOutlineElement(childInfo, res);\n      }\n    }\n\n    container.children[res.id] = res;\n  };\n\n  OutlineModel.prototype._compact = function () {\n    var count = 0;\n\n    for (var key in this._groups) {\n      var group = this._groups[key];\n\n      if (first(group.children) === undefined) {\n        // empty\n        delete this._groups[key];\n      } else {\n        count += 1;\n      }\n    }\n\n    if (count !== 1) {\n      //\n      this.children = this._groups;\n    } else {\n      // adopt all elements of the first group\n      var group = first(this._groups);\n\n      for (var key in group.children) {\n        var child = group.children[key];\n        child.parent = this;\n        this.children[child.id] = child;\n      }\n    }\n\n    return this;\n  };\n\n  OutlineModel._requestDurations = new LRUCache(50, 0.7);\n  OutlineModel._requests = new LRUCache(9, 0.75);\n  OutlineModel._keys = new (\n  /** @class */\n  function () {\n    function class_1() {\n      this._counter = 1;\n      this._data = new WeakMap();\n    }\n\n    class_1.prototype.for = function (textModel, version) {\n      return textModel.id + \"/\" + (version ? textModel.getVersionId() : '') + \"/\" + this._hash(DocumentSymbolProviderRegistry.all(textModel));\n    };\n\n    class_1.prototype._hash = function (providers) {\n      var result = '';\n\n      for (var _i = 0, providers_1 = providers; _i < providers_1.length; _i++) {\n        var provider = providers_1[_i];\n\n        var n = this._data.get(provider);\n\n        if (typeof n === 'undefined') {\n          n = this._counter++;\n\n          this._data.set(provider, n);\n        }\n\n        result += n;\n      }\n\n      return result;\n    };\n\n    return class_1;\n  }())();\n  return OutlineModel;\n}(TreeElement);\n\nexport { OutlineModel };","map":null,"metadata":{},"sourceType":"module"}