{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict'; // Allow for running under nodejs/requirejs in tests\n\nvar _monaco = typeof monaco === 'undefined' ? self.monaco : monaco;\n\nexport var conf = {\n  comments: {\n    lineComment: '#',\n    blockComment: ['\\'\\'\\'', '\\'\\'\\'']\n  },\n  brackets: [['{', '}'], ['[', ']'], ['(', ')']],\n  autoClosingPairs: [{\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: '\"',\n    close: '\"',\n    notIn: ['string']\n  }, {\n    open: '\\'',\n    close: '\\'',\n    notIn: ['string', 'comment']\n  }],\n  surroundingPairs: [{\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: '\\'',\n    close: '\\''\n  }],\n  onEnterRules: [{\n    beforeText: new RegExp(\"^\\\\s*(?:def|class|for|if|elif|else|while|try|with|finally|except|async).*?:\\\\s*$\"),\n    action: {\n      indentAction: _monaco.languages.IndentAction.Indent\n    }\n  }],\n  folding: {\n    offSide: true,\n    markers: {\n      start: new RegExp(\"^\\\\s*#region\\\\b\"),\n      end: new RegExp(\"^\\\\s*#endregion\\\\b\")\n    }\n  }\n};\nexport var language = {\n  defaultToken: '',\n  tokenPostfix: '.python',\n  keywords: ['and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'exec', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'None', 'not', 'or', 'pass', 'print', 'raise', 'return', 'self', 'try', 'while', 'with', 'yield', 'int', 'float', 'long', 'complex', 'hex', 'abs', 'all', 'any', 'apply', 'basestring', 'bin', 'bool', 'buffer', 'bytearray', 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'execfile', 'file', 'filter', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'id', 'input', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'locals', 'list', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'reversed', 'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip', 'True', 'False', '__dict__', '__methods__', '__members__', '__class__', '__bases__', '__name__', '__mro__', '__subclasses__', '__init__', '__import__'],\n  brackets: [{\n    open: '{',\n    close: '}',\n    token: 'delimiter.curly'\n  }, {\n    open: '[',\n    close: ']',\n    token: 'delimiter.bracket'\n  }, {\n    open: '(',\n    close: ')',\n    token: 'delimiter.parenthesis'\n  }],\n  tokenizer: {\n    root: [{\n      include: '@whitespace'\n    }, {\n      include: '@numbers'\n    }, {\n      include: '@strings'\n    }, [/[,:;]/, 'delimiter'], [/[{}\\[\\]()]/, '@brackets'], [/@[a-zA-Z]\\w*/, 'tag'], [/[a-zA-Z]\\w*/, {\n      cases: {\n        '@keywords': 'keyword',\n        '@default': 'identifier'\n      }\n    }]],\n    // Deal with white space, including single and multi-line comments\n    whitespace: [[/\\s+/, 'white'], [/(^#.*$)/, 'comment'], [/'''/, 'string', '@endDocString'], [/\"\"\"/, 'string', '@endDblDocString']],\n    endDocString: [[/[^']+/, 'string'], [/\\\\'/, 'string'], [/'''/, 'string', '@popall'], [/'/, 'string']],\n    endDblDocString: [[/[^\"]+/, 'string'], [/\\\\\"/, 'string'], [/\"\"\"/, 'string', '@popall'], [/\"/, 'string']],\n    // Recognize hex, negatives, decimals, imaginaries, longs, and scientific notation\n    numbers: [[/-?0x([abcdef]|[ABCDEF]|\\d)+[lL]?/, 'number.hex'], [/-?(\\d*\\.)?\\d+([eE][+\\-]?\\d+)?[jJ]?[lL]?/, 'number']],\n    // Recognize strings, including those broken across lines with \\ (but not without)\n    strings: [[/'$/, 'string.escape', '@popall'], [/'/, 'string.escape', '@stringBody'], [/\"$/, 'string.escape', '@popall'], [/\"/, 'string.escape', '@dblStringBody']],\n    stringBody: [[/[^\\\\']+$/, 'string', '@popall'], [/[^\\\\']+/, 'string'], [/\\\\./, 'string'], [/'/, 'string.escape', '@popall'], [/\\\\$/, 'string']],\n    dblStringBody: [[/[^\\\\\"]+$/, 'string', '@popall'], [/[^\\\\\"]+/, 'string'], [/\\\\./, 'string'], [/\"/, 'string.escape', '@popall'], [/\\\\$/, 'string']]\n  }\n};","map":null,"metadata":{},"sourceType":"module"}