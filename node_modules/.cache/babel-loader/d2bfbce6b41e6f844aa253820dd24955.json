{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../_deps/vscode-languageserver-types/main.js';\nimport { createScanner } from '../../jsonc-parser/main.js';\nimport { FoldingRangeKind } from '../jsonLanguageTypes.js';\nexport function getFoldingRanges(document, context) {\n  var ranges = [];\n  var nestingLevels = [];\n  var stack = [];\n  var prevStart = -1;\n  var scanner = createScanner(document.getText(), false);\n  var token = scanner.scan();\n\n  function addRange(range) {\n    ranges.push(range);\n    nestingLevels.push(stack.length);\n  }\n\n  while (token !== 17\n  /* EOF */\n  ) {\n    switch (token) {\n      case 1\n      /* OpenBraceToken */\n      :\n      case 3\n      /* OpenBracketToken */\n      :\n        {\n          var startLine = document.positionAt(scanner.getTokenOffset()).line;\n          var range = {\n            startLine: startLine,\n            endLine: startLine,\n            kind: token === 1\n            /* OpenBraceToken */\n            ? 'object' : 'array'\n          };\n          stack.push(range);\n          break;\n        }\n\n      case 2\n      /* CloseBraceToken */\n      :\n      case 4\n      /* CloseBracketToken */\n      :\n        {\n          var kind = token === 2\n          /* CloseBraceToken */\n          ? 'object' : 'array';\n\n          if (stack.length > 0 && stack[stack.length - 1].kind === kind) {\n            var range = stack.pop();\n            var line = document.positionAt(scanner.getTokenOffset()).line;\n\n            if (range && line > range.startLine + 1 && prevStart !== range.startLine) {\n              range.endLine = line - 1;\n              addRange(range);\n              prevStart = range.startLine;\n            }\n          }\n\n          break;\n        }\n\n      case 13\n      /* BlockCommentTrivia */\n      :\n        {\n          var startLine = document.positionAt(scanner.getTokenOffset()).line;\n          var endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\n\n          if (scanner.getTokenError() === 1\n          /* UnexpectedEndOfComment */\n          && startLine + 1 < document.lineCount) {\n            scanner.setPosition(document.offsetAt(Position.create(startLine + 1, 0)));\n          } else {\n            if (startLine < endLine) {\n              addRange({\n                startLine: startLine,\n                endLine: endLine,\n                kind: FoldingRangeKind.Comment\n              });\n              prevStart = startLine;\n            }\n          }\n\n          break;\n        }\n\n      case 12\n      /* LineCommentTrivia */\n      :\n        {\n          var text = document.getText().substr(scanner.getTokenOffset(), scanner.getTokenLength());\n          var m = text.match(/^\\/\\/\\s*#(region\\b)|(endregion\\b)/);\n\n          if (m) {\n            var line = document.positionAt(scanner.getTokenOffset()).line;\n\n            if (m[1]) {\n              // start pattern match\n              var range = {\n                startLine: line,\n                endLine: line,\n                kind: FoldingRangeKind.Region\n              };\n              stack.push(range);\n            } else {\n              var i = stack.length - 1;\n\n              while (i >= 0 && stack[i].kind !== FoldingRangeKind.Region) {\n                i--;\n              }\n\n              if (i >= 0) {\n                var range = stack[i];\n                stack.length = i;\n\n                if (line > range.startLine && prevStart !== range.startLine) {\n                  range.endLine = line;\n                  addRange(range);\n                  prevStart = range.startLine;\n                }\n              }\n            }\n          }\n\n          break;\n        }\n    }\n\n    token = scanner.scan();\n  }\n\n  var rangeLimit = context && context.rangeLimit;\n\n  if (typeof rangeLimit !== 'number' || ranges.length <= rangeLimit) {\n    return ranges;\n  }\n\n  var counts = [];\n\n  for (var _i = 0, nestingLevels_1 = nestingLevels; _i < nestingLevels_1.length; _i++) {\n    var level = nestingLevels_1[_i];\n\n    if (level < 30) {\n      counts[level] = (counts[level] || 0) + 1;\n    }\n  }\n\n  var entries = 0;\n  var maxLevel = 0;\n\n  for (var i = 0; i < counts.length; i++) {\n    var n = counts[i];\n\n    if (n) {\n      if (n + entries > rangeLimit) {\n        maxLevel = i;\n        break;\n      }\n\n      entries += n;\n    }\n  }\n\n  var result = [];\n\n  for (var i = 0; i < ranges.length; i++) {\n    var level = nestingLevels[i];\n\n    if (typeof level === 'number') {\n      if (level < maxLevel || level === maxLevel && entries++ < rangeLimit) {\n        result.push(ranges[i]);\n      }\n    }\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}