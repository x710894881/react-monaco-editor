{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { URI } from './uri.js';\nimport { posix, normalize } from './path.js';\nimport { startsWithIgnoreCase, rtrim, startsWith } from './strings.js';\nimport { Schemas } from './network.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { isEqual, basename, relativePath } from './resources.js';\n/**\n * @deprecated use LabelService instead\n */\n\nexport function getPathLabel(resource, userHomeProvider, rootProvider) {\n  if (typeof resource === 'string') {\n    resource = URI.file(resource);\n  } // return early if we can resolve a relative path label from the root\n\n\n  if (rootProvider) {\n    var baseResource = rootProvider.getWorkspaceFolder(resource);\n\n    if (baseResource) {\n      var hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;\n      var pathLabel = void 0;\n\n      if (isEqual(baseResource.uri, resource)) {\n        pathLabel = ''; // no label if paths are identical\n      } else {\n        pathLabel = relativePath(baseResource.uri, resource);\n      }\n\n      if (hasMultipleRoots) {\n        var rootName = baseResource && baseResource.name ? baseResource.name : basename(baseResource.uri);\n        pathLabel = pathLabel ? rootName + ' â€¢ ' + pathLabel : rootName; // always show root basename if there are multiple\n      }\n\n      return pathLabel;\n    }\n  } // return if the resource is neither file:// nor untitled:// and no baseResource was provided\n\n\n  if (resource.scheme !== Schemas.file && resource.scheme !== Schemas.untitled) {\n    return resource.with({\n      query: null,\n      fragment: null\n    }).toString(true);\n  } // convert c:\\something => C:\\something\n\n\n  if (hasDriveLetter(resource.fsPath)) {\n    return normalize(normalizeDriveLetter(resource.fsPath));\n  } // normalize and tildify (macOS, Linux only)\n\n\n  var res = normalize(resource.fsPath);\n\n  if (!isWindows && userHomeProvider) {\n    res = tildify(res, userHomeProvider.userHome);\n  }\n\n  return res;\n}\nexport function getBaseLabel(resource) {\n  if (!resource) {\n    return undefined;\n  }\n\n  if (typeof resource === 'string') {\n    resource = URI.file(resource);\n  }\n\n  var base = basename(resource) || (resource.scheme === Schemas.file ? resource.fsPath : resource.path)\n  /* can be empty string if '/' is passed in */\n  ; // convert c: => C:\n\n  if (hasDriveLetter(base)) {\n    return normalizeDriveLetter(base);\n  }\n\n  return base;\n}\n\nfunction hasDriveLetter(path) {\n  return !!(isWindows && path && path[1] === ':');\n}\n\nexport function normalizeDriveLetter(path) {\n  if (hasDriveLetter(path)) {\n    return path.charAt(0).toUpperCase() + path.slice(1);\n  }\n\n  return path;\n}\nvar normalizedUserHomeCached = Object.create(null);\nexport function tildify(path, userHome) {\n  if (isWindows || !path || !userHome) {\n    return path; // unsupported\n  } // Keep a normalized user home path as cache to prevent accumulated string creation\n\n\n  var normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n\n  if (!normalizedUserHome) {\n    normalizedUserHome = \"\" + rtrim(userHome, posix.sep) + posix.sep;\n    normalizedUserHomeCached = {\n      original: userHome,\n      normalized: normalizedUserHome\n    };\n  } // Linux: case sensitive, macOS: case insensitive\n\n\n  if (isLinux ? startsWith(path, normalizedUserHome) : startsWithIgnoreCase(path, normalizedUserHome)) {\n    path = \"~/\" + path.substr(normalizedUserHome.length);\n  }\n\n  return path;\n}","map":null,"metadata":{},"sourceType":"module"}