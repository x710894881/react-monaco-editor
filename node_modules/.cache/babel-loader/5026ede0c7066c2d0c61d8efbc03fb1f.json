{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n  return (node.metadata & 1\n  /* ColorMask */\n  ) >>> 0\n  /* ColorOffset */\n  ;\n}\n\nfunction setNodeColor(node, color) {\n  node.metadata = node.metadata & 254\n  /* ColorMaskInverse */\n  | color << 0\n  /* ColorOffset */\n  ;\n}\n\nfunction getNodeIsVisited(node) {\n  return (node.metadata & 2\n  /* IsVisitedMask */\n  ) >>> 1\n  /* IsVisitedOffset */\n  === 1;\n}\n\nfunction setNodeIsVisited(node, value) {\n  node.metadata = node.metadata & 253\n  /* IsVisitedMaskInverse */\n  | (value ? 1 : 0) << 1\n  /* IsVisitedOffset */\n  ;\n}\n\nfunction getNodeIsForValidation(node) {\n  return (node.metadata & 4\n  /* IsForValidationMask */\n  ) >>> 2\n  /* IsForValidationOffset */\n  === 1;\n}\n\nfunction setNodeIsForValidation(node, value) {\n  node.metadata = node.metadata & 251\n  /* IsForValidationMaskInverse */\n  | (value ? 1 : 0) << 2\n  /* IsForValidationOffset */\n  ;\n}\n\nexport function getNodeIsInOverviewRuler(node) {\n  return (node.metadata & 8\n  /* IsInOverviewRulerMask */\n  ) >>> 3\n  /* IsInOverviewRulerOffset */\n  === 1;\n}\n\nfunction setNodeIsInOverviewRuler(node, value) {\n  node.metadata = node.metadata & 247\n  /* IsInOverviewRulerMaskInverse */\n  | (value ? 1 : 0) << 3\n  /* IsInOverviewRulerOffset */\n  ;\n}\n\nfunction getNodeStickiness(node) {\n  return (node.metadata & 48\n  /* StickinessMask */\n  ) >>> 4\n  /* StickinessOffset */\n  ;\n}\n\nfunction _setNodeStickiness(node, stickiness) {\n  node.metadata = node.metadata & 207\n  /* StickinessMaskInverse */\n  | stickiness << 4\n  /* StickinessOffset */\n  ;\n}\n\nfunction getCollapseOnReplaceEdit(node) {\n  return (node.metadata & 64\n  /* CollapseOnReplaceEditMask */\n  ) >>> 6\n  /* CollapseOnReplaceEditOffset */\n  === 1;\n}\n\nfunction setCollapseOnReplaceEdit(node, value) {\n  node.metadata = node.metadata & 191\n  /* CollapseOnReplaceEditMaskInverse */\n  | (value ? 1 : 0) << 6\n  /* CollapseOnReplaceEditOffset */\n  ;\n}\n\nvar IntervalNode =\n/** @class */\nfunction () {\n  function IntervalNode(id, start, end) {\n    this.metadata = 0;\n    this.parent = this;\n    this.left = this;\n    this.right = this;\n    setNodeColor(this, 1\n    /* Red */\n    );\n    this.start = start;\n    this.end = end; // FORCE_OVERFLOWING_TEST: this.delta = start;\n\n    this.delta = 0;\n    this.maxEnd = end;\n    this.id = id;\n    this.ownerId = 0;\n    this.options = null;\n    setNodeIsForValidation(this, false);\n\n    _setNodeStickiness(this, 1\n    /* NeverGrowsWhenTypingAtEdges */\n    );\n\n    setNodeIsInOverviewRuler(this, false);\n    setCollapseOnReplaceEdit(this, false);\n    this.cachedVersionId = 0;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = null;\n    setNodeIsVisited(this, false);\n  }\n\n  IntervalNode.prototype.reset = function (versionId, start, end, range) {\n    this.start = start;\n    this.end = end;\n    this.maxEnd = end;\n    this.cachedVersionId = versionId;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = range;\n  };\n\n  IntervalNode.prototype.setOptions = function (options) {\n    this.options = options;\n    var className = this.options.className;\n    setNodeIsForValidation(this, className === \"squiggly-error\"\n    /* EditorErrorDecoration */\n    || className === \"squiggly-warning\"\n    /* EditorWarningDecoration */\n    || className === \"squiggly-info\"\n    /* EditorInfoDecoration */\n    );\n\n    _setNodeStickiness(this, this.options.stickiness);\n\n    setNodeIsInOverviewRuler(this, this.options.overviewRuler && this.options.overviewRuler.color ? true : false);\n    setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n  };\n\n  IntervalNode.prototype.setCachedOffsets = function (absoluteStart, absoluteEnd, cachedVersionId) {\n    if (this.cachedVersionId !== cachedVersionId) {\n      this.range = null;\n    }\n\n    this.cachedVersionId = cachedVersionId;\n    this.cachedAbsoluteStart = absoluteStart;\n    this.cachedAbsoluteEnd = absoluteEnd;\n  };\n\n  IntervalNode.prototype.detach = function () {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  };\n\n  return IntervalNode;\n}();\n\nexport { IntervalNode };\nexport var SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0\n/* Black */\n);\n\nvar IntervalTree =\n/** @class */\nfunction () {\n  function IntervalTree() {\n    this.root = SENTINEL;\n    this.requestNormalizeDelta = false;\n  }\n\n  IntervalTree.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n\n    return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n  };\n\n  IntervalTree.prototype.search = function (filterOwnerId, filterOutValidation, cachedVersionId) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n\n    return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n  };\n  /**\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n   */\n\n\n  IntervalTree.prototype.collectNodesFromOwner = function (ownerId) {\n    return collectNodesFromOwner(this, ownerId);\n  };\n  /**\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n   */\n\n\n  IntervalTree.prototype.collectNodesPostOrder = function () {\n    return collectNodesPostOrder(this);\n  };\n\n  IntervalTree.prototype.insert = function (node) {\n    rbTreeInsert(this, node);\n\n    this._normalizeDeltaIfNecessary();\n  };\n\n  IntervalTree.prototype.delete = function (node) {\n    rbTreeDelete(this, node);\n\n    this._normalizeDeltaIfNecessary();\n  };\n\n  IntervalTree.prototype.resolveNode = function (node, cachedVersionId) {\n    var initialNode = node;\n    var delta = 0;\n\n    while (node !== this.root) {\n      if (node === node.parent.right) {\n        delta += node.parent.delta;\n      }\n\n      node = node.parent;\n    }\n\n    var nodeStart = initialNode.start + delta;\n    var nodeEnd = initialNode.end + delta;\n    initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n  };\n\n  IntervalTree.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {\n    // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n    // (1) collect all nodes that are intersecting this edit as nodes of interest\n    var nodesOfInterest = searchForEditing(this, offset, offset + length); // (2) remove all nodes that are intersecting this edit\n\n    for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\n      var node = nodesOfInterest[i];\n      rbTreeDelete(this, node);\n    }\n\n    this._normalizeDeltaIfNecessary(); // (3) edit all tree nodes except the nodes of interest\n\n\n    noOverlapReplace(this, offset, offset + length, textLength);\n\n    this._normalizeDeltaIfNecessary(); // (4) edit the nodes of interest and insert them back in the tree\n\n\n    for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\n      var node = nodesOfInterest[i];\n      node.start = node.cachedAbsoluteStart;\n      node.end = node.cachedAbsoluteEnd;\n      nodeAcceptEdit(node, offset, offset + length, textLength, forceMoveMarkers);\n      node.maxEnd = node.end;\n      rbTreeInsert(this, node);\n    }\n\n    this._normalizeDeltaIfNecessary();\n  };\n\n  IntervalTree.prototype._normalizeDeltaIfNecessary = function () {\n    if (!this.requestNormalizeDelta) {\n      return;\n    }\n\n    this.requestNormalizeDelta = false;\n    normalizeDelta(this);\n  };\n\n  return IntervalTree;\n}();\n\nexport { IntervalTree }; //#region Delta Normalization\n\nfunction normalizeDelta(T) {\n  var node = T.root;\n  var delta = 0;\n\n  while (node !== SENTINEL) {\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    } // handle current node\n\n\n    node.start = delta + node.start;\n    node.end = delta + node.end;\n    node.delta = 0;\n    recomputeMaxEnd(node);\n    setNodeIsVisited(node, true); // going up from this node\n\n    setNodeIsVisited(node.left, false);\n    setNodeIsVisited(node.right, false);\n\n    if (node === node.parent.right) {\n      delta -= node.parent.delta;\n    }\n\n    node = node.parent;\n  }\n\n  setNodeIsVisited(T.root, false);\n}\n\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n  if (markerOffset < checkOffset) {\n    return true;\n  }\n\n  if (markerOffset > checkOffset) {\n    return false;\n  }\n\n  if (moveSemantics === 1\n  /* ForceMove */\n  ) {\n      return false;\n    }\n\n  if (moveSemantics === 2\n  /* ForceStay */\n  ) {\n      return true;\n    }\n\n  return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\n\n\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n  var nodeStickiness = getNodeStickiness(node);\n  var startStickToPreviousCharacter = nodeStickiness === 0\n  /* AlwaysGrowsWhenTypingAtEdges */\n  || nodeStickiness === 2\n  /* GrowsOnlyWhenTypingBefore */\n  ;\n  var endStickToPreviousCharacter = nodeStickiness === 1\n  /* NeverGrowsWhenTypingAtEdges */\n  || nodeStickiness === 2\n  /* GrowsOnlyWhenTypingBefore */\n  ;\n  var deletingCnt = end - start;\n  var insertingCnt = textLength;\n  var commonLength = Math.min(deletingCnt, insertingCnt);\n  var nodeStart = node.start;\n  var startDone = false;\n  var nodeEnd = node.end;\n  var endDone = false;\n\n  if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n    // This edit encompasses the entire decoration range\n    // and the decoration has asked to become collapsed\n    node.start = start;\n    startDone = true;\n    node.end = start;\n    endDone = true;\n  }\n\n  {\n    var moveSemantics = forceMoveMarkers ? 1\n    /* ForceMove */\n    : deletingCnt > 0 ? 2\n    /* ForceStay */\n    : 0\n    /* MarkerDefined */\n    ;\n\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n      startDone = true;\n    }\n\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n      endDone = true;\n    }\n  }\n\n  if (commonLength > 0 && !forceMoveMarkers) {\n    var moveSemantics = deletingCnt > insertingCnt ? 2\n    /* ForceStay */\n    : 0\n    /* MarkerDefined */\n    ;\n\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      startDone = true;\n    }\n\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      endDone = true;\n    }\n  }\n\n  {\n    var moveSemantics = forceMoveMarkers ? 1\n    /* ForceMove */\n    : 0\n    /* MarkerDefined */\n    ;\n\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n      node.start = start + insertingCnt;\n      startDone = true;\n    }\n\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n      node.end = start + insertingCnt;\n      endDone = true;\n    }\n  } // Finish\n\n  var deltaColumn = insertingCnt - deletingCnt;\n\n  if (!startDone) {\n    node.start = Math.max(0, nodeStart + deltaColumn);\n  }\n\n  if (!endDone) {\n    node.end = Math.max(0, nodeEnd + deltaColumn);\n  }\n\n  if (node.start > node.end) {\n    node.end = node.start;\n  }\n}\n\nfunction searchForEditing(T, start, end) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      node = node.parent;\n      continue;\n    }\n\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n\n    if (nodeStart > end) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n\n    nodeEnd = delta + node.end;\n\n    if (nodeEnd >= start) {\n      node.setCachedOffsets(nodeStart, nodeEnd, 0);\n      result[resultLen++] = node;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction noOverlapReplace(T, start, end, textLength) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var editDelta = textLength - (end - start);\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      recomputeMaxEnd(node);\n      node = node.parent;\n      continue;\n    }\n\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n\n    if (nodeStart > end) {\n      node.start += editDelta;\n      node.end += editDelta;\n      node.delta += editDelta;\n\n      if (node.delta < -1073741824\n      /* MIN_SAFE_DELTA */\n      || node.delta > 1073741824\n      /* MAX_SAFE_DELTA */\n      ) {\n          T.requestNormalizeDelta = true;\n        } // cover case a) from above\n      // there is no need to search this node or its right subtree\n\n\n      setNodeIsVisited(node, true);\n      continue;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n} //#endregion\n//#region Searching\n\n\nfunction collectNodesFromOwner(T, ownerId) {\n  var node = T.root;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    } // handle current node\n\n\n    if (node.ownerId === ownerId) {\n      result[resultLen++] = node;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction collectNodesPostOrder(T) {\n  var node = T.root;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    } // handle current node\n\n\n    result[resultLen++] = node;\n    setNodeIsVisited(node, true);\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n  var node = T.root;\n  var delta = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      node = node.parent;\n      continue;\n    }\n\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n    nodeEnd = delta + node.end;\n    node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    var include = true;\n\n    if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n      include = false;\n    }\n\n    if (filterOutValidation && getNodeIsForValidation(node)) {\n      include = false;\n    }\n\n    if (include) {\n      result[resultLen++] = node;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      node = node.parent;\n      continue;\n    }\n\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n\n      if (nodeMaxEnd < intervalStart) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n\n    if (nodeStart > intervalEnd) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n\n    nodeEnd = delta + node.end;\n\n    if (nodeEnd >= intervalStart) {\n      // There is overlap\n      node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n      var include = true;\n\n      if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n        include = false;\n      }\n\n      if (filterOutValidation && getNodeIsForValidation(node)) {\n        include = false;\n      }\n\n      if (include) {\n        result[resultLen++] = node;\n      }\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n} //#endregion\n//#region Insertion\n\n\nfunction rbTreeInsert(T, newNode) {\n  if (T.root === SENTINEL) {\n    newNode.parent = SENTINEL;\n    newNode.left = SENTINEL;\n    newNode.right = SENTINEL;\n    setNodeColor(newNode, 0\n    /* Black */\n    );\n    T.root = newNode;\n    return T.root;\n  }\n\n  treeInsert(T, newNode);\n  recomputeMaxEndWalkToRoot(newNode.parent); // repair tree\n\n  var x = newNode;\n\n  while (x !== T.root && getNodeColor(x.parent) === 1\n  /* Red */\n  ) {\n    if (x.parent === x.parent.parent.left) {\n      var y = x.parent.parent.right;\n\n      if (getNodeColor(y) === 1\n      /* Red */\n      ) {\n          setNodeColor(x.parent, 0\n          /* Black */\n          );\n          setNodeColor(y, 0\n          /* Black */\n          );\n          setNodeColor(x.parent.parent, 1\n          /* Red */\n          );\n          x = x.parent.parent;\n        } else {\n        if (x === x.parent.right) {\n          x = x.parent;\n          leftRotate(T, x);\n        }\n\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(x.parent.parent, 1\n        /* Red */\n        );\n        rightRotate(T, x.parent.parent);\n      }\n    } else {\n      var y = x.parent.parent.left;\n\n      if (getNodeColor(y) === 1\n      /* Red */\n      ) {\n          setNodeColor(x.parent, 0\n          /* Black */\n          );\n          setNodeColor(y, 0\n          /* Black */\n          );\n          setNodeColor(x.parent.parent, 1\n          /* Red */\n          );\n          x = x.parent.parent;\n        } else {\n        if (x === x.parent.left) {\n          x = x.parent;\n          rightRotate(T, x);\n        }\n\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(x.parent.parent, 1\n        /* Red */\n        );\n        leftRotate(T, x.parent.parent);\n      }\n    }\n  }\n\n  setNodeColor(T.root, 0\n  /* Black */\n  );\n  return newNode;\n}\n\nfunction treeInsert(T, z) {\n  var delta = 0;\n  var x = T.root;\n  var zAbsoluteStart = z.start;\n  var zAbsoluteEnd = z.end;\n\n  while (true) {\n    var cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n\n    if (cmp < 0) {\n      // this node should be inserted to the left\n      // => it is not affected by the node's delta\n      if (x.left === SENTINEL) {\n        z.start -= delta;\n        z.end -= delta;\n        z.maxEnd -= delta;\n        x.left = z;\n        break;\n      } else {\n        x = x.left;\n      }\n    } else {\n      // this node should be inserted to the right\n      // => it is not affected by the node's delta\n      if (x.right === SENTINEL) {\n        z.start -= delta + x.delta;\n        z.end -= delta + x.delta;\n        z.maxEnd -= delta + x.delta;\n        x.right = z;\n        break;\n      } else {\n        delta += x.delta;\n        x = x.right;\n      }\n    }\n  }\n\n  z.parent = x;\n  z.left = SENTINEL;\n  z.right = SENTINEL;\n  setNodeColor(z, 1\n  /* Red */\n  );\n} //#endregion\n//#region Deletion\n\n\nfunction rbTreeDelete(T, z) {\n  var x;\n  var y; // RB-DELETE except we don't swap z and y in case c)\n  // i.e. we always delete what's pointed at by z.\n\n  if (z.left === SENTINEL) {\n    x = z.right;\n    y = z; // x's delta is no longer influenced by z's delta\n\n    x.delta += z.delta;\n\n    if (x.delta < -1073741824\n    /* MIN_SAFE_DELTA */\n    || x.delta > 1073741824\n    /* MAX_SAFE_DELTA */\n    ) {\n        T.requestNormalizeDelta = true;\n      }\n\n    x.start += z.delta;\n    x.end += z.delta;\n  } else if (z.right === SENTINEL) {\n    x = z.left;\n    y = z;\n  } else {\n    y = leftest(z.right);\n    x = y.right; // y's delta is no longer influenced by z's delta,\n    // but we don't want to walk the entire right-hand-side subtree of x.\n    // we therefore maintain z's delta in y, and adjust only x\n\n    x.start += y.delta;\n    x.end += y.delta;\n    x.delta += y.delta;\n\n    if (x.delta < -1073741824\n    /* MIN_SAFE_DELTA */\n    || x.delta > 1073741824\n    /* MAX_SAFE_DELTA */\n    ) {\n        T.requestNormalizeDelta = true;\n      }\n\n    y.start += z.delta;\n    y.end += z.delta;\n    y.delta = z.delta;\n\n    if (y.delta < -1073741824\n    /* MIN_SAFE_DELTA */\n    || y.delta > 1073741824\n    /* MAX_SAFE_DELTA */\n    ) {\n        T.requestNormalizeDelta = true;\n      }\n  }\n\n  if (y === T.root) {\n    T.root = x;\n    setNodeColor(x, 0\n    /* Black */\n    );\n    z.detach();\n    resetSentinel();\n    recomputeMaxEnd(x);\n    T.root.parent = SENTINEL;\n    return;\n  }\n\n  var yWasRed = getNodeColor(y) === 1\n  /* Red */\n  ;\n\n  if (y === y.parent.left) {\n    y.parent.left = x;\n  } else {\n    y.parent.right = x;\n  }\n\n  if (y === z) {\n    x.parent = y.parent;\n  } else {\n    if (y.parent === z) {\n      x.parent = y;\n    } else {\n      x.parent = y.parent;\n    }\n\n    y.left = z.left;\n    y.right = z.right;\n    y.parent = z.parent;\n    setNodeColor(y, getNodeColor(z));\n\n    if (z === T.root) {\n      T.root = y;\n    } else {\n      if (z === z.parent.left) {\n        z.parent.left = y;\n      } else {\n        z.parent.right = y;\n      }\n    }\n\n    if (y.left !== SENTINEL) {\n      y.left.parent = y;\n    }\n\n    if (y.right !== SENTINEL) {\n      y.right.parent = y;\n    }\n  }\n\n  z.detach();\n\n  if (yWasRed) {\n    recomputeMaxEndWalkToRoot(x.parent);\n\n    if (y !== z) {\n      recomputeMaxEndWalkToRoot(y);\n      recomputeMaxEndWalkToRoot(y.parent);\n    }\n\n    resetSentinel();\n    return;\n  }\n\n  recomputeMaxEndWalkToRoot(x);\n  recomputeMaxEndWalkToRoot(x.parent);\n\n  if (y !== z) {\n    recomputeMaxEndWalkToRoot(y);\n    recomputeMaxEndWalkToRoot(y.parent);\n  } // RB-DELETE-FIXUP\n\n\n  var w;\n\n  while (x !== T.root && getNodeColor(x) === 0\n  /* Black */\n  ) {\n    if (x === x.parent.left) {\n      w = x.parent.right;\n\n      if (getNodeColor(w) === 1\n      /* Red */\n      ) {\n          setNodeColor(w, 0\n          /* Black */\n          );\n          setNodeColor(x.parent, 1\n          /* Red */\n          );\n          leftRotate(T, x.parent);\n          w = x.parent.right;\n        }\n\n      if (getNodeColor(w.left) === 0\n      /* Black */\n      && getNodeColor(w.right) === 0\n      /* Black */\n      ) {\n          setNodeColor(w, 1\n          /* Red */\n          );\n          x = x.parent;\n        } else {\n        if (getNodeColor(w.right) === 0\n        /* Black */\n        ) {\n            setNodeColor(w.left, 0\n            /* Black */\n            );\n            setNodeColor(w, 1\n            /* Red */\n            );\n            rightRotate(T, w);\n            w = x.parent.right;\n          }\n\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(w.right, 0\n        /* Black */\n        );\n        leftRotate(T, x.parent);\n        x = T.root;\n      }\n    } else {\n      w = x.parent.left;\n\n      if (getNodeColor(w) === 1\n      /* Red */\n      ) {\n          setNodeColor(w, 0\n          /* Black */\n          );\n          setNodeColor(x.parent, 1\n          /* Red */\n          );\n          rightRotate(T, x.parent);\n          w = x.parent.left;\n        }\n\n      if (getNodeColor(w.left) === 0\n      /* Black */\n      && getNodeColor(w.right) === 0\n      /* Black */\n      ) {\n          setNodeColor(w, 1\n          /* Red */\n          );\n          x = x.parent;\n        } else {\n        if (getNodeColor(w.left) === 0\n        /* Black */\n        ) {\n            setNodeColor(w.right, 0\n            /* Black */\n            );\n            setNodeColor(w, 1\n            /* Red */\n            );\n            leftRotate(T, w);\n            w = x.parent.left;\n          }\n\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(w.left, 0\n        /* Black */\n        );\n        rightRotate(T, x.parent);\n        x = T.root;\n      }\n    }\n  }\n\n  setNodeColor(x, 0\n  /* Black */\n  );\n  resetSentinel();\n}\n\nfunction leftest(node) {\n  while (node.left !== SENTINEL) {\n    node = node.left;\n  }\n\n  return node;\n}\n\nfunction resetSentinel() {\n  SENTINEL.parent = SENTINEL;\n  SENTINEL.delta = 0; // optional\n\n  SENTINEL.start = 0; // optional\n\n  SENTINEL.end = 0; // optional\n} //#endregion\n//#region Rotations\n\n\nfunction leftRotate(T, x) {\n  var y = x.right; // set y.\n\n  y.delta += x.delta; // y's delta is no longer influenced by x's delta\n\n  if (y.delta < -1073741824\n  /* MIN_SAFE_DELTA */\n  || y.delta > 1073741824\n  /* MAX_SAFE_DELTA */\n  ) {\n      T.requestNormalizeDelta = true;\n    }\n\n  y.start += x.delta;\n  y.end += x.delta;\n  x.right = y.left; // turn y's left subtree into x's right subtree.\n\n  if (y.left !== SENTINEL) {\n    y.left.parent = x;\n  }\n\n  y.parent = x.parent; // link x's parent to y.\n\n  if (x.parent === SENTINEL) {\n    T.root = y;\n  } else if (x === x.parent.left) {\n    x.parent.left = y;\n  } else {\n    x.parent.right = y;\n  }\n\n  y.left = x; // put x on y's left.\n\n  x.parent = y;\n  recomputeMaxEnd(x);\n  recomputeMaxEnd(y);\n}\n\nfunction rightRotate(T, y) {\n  var x = y.left;\n  y.delta -= x.delta;\n\n  if (y.delta < -1073741824\n  /* MIN_SAFE_DELTA */\n  || y.delta > 1073741824\n  /* MAX_SAFE_DELTA */\n  ) {\n      T.requestNormalizeDelta = true;\n    }\n\n  y.start -= x.delta;\n  y.end -= x.delta;\n  y.left = x.right;\n\n  if (x.right !== SENTINEL) {\n    x.right.parent = y;\n  }\n\n  x.parent = y.parent;\n\n  if (y.parent === SENTINEL) {\n    T.root = x;\n  } else if (y === y.parent.right) {\n    y.parent.right = x;\n  } else {\n    y.parent.left = x;\n  }\n\n  x.right = y;\n  y.parent = x;\n  recomputeMaxEnd(y);\n  recomputeMaxEnd(x);\n} //#endregion\n//#region max end computation\n\n\nfunction computeMaxEnd(node) {\n  var maxEnd = node.end;\n\n  if (node.left !== SENTINEL) {\n    var leftMaxEnd = node.left.maxEnd;\n\n    if (leftMaxEnd > maxEnd) {\n      maxEnd = leftMaxEnd;\n    }\n  }\n\n  if (node.right !== SENTINEL) {\n    var rightMaxEnd = node.right.maxEnd + node.delta;\n\n    if (rightMaxEnd > maxEnd) {\n      maxEnd = rightMaxEnd;\n    }\n  }\n\n  return maxEnd;\n}\n\nexport function recomputeMaxEnd(node) {\n  node.maxEnd = computeMaxEnd(node);\n}\n\nfunction recomputeMaxEndWalkToRoot(node) {\n  while (node !== SENTINEL) {\n    var maxEnd = computeMaxEnd(node);\n\n    if (node.maxEnd === maxEnd) {\n      // no need to go further\n      return;\n    }\n\n    node.maxEnd = maxEnd;\n    node = node.parent;\n  }\n} //#endregion\n//#region utils\n\n\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n  if (aStart === bStart) {\n    return aEnd - bEnd;\n  }\n\n  return aStart - bStart;\n} //#endregion","map":null,"metadata":{},"sourceType":"module"}