{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../common/core/range.js';\nimport { Token, TokenizationResult, TokenizationResult2 } from '../../common/core/token.js';\nimport * as modes from '../../common/modes.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport { ModesRegistry } from '../../common/modes/modesRegistry.js';\nimport * as standaloneEnums from '../../common/standalone/standaloneEnums.js';\nimport { StaticServices } from './standaloneServices.js';\nimport { compile } from '../common/monarch/monarchCompile.js';\nimport { createTokenizationSupport } from '../common/monarch/monarchLexer.js';\n/**\n * Register information about a new language.\n */\n\nexport function register(language) {\n  ModesRegistry.registerLanguage(language);\n}\n/**\n * Get the information of all the registered languages.\n */\n\nexport function getLanguages() {\n  var result = [];\n  result = result.concat(ModesRegistry.getLanguages());\n  return result;\n}\nexport function getEncodedLanguageId(languageId) {\n  var lid = StaticServices.modeService.get().getLanguageIdentifier(languageId);\n  return lid ? lid.id : 0;\n}\n/**\n * An event emitted when a language is first time needed (e.g. a model has it set).\n * @event\n */\n\nexport function onLanguage(languageId, callback) {\n  var disposable = StaticServices.modeService.get().onDidCreateMode(function (mode) {\n    if (mode.getId() === languageId) {\n      // stop listening\n      disposable.dispose(); // invoke actual listener\n\n      callback();\n    }\n  });\n  return disposable;\n}\n/**\n * Set the editing configuration for a language.\n */\n\nexport function setLanguageConfiguration(languageId, configuration) {\n  var languageIdentifier = StaticServices.modeService.get().getLanguageIdentifier(languageId);\n\n  if (!languageIdentifier) {\n    throw new Error(\"Cannot set configuration for unknown language \" + languageId);\n  }\n\n  return LanguageConfigurationRegistry.register(languageIdentifier, configuration);\n}\n/**\n * @internal\n */\n\nvar EncodedTokenizationSupport2Adapter =\n/** @class */\nfunction () {\n  function EncodedTokenizationSupport2Adapter(actual) {\n    this._actual = actual;\n  }\n\n  EncodedTokenizationSupport2Adapter.prototype.getInitialState = function () {\n    return this._actual.getInitialState();\n  };\n\n  EncodedTokenizationSupport2Adapter.prototype.tokenize = function (line, state, offsetDelta) {\n    throw new Error('Not supported!');\n  };\n\n  EncodedTokenizationSupport2Adapter.prototype.tokenize2 = function (line, state) {\n    var result = this._actual.tokenizeEncoded(line, state);\n\n    return new TokenizationResult2(result.tokens, result.endState);\n  };\n\n  return EncodedTokenizationSupport2Adapter;\n}();\n\nexport { EncodedTokenizationSupport2Adapter };\n/**\n * @internal\n */\n\nvar TokenizationSupport2Adapter =\n/** @class */\nfunction () {\n  function TokenizationSupport2Adapter(standaloneThemeService, languageIdentifier, actual) {\n    this._standaloneThemeService = standaloneThemeService;\n    this._languageIdentifier = languageIdentifier;\n    this._actual = actual;\n  }\n\n  TokenizationSupport2Adapter.prototype.getInitialState = function () {\n    return this._actual.getInitialState();\n  };\n\n  TokenizationSupport2Adapter.prototype._toClassicTokens = function (tokens, language, offsetDelta) {\n    var result = [];\n    var previousStartIndex = 0;\n\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      var t = tokens[i];\n      var startIndex = t.startIndex; // Prevent issues stemming from a buggy external tokenizer.\n\n      if (i === 0) {\n        // Force first token to start at first index!\n        startIndex = 0;\n      } else if (startIndex < previousStartIndex) {\n        // Force tokens to be after one another!\n        startIndex = previousStartIndex;\n      }\n\n      result[i] = new Token(startIndex + offsetDelta, t.scopes, language);\n      previousStartIndex = startIndex;\n    }\n\n    return result;\n  };\n\n  TokenizationSupport2Adapter.prototype.tokenize = function (line, state, offsetDelta) {\n    var actualResult = this._actual.tokenize(line, state);\n\n    var tokens = this._toClassicTokens(actualResult.tokens, this._languageIdentifier.language, offsetDelta);\n\n    var endState; // try to save an object if possible\n\n    if (actualResult.endState.equals(state)) {\n      endState = state;\n    } else {\n      endState = actualResult.endState;\n    }\n\n    return new TokenizationResult(tokens, endState);\n  };\n\n  TokenizationSupport2Adapter.prototype._toBinaryTokens = function (tokens, offsetDelta) {\n    var languageId = this._languageIdentifier.id;\n\n    var tokenTheme = this._standaloneThemeService.getTheme().tokenTheme;\n\n    var result = [],\n        resultLen = 0;\n    var previousStartIndex = 0;\n\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      var t = tokens[i];\n      var metadata = tokenTheme.match(languageId, t.scopes);\n\n      if (resultLen > 0 && result[resultLen - 1] === metadata) {\n        // same metadata\n        continue;\n      }\n\n      var startIndex = t.startIndex; // Prevent issues stemming from a buggy external tokenizer.\n\n      if (i === 0) {\n        // Force first token to start at first index!\n        startIndex = 0;\n      } else if (startIndex < previousStartIndex) {\n        // Force tokens to be after one another!\n        startIndex = previousStartIndex;\n      }\n\n      result[resultLen++] = startIndex + offsetDelta;\n      result[resultLen++] = metadata;\n      previousStartIndex = startIndex;\n    }\n\n    var actualResult = new Uint32Array(resultLen);\n\n    for (var i = 0; i < resultLen; i++) {\n      actualResult[i] = result[i];\n    }\n\n    return actualResult;\n  };\n\n  TokenizationSupport2Adapter.prototype.tokenize2 = function (line, state, offsetDelta) {\n    var actualResult = this._actual.tokenize(line, state);\n\n    var tokens = this._toBinaryTokens(actualResult.tokens, offsetDelta);\n\n    var endState; // try to save an object if possible\n\n    if (actualResult.endState.equals(state)) {\n      endState = state;\n    } else {\n      endState = actualResult.endState;\n    }\n\n    return new TokenizationResult2(tokens, endState);\n  };\n\n  return TokenizationSupport2Adapter;\n}();\n\nexport { TokenizationSupport2Adapter };\n\nfunction isEncodedTokensProvider(provider) {\n  return 'tokenizeEncoded' in provider;\n}\n\nfunction isThenable(obj) {\n  return obj && typeof obj.then === 'function';\n}\n/**\n * Set the tokens provider for a language (manual implementation).\n */\n\n\nexport function setTokensProvider(languageId, provider) {\n  var languageIdentifier = StaticServices.modeService.get().getLanguageIdentifier(languageId);\n\n  if (!languageIdentifier) {\n    throw new Error(\"Cannot set tokens provider for unknown language \" + languageId);\n  }\n\n  var create = function (provider) {\n    if (isEncodedTokensProvider(provider)) {\n      return new EncodedTokenizationSupport2Adapter(provider);\n    } else {\n      return new TokenizationSupport2Adapter(StaticServices.standaloneThemeService.get(), languageIdentifier, provider);\n    }\n  };\n\n  if (isThenable(provider)) {\n    return modes.TokenizationRegistry.registerPromise(languageId, provider.then(function (provider) {\n      return create(provider);\n    }));\n  }\n\n  return modes.TokenizationRegistry.register(languageId, create(provider));\n}\n/**\n * Set the tokens provider for a language (monarch implementation).\n */\n\nexport function setMonarchTokensProvider(languageId, languageDef) {\n  var create = function (languageDef) {\n    return createTokenizationSupport(StaticServices.modeService.get(), StaticServices.standaloneThemeService.get(), languageId, compile(languageId, languageDef));\n  };\n\n  if (isThenable(languageDef)) {\n    return modes.TokenizationRegistry.registerPromise(languageId, languageDef.then(function (languageDef) {\n      return create(languageDef);\n    }));\n  }\n\n  return modes.TokenizationRegistry.register(languageId, create(languageDef));\n}\n/**\n * Register a reference provider (used by e.g. reference search).\n */\n\nexport function registerReferenceProvider(languageId, provider) {\n  return modes.ReferenceProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a rename provider (used by e.g. rename symbol).\n */\n\nexport function registerRenameProvider(languageId, provider) {\n  return modes.RenameProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a signature help provider (used by e.g. parameter hints).\n */\n\nexport function registerSignatureHelpProvider(languageId, provider) {\n  return modes.SignatureHelpProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a hover provider (used by e.g. editor hover).\n */\n\nexport function registerHoverProvider(languageId, provider) {\n  return modes.HoverProviderRegistry.register(languageId, {\n    provideHover: function (model, position, token) {\n      var word = model.getWordAtPosition(position);\n      return Promise.resolve(provider.provideHover(model, position, token)).then(function (value) {\n        if (!value) {\n          return undefined;\n        }\n\n        if (!value.range && word) {\n          value.range = new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);\n        }\n\n        if (!value.range) {\n          value.range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);\n        }\n\n        return value;\n      });\n    }\n  });\n}\n/**\n * Register a document symbol provider (used by e.g. outline).\n */\n\nexport function registerDocumentSymbolProvider(languageId, provider) {\n  return modes.DocumentSymbolProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a document highlight provider (used by e.g. highlight occurrences).\n */\n\nexport function registerDocumentHighlightProvider(languageId, provider) {\n  return modes.DocumentHighlightProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a definition provider (used by e.g. go to definition).\n */\n\nexport function registerDefinitionProvider(languageId, provider) {\n  return modes.DefinitionProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a implementation provider (used by e.g. go to implementation).\n */\n\nexport function registerImplementationProvider(languageId, provider) {\n  return modes.ImplementationProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a type definition provider (used by e.g. go to type definition).\n */\n\nexport function registerTypeDefinitionProvider(languageId, provider) {\n  return modes.TypeDefinitionProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a code lens provider (used by e.g. inline code lenses).\n */\n\nexport function registerCodeLensProvider(languageId, provider) {\n  return modes.CodeLensProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a code action provider (used by e.g. quick fix).\n */\n\nexport function registerCodeActionProvider(languageId, provider) {\n  return modes.CodeActionProviderRegistry.register(languageId, {\n    provideCodeActions: function (model, range, context, token) {\n      var markers = StaticServices.markerService.get().read({\n        resource: model.uri\n      }).filter(function (m) {\n        return Range.areIntersectingOrTouching(m, range);\n      });\n      return provider.provideCodeActions(model, range, {\n        markers: markers,\n        only: context.only\n      }, token);\n    }\n  });\n}\n/**\n * Register a formatter that can handle only entire models.\n */\n\nexport function registerDocumentFormattingEditProvider(languageId, provider) {\n  return modes.DocumentFormattingEditProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a formatter that can handle a range inside a model.\n */\n\nexport function registerDocumentRangeFormattingEditProvider(languageId, provider) {\n  return modes.DocumentRangeFormattingEditProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a formatter than can do formatting as the user types.\n */\n\nexport function registerOnTypeFormattingEditProvider(languageId, provider) {\n  return modes.OnTypeFormattingEditProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a link provider that can find links in text.\n */\n\nexport function registerLinkProvider(languageId, provider) {\n  return modes.LinkProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a completion item provider (use by e.g. suggestions).\n */\n\nexport function registerCompletionItemProvider(languageId, provider) {\n  return modes.CompletionProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a document color provider (used by Color Picker, Color Decorator).\n */\n\nexport function registerColorProvider(languageId, provider) {\n  return modes.ColorProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a folding range provider\n */\n\nexport function registerFoldingRangeProvider(languageId, provider) {\n  return modes.FoldingRangeProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a declaration provider\n */\n\nexport function registerDeclarationProvider(languageId, provider) {\n  return modes.DeclarationProviderRegistry.register(languageId, provider);\n}\n/**\n * Register a selection range provider\n */\n\nexport function registerSelectionRangeProvider(languageId, provider) {\n  return modes.SelectionRangeRegistry.register(languageId, provider);\n}\n/**\n * @internal\n */\n\nexport function createMonacoLanguagesAPI() {\n  return {\n    register: register,\n    getLanguages: getLanguages,\n    onLanguage: onLanguage,\n    getEncodedLanguageId: getEncodedLanguageId,\n    // provider methods\n    setLanguageConfiguration: setLanguageConfiguration,\n    setTokensProvider: setTokensProvider,\n    setMonarchTokensProvider: setMonarchTokensProvider,\n    registerReferenceProvider: registerReferenceProvider,\n    registerRenameProvider: registerRenameProvider,\n    registerCompletionItemProvider: registerCompletionItemProvider,\n    registerSignatureHelpProvider: registerSignatureHelpProvider,\n    registerHoverProvider: registerHoverProvider,\n    registerDocumentSymbolProvider: registerDocumentSymbolProvider,\n    registerDocumentHighlightProvider: registerDocumentHighlightProvider,\n    registerDefinitionProvider: registerDefinitionProvider,\n    registerImplementationProvider: registerImplementationProvider,\n    registerTypeDefinitionProvider: registerTypeDefinitionProvider,\n    registerCodeLensProvider: registerCodeLensProvider,\n    registerCodeActionProvider: registerCodeActionProvider,\n    registerDocumentFormattingEditProvider: registerDocumentFormattingEditProvider,\n    registerDocumentRangeFormattingEditProvider: registerDocumentRangeFormattingEditProvider,\n    registerOnTypeFormattingEditProvider: registerOnTypeFormattingEditProvider,\n    registerLinkProvider: registerLinkProvider,\n    registerColorProvider: registerColorProvider,\n    registerFoldingRangeProvider: registerFoldingRangeProvider,\n    registerDeclarationProvider: registerDeclarationProvider,\n    registerSelectionRangeProvider: registerSelectionRangeProvider,\n    // enums\n    DocumentHighlightKind: standaloneEnums.DocumentHighlightKind,\n    CompletionItemKind: standaloneEnums.CompletionItemKind,\n    CompletionItemTag: standaloneEnums.CompletionItemTag,\n    CompletionItemInsertTextRule: standaloneEnums.CompletionItemInsertTextRule,\n    SymbolKind: standaloneEnums.SymbolKind,\n    SymbolTag: standaloneEnums.SymbolTag,\n    IndentAction: standaloneEnums.IndentAction,\n    CompletionTriggerKind: standaloneEnums.CompletionTriggerKind,\n    SignatureHelpTriggerKind: standaloneEnums.SignatureHelpTriggerKind,\n    // classes\n    FoldingRangeKind: modes.FoldingRangeKind\n  };\n}","map":null,"metadata":{},"sourceType":"module"}