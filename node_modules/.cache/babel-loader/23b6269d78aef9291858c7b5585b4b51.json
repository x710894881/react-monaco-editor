{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { FoldingRegions } from './foldingRanges.js';\n\nvar FoldingModel =\n/** @class */\nfunction () {\n  function FoldingModel(textModel, decorationProvider) {\n    this._updateEventEmitter = new Emitter();\n    this.onDidChange = this._updateEventEmitter.event;\n    this._textModel = textModel;\n    this._decorationProvider = decorationProvider;\n    this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n    this._editorDecorationIds = [];\n    this._isInitialized = false;\n  }\n\n  Object.defineProperty(FoldingModel.prototype, \"regions\", {\n    get: function () {\n      return this._regions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FoldingModel.prototype, \"textModel\", {\n    get: function () {\n      return this._textModel;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FoldingModel.prototype, \"isInitialized\", {\n    get: function () {\n      return this._isInitialized;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FoldingModel.prototype.toggleCollapseState = function (regions) {\n    var _this = this;\n\n    if (!regions.length) {\n      return;\n    }\n\n    var processed = {};\n\n    this._decorationProvider.changeDecorations(function (accessor) {\n      for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {\n        var region = regions_1[_i];\n        var index = region.regionIndex;\n        var editorDecorationId = _this._editorDecorationIds[index];\n\n        if (editorDecorationId && !processed[editorDecorationId]) {\n          processed[editorDecorationId] = true;\n          var newCollapseState = !_this._regions.isCollapsed(index);\n\n          _this._regions.setCollapsed(index, newCollapseState);\n\n          accessor.changeDecorationOptions(editorDecorationId, _this._decorationProvider.getDecorationOption(newCollapseState));\n        }\n      }\n    });\n\n    this._updateEventEmitter.fire({\n      model: this,\n      collapseStateChanged: regions\n    });\n  };\n\n  FoldingModel.prototype.update = function (newRegions, blockedLineNumers) {\n    var _this = this;\n\n    if (blockedLineNumers === void 0) {\n      blockedLineNumers = [];\n    }\n\n    var newEditorDecorations = [];\n\n    var isBlocked = function (startLineNumber, endLineNumber) {\n      for (var _i = 0, blockedLineNumers_1 = blockedLineNumers; _i < blockedLineNumers_1.length; _i++) {\n        var blockedLineNumber = blockedLineNumers_1[_i];\n\n        if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {\n          // first line is visible\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    var initRange = function (index, isCollapsed) {\n      var startLineNumber = newRegions.getStartLineNumber(index);\n\n      if (isCollapsed && isBlocked(startLineNumber, newRegions.getEndLineNumber(index))) {\n        isCollapsed = false;\n      }\n\n      newRegions.setCollapsed(index, isCollapsed);\n\n      var maxColumn = _this._textModel.getLineMaxColumn(startLineNumber);\n\n      var decorationRange = {\n        startLineNumber: startLineNumber,\n        startColumn: maxColumn,\n        endLineNumber: startLineNumber,\n        endColumn: maxColumn\n      };\n      newEditorDecorations.push({\n        range: decorationRange,\n        options: _this._decorationProvider.getDecorationOption(isCollapsed)\n      });\n    };\n\n    var i = 0;\n\n    var nextCollapsed = function () {\n      while (i < _this._regions.length) {\n        var isCollapsed = _this._regions.isCollapsed(i);\n\n        i++;\n\n        if (isCollapsed) {\n          return i - 1;\n        }\n      }\n\n      return -1;\n    };\n\n    var k = 0;\n    var collapsedIndex = nextCollapsed();\n\n    while (collapsedIndex !== -1 && k < newRegions.length) {\n      // get the latest range\n      var decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\n\n      if (decRange) {\n        var collapsedStartLineNumber = decRange.startLineNumber;\n\n        if (this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.startColumn) {\n          // test that the decoration is still at the end otherwise it got deleted\n          while (k < newRegions.length) {\n            var startLineNumber = newRegions.getStartLineNumber(k);\n\n            if (collapsedStartLineNumber >= startLineNumber) {\n              initRange(k, collapsedStartLineNumber === startLineNumber);\n              k++;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n\n      collapsedIndex = nextCollapsed();\n    }\n\n    while (k < newRegions.length) {\n      initRange(k, false);\n      k++;\n    }\n\n    this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\n    this._regions = newRegions;\n    this._isInitialized = true;\n\n    this._updateEventEmitter.fire({\n      model: this\n    });\n  };\n  /**\n   * Collapse state memento, for persistence only\n   */\n\n\n  FoldingModel.prototype.getMemento = function () {\n    var collapsedRanges = [];\n\n    for (var i = 0; i < this._regions.length; i++) {\n      if (this._regions.isCollapsed(i)) {\n        var range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n\n        if (range) {\n          var startLineNumber = range.startLineNumber;\n\n          var endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\n\n          collapsedRanges.push({\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber\n          });\n        }\n      }\n    }\n\n    if (collapsedRanges.length > 0) {\n      return collapsedRanges;\n    }\n\n    return undefined;\n  };\n  /**\n   * Apply persisted state, for persistence only\n   */\n\n\n  FoldingModel.prototype.applyMemento = function (state) {\n    if (!Array.isArray(state)) {\n      return;\n    }\n\n    var toToogle = [];\n\n    for (var _i = 0, state_1 = state; _i < state_1.length; _i++) {\n      var range = state_1[_i];\n      var region = this.getRegionAtLine(range.startLineNumber);\n\n      if (region && !region.isCollapsed) {\n        toToogle.push(region);\n      }\n    }\n\n    this.toggleCollapseState(toToogle);\n  };\n\n  FoldingModel.prototype.dispose = function () {\n    this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\n  };\n\n  FoldingModel.prototype.getAllRegionsAtLine = function (lineNumber, filter) {\n    var result = [];\n\n    if (this._regions) {\n      var index = this._regions.findRange(lineNumber);\n\n      var level = 1;\n\n      while (index >= 0) {\n        var current = this._regions.toRegion(index);\n\n        if (!filter || filter(current, level)) {\n          result.push(current);\n        }\n\n        level++;\n        index = current.parentIndex;\n      }\n    }\n\n    return result;\n  };\n\n  FoldingModel.prototype.getRegionAtLine = function (lineNumber) {\n    if (this._regions) {\n      var index = this._regions.findRange(lineNumber);\n\n      if (index >= 0) {\n        return this._regions.toRegion(index);\n      }\n    }\n\n    return null;\n  };\n\n  FoldingModel.prototype.getRegionsInside = function (region, filter) {\n    var result = [];\n    var index = region ? region.regionIndex + 1 : 0;\n    var endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n\n    if (filter && filter.length === 2) {\n      var levelStack = [];\n\n      for (var i = index, len = this._regions.length; i < len; i++) {\n        var current = this._regions.toRegion(i);\n\n        if (this._regions.getStartLineNumber(i) < endLineNumber) {\n          while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n            levelStack.pop();\n          }\n\n          levelStack.push(current);\n\n          if (filter(current, levelStack.length)) {\n            result.push(current);\n          }\n        } else {\n          break;\n        }\n      }\n    } else {\n      for (var i = index, len = this._regions.length; i < len; i++) {\n        var current = this._regions.toRegion(i);\n\n        if (this._regions.getStartLineNumber(i) < endLineNumber) {\n          if (!filter || filter(current)) {\n            result.push(current);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n\n    return result;\n  };\n\n  return FoldingModel;\n}();\n\nexport { FoldingModel };\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Wheter to collase or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\n\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels, lineNumbers) {\n  if (levels === void 0) {\n    levels = Number.MAX_VALUE;\n  }\n\n  var toToggle = [];\n\n  if (lineNumbers && lineNumbers.length > 0) {\n    for (var _i = 0, lineNumbers_1 = lineNumbers; _i < lineNumbers_1.length; _i++) {\n      var lineNumber = lineNumbers_1[_i];\n      var region = foldingModel.getRegionAtLine(lineNumber);\n\n      if (region) {\n        if (region.isCollapsed !== doCollapse) {\n          toToggle.push(region);\n        }\n\n        if (levels > 1) {\n          var regionsInside = foldingModel.getRegionsInside(region, function (r, level) {\n            return r.isCollapsed !== doCollapse && level < levels;\n          });\n          toToggle.push.apply(toToggle, regionsInside);\n        }\n      }\n    }\n  } else {\n    var regionsInside = foldingModel.getRegionsInside(null, function (r, level) {\n      return r.isCollapsed !== doCollapse && level < levels;\n    });\n    toToggle.push.apply(toToggle, regionsInside);\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Wheter to collase or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\n\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n  var toToggle = [];\n\n  for (var _i = 0, lineNumbers_2 = lineNumbers; _i < lineNumbers_2.length; _i++) {\n    var lineNumber = lineNumbers_2[_i];\n    var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region, level) {\n      return region.isCollapsed !== doCollapse && level <= levels;\n    });\n    toToggle.push.apply(toToggle, regions);\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Wheter to collase or expand\n*/\n\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n  var filter = function (region, level) {\n    return level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(function (line) {\n      return region.containsLine(line);\n    });\n  };\n\n  var toToggle = foldingModel.getRegionsInside(null, filter);\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\n\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n  var editorModel = foldingModel.textModel;\n  var regions = foldingModel.regions;\n  var toToggle = [];\n\n  for (var i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i)) {\n      var startLineNumber = regions.getStartLineNumber(i);\n\n      if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n        toToggle.push(regions.toRegion(i));\n      }\n    }\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\n\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\n  var regions = foldingModel.regions;\n  var toToggle = [];\n\n  for (var i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n      toToggle.push(regions.toRegion(i));\n    }\n  }\n\n  foldingModel.toggleCollapseState(toToggle);\n}","map":null,"metadata":{},"sourceType":"module"}