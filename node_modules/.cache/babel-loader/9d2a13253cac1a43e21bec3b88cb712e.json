{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport './bracketMatching.css';\nimport * as nls from '../../../nls.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution } from '../../browser/editorExtensions.js';\nimport { Position } from '../../common/core/position.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { EditorContextKeys } from '../../common/editorContextKeys.js';\nimport { OverviewRulerLane } from '../../common/model.js';\nimport { ModelDecorationOptions } from '../../common/model/textModel.js';\nimport { editorBracketMatchBackground, editorBracketMatchBorder } from '../../common/view/editorColorRegistry.js';\nimport { registerColor } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant, themeColorFromId } from '../../../platform/theme/common/themeService.js';\nimport { MenuRegistry } from '../../../platform/actions/common/actions.js';\nvar overviewRulerBracketMatchForeground = registerColor('editorOverviewRuler.bracketMatchForeground', {\n  dark: '#A0A0A0',\n  light: '#A0A0A0',\n  hc: '#A0A0A0'\n}, nls.localize('overviewRulerBracketMatchForeground', 'Overview ruler marker color for matching brackets.'));\n\nvar JumpToBracketAction =\n/** @class */\nfunction (_super) {\n  __extends(JumpToBracketAction, _super);\n\n  function JumpToBracketAction() {\n    return _super.call(this, {\n      id: 'editor.action.jumpToBracket',\n      label: nls.localize('smartSelect.jumpBracket', \"Go to Bracket\"),\n      alias: 'Go to Bracket',\n      precondition: undefined,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 2048\n        /* CtrlCmd */\n        | 1024\n        /* Shift */\n        | 88\n        /* US_BACKSLASH */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  JumpToBracketAction.prototype.run = function (accessor, editor) {\n    var controller = BracketMatchingController.get(editor);\n\n    if (!controller) {\n      return;\n    }\n\n    controller.jumpToBracket();\n  };\n\n  return JumpToBracketAction;\n}(EditorAction);\n\nvar SelectToBracketAction =\n/** @class */\nfunction (_super) {\n  __extends(SelectToBracketAction, _super);\n\n  function SelectToBracketAction() {\n    return _super.call(this, {\n      id: 'editor.action.selectToBracket',\n      label: nls.localize('smartSelect.selectToBracket', \"Select to Bracket\"),\n      alias: 'Select to Bracket',\n      precondition: undefined\n    }) || this;\n  }\n\n  SelectToBracketAction.prototype.run = function (accessor, editor) {\n    var controller = BracketMatchingController.get(editor);\n\n    if (!controller) {\n      return;\n    }\n\n    controller.selectToBracket();\n  };\n\n  return SelectToBracketAction;\n}(EditorAction);\n\nvar BracketsData =\n/** @class */\nfunction () {\n  function BracketsData(position, brackets) {\n    this.position = position;\n    this.brackets = brackets;\n  }\n\n  return BracketsData;\n}();\n\nvar BracketMatchingController =\n/** @class */\nfunction (_super) {\n  __extends(BracketMatchingController, _super);\n\n  function BracketMatchingController(editor) {\n    var _this = _super.call(this) || this;\n\n    _this._editor = editor;\n    _this._lastBracketsData = [];\n    _this._lastVersionId = 0;\n    _this._decorations = [];\n    _this._updateBracketsSoon = _this._register(new RunOnceScheduler(function () {\n      return _this._updateBrackets();\n    }, 50));\n    _this._matchBrackets = _this._editor.getConfiguration().contribInfo.matchBrackets;\n\n    _this._updateBracketsSoon.schedule();\n\n    _this._register(editor.onDidChangeCursorPosition(function (e) {\n      if (!_this._matchBrackets) {\n        // Early exit if nothing needs to be done!\n        // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\n        return;\n      }\n\n      _this._updateBracketsSoon.schedule();\n    }));\n\n    _this._register(editor.onDidChangeModelContent(function (e) {\n      _this._updateBracketsSoon.schedule();\n    }));\n\n    _this._register(editor.onDidChangeModel(function (e) {\n      _this._lastBracketsData = [];\n      _this._decorations = [];\n\n      _this._updateBracketsSoon.schedule();\n    }));\n\n    _this._register(editor.onDidChangeModelLanguageConfiguration(function (e) {\n      _this._lastBracketsData = [];\n\n      _this._updateBracketsSoon.schedule();\n    }));\n\n    _this._register(editor.onDidChangeConfiguration(function (e) {\n      _this._matchBrackets = _this._editor.getConfiguration().contribInfo.matchBrackets;\n\n      if (!_this._matchBrackets && _this._decorations.length > 0) {\n        // Remove existing decorations if bracket matching is off\n        _this._decorations = _this._editor.deltaDecorations(_this._decorations, []);\n      }\n\n      _this._updateBracketsSoon.schedule();\n    }));\n\n    return _this;\n  }\n\n  BracketMatchingController.get = function (editor) {\n    return editor.getContribution(BracketMatchingController.ID);\n  };\n\n  BracketMatchingController.prototype.getId = function () {\n    return BracketMatchingController.ID;\n  };\n\n  BracketMatchingController.prototype.jumpToBracket = function () {\n    if (!this._editor.hasModel()) {\n      return;\n    }\n\n    var model = this._editor.getModel();\n\n    var newSelections = this._editor.getSelections().map(function (selection) {\n      var position = selection.getStartPosition(); // find matching brackets if position is on a bracket\n\n      var brackets = model.matchBracket(position);\n      var newCursorPosition = null;\n\n      if (brackets) {\n        if (brackets[0].containsPosition(position)) {\n          newCursorPosition = brackets[1].getStartPosition();\n        } else if (brackets[1].containsPosition(position)) {\n          newCursorPosition = brackets[0].getStartPosition();\n        }\n      } else {\n        // find the next bracket if the position isn't on a matching bracket\n        var nextBracket = model.findNextBracket(position);\n\n        if (nextBracket && nextBracket.range) {\n          newCursorPosition = nextBracket.range.getStartPosition();\n        }\n      }\n\n      if (newCursorPosition) {\n        return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);\n      }\n\n      return new Selection(position.lineNumber, position.column, position.lineNumber, position.column);\n    });\n\n    this._editor.setSelections(newSelections);\n\n    this._editor.revealRange(newSelections[0]);\n  };\n\n  BracketMatchingController.prototype.selectToBracket = function () {\n    if (!this._editor.hasModel()) {\n      return;\n    }\n\n    var model = this._editor.getModel();\n\n    var newSelections = [];\n\n    this._editor.getSelections().forEach(function (selection) {\n      var position = selection.getStartPosition();\n      var brackets = model.matchBracket(position);\n      var openBracket = null;\n      var closeBracket = null;\n\n      if (!brackets) {\n        var nextBracket = model.findNextBracket(position);\n\n        if (nextBracket && nextBracket.range) {\n          brackets = model.matchBracket(nextBracket.range.getStartPosition());\n        }\n      }\n\n      if (brackets) {\n        if (brackets[0].startLineNumber === brackets[1].startLineNumber) {\n          openBracket = brackets[1].startColumn < brackets[0].startColumn ? brackets[1].getStartPosition() : brackets[0].getStartPosition();\n          closeBracket = brackets[1].startColumn < brackets[0].startColumn ? brackets[0].getEndPosition() : brackets[1].getEndPosition();\n        } else {\n          openBracket = brackets[1].startLineNumber < brackets[0].startLineNumber ? brackets[1].getStartPosition() : brackets[0].getStartPosition();\n          closeBracket = brackets[1].startLineNumber < brackets[0].startLineNumber ? brackets[0].getEndPosition() : brackets[1].getEndPosition();\n        }\n      }\n\n      if (openBracket && closeBracket) {\n        newSelections.push(new Selection(openBracket.lineNumber, openBracket.column, closeBracket.lineNumber, closeBracket.column));\n      }\n    });\n\n    if (newSelections.length > 0) {\n      this._editor.setSelections(newSelections);\n\n      this._editor.revealRange(newSelections[0]);\n    }\n  };\n\n  BracketMatchingController.prototype._updateBrackets = function () {\n    if (!this._matchBrackets) {\n      return;\n    }\n\n    this._recomputeBrackets();\n\n    var newDecorations = [],\n        newDecorationsLen = 0;\n\n    for (var i = 0, len = this._lastBracketsData.length; i < len; i++) {\n      var brackets = this._lastBracketsData[i].brackets;\n\n      if (brackets) {\n        newDecorations[newDecorationsLen++] = {\n          range: brackets[0],\n          options: BracketMatchingController._DECORATION_OPTIONS\n        };\n        newDecorations[newDecorationsLen++] = {\n          range: brackets[1],\n          options: BracketMatchingController._DECORATION_OPTIONS\n        };\n      }\n    }\n\n    this._decorations = this._editor.deltaDecorations(this._decorations, newDecorations);\n  };\n\n  BracketMatchingController.prototype._recomputeBrackets = function () {\n    if (!this._editor.hasModel()) {\n      // no model => no brackets!\n      this._lastBracketsData = [];\n      this._lastVersionId = 0;\n      return;\n    }\n\n    var model = this._editor.getModel();\n\n    var versionId = model.getVersionId();\n    var previousData = [];\n\n    if (this._lastVersionId === versionId) {\n      // use the previous data only if the model is at the same version id\n      previousData = this._lastBracketsData;\n    }\n\n    var selections = this._editor.getSelections();\n\n    var positions = [],\n        positionsLen = 0;\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n\n      if (selection.isEmpty()) {\n        // will bracket match a cursor only if the selection is collapsed\n        positions[positionsLen++] = selection.getStartPosition();\n      }\n    } // sort positions for `previousData` cache hits\n\n\n    if (positions.length > 1) {\n      positions.sort(Position.compare);\n    }\n\n    var newData = [],\n        newDataLen = 0;\n    var previousIndex = 0,\n        previousLen = previousData.length;\n\n    for (var i = 0, len = positions.length; i < len; i++) {\n      var position = positions[i];\n\n      while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) {\n        previousIndex++;\n      }\n\n      if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) {\n        newData[newDataLen++] = previousData[previousIndex];\n      } else {\n        var brackets = model.matchBracket(position);\n        newData[newDataLen++] = new BracketsData(position, brackets);\n      }\n    }\n\n    this._lastBracketsData = newData;\n    this._lastVersionId = versionId;\n  };\n\n  BracketMatchingController.ID = 'editor.contrib.bracketMatchingController';\n  BracketMatchingController._DECORATION_OPTIONS = ModelDecorationOptions.register({\n    stickiness: 1\n    /* NeverGrowsWhenTypingAtEdges */\n    ,\n    className: 'bracket-match',\n    overviewRuler: {\n      color: themeColorFromId(overviewRulerBracketMatchForeground),\n      position: OverviewRulerLane.Center\n    }\n  });\n  return BracketMatchingController;\n}(Disposable);\n\nexport { BracketMatchingController };\nregisterEditorContribution(BracketMatchingController);\nregisterEditorAction(SelectToBracketAction);\nregisterEditorAction(JumpToBracketAction);\nregisterThemingParticipant(function (theme, collector) {\n  var bracketMatchBackground = theme.getColor(editorBracketMatchBackground);\n\n  if (bracketMatchBackground) {\n    collector.addRule(\".monaco-editor .bracket-match { background-color: \" + bracketMatchBackground + \"; }\");\n  }\n\n  var bracketMatchBorder = theme.getColor(editorBracketMatchBorder);\n\n  if (bracketMatchBorder) {\n    collector.addRule(\".monaco-editor .bracket-match { border: 1px solid \" + bracketMatchBorder + \"; }\");\n  }\n}); // Go to menu\n\nMenuRegistry.appendMenuItem(16\n/* MenubarGoMenu */\n, {\n  group: '5_infile_nav',\n  command: {\n    id: 'editor.action.jumpToBracket',\n    title: nls.localize({\n      key: 'miGoToBracket',\n      comment: ['&& denotes a mnemonic']\n    }, \"Go to &&Bracket\")\n  },\n  order: 2\n});","map":null,"metadata":{},"sourceType":"module"}