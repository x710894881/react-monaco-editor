{"ast":null,"code":"/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail(array, n) {\n  if (n === void 0) {\n    n = 0;\n  }\n\n  return array[array.length - (1 + n)];\n}\nexport function tail2(arr) {\n  if (arr.length === 0) {\n    throw new Error('Invalid tail call');\n  }\n\n  return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\nexport function equals(one, other, itemEquals) {\n  if (itemEquals === void 0) {\n    itemEquals = function (a, b) {\n      return a === b;\n    };\n  }\n\n  if (one === other) {\n    return true;\n  }\n\n  if (!one || !other) {\n    return false;\n  }\n\n  if (one.length !== other.length) {\n    return false;\n  }\n\n  for (var i = 0, len = one.length; i < len; i++) {\n    if (!itemEquals(one[i], other[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function binarySearch(array, key, comparator) {\n  var low = 0,\n      high = array.length - 1;\n\n  while (low <= high) {\n    var mid = (low + high) / 2 | 0;\n    var comp = comparator(array[mid], key);\n\n    if (comp < 0) {\n      low = mid + 1;\n    } else if (comp > 0) {\n      high = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -(low + 1);\n}\n/**\n * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\n * are located before all elements where p(x) is true.\n * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\n */\n\nexport function findFirstInSorted(array, p) {\n  var low = 0,\n      high = array.length;\n\n  if (high === 0) {\n    return 0; // no children\n  }\n\n  while (low < high) {\n    var mid = Math.floor((low + high) / 2);\n\n    if (p(array[mid])) {\n      high = mid;\n    } else {\n      low = mid + 1;\n    }\n  }\n\n  return low;\n}\n/**\n * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`\n * so only use this when actually needing stable sort.\n */\n\nexport function mergeSort(data, compare) {\n  _sort(data, compare, 0, data.length - 1, []);\n\n  return data;\n}\n\nfunction _merge(a, compare, lo, mid, hi, aux) {\n  var leftIdx = lo,\n      rightIdx = mid + 1;\n\n  for (var i = lo; i <= hi; i++) {\n    aux[i] = a[i];\n  }\n\n  for (var i = lo; i <= hi; i++) {\n    if (leftIdx > mid) {\n      // left side consumed\n      a[i] = aux[rightIdx++];\n    } else if (rightIdx > hi) {\n      // right side consumed\n      a[i] = aux[leftIdx++];\n    } else if (compare(aux[rightIdx], aux[leftIdx]) < 0) {\n      // right element is less -> comes first\n      a[i] = aux[rightIdx++];\n    } else {\n      // left element comes first (less or equal)\n      a[i] = aux[leftIdx++];\n    }\n  }\n}\n\nfunction _sort(a, compare, lo, hi, aux) {\n  if (hi <= lo) {\n    return;\n  }\n\n  var mid = lo + (hi - lo) / 2 | 0;\n\n  _sort(a, compare, lo, mid, aux);\n\n  _sort(a, compare, mid + 1, hi, aux);\n\n  if (compare(a[mid], a[mid + 1]) <= 0) {\n    // left and right are sorted and if the last-left element is less\n    // or equals than the first-right element there is nothing else\n    // to do\n    return;\n  }\n\n  _merge(a, compare, lo, mid, hi, aux);\n}\n\nexport function groupBy(data, compare) {\n  var result = [];\n  var currentGroup = undefined;\n\n  for (var _i = 0, _a = mergeSort(data.slice(0), compare); _i < _a.length; _i++) {\n    var element = _a[_i];\n\n    if (!currentGroup || compare(currentGroup[0], element) !== 0) {\n      currentGroup = [element];\n      result.push(currentGroup);\n    } else {\n      currentGroup.push(element);\n    }\n  }\n\n  return result;\n}\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\n\nexport function coalesce(array) {\n  return array.filter(function (e) {\n    return !!e;\n  });\n}\n/**\n * @returns false if the provided object is an array and not empty.\n */\n\nexport function isFalsyOrEmpty(obj) {\n  return !Array.isArray(obj) || obj.length === 0;\n}\nexport function isNonEmptyArray(obj) {\n  return Array.isArray(obj) && obj.length > 0;\n}\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equalness by returning a unique string for each.\n */\n\nexport function distinct(array, keyFn) {\n  if (!keyFn) {\n    return array.filter(function (element, position) {\n      return array.indexOf(element) === position;\n    });\n  }\n\n  var seen = Object.create(null);\n  return array.filter(function (elem) {\n    var key = keyFn(elem);\n\n    if (seen[key]) {\n      return false;\n    }\n\n    seen[key] = true;\n    return true;\n  });\n}\nexport function distinctES6(array) {\n  var seen = new Set();\n  return array.filter(function (element) {\n    if (seen.has(element)) {\n      return false;\n    }\n\n    seen.add(element);\n    return true;\n  });\n}\nexport function firstIndex(array, fn) {\n  for (var i = 0; i < array.length; i++) {\n    var element = array[i];\n\n    if (fn(element)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\nexport function first(array, fn, notFoundValue) {\n  if (notFoundValue === void 0) {\n    notFoundValue = undefined;\n  }\n\n  var index = firstIndex(array, fn);\n  return index < 0 ? notFoundValue : array[index];\n}\nexport function flatten(arr) {\n  var _a;\n\n  return (_a = []).concat.apply(_a, arr);\n}\nexport function range(arg, to) {\n  var from = typeof to === 'number' ? arg : 0;\n\n  if (typeof to === 'number') {\n    from = arg;\n  } else {\n    from = 0;\n    to = arg;\n  }\n\n  var result = [];\n\n  if (from <= to) {\n    for (var i = from; i < to; i++) {\n      result.push(i);\n    }\n  } else {\n    for (var i = from; i > to; i--) {\n      result.push(i);\n    }\n  }\n\n  return result;\n}\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\n\nexport function arrayInsert(target, insertIndex, insertArr) {\n  var before = target.slice(0, insertIndex);\n  var after = target.slice(insertIndex);\n  return before.concat(insertArr, after);\n}\n/**\n * Pushes an element to the start of the array, if found.\n */\n\nexport function pushToStart(arr, value) {\n  var index = arr.indexOf(value);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n    arr.unshift(value);\n  }\n}\n/**\n * Pushes an element to the end of the array, if found.\n */\n\nexport function pushToEnd(arr, value) {\n  var index = arr.indexOf(value);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n    arr.push(value);\n  }\n}\nexport function asArray(x) {\n  return Array.isArray(x) ? x : [x];\n}","map":null,"metadata":{},"sourceType":"module"}