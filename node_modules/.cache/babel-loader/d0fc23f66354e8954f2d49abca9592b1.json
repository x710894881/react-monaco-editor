{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function isFuzzyActionArr(what) {\n  return Array.isArray(what);\n}\nexport function isFuzzyAction(what) {\n  return !isFuzzyActionArr(what);\n}\nexport function isString(what) {\n  return typeof what === 'string';\n}\nexport function isIAction(what) {\n  return !isString(what);\n} // Small helper functions\n\n/**\n * Is a string null, undefined, or empty?\n */\n\nexport function empty(s) {\n  return s ? false : true;\n}\n/**\n * Puts a string to lower case if 'ignoreCase' is set.\n */\n\nexport function fixCase(lexer, str) {\n  return lexer.ignoreCase && str ? str.toLowerCase() : str;\n}\n/**\n * Ensures there are no bad characters in a CSS token class.\n */\n\nexport function sanitize(s) {\n  return s.replace(/[&<>'\"_]/g, '-'); // used on all output token CSS classes\n} // Logging\n\n/**\n * Logs a message.\n */\n\nexport function log(lexer, msg) {\n  console.log(lexer.languageId + \": \" + msg);\n} // Throwing errors\n\nexport function createError(lexer, msg) {\n  return new Error(lexer.languageId + \": \" + msg);\n} // Helper functions for rule finding and substitution\n\n/**\n * substituteMatches is used on lexer strings and can substitutes predefined patterns:\n * \t\t$$  => $\n * \t\t$#  => id\n * \t\t$n  => matched entry n\n * \t\t@attr => contents of lexer[attr]\n *\n * See documentation for more info\n */\n\nexport function substituteMatches(lexer, str, id, matches, state) {\n  var re = /\\$((\\$)|(#)|(\\d\\d?)|[sS](\\d\\d?)|@(\\w+))/g;\n  var stateMatches = null;\n  return str.replace(re, function (full, sub, dollar, hash, n, s, attr, ofs, total) {\n    if (!empty(dollar)) {\n      return '$'; // $$\n    }\n\n    if (!empty(hash)) {\n      return fixCase(lexer, id); // default $#\n    }\n\n    if (!empty(n) && n < matches.length) {\n      return fixCase(lexer, matches[n]); // $n\n    }\n\n    if (!empty(attr) && lexer && typeof lexer[attr] === 'string') {\n      return lexer[attr]; //@attribute\n    }\n\n    if (stateMatches === null) {\n      // split state on demand\n      stateMatches = state.split('.');\n      stateMatches.unshift(state);\n    }\n\n    if (!empty(s) && s < stateMatches.length) {\n      return fixCase(lexer, stateMatches[s]); //$Sn\n    }\n\n    return '';\n  });\n}\n/**\n * Find the tokenizer rules for a specific state (i.e. next action)\n */\n\nexport function findRules(lexer, inState) {\n  var state = inState;\n\n  while (state && state.length > 0) {\n    var rules = lexer.tokenizer[state];\n\n    if (rules) {\n      return rules;\n    }\n\n    var idx = state.lastIndexOf('.');\n\n    if (idx < 0) {\n      state = null; // no further parent\n    } else {\n      state = state.substr(0, idx);\n    }\n  }\n\n  return null;\n}\n/**\n * Is a certain state defined? In contrast to 'findRules' this works on a ILexerMin.\n * This is used during compilation where we may know the defined states\n * but not yet whether the corresponding rules are correct.\n */\n\nexport function stateExists(lexer, inState) {\n  var state = inState;\n\n  while (state && state.length > 0) {\n    var exist = lexer.stateNames[state];\n\n    if (exist) {\n      return true;\n    }\n\n    var idx = state.lastIndexOf('.');\n\n    if (idx < 0) {\n      state = null; // no further parent\n    } else {\n      state = state.substr(0, idx);\n    }\n  }\n\n  return false;\n}","map":null,"metadata":{},"sourceType":"module"}