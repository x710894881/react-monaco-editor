{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/*\n * This module only exports 'compile' which compiles a JSON language definition\n * into a typed and checked ILexer definition.\n */\nimport * as monarchCommon from './monarchCommon.js';\n/*\n * Type helpers\n *\n * Note: this is just for sanity checks on the JSON description which is\n * helpful for the programmer. No checks are done anymore once the lexer is\n * already 'compiled and checked'.\n *\n */\n\nfunction isArrayOf(elemType, obj) {\n  if (!obj) {\n    return false;\n  }\n\n  if (!Array.isArray(obj)) {\n    return false;\n  }\n\n  for (var _i = 0, obj_1 = obj; _i < obj_1.length; _i++) {\n    var el = obj_1[_i];\n\n    if (!elemType(el)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction bool(prop, defValue) {\n  if (typeof prop === 'boolean') {\n    return prop;\n  }\n\n  return defValue;\n}\n\nfunction string(prop, defValue) {\n  if (typeof prop === 'string') {\n    return prop;\n  }\n\n  return defValue;\n}\n\nfunction arrayToHash(array) {\n  var result = {};\n\n  for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n    var e = array_1[_i];\n    result[e] = true;\n  }\n\n  return result;\n}\n\nfunction createKeywordMatcher(arr, caseInsensitive) {\n  if (caseInsensitive === void 0) {\n    caseInsensitive = false;\n  }\n\n  if (caseInsensitive) {\n    arr = arr.map(function (x) {\n      return x.toLowerCase();\n    });\n  }\n\n  var hash = arrayToHash(arr);\n\n  if (caseInsensitive) {\n    return function (word) {\n      return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());\n    };\n  } else {\n    return function (word) {\n      return hash[word] !== undefined && hash.hasOwnProperty(word);\n    };\n  }\n} // Lexer helpers\n\n/**\n * Compiles a regular expression string, adding the 'i' flag if 'ignoreCase' is set.\n * Also replaces @\\w+ or sequences with the content of the specified attribute\n */\n\n\nfunction compileRegExp(lexer, str) {\n  var n = 0;\n\n  while (str.indexOf('@') >= 0 && n < 5) {\n    // at most 5 expansions\n    n++;\n    str = str.replace(/@(\\w+)/g, function (s, attr) {\n      var sub = '';\n\n      if (typeof lexer[attr] === 'string') {\n        sub = lexer[attr];\n      } else if (lexer[attr] && lexer[attr] instanceof RegExp) {\n        sub = lexer[attr].source;\n      } else {\n        if (lexer[attr] === undefined) {\n          throw monarchCommon.createError(lexer, 'language definition does not contain attribute \\'' + attr + '\\', used at: ' + str);\n        } else {\n          throw monarchCommon.createError(lexer, 'attribute reference \\'' + attr + '\\' must be a string, used at: ' + str);\n        }\n      }\n\n      return monarchCommon.empty(sub) ? '' : '(?:' + sub + ')';\n    });\n  }\n\n  return new RegExp(str, lexer.ignoreCase ? 'i' : '');\n}\n/**\n * Compiles guard functions for case matches.\n * This compiles 'cases' attributes into efficient match functions.\n *\n */\n\n\nfunction selectScrutinee(id, matches, state, num) {\n  if (num < 0) {\n    return id;\n  }\n\n  if (num < matches.length) {\n    return matches[num];\n  }\n\n  if (num >= 100) {\n    num = num - 100;\n    var parts = state.split('.');\n    parts.unshift(state);\n\n    if (num < parts.length) {\n      return parts[num];\n    }\n  }\n\n  return null;\n}\n\nfunction createGuard(lexer, ruleName, tkey, val) {\n  // get the scrutinee and pattern\n  var scrut = -1; // -1: $!, 0-99: $n, 100+n: $Sn\n\n  var oppat = tkey;\n  var matches = tkey.match(/^\\$(([sS]?)(\\d\\d?)|#)(.*)$/);\n\n  if (matches) {\n    if (matches[3]) {\n      // if digits\n      scrut = parseInt(matches[3]);\n\n      if (matches[2]) {\n        scrut = scrut + 100; // if [sS] present\n      }\n    }\n\n    oppat = matches[4];\n  } // get operator\n\n\n  var op = '~';\n  var pat = oppat;\n\n  if (!oppat || oppat.length === 0) {\n    op = '!=';\n    pat = '';\n  } else if (/^\\w*$/.test(pat)) {\n    // just a word\n    op = '==';\n  } else {\n    matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);\n\n    if (matches) {\n      op = matches[1];\n      pat = matches[2];\n    }\n  } // set the tester function\n\n\n  var tester; // special case a regexp that matches just words\n\n  if ((op === '~' || op === '!~') && /^(\\w|\\|)*$/.test(pat)) {\n    var inWords_1 = createKeywordMatcher(pat.split('|'), lexer.ignoreCase);\n\n    tester = function (s) {\n      return op === '~' ? inWords_1(s) : !inWords_1(s);\n    };\n  } else if (op === '@' || op === '!@') {\n    var words = lexer[pat];\n\n    if (!words) {\n      throw monarchCommon.createError(lexer, 'the @ match target \\'' + pat + '\\' is not defined, in rule: ' + ruleName);\n    }\n\n    if (!isArrayOf(function (elem) {\n      return typeof elem === 'string';\n    }, words)) {\n      throw monarchCommon.createError(lexer, 'the @ match target \\'' + pat + '\\' must be an array of strings, in rule: ' + ruleName);\n    }\n\n    var inWords_2 = createKeywordMatcher(words, lexer.ignoreCase);\n\n    tester = function (s) {\n      return op === '@' ? inWords_2(s) : !inWords_2(s);\n    };\n  } else if (op === '~' || op === '!~') {\n    if (pat.indexOf('$') < 0) {\n      // precompile regular expression\n      var re_1 = compileRegExp(lexer, '^' + pat + '$');\n\n      tester = function (s) {\n        return op === '~' ? re_1.test(s) : !re_1.test(s);\n      };\n    } else {\n      tester = function (s, id, matches, state) {\n        var re = compileRegExp(lexer, '^' + monarchCommon.substituteMatches(lexer, pat, id, matches, state) + '$');\n        return re.test(s);\n      };\n    }\n  } else {\n    // if (op==='==' || op==='!=') {\n    if (pat.indexOf('$') < 0) {\n      var patx_1 = monarchCommon.fixCase(lexer, pat);\n\n      tester = function (s) {\n        return op === '==' ? s === patx_1 : s !== patx_1;\n      };\n    } else {\n      var patx_2 = monarchCommon.fixCase(lexer, pat);\n\n      tester = function (s, id, matches, state, eos) {\n        var patexp = monarchCommon.substituteMatches(lexer, patx_2, id, matches, state);\n        return op === '==' ? s === patexp : s !== patexp;\n      };\n    }\n  } // return the branch object\n\n\n  if (scrut === -1) {\n    return {\n      name: tkey,\n      value: val,\n      test: function (id, matches, state, eos) {\n        return tester(id, id, matches, state, eos);\n      }\n    };\n  } else {\n    return {\n      name: tkey,\n      value: val,\n      test: function (id, matches, state, eos) {\n        var scrutinee = selectScrutinee(id, matches, state, scrut);\n        return tester(!scrutinee ? '' : scrutinee, id, matches, state, eos);\n      }\n    };\n  }\n}\n/**\n * Compiles an action: i.e. optimize regular expressions and case matches\n * and do many sanity checks.\n *\n * This is called only during compilation but if the lexer definition\n * contains user functions as actions (which is usually not allowed), then this\n * may be called during lexing. It is important therefore to compile common cases efficiently\n */\n\n\nfunction compileAction(lexer, ruleName, action) {\n  if (!action) {\n    return {\n      token: ''\n    };\n  } else if (typeof action === 'string') {\n    return action; // { token: action };\n  } else if (action.token || action.token === '') {\n    if (typeof action.token !== 'string') {\n      throw monarchCommon.createError(lexer, 'a \\'token\\' attribute must be of type string, in rule: ' + ruleName);\n    } else {\n      // only copy specific typed fields (only happens once during compile Lexer)\n      var newAction = {\n        token: action.token\n      };\n\n      if (action.token.indexOf('$') >= 0) {\n        newAction.tokenSubst = true;\n      }\n\n      if (typeof action.bracket === 'string') {\n        if (action.bracket === '@open') {\n          newAction.bracket = 1\n          /* Open */\n          ;\n        } else if (action.bracket === '@close') {\n          newAction.bracket = -1\n          /* Close */\n          ;\n        } else {\n          throw monarchCommon.createError(lexer, 'a \\'bracket\\' attribute must be either \\'@open\\' or \\'@close\\', in rule: ' + ruleName);\n        }\n      }\n\n      if (action.next) {\n        if (typeof action.next !== 'string') {\n          throw monarchCommon.createError(lexer, 'the next state must be a string value in rule: ' + ruleName);\n        } else {\n          var next = action.next;\n\n          if (!/^(@pop|@push|@popall)$/.test(next)) {\n            if (next[0] === '@') {\n              next = next.substr(1); // peel off starting @ sign\n            }\n\n            if (next.indexOf('$') < 0) {\n              // no dollar substitution, we can check if the state exists\n              if (!monarchCommon.stateExists(lexer, monarchCommon.substituteMatches(lexer, next, '', [], ''))) {\n                throw monarchCommon.createError(lexer, 'the next state \\'' + action.next + '\\' is not defined in rule: ' + ruleName);\n              }\n            }\n          }\n\n          newAction.next = next;\n        }\n      }\n\n      if (typeof action.goBack === 'number') {\n        newAction.goBack = action.goBack;\n      }\n\n      if (typeof action.switchTo === 'string') {\n        newAction.switchTo = action.switchTo;\n      }\n\n      if (typeof action.log === 'string') {\n        newAction.log = action.log;\n      }\n\n      if (typeof action.nextEmbedded === 'string') {\n        newAction.nextEmbedded = action.nextEmbedded;\n        lexer.usesEmbedded = true;\n      }\n\n      return newAction;\n    }\n  } else if (Array.isArray(action)) {\n    var results = [];\n\n    for (var i = 0, len = action.length; i < len; i++) {\n      results[i] = compileAction(lexer, ruleName, action[i]);\n    }\n\n    return {\n      group: results\n    };\n  } else if (action.cases) {\n    // build an array of test cases\n    var cases_1 = []; // for each case, push a test function and result value\n\n    for (var tkey in action.cases) {\n      if (action.cases.hasOwnProperty(tkey)) {\n        var val = compileAction(lexer, ruleName, action.cases[tkey]); // what kind of case\n\n        if (tkey === '@default' || tkey === '@' || tkey === '') {\n          cases_1.push({\n            test: undefined,\n            value: val,\n            name: tkey\n          });\n        } else if (tkey === '@eos') {\n          cases_1.push({\n            test: function (id, matches, state, eos) {\n              return eos;\n            },\n            value: val,\n            name: tkey\n          });\n        } else {\n          cases_1.push(createGuard(lexer, ruleName, tkey, val)); // call separate function to avoid local variable capture\n        }\n      }\n    } // create a matching function\n\n\n    var def_1 = lexer.defaultToken;\n    return {\n      test: function (id, matches, state, eos) {\n        for (var _i = 0, cases_2 = cases_1; _i < cases_2.length; _i++) {\n          var _case = cases_2[_i];\n\n          var didmatch = !_case.test || _case.test(id, matches, state, eos);\n\n          if (didmatch) {\n            return _case.value;\n          }\n        }\n\n        return def_1;\n      }\n    };\n  } else {\n    throw monarchCommon.createError(lexer, 'an action must be a string, an object with a \\'token\\' or \\'cases\\' attribute, or an array of actions; in rule: ' + ruleName);\n  }\n}\n/**\n * Helper class for creating matching rules\n */\n\n\nvar Rule =\n/** @class */\nfunction () {\n  function Rule(name) {\n    this.regex = new RegExp('');\n    this.action = {\n      token: ''\n    };\n    this.matchOnlyAtLineStart = false;\n    this.name = '';\n    this.name = name;\n  }\n\n  Rule.prototype.setRegex = function (lexer, re) {\n    var sregex;\n\n    if (typeof re === 'string') {\n      sregex = re;\n    } else if (re instanceof RegExp) {\n      sregex = re.source;\n    } else {\n      throw monarchCommon.createError(lexer, 'rules must start with a match string or regular expression: ' + this.name);\n    }\n\n    this.matchOnlyAtLineStart = sregex.length > 0 && sregex[0] === '^';\n    this.name = this.name + ': ' + sregex;\n    this.regex = compileRegExp(lexer, '^(?:' + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ')');\n  };\n\n  Rule.prototype.setAction = function (lexer, act) {\n    this.action = compileAction(lexer, this.name, act);\n  };\n\n  return Rule;\n}();\n/**\n * Compiles a json description function into json where all regular expressions,\n * case matches etc, are compiled and all include rules are expanded.\n * We also compile the bracket definitions, supply defaults, and do many sanity checks.\n * If the 'jsonStrict' parameter is 'false', we allow at certain locations\n * regular expression objects and functions that get called during lexing.\n * (Currently we have no samples that need this so perhaps we should always have\n * jsonStrict to true).\n */\n\n\nexport function compile(languageId, json) {\n  if (!json || typeof json !== 'object') {\n    throw new Error('Monarch: expecting a language definition object');\n  } // Create our lexer\n\n\n  var lexer = {};\n  lexer.languageId = languageId;\n  lexer.noThrow = false; // raise exceptions during compilation\n\n  lexer.maxStack = 100; // Set standard fields: be defensive about types\n\n  lexer.start = typeof json.start === 'string' ? json.start : null;\n  lexer.ignoreCase = bool(json.ignoreCase, false);\n  lexer.tokenPostfix = string(json.tokenPostfix, '.' + lexer.languageId);\n  lexer.defaultToken = string(json.defaultToken, 'source');\n  lexer.usesEmbedded = false; // becomes true if we find a nextEmbedded action\n  // For calling compileAction later on\n\n  var lexerMin = json;\n  lexerMin.languageId = languageId;\n  lexerMin.ignoreCase = lexer.ignoreCase;\n  lexerMin.noThrow = lexer.noThrow;\n  lexerMin.usesEmbedded = lexer.usesEmbedded;\n  lexerMin.stateNames = json.tokenizer;\n  lexerMin.defaultToken = lexer.defaultToken; // Compile an array of rules into newrules where RegExp objects are created.\n\n  function addRules(state, newrules, rules) {\n    for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {\n      var rule = rules_1[_i];\n      var include = rule.include;\n\n      if (include) {\n        if (typeof include !== 'string') {\n          throw monarchCommon.createError(lexer, 'an \\'include\\' attribute must be a string at: ' + state);\n        }\n\n        if (include[0] === '@') {\n          include = include.substr(1); // peel off starting @\n        }\n\n        if (!json.tokenizer[include]) {\n          throw monarchCommon.createError(lexer, 'include target \\'' + include + '\\' is not defined at: ' + state);\n        }\n\n        addRules(state + '.' + include, newrules, json.tokenizer[include]);\n      } else {\n        var newrule = new Rule(state); // Set up new rule attributes\n\n        if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {\n          newrule.setRegex(lexerMin, rule[0]);\n\n          if (rule.length >= 3) {\n            if (typeof rule[1] === 'string') {\n              newrule.setAction(lexerMin, {\n                token: rule[1],\n                next: rule[2]\n              });\n            } else if (typeof rule[1] === 'object') {\n              var rule1 = rule[1];\n              rule1.next = rule[2];\n              newrule.setAction(lexerMin, rule1);\n            } else {\n              throw monarchCommon.createError(lexer, 'a next state as the last element of a rule can only be given if the action is either an object or a string, at: ' + state);\n            }\n          } else {\n            newrule.setAction(lexerMin, rule[1]);\n          }\n        } else {\n          if (!rule.regex) {\n            throw monarchCommon.createError(lexer, 'a rule must either be an array, or an object with a \\'regex\\' or \\'include\\' field at: ' + state);\n          }\n\n          if (rule.name) {\n            if (typeof rule.name === 'string') {\n              newrule.name = rule.name;\n            }\n          }\n\n          if (rule.matchOnlyAtStart) {\n            newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart, false);\n          }\n\n          newrule.setRegex(lexerMin, rule.regex);\n          newrule.setAction(lexerMin, rule.action);\n        }\n\n        newrules.push(newrule);\n      }\n    }\n  } // compile the tokenizer rules\n\n\n  if (!json.tokenizer || typeof json.tokenizer !== 'object') {\n    throw monarchCommon.createError(lexer, 'a language definition must define the \\'tokenizer\\' attribute as an object');\n  }\n\n  lexer.tokenizer = [];\n\n  for (var key in json.tokenizer) {\n    if (json.tokenizer.hasOwnProperty(key)) {\n      if (!lexer.start) {\n        lexer.start = key;\n      }\n\n      var rules = json.tokenizer[key];\n      lexer.tokenizer[key] = new Array();\n      addRules('tokenizer.' + key, lexer.tokenizer[key], rules);\n    }\n  }\n\n  lexer.usesEmbedded = lexerMin.usesEmbedded; // can be set during compileAction\n  // Set simple brackets\n\n  if (json.brackets) {\n    if (!Array.isArray(json.brackets)) {\n      throw monarchCommon.createError(lexer, 'the \\'brackets\\' attribute must be defined as an array');\n    }\n  } else {\n    json.brackets = [{\n      open: '{',\n      close: '}',\n      token: 'delimiter.curly'\n    }, {\n      open: '[',\n      close: ']',\n      token: 'delimiter.square'\n    }, {\n      open: '(',\n      close: ')',\n      token: 'delimiter.parenthesis'\n    }, {\n      open: '<',\n      close: '>',\n      token: 'delimiter.angle'\n    }];\n  }\n\n  var brackets = [];\n\n  for (var _i = 0, _a = json.brackets; _i < _a.length; _i++) {\n    var el = _a[_i];\n    var desc = el;\n\n    if (desc && Array.isArray(desc) && desc.length === 3) {\n      desc = {\n        token: desc[2],\n        open: desc[0],\n        close: desc[1]\n      };\n    }\n\n    if (desc.open === desc.close) {\n      throw monarchCommon.createError(lexer, 'open and close brackets in a \\'brackets\\' attribute must be different: ' + desc.open + '\\n hint: use the \\'bracket\\' attribute if matching on equal brackets is required.');\n    }\n\n    if (typeof desc.open === 'string' && typeof desc.token === 'string' && typeof desc.close === 'string') {\n      brackets.push({\n        token: desc.token + lexer.tokenPostfix,\n        open: monarchCommon.fixCase(lexer, desc.open),\n        close: monarchCommon.fixCase(lexer, desc.close)\n      });\n    } else {\n      throw monarchCommon.createError(lexer, 'every element in the \\'brackets\\' array must be a \\'{open,close,token}\\' object or array');\n    }\n  }\n\n  lexer.brackets = brackets; // Disable throw so the syntax highlighter goes, no matter what\n\n  lexer.noThrow = true;\n  return lexer;\n}","map":null,"metadata":{},"sourceType":"module"}