{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\n\nvar Coordinate =\n/** @class */\nfunction () {\n  function Coordinate(top, left) {\n    this.top = top;\n    this.left = left;\n  }\n\n  return Coordinate;\n}();\n\nvar ViewContentWidgets =\n/** @class */\nfunction (_super) {\n  __extends(ViewContentWidgets, _super);\n\n  function ViewContentWidgets(context, viewDomNode) {\n    var _this = _super.call(this, context) || this;\n\n    _this._viewDomNode = viewDomNode;\n    _this._widgets = {};\n    _this.domNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(_this.domNode, 1\n    /* ContentWidgets */\n    );\n\n    _this.domNode.setClassName('contentWidgets');\n\n    _this.domNode.setPosition('absolute');\n\n    _this.domNode.setTop(0);\n\n    _this.overflowingContentWidgetsDomNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(_this.overflowingContentWidgetsDomNode, 2\n    /* OverflowingContentWidgets */\n    );\n\n    _this.overflowingContentWidgetsDomNode.setClassName('overflowingContentWidgets');\n\n    return _this;\n  }\n\n  ViewContentWidgets.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._widgets = {};\n  }; // --- begin event handlers\n\n\n  ViewContentWidgets.prototype.onConfigurationChanged = function (e) {\n    var keys = Object.keys(this._widgets);\n\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var widgetId = keys_1[_i];\n\n      this._widgets[widgetId].onConfigurationChanged(e);\n    }\n\n    return true;\n  };\n\n  ViewContentWidgets.prototype.onDecorationsChanged = function (e) {\n    // true for inline decorations that can end up relayouting text\n    return true;\n  };\n\n  ViewContentWidgets.prototype.onFlushed = function (e) {\n    return true;\n  };\n\n  ViewContentWidgets.prototype.onLineMappingChanged = function (e) {\n    var keys = Object.keys(this._widgets);\n\n    for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n      var widgetId = keys_2[_i];\n\n      this._widgets[widgetId].onLineMappingChanged(e);\n    }\n\n    return true;\n  };\n\n  ViewContentWidgets.prototype.onLinesChanged = function (e) {\n    return true;\n  };\n\n  ViewContentWidgets.prototype.onLinesDeleted = function (e) {\n    return true;\n  };\n\n  ViewContentWidgets.prototype.onLinesInserted = function (e) {\n    return true;\n  };\n\n  ViewContentWidgets.prototype.onScrollChanged = function (e) {\n    return true;\n  };\n\n  ViewContentWidgets.prototype.onZonesChanged = function (e) {\n    return true;\n  }; // ---- end view event handlers\n\n\n  ViewContentWidgets.prototype.addWidget = function (_widget) {\n    var myWidget = new Widget(this._context, this._viewDomNode, _widget);\n    this._widgets[myWidget.id] = myWidget;\n\n    if (myWidget.allowEditorOverflow) {\n      this.overflowingContentWidgetsDomNode.appendChild(myWidget.domNode);\n    } else {\n      this.domNode.appendChild(myWidget.domNode);\n    }\n\n    this.setShouldRender();\n  };\n\n  ViewContentWidgets.prototype.setWidgetPosition = function (widget, position, range, preference) {\n    var myWidget = this._widgets[widget.getId()];\n\n    myWidget.setPosition(position, range, preference);\n    this.setShouldRender();\n  };\n\n  ViewContentWidgets.prototype.removeWidget = function (widget) {\n    var widgetId = widget.getId();\n\n    if (this._widgets.hasOwnProperty(widgetId)) {\n      var myWidget = this._widgets[widgetId];\n      delete this._widgets[widgetId];\n      var domNode = myWidget.domNode.domNode;\n      domNode.parentNode.removeChild(domNode);\n      domNode.removeAttribute('monaco-visible-content-widget');\n      this.setShouldRender();\n    }\n  };\n\n  ViewContentWidgets.prototype.shouldSuppressMouseDownOnWidget = function (widgetId) {\n    if (this._widgets.hasOwnProperty(widgetId)) {\n      return this._widgets[widgetId].suppressMouseDown;\n    }\n\n    return false;\n  };\n\n  ViewContentWidgets.prototype.onBeforeRender = function (viewportData) {\n    var keys = Object.keys(this._widgets);\n\n    for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {\n      var widgetId = keys_3[_i];\n\n      this._widgets[widgetId].onBeforeRender(viewportData);\n    }\n  };\n\n  ViewContentWidgets.prototype.prepareRender = function (ctx) {\n    var keys = Object.keys(this._widgets);\n\n    for (var _i = 0, keys_4 = keys; _i < keys_4.length; _i++) {\n      var widgetId = keys_4[_i];\n\n      this._widgets[widgetId].prepareRender(ctx);\n    }\n  };\n\n  ViewContentWidgets.prototype.render = function (ctx) {\n    var keys = Object.keys(this._widgets);\n\n    for (var _i = 0, keys_5 = keys; _i < keys_5.length; _i++) {\n      var widgetId = keys_5[_i];\n\n      this._widgets[widgetId].render(ctx);\n    }\n  };\n\n  return ViewContentWidgets;\n}(ViewPart);\n\nexport { ViewContentWidgets };\n\nvar Widget =\n/** @class */\nfunction () {\n  function Widget(context, viewDomNode, actual) {\n    this._context = context;\n    this._viewDomNode = viewDomNode;\n    this._actual = actual;\n    this.domNode = createFastDomNode(this._actual.getDomNode());\n    this.id = this._actual.getId();\n    this.allowEditorOverflow = this._actual.allowEditorOverflow || false;\n    this.suppressMouseDown = this._actual.suppressMouseDown || false;\n    this._fixedOverflowWidgets = this._context.configuration.editor.viewInfo.fixedOverflowWidgets;\n    this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth;\n    this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft;\n    this._lineHeight = this._context.configuration.editor.lineHeight;\n    this._position = null;\n    this._range = null;\n    this._viewPosition = null;\n    this._viewRange = null;\n    this._preference = [];\n    this._cachedDomNodeClientWidth = -1;\n    this._cachedDomNodeClientHeight = -1;\n    this._maxWidth = this._getMaxWidth();\n    this._isVisible = false;\n    this._renderData = null;\n    this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? 'fixed' : 'absolute');\n    this.domNode.setVisibility('hidden');\n    this.domNode.setAttribute('widgetId', this.id);\n    this.domNode.setMaxWidth(this._maxWidth);\n  }\n\n  Widget.prototype.onConfigurationChanged = function (e) {\n    if (e.lineHeight) {\n      this._lineHeight = this._context.configuration.editor.lineHeight;\n    }\n\n    if (e.layoutInfo) {\n      this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft;\n      this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth;\n      this._maxWidth = this._getMaxWidth();\n    }\n  };\n\n  Widget.prototype.onLineMappingChanged = function (e) {\n    this._setPosition(this._position, this._range);\n  };\n\n  Widget.prototype._setPosition = function (position, range) {\n    this._position = position;\n    this._range = range;\n    this._viewPosition = null;\n    this._viewRange = null;\n\n    if (this._position) {\n      // Do not trust that widgets give a valid position\n      var validModelPosition = this._context.model.validateModelPosition(this._position);\n\n      if (this._context.model.coordinatesConverter.modelPositionIsVisible(validModelPosition)) {\n        this._viewPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(validModelPosition);\n      }\n    }\n\n    if (this._range) {\n      // Do not trust that widgets give a valid position\n      var validModelRange = this._context.model.validateModelRange(this._range);\n\n      this._viewRange = this._context.model.coordinatesConverter.convertModelRangeToViewRange(validModelRange);\n    }\n  };\n\n  Widget.prototype._getMaxWidth = function () {\n    return this.allowEditorOverflow ? window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth : this._contentWidth;\n  };\n\n  Widget.prototype.setPosition = function (position, range, preference) {\n    this._setPosition(position, range);\n\n    this._preference = preference;\n    this._cachedDomNodeClientWidth = -1;\n    this._cachedDomNodeClientHeight = -1;\n  };\n\n  Widget.prototype._layoutBoxInViewport = function (topLeft, bottomLeft, width, height, ctx) {\n    // Our visible box is split horizontally by the current line => 2 boxes\n    // a) the box above the line\n    var aboveLineTop = topLeft.top;\n    var heightAboveLine = aboveLineTop; // b) the box under the line\n\n    var underLineTop = bottomLeft.top + this._lineHeight;\n    var heightUnderLine = ctx.viewportHeight - underLineTop;\n    var aboveTop = aboveLineTop - height;\n    var fitsAbove = heightAboveLine >= height;\n    var belowTop = underLineTop;\n    var fitsBelow = heightUnderLine >= height; // And its left\n\n    var actualAboveLeft = topLeft.left;\n    var actualBelowLeft = bottomLeft.left;\n\n    if (actualAboveLeft + width > ctx.scrollLeft + ctx.viewportWidth) {\n      actualAboveLeft = ctx.scrollLeft + ctx.viewportWidth - width;\n    }\n\n    if (actualBelowLeft + width > ctx.scrollLeft + ctx.viewportWidth) {\n      actualBelowLeft = ctx.scrollLeft + ctx.viewportWidth - width;\n    }\n\n    if (actualAboveLeft < ctx.scrollLeft) {\n      actualAboveLeft = ctx.scrollLeft;\n    }\n\n    if (actualBelowLeft < ctx.scrollLeft) {\n      actualBelowLeft = ctx.scrollLeft;\n    }\n\n    return {\n      fitsAbove: fitsAbove,\n      aboveTop: aboveTop,\n      aboveLeft: actualAboveLeft,\n      fitsBelow: fitsBelow,\n      belowTop: belowTop,\n      belowLeft: actualBelowLeft\n    };\n  };\n\n  Widget.prototype._layoutBoxInPage = function (topLeft, bottomLeft, width, height, ctx) {\n    var aboveLeft0 = topLeft.left - ctx.scrollLeft;\n    var belowLeft0 = bottomLeft.left - ctx.scrollLeft;\n    var aboveTop = topLeft.top - height;\n    var belowTop = bottomLeft.top + this._lineHeight;\n    var aboveLeft = aboveLeft0 + this._contentLeft;\n    var belowLeft = belowLeft0 + this._contentLeft;\n    var domNodePosition = dom.getDomNodePagePosition(this._viewDomNode.domNode);\n    var absoluteAboveTop = domNodePosition.top + aboveTop - dom.StandardWindow.scrollY;\n    var absoluteBelowTop = domNodePosition.top + belowTop - dom.StandardWindow.scrollY;\n    var absoluteAboveLeft = domNodePosition.left + aboveLeft - dom.StandardWindow.scrollX;\n    var absoluteBelowLeft = domNodePosition.left + belowLeft - dom.StandardWindow.scrollX;\n    var INNER_WIDTH = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    var INNER_HEIGHT = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; // Leave some clearance to the bottom\n\n    var TOP_PADDING = 22;\n    var BOTTOM_PADDING = 22;\n    var fitsAbove = absoluteAboveTop >= TOP_PADDING,\n        fitsBelow = absoluteBelowTop + height <= INNER_HEIGHT - BOTTOM_PADDING;\n\n    if (absoluteAboveLeft + width + 20 > INNER_WIDTH) {\n      var delta = absoluteAboveLeft - (INNER_WIDTH - width - 20);\n      absoluteAboveLeft -= delta;\n      aboveLeft -= delta;\n    }\n\n    if (absoluteBelowLeft + width + 20 > INNER_WIDTH) {\n      var delta = absoluteBelowLeft - (INNER_WIDTH - width - 20);\n      absoluteBelowLeft -= delta;\n      belowLeft -= delta;\n    }\n\n    if (absoluteAboveLeft < 0) {\n      var delta = absoluteAboveLeft;\n      absoluteAboveLeft -= delta;\n      aboveLeft -= delta;\n    }\n\n    if (absoluteBelowLeft < 0) {\n      var delta = absoluteBelowLeft;\n      absoluteBelowLeft -= delta;\n      belowLeft -= delta;\n    }\n\n    if (this._fixedOverflowWidgets) {\n      aboveTop = absoluteAboveTop;\n      belowTop = absoluteBelowTop;\n      aboveLeft = absoluteAboveLeft;\n      belowLeft = absoluteBelowLeft;\n    }\n\n    return {\n      fitsAbove: fitsAbove,\n      aboveTop: aboveTop,\n      aboveLeft: aboveLeft,\n      fitsBelow: fitsBelow,\n      belowTop: belowTop,\n      belowLeft: belowLeft\n    };\n  };\n\n  Widget.prototype._prepareRenderWidgetAtExactPositionOverflowing = function (topLeft) {\n    return new Coordinate(topLeft.top, topLeft.left + this._contentLeft);\n  };\n  /**\n   * Compute `this._topLeft`\n   */\n\n\n  Widget.prototype._getTopAndBottomLeft = function (ctx) {\n    if (!this._viewPosition) {\n      return [null, null];\n    }\n\n    var visibleRangeForPosition = ctx.visibleRangeForPosition(this._viewPosition);\n\n    if (!visibleRangeForPosition) {\n      return [null, null];\n    }\n\n    var topForPosition = ctx.getVerticalOffsetForLineNumber(this._viewPosition.lineNumber) - ctx.scrollTop;\n    var topLeft = new Coordinate(topForPosition, visibleRangeForPosition.left);\n    var largestLineNumber = this._viewPosition.lineNumber;\n    var smallestLeft = visibleRangeForPosition.left;\n\n    if (this._viewRange) {\n      var visibleRangesForRange = ctx.linesVisibleRangesForRange(this._viewRange, false);\n\n      if (visibleRangesForRange && visibleRangesForRange.length > 0) {\n        for (var i = visibleRangesForRange.length - 1; i >= 0; i--) {\n          var visibleRangesForLine = visibleRangesForRange[i];\n\n          if (visibleRangesForLine.lineNumber >= largestLineNumber) {\n            if (visibleRangesForLine.lineNumber > largestLineNumber) {\n              largestLineNumber = visibleRangesForLine.lineNumber;\n              smallestLeft = 1073741824\n              /* MAX_SAFE_SMALL_INTEGER */\n              ;\n            }\n\n            for (var j = 0, lenJ = visibleRangesForLine.ranges.length; j < lenJ; j++) {\n              var visibleRange = visibleRangesForLine.ranges[j];\n\n              if (visibleRange.left < smallestLeft) {\n                smallestLeft = visibleRange.left;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    var topForBottomLine = ctx.getVerticalOffsetForLineNumber(largestLineNumber) - ctx.scrollTop;\n    var bottomLeft = new Coordinate(topForBottomLine, smallestLeft);\n    return [topLeft, bottomLeft];\n  };\n\n  Widget.prototype._prepareRenderWidget = function (ctx) {\n    var _a = this._getTopAndBottomLeft(ctx),\n        topLeft = _a[0],\n        bottomLeft = _a[1];\n\n    if (!topLeft || !bottomLeft) {\n      return null;\n    }\n\n    if (this._cachedDomNodeClientWidth === -1 || this._cachedDomNodeClientHeight === -1) {\n      var domNode = this.domNode.domNode;\n      this._cachedDomNodeClientWidth = domNode.clientWidth;\n      this._cachedDomNodeClientHeight = domNode.clientHeight;\n    }\n\n    var placement;\n\n    if (this.allowEditorOverflow) {\n      placement = this._layoutBoxInPage(topLeft, bottomLeft, this._cachedDomNodeClientWidth, this._cachedDomNodeClientHeight, ctx);\n    } else {\n      placement = this._layoutBoxInViewport(topLeft, bottomLeft, this._cachedDomNodeClientWidth, this._cachedDomNodeClientHeight, ctx);\n    } // Do two passes, first for perfect fit, second picks first option\n\n\n    if (this._preference) {\n      for (var pass = 1; pass <= 2; pass++) {\n        for (var _i = 0, _b = this._preference; _i < _b.length; _i++) {\n          var pref = _b[_i]; // placement\n\n          if (pref === 1\n          /* ABOVE */\n          ) {\n              if (!placement) {\n                // Widget outside of viewport\n                return null;\n              }\n\n              if (pass === 2 || placement.fitsAbove) {\n                return new Coordinate(placement.aboveTop, placement.aboveLeft);\n              }\n            } else if (pref === 2\n          /* BELOW */\n          ) {\n              if (!placement) {\n                // Widget outside of viewport\n                return null;\n              }\n\n              if (pass === 2 || placement.fitsBelow) {\n                return new Coordinate(placement.belowTop, placement.belowLeft);\n              }\n            } else {\n            if (this.allowEditorOverflow) {\n              return this._prepareRenderWidgetAtExactPositionOverflowing(topLeft);\n            } else {\n              return topLeft;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\n   * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.\n   */\n\n\n  Widget.prototype.onBeforeRender = function (viewportData) {\n    if (!this._viewPosition || !this._preference) {\n      return;\n    }\n\n    if (this._viewPosition.lineNumber < viewportData.startLineNumber || this._viewPosition.lineNumber > viewportData.endLineNumber) {\n      // Outside of viewport\n      return;\n    }\n\n    this.domNode.setMaxWidth(this._maxWidth);\n  };\n\n  Widget.prototype.prepareRender = function (ctx) {\n    this._renderData = this._prepareRenderWidget(ctx);\n  };\n\n  Widget.prototype.render = function (ctx) {\n    if (!this._renderData) {\n      // This widget should be invisible\n      if (this._isVisible) {\n        this.domNode.removeAttribute('monaco-visible-content-widget');\n        this._isVisible = false;\n        this.domNode.setVisibility('hidden');\n      }\n\n      return;\n    } // This widget should be visible\n\n\n    if (this.allowEditorOverflow) {\n      this.domNode.setTop(this._renderData.top);\n      this.domNode.setLeft(this._renderData.left);\n    } else {\n      this.domNode.setTop(this._renderData.top + ctx.scrollTop - ctx.bigNumbersDelta);\n      this.domNode.setLeft(this._renderData.left);\n    }\n\n    if (!this._isVisible) {\n      this.domNode.setVisibility('inherit');\n      this.domNode.setAttribute('monaco-visible-content-widget', 'true');\n      this._isVisible = true;\n    }\n  };\n\n  return Widget;\n}();","map":null,"metadata":{},"sourceType":"module"}