{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * Represent whitespaces in between lines and provide fast CRUD management methods.\n * The whitespaces are sorted ascending by `afterLineNumber`.\n */\n\nvar WhitespaceComputer =\n/** @class */\nfunction () {\n  function WhitespaceComputer() {\n    this._instanceId = strings.singleLetterHash(++WhitespaceComputer.INSTANCE_COUNT);\n    this._heights = [];\n    this._minWidths = [];\n    this._ids = [];\n    this._afterLineNumbers = [];\n    this._ordinals = [];\n    this._prefixSum = [];\n    this._prefixSumValidIndex = -1;\n    this._whitespaceId2Index = {};\n    this._lastWhitespaceId = 0;\n    this._minWidth = -1;\n    /* marker for not being computed */\n  }\n  /**\n   * Find the insertion index for a new value inside a sorted array of values.\n   * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n   */\n\n\n  WhitespaceComputer.findInsertionIndex = function (sortedArray, value, ordinals, valueOrdinal) {\n    var low = 0;\n    var high = sortedArray.length;\n\n    while (low < high) {\n      var mid = low + high >>> 1;\n\n      if (value === sortedArray[mid]) {\n        if (valueOrdinal < ordinals[mid]) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      } else if (value < sortedArray[mid]) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    return low;\n  };\n  /**\n   * Insert a new whitespace of a certain height after a line number.\n   * The whitespace has a \"sticky\" characteristic.\n   * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.\n   *\n   * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.\n   * @param heightInPx The height of the whitespace, in pixels.\n   * @return An id that can be used later to mutate or delete the whitespace\n   */\n\n\n  WhitespaceComputer.prototype.insertWhitespace = function (afterLineNumber, ordinal, heightInPx, minWidth) {\n    afterLineNumber = afterLineNumber | 0;\n    ordinal = ordinal | 0;\n    heightInPx = heightInPx | 0;\n    minWidth = minWidth | 0;\n    var id = this._instanceId + ++this._lastWhitespaceId;\n    var insertionIndex = WhitespaceComputer.findInsertionIndex(this._afterLineNumbers, afterLineNumber, this._ordinals, ordinal);\n\n    this._insertWhitespaceAtIndex(id, insertionIndex, afterLineNumber, ordinal, heightInPx, minWidth);\n\n    this._minWidth = -1;\n    /* marker for not being computed */\n\n    return id;\n  };\n\n  WhitespaceComputer.prototype._insertWhitespaceAtIndex = function (id, insertIndex, afterLineNumber, ordinal, heightInPx, minWidth) {\n    insertIndex = insertIndex | 0;\n    afterLineNumber = afterLineNumber | 0;\n    ordinal = ordinal | 0;\n    heightInPx = heightInPx | 0;\n    minWidth = minWidth | 0;\n\n    this._heights.splice(insertIndex, 0, heightInPx);\n\n    this._minWidths.splice(insertIndex, 0, minWidth);\n\n    this._ids.splice(insertIndex, 0, id);\n\n    this._afterLineNumbers.splice(insertIndex, 0, afterLineNumber);\n\n    this._ordinals.splice(insertIndex, 0, ordinal);\n\n    this._prefixSum.splice(insertIndex, 0, 0);\n\n    var keys = Object.keys(this._whitespaceId2Index);\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n      var sid = keys[i];\n      var oldIndex = this._whitespaceId2Index[sid];\n\n      if (oldIndex >= insertIndex) {\n        this._whitespaceId2Index[sid] = oldIndex + 1;\n      }\n    }\n\n    this._whitespaceId2Index[id] = insertIndex;\n    this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n  };\n  /**\n   * Change properties associated with a certain whitespace.\n   */\n\n\n  WhitespaceComputer.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {\n    newAfterLineNumber = newAfterLineNumber | 0;\n    newHeight = newHeight | 0;\n    var hasChanges = false;\n    hasChanges = this.changeWhitespaceHeight(id, newHeight) || hasChanges;\n    hasChanges = this.changeWhitespaceAfterLineNumber(id, newAfterLineNumber) || hasChanges;\n    return hasChanges;\n  };\n  /**\n   * Change the height of an existing whitespace\n   *\n   * @param id The whitespace to change\n   * @param newHeightInPx The new height of the whitespace, in pixels\n   * @return Returns true if the whitespace is found and if the new height is different than the old height\n   */\n\n\n  WhitespaceComputer.prototype.changeWhitespaceHeight = function (id, newHeightInPx) {\n    newHeightInPx = newHeightInPx | 0;\n\n    if (this._whitespaceId2Index.hasOwnProperty(id)) {\n      var index = this._whitespaceId2Index[id];\n\n      if (this._heights[index] !== newHeightInPx) {\n        this._heights[index] = newHeightInPx;\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Change the line number after which an existing whitespace flows.\n   *\n   * @param id The whitespace to change\n   * @param newAfterLineNumber The new line number the whitespace will follow\n   * @return Returns true if the whitespace is found and if the new line number is different than the old line number\n   */\n\n\n  WhitespaceComputer.prototype.changeWhitespaceAfterLineNumber = function (id, newAfterLineNumber) {\n    newAfterLineNumber = newAfterLineNumber | 0;\n\n    if (this._whitespaceId2Index.hasOwnProperty(id)) {\n      var index = this._whitespaceId2Index[id];\n\n      if (this._afterLineNumbers[index] !== newAfterLineNumber) {\n        // `afterLineNumber` changed for this whitespace\n        // Record old ordinal\n        var ordinal = this._ordinals[index]; // Record old height\n\n        var heightInPx = this._heights[index]; // Record old min width\n\n        var minWidth = this._minWidths[index]; // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n\n        this.removeWhitespace(id); // And add it again\n\n        var insertionIndex = WhitespaceComputer.findInsertionIndex(this._afterLineNumbers, newAfterLineNumber, this._ordinals, ordinal);\n\n        this._insertWhitespaceAtIndex(id, insertionIndex, newAfterLineNumber, ordinal, heightInPx, minWidth);\n\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Remove an existing whitespace.\n   *\n   * @param id The whitespace to remove\n   * @return Returns true if the whitespace is found and it is removed.\n   */\n\n\n  WhitespaceComputer.prototype.removeWhitespace = function (id) {\n    if (this._whitespaceId2Index.hasOwnProperty(id)) {\n      var index = this._whitespaceId2Index[id];\n      delete this._whitespaceId2Index[id];\n\n      this._removeWhitespaceAtIndex(index);\n\n      this._minWidth = -1;\n      /* marker for not being computed */\n\n      return true;\n    }\n\n    return false;\n  };\n\n  WhitespaceComputer.prototype._removeWhitespaceAtIndex = function (removeIndex) {\n    removeIndex = removeIndex | 0;\n\n    this._heights.splice(removeIndex, 1);\n\n    this._minWidths.splice(removeIndex, 1);\n\n    this._ids.splice(removeIndex, 1);\n\n    this._afterLineNumbers.splice(removeIndex, 1);\n\n    this._ordinals.splice(removeIndex, 1);\n\n    this._prefixSum.splice(removeIndex, 1);\n\n    this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    var keys = Object.keys(this._whitespaceId2Index);\n\n    for (var i = 0, len = keys.length; i < len; i++) {\n      var sid = keys[i];\n      var oldIndex = this._whitespaceId2Index[sid];\n\n      if (oldIndex >= removeIndex) {\n        this._whitespaceId2Index[sid] = oldIndex - 1;\n      }\n    }\n  };\n  /**\n   * Notify the computer that lines have been deleted (a continuous zone of lines).\n   * This gives it a chance to update `afterLineNumber` for whitespaces, giving the \"sticky\" characteristic.\n   *\n   * @param fromLineNumber The line number at which the deletion started, inclusive\n   * @param toLineNumber The line number at which the deletion ended, inclusive\n   */\n\n\n  WhitespaceComputer.prototype.onLinesDeleted = function (fromLineNumber, toLineNumber) {\n    fromLineNumber = fromLineNumber | 0;\n    toLineNumber = toLineNumber | 0;\n\n    for (var i = 0, len = this._afterLineNumbers.length; i < len; i++) {\n      var afterLineNumber = this._afterLineNumbers[i];\n\n      if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n        // The line this whitespace was after has been deleted\n        //  => move whitespace to before first deleted line\n        this._afterLineNumbers[i] = fromLineNumber - 1;\n      } else if (afterLineNumber > toLineNumber) {\n        // The line this whitespace was after has been moved up\n        //  => move whitespace up\n        this._afterLineNumbers[i] -= toLineNumber - fromLineNumber + 1;\n      }\n    }\n  };\n  /**\n   * Notify the computer that lines have been inserted (a continuous zone of lines).\n   * This gives it a chance to update `afterLineNumber` for whitespaces, giving the \"sticky\" characteristic.\n   *\n   * @param fromLineNumber The line number at which the insertion started, inclusive\n   * @param toLineNumber The line number at which the insertion ended, inclusive.\n   */\n\n\n  WhitespaceComputer.prototype.onLinesInserted = function (fromLineNumber, toLineNumber) {\n    fromLineNumber = fromLineNumber | 0;\n    toLineNumber = toLineNumber | 0;\n\n    for (var i = 0, len = this._afterLineNumbers.length; i < len; i++) {\n      var afterLineNumber = this._afterLineNumbers[i];\n\n      if (fromLineNumber <= afterLineNumber) {\n        this._afterLineNumbers[i] += toLineNumber - fromLineNumber + 1;\n      }\n    }\n  };\n  /**\n   * Get the sum of all the whitespaces.\n   */\n\n\n  WhitespaceComputer.prototype.getTotalHeight = function () {\n    if (this._heights.length === 0) {\n      return 0;\n    }\n\n    return this.getAccumulatedHeight(this._heights.length - 1);\n  };\n  /**\n   * Return the sum of the heights of the whitespaces at [0..index].\n   * This includes the whitespace at `index`.\n   *\n   * @param index The index of the whitespace.\n   * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n   */\n\n\n  WhitespaceComputer.prototype.getAccumulatedHeight = function (index) {\n    index = index | 0;\n    var startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n\n    if (startIndex === 0) {\n      this._prefixSum[0] = this._heights[0];\n      startIndex++;\n    }\n\n    for (var i = startIndex; i <= index; i++) {\n      this._prefixSum[i] = this._prefixSum[i - 1] + this._heights[i];\n    }\n\n    this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n    return this._prefixSum[index];\n  };\n  /**\n   * Find all whitespaces with `afterLineNumber` < `lineNumber` and return the sum of their heights.\n   *\n   * @param lineNumber The line number whitespaces should be before.\n   * @return The sum of the heights of the whitespaces before `lineNumber`.\n   */\n\n\n  WhitespaceComputer.prototype.getAccumulatedHeightBeforeLineNumber = function (lineNumber) {\n    lineNumber = lineNumber | 0;\n\n    var lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\n    if (lastWhitespaceBeforeLineNumber === -1) {\n      return 0;\n    }\n\n    return this.getAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n  };\n\n  WhitespaceComputer.prototype._findLastWhitespaceBeforeLineNumber = function (lineNumber) {\n    lineNumber = lineNumber | 0; // Find the whitespace before line number\n\n    var afterLineNumbers = this._afterLineNumbers;\n    var low = 0;\n    var high = afterLineNumbers.length - 1;\n\n    while (low <= high) {\n      var delta = high - low | 0;\n      var halfDelta = delta / 2 | 0;\n      var mid = low + halfDelta | 0;\n\n      if (afterLineNumbers[mid] < lineNumber) {\n        if (mid + 1 >= afterLineNumbers.length || afterLineNumbers[mid + 1] >= lineNumber) {\n          return mid;\n        } else {\n          low = mid + 1 | 0;\n        }\n      } else {\n        high = mid - 1 | 0;\n      }\n    }\n\n    return -1;\n  };\n\n  WhitespaceComputer.prototype._findFirstWhitespaceAfterLineNumber = function (lineNumber) {\n    lineNumber = lineNumber | 0;\n\n    var lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\n    var firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n\n    if (firstWhitespaceAfterLineNumber < this._heights.length) {\n      return firstWhitespaceAfterLineNumber;\n    }\n\n    return -1;\n  };\n  /**\n   * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n   * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n   */\n\n\n  WhitespaceComputer.prototype.getFirstWhitespaceIndexAfterLineNumber = function (lineNumber) {\n    lineNumber = lineNumber | 0;\n    return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n  };\n  /**\n   * The number of whitespaces.\n   */\n\n\n  WhitespaceComputer.prototype.getCount = function () {\n    return this._heights.length;\n  };\n  /**\n   * The maximum min width for all whitespaces.\n   */\n\n\n  WhitespaceComputer.prototype.getMinWidth = function () {\n    if (this._minWidth === -1) {\n      var minWidth = 0;\n\n      for (var i = 0, len = this._minWidths.length; i < len; i++) {\n        minWidth = Math.max(minWidth, this._minWidths[i]);\n      }\n\n      this._minWidth = minWidth;\n    }\n\n    return this._minWidth;\n  };\n  /**\n   * Get the `afterLineNumber` for whitespace at index `index`.\n   *\n   * @param index The index of the whitespace.\n   * @return `afterLineNumber` of whitespace at `index`.\n   */\n\n\n  WhitespaceComputer.prototype.getAfterLineNumberForWhitespaceIndex = function (index) {\n    index = index | 0;\n    return this._afterLineNumbers[index];\n  };\n  /**\n   * Get the `id` for whitespace at index `index`.\n   *\n   * @param index The index of the whitespace.\n   * @return `id` of whitespace at `index`.\n   */\n\n\n  WhitespaceComputer.prototype.getIdForWhitespaceIndex = function (index) {\n    index = index | 0;\n    return this._ids[index];\n  };\n  /**\n   * Get the `height` for whitespace at index `index`.\n   *\n   * @param index The index of the whitespace.\n   * @return `height` of whitespace at `index`.\n   */\n\n\n  WhitespaceComputer.prototype.getHeightForWhitespaceIndex = function (index) {\n    index = index | 0;\n    return this._heights[index];\n  };\n  /**\n   * Get all whitespaces.\n   */\n\n\n  WhitespaceComputer.prototype.getWhitespaces = function (deviceLineHeight) {\n    deviceLineHeight = deviceLineHeight | 0;\n    var result = [];\n\n    for (var i = 0; i < this._heights.length; i++) {\n      result.push({\n        id: this._ids[i],\n        afterLineNumber: this._afterLineNumbers[i],\n        heightInLines: this._heights[i] / deviceLineHeight\n      });\n    }\n\n    return result;\n  };\n\n  WhitespaceComputer.INSTANCE_COUNT = 0;\n  return WhitespaceComputer;\n}();\n\nexport { WhitespaceComputer };","map":null,"metadata":{},"sourceType":"module"}