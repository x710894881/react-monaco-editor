{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as json from './_deps/jsonc-parser/main.js';\nexport function createTokenizationSupport(supportComments) {\n  return {\n    getInitialState: function () {\n      return new JSONState(null, null, false);\n    },\n    tokenize: function (line, state, offsetDelta, stopAtOffset) {\n      return tokenize(supportComments, line, state, offsetDelta, stopAtOffset);\n    }\n  };\n}\nexport var TOKEN_DELIM_OBJECT = 'delimiter.bracket.json';\nexport var TOKEN_DELIM_ARRAY = 'delimiter.array.json';\nexport var TOKEN_DELIM_COLON = 'delimiter.colon.json';\nexport var TOKEN_DELIM_COMMA = 'delimiter.comma.json';\nexport var TOKEN_VALUE_BOOLEAN = 'keyword.json';\nexport var TOKEN_VALUE_NULL = 'keyword.json';\nexport var TOKEN_VALUE_STRING = 'string.value.json';\nexport var TOKEN_VALUE_NUMBER = 'number.json';\nexport var TOKEN_PROPERTY_NAME = 'string.key.json';\nexport var TOKEN_COMMENT_BLOCK = 'comment.block.json';\nexport var TOKEN_COMMENT_LINE = 'comment.line.json';\n\nvar JSONState =\n/** @class */\nfunction () {\n  function JSONState(state, scanError, lastWasColon) {\n    this._state = state;\n    this.scanError = scanError;\n    this.lastWasColon = lastWasColon;\n  }\n\n  JSONState.prototype.clone = function () {\n    return new JSONState(this._state, this.scanError, this.lastWasColon);\n  };\n\n  JSONState.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n\n    if (!other || !(other instanceof JSONState)) {\n      return false;\n    }\n\n    return this.scanError === other.scanError && this.lastWasColon === other.lastWasColon;\n  };\n\n  JSONState.prototype.getStateData = function () {\n    return this._state;\n  };\n\n  JSONState.prototype.setStateData = function (state) {\n    this._state = state;\n  };\n\n  return JSONState;\n}();\n\nfunction tokenize(comments, line, state, offsetDelta, stopAtOffset) {\n  if (offsetDelta === void 0) {\n    offsetDelta = 0;\n  } // handle multiline strings and block comments\n\n\n  var numberOfInsertedCharacters = 0,\n      adjustOffset = false;\n\n  switch (state.scanError) {\n    case 2\n    /* UnexpectedEndOfString */\n    :\n      line = '\"' + line;\n      numberOfInsertedCharacters = 1;\n      break;\n\n    case 1\n    /* UnexpectedEndOfComment */\n    :\n      line = '/*' + line;\n      numberOfInsertedCharacters = 2;\n      break;\n  }\n\n  var scanner = json.createScanner(line),\n      kind,\n      ret,\n      lastWasColon = state.lastWasColon;\n  ret = {\n    tokens: [],\n    endState: state.clone()\n  };\n\n  while (true) {\n    var offset = offsetDelta + scanner.getPosition(),\n        type = '';\n    kind = scanner.scan();\n\n    if (kind === 17\n    /* EOF */\n    ) {\n        break;\n      } // Check that the scanner has advanced\n\n\n    if (offset === offsetDelta + scanner.getPosition()) {\n      throw new Error('Scanner did not advance, next 3 characters are: ' + line.substr(scanner.getPosition(), 3));\n    } // In case we inserted /* or \" character, we need to\n    // adjust the offset of all tokens (except the first)\n\n\n    if (adjustOffset) {\n      offset -= numberOfInsertedCharacters;\n    }\n\n    adjustOffset = numberOfInsertedCharacters > 0; // brackets and type\n\n    switch (kind) {\n      case 1\n      /* OpenBraceToken */\n      :\n        type = TOKEN_DELIM_OBJECT;\n        lastWasColon = false;\n        break;\n\n      case 2\n      /* CloseBraceToken */\n      :\n        type = TOKEN_DELIM_OBJECT;\n        lastWasColon = false;\n        break;\n\n      case 3\n      /* OpenBracketToken */\n      :\n        type = TOKEN_DELIM_ARRAY;\n        lastWasColon = false;\n        break;\n\n      case 4\n      /* CloseBracketToken */\n      :\n        type = TOKEN_DELIM_ARRAY;\n        lastWasColon = false;\n        break;\n\n      case 6\n      /* ColonToken */\n      :\n        type = TOKEN_DELIM_COLON;\n        lastWasColon = true;\n        break;\n\n      case 5\n      /* CommaToken */\n      :\n        type = TOKEN_DELIM_COMMA;\n        lastWasColon = false;\n        break;\n\n      case 8\n      /* TrueKeyword */\n      :\n      case 9\n      /* FalseKeyword */\n      :\n        type = TOKEN_VALUE_BOOLEAN;\n        lastWasColon = false;\n        break;\n\n      case 7\n      /* NullKeyword */\n      :\n        type = TOKEN_VALUE_NULL;\n        lastWasColon = false;\n        break;\n\n      case 10\n      /* StringLiteral */\n      :\n        type = lastWasColon ? TOKEN_VALUE_STRING : TOKEN_PROPERTY_NAME;\n        lastWasColon = false;\n        break;\n\n      case 11\n      /* NumericLiteral */\n      :\n        type = TOKEN_VALUE_NUMBER;\n        lastWasColon = false;\n        break;\n    } // comments, iff enabled\n\n\n    if (comments) {\n      switch (kind) {\n        case 12\n        /* LineCommentTrivia */\n        :\n          type = TOKEN_COMMENT_LINE;\n          break;\n\n        case 13\n        /* BlockCommentTrivia */\n        :\n          type = TOKEN_COMMENT_BLOCK;\n          break;\n      }\n    }\n\n    ret.endState = new JSONState(state.getStateData(), scanner.getTokenError(), lastWasColon);\n    ret.tokens.push({\n      startIndex: offset,\n      scopes: type\n    });\n  }\n\n  return ret;\n}","map":null,"metadata":{},"sourceType":"module"}