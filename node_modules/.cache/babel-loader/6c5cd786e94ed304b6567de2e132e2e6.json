{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../fillers/vscode-nls.js';\nimport { TokenType, ScannerState } from '../htmlLanguageTypes.js';\nvar localize = nls.loadMessageBundle();\n\nvar MultiLineStream =\n/** @class */\nfunction () {\n  function MultiLineStream(source, position) {\n    this.source = source;\n    this.len = source.length;\n    this.position = position;\n  }\n\n  MultiLineStream.prototype.eos = function () {\n    return this.len <= this.position;\n  };\n\n  MultiLineStream.prototype.getSource = function () {\n    return this.source;\n  };\n\n  MultiLineStream.prototype.pos = function () {\n    return this.position;\n  };\n\n  MultiLineStream.prototype.goBackTo = function (pos) {\n    this.position = pos;\n  };\n\n  MultiLineStream.prototype.goBack = function (n) {\n    this.position -= n;\n  };\n\n  MultiLineStream.prototype.advance = function (n) {\n    this.position += n;\n  };\n\n  MultiLineStream.prototype.goToEnd = function () {\n    this.position = this.source.length;\n  };\n\n  MultiLineStream.prototype.nextChar = function () {\n    return this.source.charCodeAt(this.position++) || 0;\n  };\n\n  MultiLineStream.prototype.peekChar = function (n) {\n    if (n === void 0) {\n      n = 0;\n    }\n\n    return this.source.charCodeAt(this.position + n) || 0;\n  };\n\n  MultiLineStream.prototype.advanceIfChar = function (ch) {\n    if (ch === this.source.charCodeAt(this.position)) {\n      this.position++;\n      return true;\n    }\n\n    return false;\n  };\n\n  MultiLineStream.prototype.advanceIfChars = function (ch) {\n    var i;\n\n    if (this.position + ch.length > this.source.length) {\n      return false;\n    }\n\n    for (i = 0; i < ch.length; i++) {\n      if (this.source.charCodeAt(this.position + i) !== ch[i]) {\n        return false;\n      }\n    }\n\n    this.advance(i);\n    return true;\n  };\n\n  MultiLineStream.prototype.advanceIfRegExp = function (regex) {\n    var str = this.source.substr(this.position);\n    var match = str.match(regex);\n\n    if (match) {\n      this.position = this.position + match.index + match[0].length;\n      return match[0];\n    }\n\n    return '';\n  };\n\n  MultiLineStream.prototype.advanceUntilRegExp = function (regex) {\n    var str = this.source.substr(this.position);\n    var match = str.match(regex);\n\n    if (match) {\n      this.position = this.position + match.index;\n      return match[0];\n    } else {\n      this.goToEnd();\n    }\n\n    return '';\n  };\n\n  MultiLineStream.prototype.advanceUntilChar = function (ch) {\n    while (this.position < this.source.length) {\n      if (this.source.charCodeAt(this.position) === ch) {\n        return true;\n      }\n\n      this.advance(1);\n    }\n\n    return false;\n  };\n\n  MultiLineStream.prototype.advanceUntilChars = function (ch) {\n    while (this.position + ch.length <= this.source.length) {\n      var i = 0;\n\n      for (; i < ch.length && this.source.charCodeAt(this.position + i) === ch[i]; i++) {}\n\n      if (i === ch.length) {\n        return true;\n      }\n\n      this.advance(1);\n    }\n\n    this.goToEnd();\n    return false;\n  };\n\n  MultiLineStream.prototype.skipWhitespace = function () {\n    var n = this.advanceWhileChar(function (ch) {\n      return ch === _WSP || ch === _TAB || ch === _NWL || ch === _LFD || ch === _CAR;\n    });\n    return n > 0;\n  };\n\n  MultiLineStream.prototype.advanceWhileChar = function (condition) {\n    var posNow = this.position;\n\n    while (this.position < this.len && condition(this.source.charCodeAt(this.position))) {\n      this.position++;\n    }\n\n    return this.position - posNow;\n  };\n\n  return MultiLineStream;\n}();\n\nvar _BNG = '!'.charCodeAt(0);\n\nvar _MIN = '-'.charCodeAt(0);\n\nvar _LAN = '<'.charCodeAt(0);\n\nvar _RAN = '>'.charCodeAt(0);\n\nvar _FSL = '/'.charCodeAt(0);\n\nvar _EQS = '='.charCodeAt(0);\n\nvar _DQO = '\"'.charCodeAt(0);\n\nvar _SQO = '\\''.charCodeAt(0);\n\nvar _NWL = '\\n'.charCodeAt(0);\n\nvar _CAR = '\\r'.charCodeAt(0);\n\nvar _LFD = '\\f'.charCodeAt(0);\n\nvar _WSP = ' '.charCodeAt(0);\n\nvar _TAB = '\\t'.charCodeAt(0);\n\nvar htmlScriptContents = {\n  'text/x-handlebars-template': true\n};\nexport function createScanner(input, initialOffset, initialState) {\n  if (initialOffset === void 0) {\n    initialOffset = 0;\n  }\n\n  if (initialState === void 0) {\n    initialState = ScannerState.WithinContent;\n  }\n\n  var stream = new MultiLineStream(input, initialOffset);\n  var state = initialState;\n  var tokenOffset = 0;\n  var tokenType = TokenType.Unknown;\n  var tokenError;\n  var hasSpaceAfterTag;\n  var lastTag;\n  var lastAttributeName;\n  var lastTypeValue;\n\n  function nextElementName() {\n    return stream.advanceIfRegExp(/^[_:\\w][_:\\w-.\\d]*/).toLowerCase();\n  }\n\n  function nextAttributeName() {\n    return stream.advanceIfRegExp(/^[^\\s\"'>/=\\x00-\\x0F\\x7F\\x80-\\x9F]*/).toLowerCase();\n  }\n\n  function finishToken(offset, type, errorMessage) {\n    tokenType = type;\n    tokenOffset = offset;\n    tokenError = errorMessage;\n    return type;\n  }\n\n  function scan() {\n    var offset = stream.pos();\n    var oldState = state;\n    var token = internalScan();\n\n    if (token !== TokenType.EOS && offset === stream.pos()) {\n      console.log('Scanner.scan has not advanced at offset ' + offset + ', state before: ' + oldState + ' after: ' + state);\n      stream.advance(1);\n      return finishToken(offset, TokenType.Unknown);\n    }\n\n    return token;\n  }\n\n  function internalScan() {\n    var offset = stream.pos();\n\n    if (stream.eos()) {\n      return finishToken(offset, TokenType.EOS);\n    }\n\n    var errorMessage;\n\n    switch (state) {\n      case ScannerState.WithinComment:\n        if (stream.advanceIfChars([_MIN, _MIN, _RAN])) {\n          // -->\n          state = ScannerState.WithinContent;\n          return finishToken(offset, TokenType.EndCommentTag);\n        }\n\n        stream.advanceUntilChars([_MIN, _MIN, _RAN]); // -->\n\n        return finishToken(offset, TokenType.Comment);\n\n      case ScannerState.WithinDoctype:\n        if (stream.advanceIfChar(_RAN)) {\n          state = ScannerState.WithinContent;\n          return finishToken(offset, TokenType.EndDoctypeTag);\n        }\n\n        stream.advanceUntilChar(_RAN); // >\n\n        return finishToken(offset, TokenType.Doctype);\n\n      case ScannerState.WithinContent:\n        if (stream.advanceIfChar(_LAN)) {\n          // <\n          if (!stream.eos() && stream.peekChar() === _BNG) {\n            // !\n            if (stream.advanceIfChars([_BNG, _MIN, _MIN])) {\n              // <!--\n              state = ScannerState.WithinComment;\n              return finishToken(offset, TokenType.StartCommentTag);\n            }\n\n            if (stream.advanceIfRegExp(/^!doctype/i)) {\n              state = ScannerState.WithinDoctype;\n              return finishToken(offset, TokenType.StartDoctypeTag);\n            }\n          }\n\n          if (stream.advanceIfChar(_FSL)) {\n            // /\n            state = ScannerState.AfterOpeningEndTag;\n            return finishToken(offset, TokenType.EndTagOpen);\n          }\n\n          state = ScannerState.AfterOpeningStartTag;\n          return finishToken(offset, TokenType.StartTagOpen);\n        }\n\n        stream.advanceUntilChar(_LAN);\n        return finishToken(offset, TokenType.Content);\n\n      case ScannerState.AfterOpeningEndTag:\n        var tagName = nextElementName();\n\n        if (tagName.length > 0) {\n          state = ScannerState.WithinEndTag;\n          return finishToken(offset, TokenType.EndTag);\n        }\n\n        if (stream.skipWhitespace()) {\n          // white space is not valid here\n          return finishToken(offset, TokenType.Whitespace, localize('error.unexpectedWhitespace', 'Tag name must directly follow the open bracket.'));\n        }\n\n        state = ScannerState.WithinEndTag;\n        stream.advanceUntilChar(_RAN);\n\n        if (offset < stream.pos()) {\n          return finishToken(offset, TokenType.Unknown, localize('error.endTagNameExpected', 'End tag name expected.'));\n        }\n\n        return internalScan();\n\n      case ScannerState.WithinEndTag:\n        if (stream.skipWhitespace()) {\n          // white space is valid here\n          return finishToken(offset, TokenType.Whitespace);\n        }\n\n        if (stream.advanceIfChar(_RAN)) {\n          // >\n          state = ScannerState.WithinContent;\n          return finishToken(offset, TokenType.EndTagClose);\n        }\n\n        errorMessage = localize('error.tagNameExpected', 'Closing bracket expected.');\n        break;\n\n      case ScannerState.AfterOpeningStartTag:\n        lastTag = nextElementName();\n        lastTypeValue = void 0;\n        lastAttributeName = void 0;\n\n        if (lastTag.length > 0) {\n          hasSpaceAfterTag = false;\n          state = ScannerState.WithinTag;\n          return finishToken(offset, TokenType.StartTag);\n        }\n\n        if (stream.skipWhitespace()) {\n          // white space is not valid here\n          return finishToken(offset, TokenType.Whitespace, localize('error.unexpectedWhitespace', 'Tag name must directly follow the open bracket.'));\n        }\n\n        state = ScannerState.WithinTag;\n        stream.advanceUntilChar(_RAN);\n\n        if (offset < stream.pos()) {\n          return finishToken(offset, TokenType.Unknown, localize('error.startTagNameExpected', 'Start tag name expected.'));\n        }\n\n        return internalScan();\n\n      case ScannerState.WithinTag:\n        if (stream.skipWhitespace()) {\n          hasSpaceAfterTag = true; // remember that we have seen a whitespace\n\n          return finishToken(offset, TokenType.Whitespace);\n        }\n\n        if (hasSpaceAfterTag) {\n          lastAttributeName = nextAttributeName();\n\n          if (lastAttributeName.length > 0) {\n            state = ScannerState.AfterAttributeName;\n            hasSpaceAfterTag = false;\n            return finishToken(offset, TokenType.AttributeName);\n          }\n        }\n\n        if (stream.advanceIfChars([_FSL, _RAN])) {\n          // />\n          state = ScannerState.WithinContent;\n          return finishToken(offset, TokenType.StartTagSelfClose);\n        }\n\n        if (stream.advanceIfChar(_RAN)) {\n          // >\n          if (lastTag === 'script') {\n            if (lastTypeValue && htmlScriptContents[lastTypeValue]) {\n              // stay in html\n              state = ScannerState.WithinContent;\n            } else {\n              state = ScannerState.WithinScriptContent;\n            }\n          } else if (lastTag === 'style') {\n            state = ScannerState.WithinStyleContent;\n          } else {\n            state = ScannerState.WithinContent;\n          }\n\n          return finishToken(offset, TokenType.StartTagClose);\n        }\n\n        stream.advance(1);\n        return finishToken(offset, TokenType.Unknown, localize('error.unexpectedCharacterInTag', 'Unexpected character in tag.'));\n\n      case ScannerState.AfterAttributeName:\n        if (stream.skipWhitespace()) {\n          hasSpaceAfterTag = true;\n          return finishToken(offset, TokenType.Whitespace);\n        }\n\n        if (stream.advanceIfChar(_EQS)) {\n          state = ScannerState.BeforeAttributeValue;\n          return finishToken(offset, TokenType.DelimiterAssign);\n        }\n\n        state = ScannerState.WithinTag;\n        return internalScan();\n      // no advance yet - jump to WithinTag\n\n      case ScannerState.BeforeAttributeValue:\n        if (stream.skipWhitespace()) {\n          return finishToken(offset, TokenType.Whitespace);\n        }\n\n        var attributeValue = stream.advanceIfRegExp(/^[^\\s\"'`=<>\\/]+/);\n\n        if (attributeValue.length > 0) {\n          if (lastAttributeName === 'type') {\n            lastTypeValue = attributeValue;\n          }\n\n          state = ScannerState.WithinTag;\n          hasSpaceAfterTag = false;\n          return finishToken(offset, TokenType.AttributeValue);\n        }\n\n        var ch = stream.peekChar();\n\n        if (ch === _SQO || ch === _DQO) {\n          stream.advance(1); // consume quote\n\n          if (stream.advanceUntilChar(ch)) {\n            stream.advance(1); // consume quote\n          }\n\n          if (lastAttributeName === 'type') {\n            lastTypeValue = stream.getSource().substring(offset + 1, stream.pos() - 1);\n          }\n\n          state = ScannerState.WithinTag;\n          hasSpaceAfterTag = false;\n          return finishToken(offset, TokenType.AttributeValue);\n        }\n\n        state = ScannerState.WithinTag;\n        hasSpaceAfterTag = false;\n        return internalScan();\n      // no advance yet - jump to WithinTag\n\n      case ScannerState.WithinScriptContent:\n        // see http://stackoverflow.com/questions/14574471/how-do-browsers-parse-a-script-tag-exactly\n        var sciptState = 1;\n\n        while (!stream.eos()) {\n          var match = stream.advanceIfRegExp(/<!--|-->|<\\/?script\\s*\\/?>?/i);\n\n          if (match.length === 0) {\n            stream.goToEnd();\n            return finishToken(offset, TokenType.Script);\n          } else if (match === '<!--') {\n            if (sciptState === 1) {\n              sciptState = 2;\n            }\n          } else if (match === '-->') {\n            sciptState = 1;\n          } else if (match[1] !== '/') {\n            // <script\n            if (sciptState === 2) {\n              sciptState = 3;\n            }\n          } else {\n            // </script\n            if (sciptState === 3) {\n              sciptState = 2;\n            } else {\n              stream.goBack(match.length); // to the beginning of the closing tag\n\n              break;\n            }\n          }\n        }\n\n        state = ScannerState.WithinContent;\n\n        if (offset < stream.pos()) {\n          return finishToken(offset, TokenType.Script);\n        }\n\n        return internalScan();\n      // no advance yet - jump to content\n\n      case ScannerState.WithinStyleContent:\n        stream.advanceUntilRegExp(/<\\/style/i);\n        state = ScannerState.WithinContent;\n\n        if (offset < stream.pos()) {\n          return finishToken(offset, TokenType.Styles);\n        }\n\n        return internalScan();\n      // no advance yet - jump to content\n    }\n\n    stream.advance(1);\n    state = ScannerState.WithinContent;\n    return finishToken(offset, TokenType.Unknown, errorMessage);\n  }\n\n  return {\n    scan: scan,\n    getTokenType: function () {\n      return tokenType;\n    },\n    getTokenOffset: function () {\n      return tokenOffset;\n    },\n    getTokenLength: function () {\n      return stream.pos() - tokenOffset;\n    },\n    getTokenEnd: function () {\n      return stream.pos();\n    },\n    getTokenText: function () {\n      return stream.getSource().substring(tokenOffset, stream.pos());\n    },\n    getScannerState: function () {\n      return state;\n    },\n    getTokenError: function () {\n      return tokenError;\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}