{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport './list.css';\nimport { localize } from '../../../../nls.js';\nimport { dispose, DisposableStore } from '../../../common/lifecycle.js';\nimport { isNumber } from '../../../common/types.js';\nimport { range, firstIndex, binarySearch } from '../../../common/arrays.js';\nimport { memoize } from '../../../common/decorators.js';\nimport * as DOM from '../../dom.js';\nimport * as platform from '../../../common/platform.js';\nimport { Gesture } from '../../touch.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { Event, Emitter, EventBufferer } from '../../../common/event.js';\nimport { domEvent } from '../../event.js';\nimport { ListAriaRootRole } from './list.js';\nimport { ListView } from './listView.js';\nimport { Color } from '../../../common/color.js';\nimport { mixin } from '../../../common/objects.js';\nimport { CombinedSpliceable } from './splice.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { matchesPrefix } from '../../../common/filters.js';\n\nvar TraitRenderer =\n/** @class */\nfunction () {\n  function TraitRenderer(trait) {\n    this.trait = trait;\n    this.renderedElements = [];\n  }\n\n  Object.defineProperty(TraitRenderer.prototype, \"templateId\", {\n    get: function () {\n      return \"template:\" + this.trait.trait;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TraitRenderer.prototype.renderTemplate = function (container) {\n    return container;\n  };\n\n  TraitRenderer.prototype.renderElement = function (element, index, templateData) {\n    var renderedElementIndex = firstIndex(this.renderedElements, function (el) {\n      return el.templateData === templateData;\n    });\n\n    if (renderedElementIndex >= 0) {\n      var rendered = this.renderedElements[renderedElementIndex];\n      this.trait.unrender(templateData);\n      rendered.index = index;\n    } else {\n      var rendered = {\n        index: index,\n        templateData: templateData\n      };\n      this.renderedElements.push(rendered);\n    }\n\n    this.trait.renderIndex(index, templateData);\n  };\n\n  TraitRenderer.prototype.splice = function (start, deleteCount, insertCount) {\n    var rendered = [];\n\n    for (var _i = 0, _a = this.renderedElements; _i < _a.length; _i++) {\n      var renderedElement = _a[_i];\n\n      if (renderedElement.index < start) {\n        rendered.push(renderedElement);\n      } else if (renderedElement.index >= start + deleteCount) {\n        rendered.push({\n          index: renderedElement.index + insertCount - deleteCount,\n          templateData: renderedElement.templateData\n        });\n      }\n    }\n\n    this.renderedElements = rendered;\n  };\n\n  TraitRenderer.prototype.renderIndexes = function (indexes) {\n    for (var _i = 0, _a = this.renderedElements; _i < _a.length; _i++) {\n      var _b = _a[_i],\n          index = _b.index,\n          templateData = _b.templateData;\n\n      if (indexes.indexOf(index) > -1) {\n        this.trait.renderIndex(index, templateData);\n      }\n    }\n  };\n\n  TraitRenderer.prototype.disposeTemplate = function (templateData) {\n    var index = firstIndex(this.renderedElements, function (el) {\n      return el.templateData === templateData;\n    });\n\n    if (index < 0) {\n      return;\n    }\n\n    this.renderedElements.splice(index, 1);\n  };\n\n  return TraitRenderer;\n}();\n\nvar Trait =\n/** @class */\nfunction () {\n  function Trait(_trait) {\n    this._trait = _trait;\n    this.indexes = [];\n    this.sortedIndexes = [];\n    this._onChange = new Emitter();\n    this.onChange = this._onChange.event;\n  }\n\n  Object.defineProperty(Trait.prototype, \"trait\", {\n    get: function () {\n      return this._trait;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Trait.prototype, \"renderer\", {\n    get: function () {\n      return new TraitRenderer(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Trait.prototype.splice = function (start, deleteCount, elements) {\n    var diff = elements.length - deleteCount;\n    var end = start + deleteCount;\n    var indexes = this.sortedIndexes.filter(function (i) {\n      return i < start;\n    }).concat(elements.map(function (hasTrait, i) {\n      return hasTrait ? i + start : -1;\n    }).filter(function (i) {\n      return i !== -1;\n    }), this.sortedIndexes.filter(function (i) {\n      return i >= end;\n    }).map(function (i) {\n      return i + diff;\n    }));\n    this.renderer.splice(start, deleteCount, elements.length);\n\n    this._set(indexes, indexes);\n  };\n\n  Trait.prototype.renderIndex = function (index, container) {\n    DOM.toggleClass(container, this._trait, this.contains(index));\n  };\n\n  Trait.prototype.unrender = function (container) {\n    DOM.removeClass(container, this._trait);\n  };\n  /**\n   * Sets the indexes which should have this trait.\n   *\n   * @param indexes Indexes which should have this trait.\n   * @return The old indexes which had this trait.\n   */\n\n\n  Trait.prototype.set = function (indexes, browserEvent) {\n    return this._set(indexes, indexes.slice().sort(numericSort), browserEvent);\n  };\n\n  Trait.prototype._set = function (indexes, sortedIndexes, browserEvent) {\n    var result = this.indexes;\n    var sortedResult = this.sortedIndexes;\n    this.indexes = indexes;\n    this.sortedIndexes = sortedIndexes;\n    var toRender = disjunction(sortedResult, indexes);\n    this.renderer.renderIndexes(toRender);\n\n    this._onChange.fire({\n      indexes: indexes,\n      browserEvent: browserEvent\n    });\n\n    return result;\n  };\n\n  Trait.prototype.get = function () {\n    return this.indexes;\n  };\n\n  Trait.prototype.contains = function (index) {\n    return binarySearch(this.sortedIndexes, index, numericSort) >= 0;\n  };\n\n  Trait.prototype.dispose = function () {\n    this._onChange = dispose(this._onChange);\n  };\n\n  __decorate([memoize], Trait.prototype, \"renderer\", null);\n\n  return Trait;\n}();\n\nvar FocusTrait =\n/** @class */\nfunction (_super) {\n  __extends(FocusTrait, _super);\n\n  function FocusTrait() {\n    return _super.call(this, 'focused') || this;\n  }\n\n  FocusTrait.prototype.renderIndex = function (index, container) {\n    _super.prototype.renderIndex.call(this, index, container);\n\n    if (this.contains(index)) {\n      container.setAttribute('aria-selected', 'true');\n    } else {\n      container.removeAttribute('aria-selected');\n    }\n  };\n\n  return FocusTrait;\n}(Trait);\n/**\n * The TraitSpliceable is used as a util class to be able\n * to preserve traits across splice calls, given an identity\n * provider.\n */\n\n\nvar TraitSpliceable =\n/** @class */\nfunction () {\n  function TraitSpliceable(trait, view, identityProvider) {\n    this.trait = trait;\n    this.view = view;\n    this.identityProvider = identityProvider;\n  }\n\n  TraitSpliceable.prototype.splice = function (start, deleteCount, elements) {\n    var _this = this;\n\n    if (!this.identityProvider) {\n      return this.trait.splice(start, deleteCount, elements.map(function () {\n        return false;\n      }));\n    }\n\n    var pastElementsWithTrait = this.trait.get().map(function (i) {\n      return _this.identityProvider.getId(_this.view.element(i)).toString();\n    });\n    var elementsWithTrait = elements.map(function (e) {\n      return pastElementsWithTrait.indexOf(_this.identityProvider.getId(e).toString()) > -1;\n    });\n    this.trait.splice(start, deleteCount, elementsWithTrait);\n  };\n\n  return TraitSpliceable;\n}();\n\nfunction isInputElement(e) {\n  return e.tagName === 'INPUT' || e.tagName === 'TEXTAREA';\n}\n\nvar KeyboardController =\n/** @class */\nfunction () {\n  function KeyboardController(list, view, options) {\n    this.list = list;\n    this.view = view;\n    this.disposables = new DisposableStore();\n    var multipleSelectionSupport = options.multipleSelectionSupport !== false;\n    this.openController = options.openController || DefaultOpenController;\n    var onKeyDown = Event.chain(domEvent(view.domNode, 'keydown')).filter(function (e) {\n      return !isInputElement(e.target);\n    }).map(function (e) {\n      return new StandardKeyboardEvent(e);\n    });\n    onKeyDown.filter(function (e) {\n      return e.keyCode === 3\n      /* Enter */\n      ;\n    }).on(this.onEnter, this, this.disposables);\n    onKeyDown.filter(function (e) {\n      return e.keyCode === 16\n      /* UpArrow */\n      ;\n    }).on(this.onUpArrow, this, this.disposables);\n    onKeyDown.filter(function (e) {\n      return e.keyCode === 18\n      /* DownArrow */\n      ;\n    }).on(this.onDownArrow, this, this.disposables);\n    onKeyDown.filter(function (e) {\n      return e.keyCode === 11\n      /* PageUp */\n      ;\n    }).on(this.onPageUpArrow, this, this.disposables);\n    onKeyDown.filter(function (e) {\n      return e.keyCode === 12\n      /* PageDown */\n      ;\n    }).on(this.onPageDownArrow, this, this.disposables);\n    onKeyDown.filter(function (e) {\n      return e.keyCode === 9\n      /* Escape */\n      ;\n    }).on(this.onEscape, this, this.disposables);\n\n    if (multipleSelectionSupport) {\n      onKeyDown.filter(function (e) {\n        return (platform.isMacintosh ? e.metaKey : e.ctrlKey) && e.keyCode === 31\n        /* KEY_A */\n        ;\n      }).on(this.onCtrlA, this, this.disposables);\n    }\n  }\n\n  KeyboardController.prototype.onEnter = function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this.list.setSelection(this.list.getFocus(), e.browserEvent);\n\n    if (this.openController.shouldOpen(e.browserEvent)) {\n      this.list.open(this.list.getFocus(), e.browserEvent);\n    }\n  };\n\n  KeyboardController.prototype.onUpArrow = function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this.list.focusPrevious(1, false, e.browserEvent);\n    this.list.reveal(this.list.getFocus()[0]);\n    this.view.domNode.focus();\n  };\n\n  KeyboardController.prototype.onDownArrow = function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this.list.focusNext(1, false, e.browserEvent);\n    this.list.reveal(this.list.getFocus()[0]);\n    this.view.domNode.focus();\n  };\n\n  KeyboardController.prototype.onPageUpArrow = function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this.list.focusPreviousPage(e.browserEvent);\n    this.list.reveal(this.list.getFocus()[0]);\n    this.view.domNode.focus();\n  };\n\n  KeyboardController.prototype.onPageDownArrow = function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this.list.focusNextPage(e.browserEvent);\n    this.list.reveal(this.list.getFocus()[0]);\n    this.view.domNode.focus();\n  };\n\n  KeyboardController.prototype.onCtrlA = function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this.list.setSelection(range(this.list.length), e.browserEvent);\n    this.view.domNode.focus();\n  };\n\n  KeyboardController.prototype.onEscape = function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this.list.setSelection([], e.browserEvent);\n    this.view.domNode.focus();\n  };\n\n  KeyboardController.prototype.dispose = function () {\n    this.disposables.dispose();\n  };\n\n  return KeyboardController;\n}();\n\nvar TypeLabelControllerState;\n\n(function (TypeLabelControllerState) {\n  TypeLabelControllerState[TypeLabelControllerState[\"Idle\"] = 0] = \"Idle\";\n  TypeLabelControllerState[TypeLabelControllerState[\"Typing\"] = 1] = \"Typing\";\n})(TypeLabelControllerState || (TypeLabelControllerState = {}));\n\nexport function mightProducePrintableCharacter(event) {\n  if (event.ctrlKey || event.metaKey || event.altKey) {\n    return false;\n  }\n\n  return event.keyCode >= 31\n  /* KEY_A */\n  && event.keyCode <= 56\n  /* KEY_Z */\n  || event.keyCode >= 21\n  /* KEY_0 */\n  && event.keyCode <= 30\n  /* KEY_9 */\n  || event.keyCode >= 93\n  /* NUMPAD_0 */\n  && event.keyCode <= 102\n  /* NUMPAD_9 */\n  || event.keyCode >= 80\n  /* US_SEMICOLON */\n  && event.keyCode <= 90\n  /* US_QUOTE */\n  ;\n}\n\nvar TypeLabelController =\n/** @class */\nfunction () {\n  function TypeLabelController(list, view, keyboardNavigationLabelProvider) {\n    this.list = list;\n    this.view = view;\n    this.keyboardNavigationLabelProvider = keyboardNavigationLabelProvider;\n    this.enabled = false;\n    this.state = TypeLabelControllerState.Idle;\n    this.automaticKeyboardNavigation = true;\n    this.triggered = false;\n    this.enabledDisposables = new DisposableStore();\n    this.disposables = new DisposableStore();\n    this.updateOptions(list.options);\n  }\n\n  TypeLabelController.prototype.updateOptions = function (options) {\n    var enableKeyboardNavigation = typeof options.enableKeyboardNavigation === 'undefined' ? true : !!options.enableKeyboardNavigation;\n\n    if (enableKeyboardNavigation) {\n      this.enable();\n    } else {\n      this.disable();\n    }\n\n    if (typeof options.automaticKeyboardNavigation !== 'undefined') {\n      this.automaticKeyboardNavigation = options.automaticKeyboardNavigation;\n    }\n  };\n\n  TypeLabelController.prototype.enable = function () {\n    var _this = this;\n\n    if (this.enabled) {\n      return;\n    }\n\n    var onChar = Event.chain(domEvent(this.view.domNode, 'keydown')).filter(function (e) {\n      return !isInputElement(e.target);\n    }).filter(function () {\n      return _this.automaticKeyboardNavigation || _this.triggered;\n    }).map(function (event) {\n      return new StandardKeyboardEvent(event);\n    }).filter(this.keyboardNavigationLabelProvider.mightProducePrintableCharacter ? function (e) {\n      return _this.keyboardNavigationLabelProvider.mightProducePrintableCharacter(e);\n    } : function (e) {\n      return mightProducePrintableCharacter(e);\n    }).forEach(function (e) {\n      e.stopPropagation();\n      e.preventDefault();\n    }).map(function (event) {\n      return event.browserEvent.key;\n    }).event;\n    var onClear = Event.debounce(onChar, function () {\n      return null;\n    }, 800);\n    var onInput = Event.reduce(Event.any(onChar, onClear), function (r, i) {\n      return i === null ? null : (r || '') + i;\n    });\n    onInput(this.onInput, this, this.enabledDisposables);\n    this.enabled = true;\n    this.triggered = false;\n  };\n\n  TypeLabelController.prototype.disable = function () {\n    if (!this.enabled) {\n      return;\n    }\n\n    this.enabledDisposables.clear();\n    this.enabled = false;\n    this.triggered = false;\n  };\n\n  TypeLabelController.prototype.onInput = function (word) {\n    if (!word) {\n      this.state = TypeLabelControllerState.Idle;\n      this.triggered = false;\n      return;\n    }\n\n    var focus = this.list.getFocus();\n    var start = focus.length > 0 ? focus[0] : 0;\n    var delta = this.state === TypeLabelControllerState.Idle ? 1 : 0;\n    this.state = TypeLabelControllerState.Typing;\n\n    for (var i = 0; i < this.list.length; i++) {\n      var index = (start + i + delta) % this.list.length;\n      var label = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(index));\n      var labelStr = label && label.toString();\n\n      if (typeof labelStr === 'undefined' || matchesPrefix(word, labelStr)) {\n        this.list.setFocus([index]);\n        this.list.reveal(index);\n        return;\n      }\n    }\n  };\n\n  TypeLabelController.prototype.dispose = function () {\n    this.disable();\n    this.enabledDisposables.dispose();\n    this.disposables.dispose();\n  };\n\n  return TypeLabelController;\n}();\n\nvar DOMFocusController =\n/** @class */\nfunction () {\n  function DOMFocusController(list, view) {\n    this.list = list;\n    this.view = view;\n    this.disposables = new DisposableStore();\n    var onKeyDown = Event.chain(domEvent(view.domNode, 'keydown')).filter(function (e) {\n      return !isInputElement(e.target);\n    }).map(function (e) {\n      return new StandardKeyboardEvent(e);\n    });\n    onKeyDown.filter(function (e) {\n      return e.keyCode === 2\n      /* Tab */\n      && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey;\n    }).on(this.onTab, this, this.disposables);\n  }\n\n  DOMFocusController.prototype.onTab = function (e) {\n    if (e.target !== this.view.domNode) {\n      return;\n    }\n\n    var focus = this.list.getFocus();\n\n    if (focus.length === 0) {\n      return;\n    }\n\n    var focusedDomElement = this.view.domElement(focus[0]);\n\n    if (!focusedDomElement) {\n      return;\n    }\n\n    var tabIndexElement = focusedDomElement.querySelector('[tabIndex]');\n\n    if (!tabIndexElement || !(tabIndexElement instanceof HTMLElement) || tabIndexElement.tabIndex === -1) {\n      return;\n    }\n\n    var style = window.getComputedStyle(tabIndexElement);\n\n    if (style.visibility === 'hidden' || style.display === 'none') {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopPropagation();\n    tabIndexElement.focus();\n  };\n\n  DOMFocusController.prototype.dispose = function () {\n    this.disposables.dispose();\n  };\n\n  return DOMFocusController;\n}();\n\nexport function isSelectionSingleChangeEvent(event) {\n  return platform.isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;\n}\nexport function isSelectionRangeChangeEvent(event) {\n  return event.browserEvent.shiftKey;\n}\n\nfunction isMouseRightClick(event) {\n  return event instanceof MouseEvent && event.button === 2;\n}\n\nvar DefaultMultipleSelectionController = {\n  isSelectionSingleChangeEvent: isSelectionSingleChangeEvent,\n  isSelectionRangeChangeEvent: isSelectionRangeChangeEvent\n};\nvar DefaultOpenController = {\n  shouldOpen: function (event) {\n    if (event instanceof MouseEvent) {\n      return !isMouseRightClick(event);\n    }\n\n    return true;\n  }\n};\n\nvar MouseController =\n/** @class */\nfunction () {\n  function MouseController(list) {\n    this.list = list;\n    this.disposables = new DisposableStore();\n    this.multipleSelectionSupport = !(list.options.multipleSelectionSupport === false);\n\n    if (this.multipleSelectionSupport) {\n      this.multipleSelectionController = list.options.multipleSelectionController || DefaultMultipleSelectionController;\n    }\n\n    this.openController = list.options.openController || DefaultOpenController;\n    this.mouseSupport = typeof list.options.mouseSupport === 'undefined' || !!list.options.mouseSupport;\n\n    if (this.mouseSupport) {\n      list.onMouseDown(this.onMouseDown, this, this.disposables);\n      list.onContextMenu(this.onContextMenu, this, this.disposables);\n      list.onMouseDblClick(this.onDoubleClick, this, this.disposables);\n      list.onTouchStart(this.onMouseDown, this, this.disposables);\n      Gesture.addTarget(list.getHTMLElement());\n    }\n\n    list.onMouseClick(this.onPointer, this, this.disposables);\n    list.onMouseMiddleClick(this.onPointer, this, this.disposables);\n    list.onTap(this.onPointer, this, this.disposables);\n  }\n\n  MouseController.prototype.isSelectionSingleChangeEvent = function (event) {\n    if (this.multipleSelectionController) {\n      return this.multipleSelectionController.isSelectionSingleChangeEvent(event);\n    }\n\n    return platform.isMacintosh ? event.browserEvent.metaKey : event.browserEvent.ctrlKey;\n  };\n\n  MouseController.prototype.isSelectionRangeChangeEvent = function (event) {\n    if (this.multipleSelectionController) {\n      return this.multipleSelectionController.isSelectionRangeChangeEvent(event);\n    }\n\n    return event.browserEvent.shiftKey;\n  };\n\n  MouseController.prototype.isSelectionChangeEvent = function (event) {\n    return this.isSelectionSingleChangeEvent(event) || this.isSelectionRangeChangeEvent(event);\n  };\n\n  MouseController.prototype.onMouseDown = function (e) {\n    if (document.activeElement !== e.browserEvent.target) {\n      this.list.domFocus();\n    }\n  };\n\n  MouseController.prototype.onContextMenu = function (e) {\n    var focus = typeof e.index === 'undefined' ? [] : [e.index];\n    this.list.setFocus(focus, e.browserEvent);\n  };\n\n  MouseController.prototype.onPointer = function (e) {\n    if (!this.mouseSupport) {\n      return;\n    }\n\n    if (isInputElement(e.browserEvent.target)) {\n      return;\n    }\n\n    var reference = this.list.getFocus()[0];\n    var selection = this.list.getSelection();\n    reference = reference === undefined ? selection[0] : reference;\n    var focus = e.index;\n\n    if (typeof focus === 'undefined') {\n      this.list.setFocus([], e.browserEvent);\n      this.list.setSelection([], e.browserEvent);\n      return;\n    }\n\n    if (this.multipleSelectionSupport && this.isSelectionRangeChangeEvent(e)) {\n      return this.changeSelection(e, reference);\n    }\n\n    if (this.multipleSelectionSupport && this.isSelectionChangeEvent(e)) {\n      return this.changeSelection(e, reference);\n    }\n\n    this.list.setFocus([focus], e.browserEvent);\n\n    if (!isMouseRightClick(e.browserEvent)) {\n      this.list.setSelection([focus], e.browserEvent);\n\n      if (this.openController.shouldOpen(e.browserEvent)) {\n        this.list.open([focus], e.browserEvent);\n      }\n    }\n  };\n\n  MouseController.prototype.onDoubleClick = function (e) {\n    if (isInputElement(e.browserEvent.target)) {\n      return;\n    }\n\n    if (this.multipleSelectionSupport && this.isSelectionChangeEvent(e)) {\n      return;\n    }\n\n    var focus = this.list.getFocus();\n    this.list.setSelection(focus, e.browserEvent);\n    this.list.pin(focus);\n  };\n\n  MouseController.prototype.changeSelection = function (e, reference) {\n    var focus = e.index;\n\n    if (this.isSelectionRangeChangeEvent(e) && reference !== undefined) {\n      var min = Math.min(reference, focus);\n      var max = Math.max(reference, focus);\n      var rangeSelection = range(min, max + 1);\n      var selection = this.list.getSelection();\n      var contiguousRange = getContiguousRangeContaining(disjunction(selection, [reference]), reference);\n\n      if (contiguousRange.length === 0) {\n        return;\n      }\n\n      var newSelection = disjunction(rangeSelection, relativeComplement(selection, contiguousRange));\n      this.list.setSelection(newSelection, e.browserEvent);\n    } else if (this.isSelectionSingleChangeEvent(e)) {\n      var selection = this.list.getSelection();\n      var newSelection = selection.filter(function (i) {\n        return i !== focus;\n      });\n      this.list.setFocus([focus]);\n\n      if (selection.length === newSelection.length) {\n        this.list.setSelection(newSelection.concat([focus]), e.browserEvent);\n      } else {\n        this.list.setSelection(newSelection, e.browserEvent);\n      }\n    }\n  };\n\n  MouseController.prototype.dispose = function () {\n    this.disposables.dispose();\n  };\n\n  return MouseController;\n}();\n\nexport { MouseController };\n\nvar DefaultStyleController =\n/** @class */\nfunction () {\n  function DefaultStyleController(styleElement, selectorSuffix) {\n    this.styleElement = styleElement;\n    this.selectorSuffix = selectorSuffix;\n  }\n\n  DefaultStyleController.prototype.style = function (styles) {\n    var suffix = this.selectorSuffix ? \".\" + this.selectorSuffix : '';\n    var content = [];\n\n    if (styles.listFocusBackground) {\n      content.push(\".monaco-list\" + suffix + \":focus .monaco-list-row.focused { background-color: \" + styles.listFocusBackground + \"; }\");\n      content.push(\".monaco-list\" + suffix + \":focus .monaco-list-row.focused:hover { background-color: \" + styles.listFocusBackground + \"; }\"); // overwrite :hover style in this case!\n    }\n\n    if (styles.listFocusForeground) {\n      content.push(\".monaco-list\" + suffix + \":focus .monaco-list-row.focused { color: \" + styles.listFocusForeground + \"; }\");\n    }\n\n    if (styles.listActiveSelectionBackground) {\n      content.push(\".monaco-list\" + suffix + \":focus .monaco-list-row.selected { background-color: \" + styles.listActiveSelectionBackground + \"; }\");\n      content.push(\".monaco-list\" + suffix + \":focus .monaco-list-row.selected:hover { background-color: \" + styles.listActiveSelectionBackground + \"; }\"); // overwrite :hover style in this case!\n    }\n\n    if (styles.listActiveSelectionForeground) {\n      content.push(\".monaco-list\" + suffix + \":focus .monaco-list-row.selected { color: \" + styles.listActiveSelectionForeground + \"; }\");\n    }\n\n    if (styles.listFocusAndSelectionBackground) {\n      content.push(\"\\n\\t\\t\\t\\t.monaco-drag-image,\\n\\t\\t\\t\\t.monaco-list\" + suffix + \":focus .monaco-list-row.selected.focused { background-color: \" + styles.listFocusAndSelectionBackground + \"; }\\n\\t\\t\\t\");\n    }\n\n    if (styles.listFocusAndSelectionForeground) {\n      content.push(\"\\n\\t\\t\\t\\t.monaco-drag-image,\\n\\t\\t\\t\\t.monaco-list\" + suffix + \":focus .monaco-list-row.selected.focused { color: \" + styles.listFocusAndSelectionForeground + \"; }\\n\\t\\t\\t\");\n    }\n\n    if (styles.listInactiveFocusBackground) {\n      content.push(\".monaco-list\" + suffix + \" .monaco-list-row.focused { background-color:  \" + styles.listInactiveFocusBackground + \"; }\");\n      content.push(\".monaco-list\" + suffix + \" .monaco-list-row.focused:hover { background-color:  \" + styles.listInactiveFocusBackground + \"; }\"); // overwrite :hover style in this case!\n    }\n\n    if (styles.listInactiveSelectionBackground) {\n      content.push(\".monaco-list\" + suffix + \" .monaco-list-row.selected { background-color:  \" + styles.listInactiveSelectionBackground + \"; }\");\n      content.push(\".monaco-list\" + suffix + \" .monaco-list-row.selected:hover { background-color:  \" + styles.listInactiveSelectionBackground + \"; }\"); // overwrite :hover style in this case!\n    }\n\n    if (styles.listInactiveSelectionForeground) {\n      content.push(\".monaco-list\" + suffix + \" .monaco-list-row.selected { color: \" + styles.listInactiveSelectionForeground + \"; }\");\n    }\n\n    if (styles.listHoverBackground) {\n      content.push(\".monaco-list\" + suffix + \":not(.drop-target) .monaco-list-row:hover:not(.selected):not(.focused) { background-color:  \" + styles.listHoverBackground + \"; }\");\n    }\n\n    if (styles.listHoverForeground) {\n      content.push(\".monaco-list\" + suffix + \" .monaco-list-row:hover:not(.selected):not(.focused) { color:  \" + styles.listHoverForeground + \"; }\");\n    }\n\n    if (styles.listSelectionOutline) {\n      content.push(\".monaco-list\" + suffix + \" .monaco-list-row.selected { outline: 1px dotted \" + styles.listSelectionOutline + \"; outline-offset: -1px; }\");\n    }\n\n    if (styles.listFocusOutline) {\n      content.push(\"\\n\\t\\t\\t\\t.monaco-drag-image,\\n\\t\\t\\t\\t.monaco-list\" + suffix + \":focus .monaco-list-row.focused { outline: 1px solid \" + styles.listFocusOutline + \"; outline-offset: -1px; }\\n\\t\\t\\t\");\n    }\n\n    if (styles.listInactiveFocusOutline) {\n      content.push(\".monaco-list\" + suffix + \" .monaco-list-row.focused { outline: 1px dotted \" + styles.listInactiveFocusOutline + \"; outline-offset: -1px; }\");\n    }\n\n    if (styles.listHoverOutline) {\n      content.push(\".monaco-list\" + suffix + \" .monaco-list-row:hover { outline: 1px dashed \" + styles.listHoverOutline + \"; outline-offset: -1px; }\");\n    }\n\n    if (styles.listDropBackground) {\n      content.push(\"\\n\\t\\t\\t\\t.monaco-list\" + suffix + \".drop-target,\\n\\t\\t\\t\\t.monaco-list\" + suffix + \" .monaco-list-row.drop-target { background-color: \" + styles.listDropBackground + \" !important; color: inherit !important; }\\n\\t\\t\\t\");\n    }\n\n    if (styles.listFilterWidgetBackground) {\n      content.push(\".monaco-list-type-filter { background-color: \" + styles.listFilterWidgetBackground + \" }\");\n    }\n\n    if (styles.listFilterWidgetOutline) {\n      content.push(\".monaco-list-type-filter { border: 1px solid \" + styles.listFilterWidgetOutline + \"; }\");\n    }\n\n    if (styles.listFilterWidgetNoMatchesOutline) {\n      content.push(\".monaco-list-type-filter.no-matches { border: 1px solid \" + styles.listFilterWidgetNoMatchesOutline + \"; }\");\n    }\n\n    if (styles.listMatchesShadow) {\n      content.push(\".monaco-list-type-filter { box-shadow: 1px 1px 1px \" + styles.listMatchesShadow + \"; }\");\n    }\n\n    var newStyles = content.join('\\n');\n\n    if (newStyles !== this.styleElement.innerHTML) {\n      this.styleElement.innerHTML = newStyles;\n    }\n  };\n\n  return DefaultStyleController;\n}();\n\nexport { DefaultStyleController };\nvar defaultStyles = {\n  listFocusBackground: Color.fromHex('#073655'),\n  listActiveSelectionBackground: Color.fromHex('#0E639C'),\n  listActiveSelectionForeground: Color.fromHex('#FFFFFF'),\n  listFocusAndSelectionBackground: Color.fromHex('#094771'),\n  listFocusAndSelectionForeground: Color.fromHex('#FFFFFF'),\n  listInactiveSelectionBackground: Color.fromHex('#3F3F46'),\n  listHoverBackground: Color.fromHex('#2A2D2E'),\n  listDropBackground: Color.fromHex('#383B3D'),\n  treeIndentGuidesStroke: Color.fromHex('#a9a9a9')\n};\nvar DefaultOptions = {\n  keyboardSupport: true,\n  mouseSupport: true,\n  multipleSelectionSupport: true,\n  dnd: {\n    getDragURI: function () {\n      return null;\n    },\n    onDragStart: function () {},\n    onDragOver: function () {\n      return false;\n    },\n    drop: function () {}\n  },\n  ariaRootRole: ListAriaRootRole.TREE\n}; // TODO@Joao: move these utils into a SortedArray class\n\nfunction getContiguousRangeContaining(range, value) {\n  var index = range.indexOf(value);\n\n  if (index === -1) {\n    return [];\n  }\n\n  var result = [];\n  var i = index - 1;\n\n  while (i >= 0 && range[i] === value - (index - i)) {\n    result.push(range[i--]);\n  }\n\n  result.reverse();\n  i = index;\n\n  while (i < range.length && range[i] === value + (i - index)) {\n    result.push(range[i++]);\n  }\n\n  return result;\n}\n/**\n * Given two sorted collections of numbers, returns the intersection\n * between them (OR).\n */\n\n\nfunction disjunction(one, other) {\n  var result = [];\n  var i = 0,\n      j = 0;\n\n  while (i < one.length || j < other.length) {\n    if (i >= one.length) {\n      result.push(other[j++]);\n    } else if (j >= other.length) {\n      result.push(one[i++]);\n    } else if (one[i] === other[j]) {\n      result.push(one[i]);\n      i++;\n      j++;\n      continue;\n    } else if (one[i] < other[j]) {\n      result.push(one[i++]);\n    } else {\n      result.push(other[j++]);\n    }\n  }\n\n  return result;\n}\n/**\n * Given two sorted collections of numbers, returns the relative\n * complement between them (XOR).\n */\n\n\nfunction relativeComplement(one, other) {\n  var result = [];\n  var i = 0,\n      j = 0;\n\n  while (i < one.length || j < other.length) {\n    if (i >= one.length) {\n      result.push(other[j++]);\n    } else if (j >= other.length) {\n      result.push(one[i++]);\n    } else if (one[i] === other[j]) {\n      i++;\n      j++;\n      continue;\n    } else if (one[i] < other[j]) {\n      result.push(one[i++]);\n    } else {\n      j++;\n    }\n  }\n\n  return result;\n}\n\nvar numericSort = function (a, b) {\n  return a - b;\n};\n\nvar PipelineRenderer =\n/** @class */\nfunction () {\n  function PipelineRenderer(_templateId, renderers) {\n    this._templateId = _templateId;\n    this.renderers = renderers;\n  }\n\n  Object.defineProperty(PipelineRenderer.prototype, \"templateId\", {\n    get: function () {\n      return this._templateId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  PipelineRenderer.prototype.renderTemplate = function (container) {\n    return this.renderers.map(function (r) {\n      return r.renderTemplate(container);\n    });\n  };\n\n  PipelineRenderer.prototype.renderElement = function (element, index, templateData, height) {\n    var i = 0;\n\n    for (var _i = 0, _a = this.renderers; _i < _a.length; _i++) {\n      var renderer = _a[_i];\n      renderer.renderElement(element, index, templateData[i++], height);\n    }\n  };\n\n  PipelineRenderer.prototype.disposeElement = function (element, index, templateData, height) {\n    var i = 0;\n\n    for (var _i = 0, _a = this.renderers; _i < _a.length; _i++) {\n      var renderer = _a[_i];\n\n      if (renderer.disposeElement) {\n        renderer.disposeElement(element, index, templateData[i], height);\n      }\n\n      i += 1;\n    }\n  };\n\n  PipelineRenderer.prototype.disposeTemplate = function (templateData) {\n    var i = 0;\n\n    for (var _i = 0, _a = this.renderers; _i < _a.length; _i++) {\n      var renderer = _a[_i];\n      renderer.disposeTemplate(templateData[i++]);\n    }\n  };\n\n  return PipelineRenderer;\n}();\n\nvar AccessibiltyRenderer =\n/** @class */\nfunction () {\n  function AccessibiltyRenderer(accessibilityProvider) {\n    this.accessibilityProvider = accessibilityProvider;\n    this.templateId = 'a18n';\n  }\n\n  AccessibiltyRenderer.prototype.renderTemplate = function (container) {\n    return container;\n  };\n\n  AccessibiltyRenderer.prototype.renderElement = function (element, index, container) {\n    var ariaLabel = this.accessibilityProvider.getAriaLabel(element);\n\n    if (ariaLabel) {\n      container.setAttribute('aria-label', ariaLabel);\n    } else {\n      container.removeAttribute('aria-label');\n    }\n\n    var ariaLevel = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(element);\n\n    if (typeof ariaLevel === 'number') {\n      container.setAttribute('aria-level', \"\" + ariaLevel);\n    } else {\n      container.removeAttribute('aria-level');\n    }\n  };\n\n  AccessibiltyRenderer.prototype.disposeTemplate = function (templateData) {// noop\n  };\n\n  return AccessibiltyRenderer;\n}();\n\nvar ListViewDragAndDrop =\n/** @class */\nfunction () {\n  function ListViewDragAndDrop(list, dnd) {\n    this.list = list;\n    this.dnd = dnd;\n  }\n\n  ListViewDragAndDrop.prototype.getDragElements = function (element) {\n    var selection = this.list.getSelectedElements();\n    var elements = selection.indexOf(element) > -1 ? selection : [element];\n    return elements;\n  };\n\n  ListViewDragAndDrop.prototype.getDragURI = function (element) {\n    return this.dnd.getDragURI(element);\n  };\n\n  ListViewDragAndDrop.prototype.getDragLabel = function (elements) {\n    if (this.dnd.getDragLabel) {\n      return this.dnd.getDragLabel(elements);\n    }\n\n    return undefined;\n  };\n\n  ListViewDragAndDrop.prototype.onDragStart = function (data, originalEvent) {\n    if (this.dnd.onDragStart) {\n      this.dnd.onDragStart(data, originalEvent);\n    }\n  };\n\n  ListViewDragAndDrop.prototype.onDragOver = function (data, targetElement, targetIndex, originalEvent) {\n    return this.dnd.onDragOver(data, targetElement, targetIndex, originalEvent);\n  };\n\n  ListViewDragAndDrop.prototype.drop = function (data, targetElement, targetIndex, originalEvent) {\n    this.dnd.drop(data, targetElement, targetIndex, originalEvent);\n  };\n\n  return ListViewDragAndDrop;\n}();\n\nvar List =\n/** @class */\nfunction () {\n  function List(container, virtualDelegate, renderers, _options) {\n    if (_options === void 0) {\n      _options = DefaultOptions;\n    }\n\n    this._options = _options;\n    this.eventBufferer = new EventBufferer();\n    this.disposables = new DisposableStore();\n    this._onDidOpen = new Emitter();\n    this.onDidOpen = this._onDidOpen.event;\n    this._onPin = new Emitter();\n    this.didJustPressContextMenuKey = false;\n    this._onDidDispose = new Emitter();\n    this.onDidDispose = this._onDidDispose.event;\n    this.focus = new FocusTrait();\n    this.selection = new Trait('selected');\n    mixin(_options, defaultStyles, false);\n    var baseRenderers = [this.focus.renderer, this.selection.renderer];\n\n    if (_options.accessibilityProvider) {\n      baseRenderers.push(new AccessibiltyRenderer(_options.accessibilityProvider));\n    }\n\n    renderers = renderers.map(function (r) {\n      return new PipelineRenderer(r.templateId, baseRenderers.concat([r]));\n    });\n\n    var viewOptions = __assign({}, _options, {\n      dnd: _options.dnd && new ListViewDragAndDrop(this, _options.dnd)\n    });\n\n    this.view = new ListView(container, virtualDelegate, renderers, viewOptions);\n\n    if (typeof _options.ariaRole !== 'string') {\n      this.view.domNode.setAttribute('role', ListAriaRootRole.TREE);\n    } else {\n      this.view.domNode.setAttribute('role', _options.ariaRole);\n    }\n\n    this.styleElement = DOM.createStyleSheet(this.view.domNode);\n    this.styleController = _options.styleController || new DefaultStyleController(this.styleElement, this.view.domId);\n    this.spliceable = new CombinedSpliceable([new TraitSpliceable(this.focus, this.view, _options.identityProvider), new TraitSpliceable(this.selection, this.view, _options.identityProvider), this.view]);\n    this.disposables.add(this.focus);\n    this.disposables.add(this.selection);\n    this.disposables.add(this.view);\n    this.disposables.add(this._onDidDispose);\n    this.onDidFocus = Event.map(domEvent(this.view.domNode, 'focus', true), function () {\n      return null;\n    });\n    this.onDidBlur = Event.map(domEvent(this.view.domNode, 'blur', true), function () {\n      return null;\n    });\n    this.disposables.add(new DOMFocusController(this, this.view));\n\n    if (typeof _options.keyboardSupport !== 'boolean' || _options.keyboardSupport) {\n      var controller = new KeyboardController(this, this.view, _options);\n      this.disposables.add(controller);\n    }\n\n    if (_options.keyboardNavigationLabelProvider) {\n      this.typeLabelController = new TypeLabelController(this, this.view, _options.keyboardNavigationLabelProvider);\n      this.disposables.add(this.typeLabelController);\n    }\n\n    this.disposables.add(this.createMouseController(_options));\n    this.onFocusChange(this._onFocusChange, this, this.disposables);\n    this.onSelectionChange(this._onSelectionChange, this, this.disposables);\n\n    if (_options.ariaLabel) {\n      this.view.domNode.setAttribute('aria-label', localize('aria list', \"{0}. Use the navigation keys to navigate.\", _options.ariaLabel));\n    }\n\n    this.style(_options);\n  }\n\n  Object.defineProperty(List.prototype, \"onFocusChange\", {\n    get: function () {\n      var _this = this;\n\n      return Event.map(this.eventBufferer.wrapEvent(this.focus.onChange), function (e) {\n        return _this.toListEvent(e);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(List.prototype, \"onSelectionChange\", {\n    get: function () {\n      var _this = this;\n\n      return Event.map(this.eventBufferer.wrapEvent(this.selection.onChange), function (e) {\n        return _this.toListEvent(e);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(List.prototype, \"domId\", {\n    get: function () {\n      return this.view.domId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(List.prototype, \"onMouseClick\", {\n    get: function () {\n      return this.view.onMouseClick;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(List.prototype, \"onMouseDblClick\", {\n    get: function () {\n      return this.view.onMouseDblClick;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(List.prototype, \"onMouseMiddleClick\", {\n    get: function () {\n      return this.view.onMouseMiddleClick;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(List.prototype, \"onMouseDown\", {\n    get: function () {\n      return this.view.onMouseDown;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(List.prototype, \"onTouchStart\", {\n    get: function () {\n      return this.view.onTouchStart;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(List.prototype, \"onTap\", {\n    get: function () {\n      return this.view.onTap;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(List.prototype, \"onContextMenu\", {\n    get: function () {\n      var _this = this;\n\n      var fromKeydown = Event.chain(domEvent(this.view.domNode, 'keydown')).map(function (e) {\n        return new StandardKeyboardEvent(e);\n      }).filter(function (e) {\n        return _this.didJustPressContextMenuKey = e.keyCode === 58\n        /* ContextMenu */\n        || e.shiftKey && e.keyCode === 68\n        /* F10 */\n        ;\n      }).filter(function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n      }).event;\n      var fromKeyup = Event.chain(domEvent(this.view.domNode, 'keyup')).filter(function () {\n        var didJustPressContextMenuKey = _this.didJustPressContextMenuKey;\n        _this.didJustPressContextMenuKey = false;\n        return didJustPressContextMenuKey;\n      }).filter(function () {\n        return _this.getFocus().length > 0 && !!_this.view.domElement(_this.getFocus()[0]);\n      }).map(function (browserEvent) {\n        var index = _this.getFocus()[0];\n\n        var element = _this.view.element(index);\n\n        var anchor = _this.view.domElement(index);\n\n        return {\n          index: index,\n          element: element,\n          anchor: anchor,\n          browserEvent: browserEvent\n        };\n      }).event;\n      var fromMouse = Event.chain(this.view.onContextMenu).filter(function () {\n        return !_this.didJustPressContextMenuKey;\n      }).map(function (_a) {\n        var element = _a.element,\n            index = _a.index,\n            browserEvent = _a.browserEvent;\n        return {\n          element: element,\n          index: index,\n          anchor: {\n            x: browserEvent.clientX + 1,\n            y: browserEvent.clientY\n          },\n          browserEvent: browserEvent\n        };\n      }).event;\n      return Event.any(fromKeydown, fromKeyup, fromMouse);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(List.prototype, \"onKeyDown\", {\n    get: function () {\n      return domEvent(this.view.domNode, 'keydown');\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  List.prototype.createMouseController = function (options) {\n    return new MouseController(this);\n  };\n\n  List.prototype.updateOptions = function (optionsUpdate) {\n    if (optionsUpdate === void 0) {\n      optionsUpdate = {};\n    }\n\n    this._options = __assign({}, this._options, optionsUpdate);\n\n    if (this.typeLabelController) {\n      this.typeLabelController.updateOptions(this._options);\n    }\n  };\n\n  Object.defineProperty(List.prototype, \"options\", {\n    get: function () {\n      return this._options;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  List.prototype.splice = function (start, deleteCount, elements) {\n    var _this = this;\n\n    if (elements === void 0) {\n      elements = [];\n    }\n\n    if (start < 0 || start > this.view.length) {\n      throw new Error(\"Invalid start index: \" + start);\n    }\n\n    if (deleteCount < 0) {\n      throw new Error(\"Invalid delete count: \" + deleteCount);\n    }\n\n    if (deleteCount === 0 && elements.length === 0) {\n      return;\n    }\n\n    this.eventBufferer.bufferEvents(function () {\n      return _this.spliceable.splice(start, deleteCount, elements);\n    });\n  };\n\n  List.prototype.rerender = function () {\n    this.view.rerender();\n  };\n\n  List.prototype.element = function (index) {\n    return this.view.element(index);\n  };\n\n  Object.defineProperty(List.prototype, \"length\", {\n    get: function () {\n      return this.view.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(List.prototype, \"contentHeight\", {\n    get: function () {\n      return this.view.contentHeight;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(List.prototype, \"scrollTop\", {\n    get: function () {\n      return this.view.getScrollTop();\n    },\n    set: function (scrollTop) {\n      this.view.setScrollTop(scrollTop);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  List.prototype.domFocus = function () {\n    this.view.domNode.focus();\n  };\n\n  List.prototype.layout = function (height, width) {\n    this.view.layout(height, width);\n  };\n\n  List.prototype.setSelection = function (indexes, browserEvent) {\n    for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {\n      var index = indexes_1[_i];\n\n      if (index < 0 || index >= this.length) {\n        throw new Error(\"Invalid index \" + index);\n      }\n    }\n\n    this.selection.set(indexes, browserEvent);\n  };\n\n  List.prototype.getSelection = function () {\n    return this.selection.get();\n  };\n\n  List.prototype.getSelectedElements = function () {\n    var _this = this;\n\n    return this.getSelection().map(function (i) {\n      return _this.view.element(i);\n    });\n  };\n\n  List.prototype.setFocus = function (indexes, browserEvent) {\n    for (var _i = 0, indexes_2 = indexes; _i < indexes_2.length; _i++) {\n      var index = indexes_2[_i];\n\n      if (index < 0 || index >= this.length) {\n        throw new Error(\"Invalid index \" + index);\n      }\n    }\n\n    this.focus.set(indexes, browserEvent);\n  };\n\n  List.prototype.focusNext = function (n, loop, browserEvent, filter) {\n    if (n === void 0) {\n      n = 1;\n    }\n\n    if (loop === void 0) {\n      loop = false;\n    }\n\n    if (this.length === 0) {\n      return;\n    }\n\n    var focus = this.focus.get();\n    var index = this.findNextIndex(focus.length > 0 ? focus[0] + n : 0, loop, filter);\n\n    if (index > -1) {\n      this.setFocus([index], browserEvent);\n    }\n  };\n\n  List.prototype.focusPrevious = function (n, loop, browserEvent, filter) {\n    if (n === void 0) {\n      n = 1;\n    }\n\n    if (loop === void 0) {\n      loop = false;\n    }\n\n    if (this.length === 0) {\n      return;\n    }\n\n    var focus = this.focus.get();\n    var index = this.findPreviousIndex(focus.length > 0 ? focus[0] - n : 0, loop, filter);\n\n    if (index > -1) {\n      this.setFocus([index], browserEvent);\n    }\n  };\n\n  List.prototype.focusNextPage = function (browserEvent, filter) {\n    var _this = this;\n\n    var lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);\n    lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;\n    var lastPageElement = this.view.element(lastPageIndex);\n    var currentlyFocusedElement = this.getFocusedElements()[0];\n\n    if (currentlyFocusedElement !== lastPageElement) {\n      var lastGoodPageIndex = this.findPreviousIndex(lastPageIndex, false, filter);\n\n      if (lastGoodPageIndex > -1 && currentlyFocusedElement !== this.view.element(lastGoodPageIndex)) {\n        this.setFocus([lastGoodPageIndex], browserEvent);\n      } else {\n        this.setFocus([lastPageIndex], browserEvent);\n      }\n    } else {\n      var previousScrollTop = this.view.getScrollTop();\n      this.view.setScrollTop(previousScrollTop + this.view.renderHeight - this.view.elementHeight(lastPageIndex));\n\n      if (this.view.getScrollTop() !== previousScrollTop) {\n        // Let the scroll event listener run\n        setTimeout(function () {\n          return _this.focusNextPage(browserEvent, filter);\n        }, 0);\n      }\n    }\n  };\n\n  List.prototype.focusPreviousPage = function (browserEvent, filter) {\n    var _this = this;\n\n    var firstPageIndex;\n    var scrollTop = this.view.getScrollTop();\n\n    if (scrollTop === 0) {\n      firstPageIndex = this.view.indexAt(scrollTop);\n    } else {\n      firstPageIndex = this.view.indexAfter(scrollTop - 1);\n    }\n\n    var firstPageElement = this.view.element(firstPageIndex);\n    var currentlyFocusedElement = this.getFocusedElements()[0];\n\n    if (currentlyFocusedElement !== firstPageElement) {\n      var firstGoodPageIndex = this.findNextIndex(firstPageIndex, false, filter);\n\n      if (firstGoodPageIndex > -1 && currentlyFocusedElement !== this.view.element(firstGoodPageIndex)) {\n        this.setFocus([firstGoodPageIndex], browserEvent);\n      } else {\n        this.setFocus([firstPageIndex], browserEvent);\n      }\n    } else {\n      var previousScrollTop = scrollTop;\n      this.view.setScrollTop(scrollTop - this.view.renderHeight);\n\n      if (this.view.getScrollTop() !== previousScrollTop) {\n        // Let the scroll event listener run\n        setTimeout(function () {\n          return _this.focusPreviousPage(browserEvent, filter);\n        }, 0);\n      }\n    }\n  };\n\n  List.prototype.focusLast = function (browserEvent, filter) {\n    if (this.length === 0) {\n      return;\n    }\n\n    var index = this.findPreviousIndex(this.length - 1, false, filter);\n\n    if (index > -1) {\n      this.setFocus([index], browserEvent);\n    }\n  };\n\n  List.prototype.focusFirst = function (browserEvent, filter) {\n    if (this.length === 0) {\n      return;\n    }\n\n    var index = this.findNextIndex(0, false, filter);\n\n    if (index > -1) {\n      this.setFocus([index], browserEvent);\n    }\n  };\n\n  List.prototype.findNextIndex = function (index, loop, filter) {\n    if (loop === void 0) {\n      loop = false;\n    }\n\n    for (var i = 0; i < this.length; i++) {\n      if (index >= this.length && !loop) {\n        return -1;\n      }\n\n      index = index % this.length;\n\n      if (!filter || filter(this.element(index))) {\n        return index;\n      }\n\n      index++;\n    }\n\n    return -1;\n  };\n\n  List.prototype.findPreviousIndex = function (index, loop, filter) {\n    if (loop === void 0) {\n      loop = false;\n    }\n\n    for (var i = 0; i < this.length; i++) {\n      if (index < 0 && !loop) {\n        return -1;\n      }\n\n      index = (this.length + index % this.length) % this.length;\n\n      if (!filter || filter(this.element(index))) {\n        return index;\n      }\n\n      index--;\n    }\n\n    return -1;\n  };\n\n  List.prototype.getFocus = function () {\n    return this.focus.get();\n  };\n\n  List.prototype.getFocusedElements = function () {\n    var _this = this;\n\n    return this.getFocus().map(function (i) {\n      return _this.view.element(i);\n    });\n  };\n\n  List.prototype.reveal = function (index, relativeTop) {\n    if (index < 0 || index >= this.length) {\n      throw new Error(\"Invalid index \" + index);\n    }\n\n    var scrollTop = this.view.getScrollTop();\n    var elementTop = this.view.elementTop(index);\n    var elementHeight = this.view.elementHeight(index);\n\n    if (isNumber(relativeTop)) {\n      // y = mx + b\n      var m = elementHeight - this.view.renderHeight;\n      this.view.setScrollTop(m * clamp(relativeTop, 0, 1) + elementTop);\n    } else {\n      var viewItemBottom = elementTop + elementHeight;\n      var wrapperBottom = scrollTop + this.view.renderHeight;\n\n      if (elementTop < scrollTop) {\n        this.view.setScrollTop(elementTop);\n      } else if (viewItemBottom >= wrapperBottom) {\n        this.view.setScrollTop(viewItemBottom - this.view.renderHeight);\n      }\n    }\n  };\n  /**\n   * Returns the relative position of an element rendered in the list.\n   * Returns `null` if the element isn't *entirely* in the visible viewport.\n   */\n\n\n  List.prototype.getRelativeTop = function (index) {\n    if (index < 0 || index >= this.length) {\n      throw new Error(\"Invalid index \" + index);\n    }\n\n    var scrollTop = this.view.getScrollTop();\n    var elementTop = this.view.elementTop(index);\n    var elementHeight = this.view.elementHeight(index);\n\n    if (elementTop < scrollTop || elementTop + elementHeight > scrollTop + this.view.renderHeight) {\n      return null;\n    } // y = mx + b\n\n\n    var m = elementHeight - this.view.renderHeight;\n    return Math.abs((scrollTop - elementTop) / m);\n  };\n\n  List.prototype.getHTMLElement = function () {\n    return this.view.domNode;\n  };\n\n  List.prototype.open = function (indexes, browserEvent) {\n    var _this = this;\n\n    for (var _i = 0, indexes_3 = indexes; _i < indexes_3.length; _i++) {\n      var index = indexes_3[_i];\n\n      if (index < 0 || index >= this.length) {\n        throw new Error(\"Invalid index \" + index);\n      }\n    }\n\n    this._onDidOpen.fire({\n      indexes: indexes,\n      elements: indexes.map(function (i) {\n        return _this.view.element(i);\n      }),\n      browserEvent: browserEvent\n    });\n  };\n\n  List.prototype.pin = function (indexes) {\n    for (var _i = 0, indexes_4 = indexes; _i < indexes_4.length; _i++) {\n      var index = indexes_4[_i];\n\n      if (index < 0 || index >= this.length) {\n        throw new Error(\"Invalid index \" + index);\n      }\n    }\n\n    this._onPin.fire(indexes);\n  };\n\n  List.prototype.style = function (styles) {\n    this.styleController.style(styles);\n  };\n\n  List.prototype.toListEvent = function (_a) {\n    var _this = this;\n\n    var indexes = _a.indexes,\n        browserEvent = _a.browserEvent;\n    return {\n      indexes: indexes,\n      elements: indexes.map(function (i) {\n        return _this.view.element(i);\n      }),\n      browserEvent: browserEvent\n    };\n  };\n\n  List.prototype._onFocusChange = function () {\n    var focus = this.focus.get();\n\n    if (focus.length > 0) {\n      this.view.domNode.setAttribute('aria-activedescendant', this.view.getElementDomId(focus[0]));\n    } else {\n      this.view.domNode.removeAttribute('aria-activedescendant');\n    }\n\n    this.view.domNode.setAttribute('role', 'tree');\n    DOM.toggleClass(this.view.domNode, 'element-focused', focus.length > 0);\n  };\n\n  List.prototype._onSelectionChange = function () {\n    var selection = this.selection.get();\n    DOM.toggleClass(this.view.domNode, 'selection-none', selection.length === 0);\n    DOM.toggleClass(this.view.domNode, 'selection-single', selection.length === 1);\n    DOM.toggleClass(this.view.domNode, 'selection-multiple', selection.length > 1);\n  };\n\n  List.prototype.dispose = function () {\n    this._onDidDispose.fire();\n\n    this.disposables.dispose();\n\n    this._onDidOpen.dispose();\n\n    this._onPin.dispose();\n\n    this._onDidDispose.dispose();\n  };\n\n  __decorate([memoize], List.prototype, \"onFocusChange\", null);\n\n  __decorate([memoize], List.prototype, \"onSelectionChange\", null);\n\n  __decorate([memoize], List.prototype, \"onContextMenu\", null);\n\n  return List;\n}();\n\nexport { List };","map":null,"metadata":{},"sourceType":"module"}