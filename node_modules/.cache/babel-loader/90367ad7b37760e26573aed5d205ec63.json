{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport * as paths from './path.js';\nimport { URI } from './uri.js';\nimport { equalsIgnoreCase } from './strings.js';\nimport { Schemas } from './network.js';\nimport { isLinux, isWindows } from './platform.js';\nexport function hasToIgnoreCase(resource) {\n  // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n  // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n  return resource && resource.scheme === Schemas.file ? !isLinux : true;\n}\nexport function basenameOrAuthority(resource) {\n  return basename(resource) || resource.authority;\n}\n/**\n * Tests wheter the two authorities are the same\n */\n\nexport function isEqualAuthority(a1, a2) {\n  return a1 === a2 || equalsIgnoreCase(a1, a2);\n}\nexport function isEqual(first, second, ignoreCase) {\n  if (ignoreCase === void 0) {\n    ignoreCase = hasToIgnoreCase(first);\n  }\n\n  if (first === second) {\n    return true;\n  }\n\n  if (!first || !second) {\n    return false;\n  }\n\n  if (first.scheme !== second.scheme || !isEqualAuthority(first.authority, second.authority)) {\n    return false;\n  }\n\n  var p1 = first.path || '/',\n      p2 = second.path || '/';\n  return p1 === p2 || ignoreCase && equalsIgnoreCase(p1 || '/', p2 || '/');\n}\nexport function basename(resource) {\n  return paths.posix.basename(resource.path);\n}\n/**\n * Return a URI representing the directory of a URI path.\n *\n * @param resource The input URI.\n * @returns The URI representing the directory of the input URI.\n */\n\nexport function dirname(resource) {\n  if (resource.path.length === 0) {\n    return resource;\n  }\n\n  if (resource.scheme === Schemas.file) {\n    return URI.file(paths.dirname(originalFSPath(resource)));\n  }\n\n  var dirname = paths.posix.dirname(resource.path);\n\n  if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47\n  /* Slash */\n  ) {\n      console.error(\"dirname(\\\"\" + resource.toString + \")) resulted in a relative path\");\n      dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n    }\n\n  return resource.with({\n    path: dirname\n  });\n}\n/**\n * Join a URI path with path fragments and normalizes the resulting path.\n *\n * @param resource The input URI.\n * @param pathFragment The path fragment to add to the URI path.\n * @returns The resulting URI.\n */\n\nexport function joinPath(resource) {\n  var _a;\n\n  var pathFragment = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    pathFragment[_i - 1] = arguments[_i];\n  }\n\n  var joinedPath;\n\n  if (resource.scheme === Schemas.file) {\n    joinedPath = URI.file(paths.join.apply(paths, [originalFSPath(resource)].concat(pathFragment))).path;\n  } else {\n    joinedPath = (_a = paths.posix).join.apply(_a, [resource.path || '/'].concat(pathFragment));\n  }\n\n  return resource.with({\n    path: joinedPath\n  });\n}\n/**\n * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n *\n * @param resource The URI to normalize the path.\n * @returns The URI with the normalized path.\n */\n\nexport function normalizePath(resource) {\n  if (!resource.path.length) {\n    return resource;\n  }\n\n  var normalizedPath;\n\n  if (resource.scheme === Schemas.file) {\n    normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n  } else {\n    normalizedPath = paths.posix.normalize(resource.path);\n  }\n\n  return resource.with({\n    path: normalizedPath\n  });\n}\n/**\n * Returns the fsPath of an URI where the drive letter is not normalized.\n * See #56403.\n */\n\nexport function originalFSPath(uri) {\n  var value;\n  var uriPath = uri.path;\n\n  if (uri.authority && uriPath.length > 1 && uri.scheme === Schemas.file) {\n    // unc path: file://shares/c$/far/boo\n    value = \"//\" + uri.authority + uriPath;\n  } else if (isWindows && uriPath.charCodeAt(0) === 47\n  /* Slash */\n  && extpath.isWindowsDriveLetter(uriPath.charCodeAt(1)) && uriPath.charCodeAt(2) === 58\n  /* Colon */\n  ) {\n      value = uriPath.substr(1);\n    } else {\n    // other path\n    value = uriPath;\n  }\n\n  if (isWindows) {\n    value = value.replace(/\\//g, '\\\\');\n  }\n\n  return value;\n}\n/**\n * Returns a relative path between two URIs. If the URIs don't have the same schema or authority, `undefined` is returned.\n * The returned relative path always uses forward slashes.\n */\n\nexport function relativePath(from, to, ignoreCase) {\n  if (ignoreCase === void 0) {\n    ignoreCase = hasToIgnoreCase(from);\n  }\n\n  if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n    return undefined;\n  }\n\n  if (from.scheme === Schemas.file) {\n    var relativePath_1 = paths.relative(from.path, to.path);\n    return isWindows ? extpath.toSlashes(relativePath_1) : relativePath_1;\n  }\n\n  var fromPath = from.path || '/',\n      toPath = to.path || '/';\n\n  if (ignoreCase) {\n    // make casing of fromPath match toPath\n    var i = 0;\n\n    for (var len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n      if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n        if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n          break;\n        }\n      }\n    }\n\n    fromPath = toPath.substr(0, i) + fromPath.substr(i);\n  }\n\n  return paths.posix.relative(fromPath, toPath);\n}\n/**\n * Data URI related helpers.\n */\n\nexport var DataUri;\n\n(function (DataUri) {\n  DataUri.META_DATA_LABEL = 'label';\n  DataUri.META_DATA_DESCRIPTION = 'description';\n  DataUri.META_DATA_SIZE = 'size';\n  DataUri.META_DATA_MIME = 'mime';\n\n  function parseMetaData(dataUri) {\n    var metadata = new Map(); // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\n    var meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n    meta.split(';').forEach(function (property) {\n      var _a = property.split(':'),\n          key = _a[0],\n          value = _a[1];\n\n      if (key && value) {\n        metadata.set(key, value);\n      }\n    }); // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the mime is: image/png\n\n    var mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\n    if (mime) {\n      metadata.set(DataUri.META_DATA_MIME, mime);\n    }\n\n    return metadata;\n  }\n\n  DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));","map":null,"metadata":{},"sourceType":"module"}