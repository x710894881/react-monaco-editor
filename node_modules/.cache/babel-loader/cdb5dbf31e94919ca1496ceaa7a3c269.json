{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as mime from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { LanguageIdentifier } from '../modes.js';\nimport { ModesRegistry } from '../modes/modesRegistry.js';\nimport { NULL_LANGUAGE_IDENTIFIER, NULL_MODE_ID } from '../modes/nullMode.js';\nimport { Extensions } from '../../../platform/configuration/common/configurationRegistry.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar LanguagesRegistry =\n/** @class */\nfunction (_super) {\n  __extends(LanguagesRegistry, _super);\n\n  function LanguagesRegistry(useModesRegistry, warnOnOverwrite) {\n    if (useModesRegistry === void 0) {\n      useModesRegistry = true;\n    }\n\n    if (warnOnOverwrite === void 0) {\n      warnOnOverwrite = false;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this._onDidChange = _this._register(new Emitter());\n    _this.onDidChange = _this._onDidChange.event;\n    _this._warnOnOverwrite = warnOnOverwrite;\n    _this._nextLanguageId2 = 1;\n    _this._languageIdToLanguage = [];\n    _this._languageToLanguageId = Object.create(null);\n    _this._languages = {};\n    _this._mimeTypesMap = {};\n    _this._nameMap = {};\n    _this._lowercaseNameMap = {};\n\n    if (useModesRegistry) {\n      _this._initializeFromRegistry();\n\n      _this._register(ModesRegistry.onDidChangeLanguages(function (m) {\n        return _this._initializeFromRegistry();\n      }));\n    }\n\n    return _this;\n  }\n\n  LanguagesRegistry.prototype._initializeFromRegistry = function () {\n    this._languages = {};\n    this._mimeTypesMap = {};\n    this._nameMap = {};\n    this._lowercaseNameMap = {};\n    var desc = ModesRegistry.getLanguages();\n\n    this._registerLanguages(desc);\n  };\n\n  LanguagesRegistry.prototype._registerLanguages = function (desc) {\n    var _this = this;\n\n    for (var _i = 0, desc_1 = desc; _i < desc_1.length; _i++) {\n      var d = desc_1[_i];\n\n      this._registerLanguage(d);\n    } // Rebuild fast path maps\n\n\n    this._mimeTypesMap = {};\n    this._nameMap = {};\n    this._lowercaseNameMap = {};\n    Object.keys(this._languages).forEach(function (langId) {\n      var language = _this._languages[langId];\n\n      if (language.name) {\n        _this._nameMap[language.name] = language.identifier;\n      }\n\n      language.aliases.forEach(function (alias) {\n        _this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;\n      });\n      language.mimetypes.forEach(function (mimetype) {\n        _this._mimeTypesMap[mimetype] = language.identifier;\n      });\n    });\n    Registry.as(Extensions.Configuration).registerOverrideIdentifiers(ModesRegistry.getLanguages().map(function (language) {\n      return language.id;\n    }));\n\n    this._onDidChange.fire();\n  };\n\n  LanguagesRegistry.prototype._getLanguageId = function (language) {\n    if (this._languageToLanguageId[language]) {\n      return this._languageToLanguageId[language];\n    }\n\n    var languageId = this._nextLanguageId2++;\n    this._languageIdToLanguage[languageId] = language;\n    this._languageToLanguageId[language] = languageId;\n    return languageId;\n  };\n\n  LanguagesRegistry.prototype._registerLanguage = function (lang) {\n    var langId = lang.id;\n    var resolvedLanguage;\n\n    if (hasOwnProperty.call(this._languages, langId)) {\n      resolvedLanguage = this._languages[langId];\n    } else {\n      var languageId = this._getLanguageId(langId);\n\n      resolvedLanguage = {\n        identifier: new LanguageIdentifier(langId, languageId),\n        name: null,\n        mimetypes: [],\n        aliases: [],\n        extensions: [],\n        filenames: [],\n        configurationFiles: []\n      };\n      this._languages[langId] = resolvedLanguage;\n    }\n\n    this._mergeLanguage(resolvedLanguage, lang);\n  };\n\n  LanguagesRegistry.prototype._mergeLanguage = function (resolvedLanguage, lang) {\n    var _a;\n\n    var langId = lang.id;\n    var primaryMime = null;\n\n    if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {\n      (_a = resolvedLanguage.mimetypes).push.apply(_a, lang.mimetypes);\n\n      primaryMime = lang.mimetypes[0];\n    }\n\n    if (!primaryMime) {\n      primaryMime = \"text/x-\" + langId;\n      resolvedLanguage.mimetypes.push(primaryMime);\n    }\n\n    if (Array.isArray(lang.extensions)) {\n      for (var _i = 0, _b = lang.extensions; _i < _b.length; _i++) {\n        var extension = _b[_i];\n        mime.registerTextMime({\n          id: langId,\n          mime: primaryMime,\n          extension: extension\n        }, this._warnOnOverwrite);\n        resolvedLanguage.extensions.push(extension);\n      }\n    }\n\n    if (Array.isArray(lang.filenames)) {\n      for (var _c = 0, _d = lang.filenames; _c < _d.length; _c++) {\n        var filename = _d[_c];\n        mime.registerTextMime({\n          id: langId,\n          mime: primaryMime,\n          filename: filename\n        }, this._warnOnOverwrite);\n        resolvedLanguage.filenames.push(filename);\n      }\n    }\n\n    if (Array.isArray(lang.filenamePatterns)) {\n      for (var _e = 0, _f = lang.filenamePatterns; _e < _f.length; _e++) {\n        var filenamePattern = _f[_e];\n        mime.registerTextMime({\n          id: langId,\n          mime: primaryMime,\n          filepattern: filenamePattern\n        }, this._warnOnOverwrite);\n      }\n    }\n\n    if (typeof lang.firstLine === 'string' && lang.firstLine.length > 0) {\n      var firstLineRegexStr = lang.firstLine;\n\n      if (firstLineRegexStr.charAt(0) !== '^') {\n        firstLineRegexStr = '^' + firstLineRegexStr;\n      }\n\n      try {\n        var firstLineRegex = new RegExp(firstLineRegexStr);\n\n        if (!strings.regExpLeadsToEndlessLoop(firstLineRegex)) {\n          mime.registerTextMime({\n            id: langId,\n            mime: primaryMime,\n            firstline: firstLineRegex\n          }, this._warnOnOverwrite);\n        }\n      } catch (err) {\n        // Most likely, the regex was bad\n        onUnexpectedError(err);\n      }\n    }\n\n    resolvedLanguage.aliases.push(langId);\n    var langAliases = null;\n\n    if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases)) {\n      if (lang.aliases.length === 0) {\n        // signal that this language should not get a name\n        langAliases = [null];\n      } else {\n        langAliases = lang.aliases;\n      }\n    }\n\n    if (langAliases !== null) {\n      for (var _g = 0, langAliases_1 = langAliases; _g < langAliases_1.length; _g++) {\n        var langAlias = langAliases_1[_g];\n\n        if (!langAlias || langAlias.length === 0) {\n          continue;\n        }\n\n        resolvedLanguage.aliases.push(langAlias);\n      }\n    }\n\n    var containsAliases = langAliases !== null && langAliases.length > 0;\n\n    if (containsAliases && langAliases[0] === null) {// signal that this language should not get a name\n    } else {\n      var bestName = (containsAliases ? langAliases[0] : null) || langId;\n\n      if (containsAliases || !resolvedLanguage.name) {\n        resolvedLanguage.name = bestName;\n      }\n    }\n\n    if (lang.configuration) {\n      resolvedLanguage.configurationFiles.push(lang.configuration);\n    }\n  };\n\n  LanguagesRegistry.prototype.isRegisteredMode = function (mimetypeOrModeId) {\n    // Is this a known mime type ?\n    if (hasOwnProperty.call(this._mimeTypesMap, mimetypeOrModeId)) {\n      return true;\n    } // Is this a known mode id ?\n\n\n    return hasOwnProperty.call(this._languages, mimetypeOrModeId);\n  };\n\n  LanguagesRegistry.prototype.getModeIdForLanguageNameLowercase = function (languageNameLower) {\n    if (!hasOwnProperty.call(this._lowercaseNameMap, languageNameLower)) {\n      return null;\n    }\n\n    return this._lowercaseNameMap[languageNameLower].language;\n  };\n\n  LanguagesRegistry.prototype.extractModeIds = function (commaSeparatedMimetypesOrCommaSeparatedIds) {\n    var _this = this;\n\n    if (!commaSeparatedMimetypesOrCommaSeparatedIds) {\n      return [];\n    }\n\n    return commaSeparatedMimetypesOrCommaSeparatedIds.split(',').map(function (mimeTypeOrId) {\n      return mimeTypeOrId.trim();\n    }).map(function (mimeTypeOrId) {\n      if (hasOwnProperty.call(_this._mimeTypesMap, mimeTypeOrId)) {\n        return _this._mimeTypesMap[mimeTypeOrId].language;\n      }\n\n      return mimeTypeOrId;\n    }).filter(function (modeId) {\n      return hasOwnProperty.call(_this._languages, modeId);\n    });\n  };\n\n  LanguagesRegistry.prototype.getLanguageIdentifier = function (_modeId) {\n    if (_modeId === NULL_MODE_ID || _modeId === 0\n    /* Null */\n    ) {\n        return NULL_LANGUAGE_IDENTIFIER;\n      }\n\n    var modeId;\n\n    if (typeof _modeId === 'string') {\n      modeId = _modeId;\n    } else {\n      modeId = this._languageIdToLanguage[_modeId];\n\n      if (!modeId) {\n        return null;\n      }\n    }\n\n    if (!hasOwnProperty.call(this._languages, modeId)) {\n      return null;\n    }\n\n    return this._languages[modeId].identifier;\n  };\n\n  LanguagesRegistry.prototype.getModeIdsFromFilepathOrFirstLine = function (resource, firstLine) {\n    if (!resource && !firstLine) {\n      return [];\n    }\n\n    var mimeTypes = mime.guessMimeTypes(resource, firstLine);\n    return this.extractModeIds(mimeTypes.join(','));\n  };\n\n  return LanguagesRegistry;\n}(Disposable);\n\nexport { LanguagesRegistry };","map":null,"metadata":{},"sourceType":"module"}