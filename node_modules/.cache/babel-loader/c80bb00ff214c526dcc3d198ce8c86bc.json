{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport * as nls from '../../../nls.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport { RawContextKey, IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IMarkerService, MarkerSeverity } from '../../../platform/markers/common/markers.js';\nimport { Range } from '../../common/core/range.js';\nimport { registerEditorAction, registerEditorContribution, EditorAction, EditorCommand, registerEditorCommand } from '../../browser/editorExtensions.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { EditorContextKeys } from '../../common/editorContextKeys.js';\nimport { MarkerNavigationWidget } from './gotoErrorWidget.js';\nimport { compare } from '../../../base/common/strings.js';\nimport { binarySearch } from '../../../base/common/arrays.js';\nimport { ICodeEditorService } from '../../browser/services/codeEditorService.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { MenuRegistry } from '../../../platform/actions/common/actions.js';\nimport { Action } from '../../../base/common/actions.js';\nimport { IKeybindingService } from '../../../platform/keybinding/common/keybinding.js';\n\nvar MarkerModel =\n/** @class */\nfunction () {\n  function MarkerModel(editor, markers) {\n    var _this = this;\n\n    this._toUnbind = new DisposableStore();\n    this._editor = editor;\n    this._markers = [];\n    this._nextIdx = -1;\n    this._ignoreSelectionChange = false;\n    this._onCurrentMarkerChanged = new Emitter();\n    this._onMarkerSetChanged = new Emitter();\n    this.setMarkers(markers); // listen on editor\n\n    this._toUnbind.add(this._editor.onDidDispose(function () {\n      return _this.dispose();\n    }));\n\n    this._toUnbind.add(this._editor.onDidChangeCursorPosition(function () {\n      if (_this._ignoreSelectionChange) {\n        return;\n      }\n\n      if (_this.currentMarker && _this._editor.getPosition() && Range.containsPosition(_this.currentMarker, _this._editor.getPosition())) {\n        return;\n      }\n\n      _this._nextIdx = -1;\n    }));\n  }\n\n  Object.defineProperty(MarkerModel.prototype, \"onCurrentMarkerChanged\", {\n    get: function () {\n      return this._onCurrentMarkerChanged.event;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MarkerModel.prototype, \"onMarkerSetChanged\", {\n    get: function () {\n      return this._onMarkerSetChanged.event;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MarkerModel.prototype.setMarkers = function (markers) {\n    var oldMarker = this._nextIdx >= 0 ? this._markers[this._nextIdx] : undefined;\n    this._markers = markers || [];\n\n    this._markers.sort(MarkerNavigationAction.compareMarker);\n\n    if (!oldMarker) {\n      this._nextIdx = -1;\n    } else {\n      this._nextIdx = Math.max(-1, binarySearch(this._markers, oldMarker, MarkerNavigationAction.compareMarker));\n    }\n\n    this._onMarkerSetChanged.fire(this);\n  };\n\n  MarkerModel.prototype.withoutWatchingEditorPosition = function (callback) {\n    this._ignoreSelectionChange = true;\n\n    try {\n      callback();\n    } finally {\n      this._ignoreSelectionChange = false;\n    }\n  };\n\n  MarkerModel.prototype._initIdx = function (fwd) {\n    var found = false;\n\n    var position = this._editor.getPosition();\n\n    for (var i = 0; i < this._markers.length; i++) {\n      var range = Range.lift(this._markers[i]);\n\n      if (range.isEmpty() && this._editor.getModel()) {\n        var word = this._editor.getModel().getWordAtPosition(range.getStartPosition());\n\n        if (word) {\n          range = new Range(range.startLineNumber, word.startColumn, range.startLineNumber, word.endColumn);\n        }\n      }\n\n      if (position && (range.containsPosition(position) || position.isBeforeOrEqual(range.getStartPosition()))) {\n        this._nextIdx = i;\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      // after the last change\n      this._nextIdx = fwd ? 0 : this._markers.length - 1;\n    }\n\n    if (this._nextIdx < 0) {\n      this._nextIdx = this._markers.length - 1;\n    }\n  };\n\n  Object.defineProperty(MarkerModel.prototype, \"currentMarker\", {\n    get: function () {\n      return this.canNavigate() ? this._markers[this._nextIdx] : undefined;\n    },\n    set: function (marker) {\n      var idx = this._nextIdx;\n      this._nextIdx = -1;\n\n      if (marker) {\n        this._nextIdx = this.indexOf(marker);\n      }\n\n      if (this._nextIdx !== idx) {\n        this._onCurrentMarkerChanged.fire(marker);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MarkerModel.prototype.move = function (fwd, inCircles) {\n    if (!this.canNavigate()) {\n      this._onCurrentMarkerChanged.fire(undefined);\n\n      return !inCircles;\n    }\n\n    var oldIdx = this._nextIdx;\n    var atEdge = false;\n\n    if (this._nextIdx === -1) {\n      this._initIdx(fwd);\n    } else if (fwd) {\n      if (inCircles || this._nextIdx + 1 < this._markers.length) {\n        this._nextIdx = (this._nextIdx + 1) % this._markers.length;\n      } else {\n        atEdge = true;\n      }\n    } else if (!fwd) {\n      if (inCircles || this._nextIdx > 0) {\n        this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length;\n      } else {\n        atEdge = true;\n      }\n    }\n\n    if (oldIdx !== this._nextIdx) {\n      var marker = this._markers[this._nextIdx];\n\n      this._onCurrentMarkerChanged.fire(marker);\n    }\n\n    return atEdge;\n  };\n\n  MarkerModel.prototype.canNavigate = function () {\n    return this._markers.length > 0;\n  };\n\n  MarkerModel.prototype.findMarkerAtPosition = function (pos) {\n    for (var _i = 0, _a = this._markers; _i < _a.length; _i++) {\n      var marker = _a[_i];\n\n      if (Range.containsPosition(marker, pos)) {\n        return marker;\n      }\n    }\n\n    return undefined;\n  };\n\n  Object.defineProperty(MarkerModel.prototype, \"total\", {\n    get: function () {\n      return this._markers.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MarkerModel.prototype.indexOf = function (marker) {\n    return 1 + this._markers.indexOf(marker);\n  };\n\n  MarkerModel.prototype.dispose = function () {\n    this._toUnbind.dispose();\n  };\n\n  return MarkerModel;\n}();\n\nvar MarkerController =\n/** @class */\nfunction () {\n  function MarkerController(editor, _markerService, _contextKeyService, _themeService, _editorService, _keybindingService) {\n    this._markerService = _markerService;\n    this._contextKeyService = _contextKeyService;\n    this._themeService = _themeService;\n    this._editorService = _editorService;\n    this._keybindingService = _keybindingService;\n    this._model = null;\n    this._widget = null;\n    this._disposeOnClose = new DisposableStore();\n    this._editor = editor;\n    this._widgetVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);\n  }\n\n  MarkerController.get = function (editor) {\n    return editor.getContribution(MarkerController.ID);\n  };\n\n  MarkerController.prototype.getId = function () {\n    return MarkerController.ID;\n  };\n\n  MarkerController.prototype.dispose = function () {\n    this._cleanUp();\n\n    this._disposeOnClose.dispose();\n  };\n\n  MarkerController.prototype._cleanUp = function () {\n    this._widgetVisible.reset();\n\n    this._disposeOnClose.clear();\n\n    this._widget = null;\n    this._model = null;\n  };\n\n  MarkerController.prototype.getOrCreateModel = function () {\n    var _this = this;\n\n    if (this._model) {\n      return this._model;\n    }\n\n    var markers = this._getMarkers();\n\n    this._model = new MarkerModel(this._editor, markers);\n\n    this._markerService.onMarkerChanged(this._onMarkerChanged, this, this._disposeOnClose);\n\n    var prevMarkerKeybinding = this._keybindingService.lookupKeybinding(PrevMarkerAction.ID);\n\n    var nextMarkerKeybinding = this._keybindingService.lookupKeybinding(NextMarkerAction.ID);\n\n    var actions = [new Action(PrevMarkerAction.ID, PrevMarkerAction.LABEL + (prevMarkerKeybinding ? \" (\" + prevMarkerKeybinding.getLabel() + \")\" : ''), 'show-previous-problem chevron-up', this._model.canNavigate(), function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          if (this._model) {\n            this._model.move(false, true);\n          }\n\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    }), new Action(NextMarkerAction.ID, NextMarkerAction.LABEL + (nextMarkerKeybinding ? \" (\" + nextMarkerKeybinding.getLabel() + \")\" : ''), 'show-next-problem chevron-down', this._model.canNavigate(), function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          if (this._model) {\n            this._model.move(true, true);\n          }\n\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    })];\n    this._widget = new MarkerNavigationWidget(this._editor, actions, this._themeService);\n\n    this._widgetVisible.set(true);\n\n    this._widget.onDidClose(function () {\n      return _this._cleanUp();\n    }, this, this._disposeOnClose);\n\n    this._disposeOnClose.add(this._model);\n\n    this._disposeOnClose.add(this._widget);\n\n    for (var _i = 0, actions_1 = actions; _i < actions_1.length; _i++) {\n      var action = actions_1[_i];\n\n      this._disposeOnClose.add(action);\n    }\n\n    this._disposeOnClose.add(this._widget.onDidSelectRelatedInformation(function (related) {\n      _this._editorService.openCodeEditor({\n        resource: related.resource,\n        options: {\n          pinned: true,\n          revealIfOpened: true,\n          selection: Range.lift(related).collapseToStart()\n        }\n      }, _this._editor).then(undefined, onUnexpectedError);\n\n      _this.closeMarkersNavigation(false);\n    }));\n\n    this._disposeOnClose.add(this._editor.onDidChangeModel(function () {\n      return _this._cleanUp();\n    }));\n\n    this._disposeOnClose.add(this._model.onCurrentMarkerChanged(function (marker) {\n      if (!marker || !_this._model) {\n        _this._cleanUp();\n      } else {\n        _this._model.withoutWatchingEditorPosition(function () {\n          if (!_this._widget || !_this._model) {\n            return;\n          }\n\n          _this._widget.showAtMarker(marker, _this._model.indexOf(marker), _this._model.total);\n        });\n      }\n    }));\n\n    this._disposeOnClose.add(this._model.onMarkerSetChanged(function () {\n      if (!_this._widget || !_this._widget.position || !_this._model) {\n        return;\n      }\n\n      var marker = _this._model.findMarkerAtPosition(_this._widget.position);\n\n      if (marker) {\n        _this._widget.updateMarker(marker);\n      } else {\n        _this._widget.showStale();\n      }\n    }));\n\n    return this._model;\n  };\n\n  MarkerController.prototype.closeMarkersNavigation = function (focusEditor) {\n    if (focusEditor === void 0) {\n      focusEditor = true;\n    }\n\n    this._cleanUp();\n\n    if (focusEditor) {\n      this._editor.focus();\n    }\n  };\n\n  MarkerController.prototype.show = function (marker) {\n    var model = this.getOrCreateModel();\n    model.currentMarker = marker;\n  };\n\n  MarkerController.prototype._onMarkerChanged = function (changedResources) {\n    var editorModel = this._editor.getModel();\n\n    if (!editorModel) {\n      return;\n    }\n\n    if (!this._model) {\n      return;\n    }\n\n    if (!changedResources.some(function (r) {\n      return editorModel.uri.toString() === r.toString();\n    })) {\n      return;\n    }\n\n    this._model.setMarkers(this._getMarkers());\n  };\n\n  MarkerController.prototype._getMarkers = function () {\n    var model = this._editor.getModel();\n\n    if (!model) {\n      return [];\n    }\n\n    return this._markerService.read({\n      resource: model.uri,\n      severities: MarkerSeverity.Error | MarkerSeverity.Warning | MarkerSeverity.Info\n    });\n  };\n\n  MarkerController.ID = 'editor.contrib.markerController';\n  MarkerController = __decorate([__param(1, IMarkerService), __param(2, IContextKeyService), __param(3, IThemeService), __param(4, ICodeEditorService), __param(5, IKeybindingService)], MarkerController);\n  return MarkerController;\n}();\n\nexport { MarkerController };\n\nvar MarkerNavigationAction =\n/** @class */\nfunction (_super) {\n  __extends(MarkerNavigationAction, _super);\n\n  function MarkerNavigationAction(next, multiFile, opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this._isNext = next;\n    _this._multiFile = multiFile;\n    return _this;\n  }\n\n  MarkerNavigationAction.prototype.run = function (accessor, editor) {\n    var _this = this;\n\n    var markerService = accessor.get(IMarkerService);\n    var editorService = accessor.get(ICodeEditorService);\n    var controller = MarkerController.get(editor);\n\n    if (!controller) {\n      return Promise.resolve(undefined);\n    }\n\n    var model = controller.getOrCreateModel();\n    var atEdge = model.move(this._isNext, !this._multiFile);\n\n    if (!atEdge || !this._multiFile) {\n      return Promise.resolve(undefined);\n    } // try with the next/prev file\n\n\n    var markers = markerService.read({\n      severities: MarkerSeverity.Error | MarkerSeverity.Warning | MarkerSeverity.Info\n    }).sort(MarkerNavigationAction.compareMarker);\n\n    if (markers.length === 0) {\n      return Promise.resolve(undefined);\n    }\n\n    var editorModel = editor.getModel();\n\n    if (!editorModel) {\n      return Promise.resolve(undefined);\n    }\n\n    var oldMarker = model.currentMarker || {\n      resource: editorModel.uri,\n      severity: MarkerSeverity.Error,\n      startLineNumber: 1,\n      startColumn: 1,\n      endLineNumber: 1,\n      endColumn: 1\n    };\n    var idx = binarySearch(markers, oldMarker, MarkerNavigationAction.compareMarker);\n\n    if (idx < 0) {\n      // find best match...\n      idx = ~idx;\n      idx %= markers.length;\n    } else if (this._isNext) {\n      idx = (idx + 1) % markers.length;\n    } else {\n      idx = (idx + markers.length - 1) % markers.length;\n    }\n\n    var newMarker = markers[idx];\n\n    if (newMarker.resource.toString() === editorModel.uri.toString()) {\n      // the next `resource` is this resource which\n      // means we cycle within this file\n      model.move(this._isNext, true);\n      return Promise.resolve(undefined);\n    } // close the widget for this editor-instance, open the resource\n    // for the next marker and re-start marker navigation in there\n\n\n    controller.closeMarkersNavigation();\n    return editorService.openCodeEditor({\n      resource: newMarker.resource,\n      options: {\n        pinned: false,\n        revealIfOpened: true,\n        revealInCenterIfOutsideViewport: true,\n        selection: newMarker\n      }\n    }, editor).then(function (editor) {\n      if (!editor) {\n        return undefined;\n      }\n\n      return editor.getAction(_this.id).run();\n    });\n  };\n\n  MarkerNavigationAction.compareMarker = function (a, b) {\n    var res = compare(a.resource.toString(), b.resource.toString());\n\n    if (res === 0) {\n      res = MarkerSeverity.compare(a.severity, b.severity);\n    }\n\n    if (res === 0) {\n      res = Range.compareRangesUsingStarts(a, b);\n    }\n\n    return res;\n  };\n\n  return MarkerNavigationAction;\n}(EditorAction);\n\nvar NextMarkerAction =\n/** @class */\nfunction (_super) {\n  __extends(NextMarkerAction, _super);\n\n  function NextMarkerAction() {\n    return _super.call(this, true, false, {\n      id: NextMarkerAction.ID,\n      label: NextMarkerAction.LABEL,\n      alias: 'Go to Next Problem (Error, Warning, Info)',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 512\n        /* Alt */\n        | 66\n        /* F8 */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  NextMarkerAction.ID = 'editor.action.marker.next';\n  NextMarkerAction.LABEL = nls.localize('markerAction.next.label', \"Go to Next Problem (Error, Warning, Info)\");\n  return NextMarkerAction;\n}(MarkerNavigationAction);\n\nexport { NextMarkerAction };\n\nvar PrevMarkerAction =\n/** @class */\nfunction (_super) {\n  __extends(PrevMarkerAction, _super);\n\n  function PrevMarkerAction() {\n    return _super.call(this, false, false, {\n      id: PrevMarkerAction.ID,\n      label: PrevMarkerAction.LABEL,\n      alias: 'Go to Previous Problem (Error, Warning, Info)',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 1024\n        /* Shift */\n        | 512\n        /* Alt */\n        | 66\n        /* F8 */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  PrevMarkerAction.ID = 'editor.action.marker.prev';\n  PrevMarkerAction.LABEL = nls.localize('markerAction.previous.label', \"Go to Previous Problem (Error, Warning, Info)\");\n  return PrevMarkerAction;\n}(MarkerNavigationAction);\n\nvar NextMarkerInFilesAction =\n/** @class */\nfunction (_super) {\n  __extends(NextMarkerInFilesAction, _super);\n\n  function NextMarkerInFilesAction() {\n    return _super.call(this, true, true, {\n      id: 'editor.action.marker.nextInFiles',\n      label: nls.localize('markerAction.nextInFiles.label', \"Go to Next Problem in Files (Error, Warning, Info)\"),\n      alias: 'Go to Next Problem in Files (Error, Warning, Info)',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.focus,\n        primary: 66\n        /* F8 */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  return NextMarkerInFilesAction;\n}(MarkerNavigationAction);\n\nvar PrevMarkerInFilesAction =\n/** @class */\nfunction (_super) {\n  __extends(PrevMarkerInFilesAction, _super);\n\n  function PrevMarkerInFilesAction() {\n    return _super.call(this, false, true, {\n      id: 'editor.action.marker.prevInFiles',\n      label: nls.localize('markerAction.previousInFiles.label', \"Go to Previous Problem in Files (Error, Warning, Info)\"),\n      alias: 'Go to Previous Problem in Files (Error, Warning, Info)',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.focus,\n        primary: 1024\n        /* Shift */\n        | 66\n        /* F8 */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  return PrevMarkerInFilesAction;\n}(MarkerNavigationAction);\n\nregisterEditorContribution(MarkerController);\nregisterEditorAction(NextMarkerAction);\nregisterEditorAction(PrevMarkerAction);\nregisterEditorAction(NextMarkerInFilesAction);\nregisterEditorAction(PrevMarkerInFilesAction);\nvar CONTEXT_MARKERS_NAVIGATION_VISIBLE = new RawContextKey('markersNavigationVisible', false);\nvar MarkerCommand = EditorCommand.bindToContribution(MarkerController.get);\nregisterEditorCommand(new MarkerCommand({\n  id: 'closeMarkersNavigation',\n  precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,\n  handler: function (x) {\n    return x.closeMarkersNavigation();\n  },\n  kbOpts: {\n    weight: 100\n    /* EditorContrib */\n    + 50,\n    kbExpr: EditorContextKeys.focus,\n    primary: 9\n    /* Escape */\n    ,\n    secondary: [1024\n    /* Shift */\n    | 9\n    /* Escape */\n    ]\n  }\n})); // Go to menu\n\nMenuRegistry.appendMenuItem(16\n/* MenubarGoMenu */\n, {\n  group: '6_problem_nav',\n  command: {\n    id: 'editor.action.marker.nextInFiles',\n    title: nls.localize({\n      key: 'miGotoNextProblem',\n      comment: ['&& denotes a mnemonic']\n    }, \"Next &&Problem\")\n  },\n  order: 1\n});\nMenuRegistry.appendMenuItem(16\n/* MenubarGoMenu */\n, {\n  group: '6_problem_nav',\n  command: {\n    id: 'editor.action.marker.prevInFiles',\n    title: nls.localize({\n      key: 'miGotoPreviousProblem',\n      comment: ['&& denotes a mnemonic']\n    }, \"Previous &&Problem\")\n  },\n  order: 2\n});","map":null,"metadata":{},"sourceType":"module"}