{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TimeoutTimer } from '../../../base/common/async.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../../common/core/lineTokens.js';\nimport { TokenizationRegistry } from '../../common/modes.js';\nimport { RenderLineInput, renderViewLine2 as renderViewLine } from '../../common/viewLayout/viewLineRenderer.js';\nimport { ViewLineRenderingData } from '../../common/viewModel/viewModel.js';\nimport { MonarchTokenizer } from '../common/monarch/monarchLexer.js';\n\nvar Colorizer =\n/** @class */\nfunction () {\n  function Colorizer() {}\n\n  Colorizer.colorizeElement = function (themeService, modeService, domNode, options) {\n    options = options || {};\n    var theme = options.theme || 'vs';\n    var mimeType = options.mimeType || domNode.getAttribute('lang') || domNode.getAttribute('data-lang');\n\n    if (!mimeType) {\n      console.error('Mode not detected');\n      return Promise.resolve();\n    }\n\n    themeService.setTheme(theme);\n    var text = domNode.firstChild ? domNode.firstChild.nodeValue : '';\n    domNode.className += ' ' + theme;\n\n    var render = function (str) {\n      domNode.innerHTML = str;\n    };\n\n    return this.colorize(modeService, text || '', mimeType, options).then(render, function (err) {\n      return console.error(err);\n    });\n  };\n\n  Colorizer.colorize = function (modeService, text, mimeType, options) {\n    var tabSize = 4;\n\n    if (options && typeof options.tabSize === 'number') {\n      tabSize = options.tabSize;\n    }\n\n    if (strings.startsWithUTF8BOM(text)) {\n      text = text.substr(1);\n    }\n\n    var lines = text.split(/\\r\\n|\\r|\\n/);\n    var language = modeService.getModeId(mimeType);\n\n    if (!language) {\n      return Promise.resolve(_fakeColorize(lines, tabSize));\n    } // Send out the event to create the mode\n\n\n    modeService.triggerMode(language);\n    var tokenizationSupport = TokenizationRegistry.get(language);\n\n    if (tokenizationSupport) {\n      return _colorize(lines, tabSize, tokenizationSupport);\n    }\n\n    var tokenizationSupportPromise = TokenizationRegistry.getPromise(language);\n\n    if (tokenizationSupportPromise) {\n      // A tokenizer will be registered soon\n      return new Promise(function (resolve, reject) {\n        tokenizationSupportPromise.then(function (tokenizationSupport) {\n          _colorize(lines, tabSize, tokenizationSupport).then(resolve, reject);\n        }, reject);\n      });\n    }\n\n    return new Promise(function (resolve, reject) {\n      var listener = null;\n      var timeout = null;\n\n      var execute = function () {\n        if (listener) {\n          listener.dispose();\n          listener = null;\n        }\n\n        if (timeout) {\n          timeout.dispose();\n          timeout = null;\n        }\n\n        var tokenizationSupport = TokenizationRegistry.get(language);\n\n        if (tokenizationSupport) {\n          _colorize(lines, tabSize, tokenizationSupport).then(resolve, reject);\n\n          return;\n        }\n\n        resolve(_fakeColorize(lines, tabSize));\n      }; // wait 500ms for mode to load, then give up\n\n\n      timeout = new TimeoutTimer();\n      timeout.cancelAndSet(execute, 500);\n      listener = TokenizationRegistry.onDidChange(function (e) {\n        if (e.changedLanguages.indexOf(language) >= 0) {\n          execute();\n        }\n      });\n    });\n  };\n\n  Colorizer.colorizeLine = function (line, mightContainNonBasicASCII, mightContainRTL, tokens, tabSize) {\n    if (tabSize === void 0) {\n      tabSize = 4;\n    }\n\n    var isBasicASCII = ViewLineRenderingData.isBasicASCII(line, mightContainNonBasicASCII);\n    var containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII, mightContainRTL);\n    var renderResult = renderViewLine(new RenderLineInput(false, true, line, false, isBasicASCII, containsRTL, 0, tokens, [], tabSize, 0, -1, 'none', false, false, null));\n    return renderResult.html;\n  };\n\n  Colorizer.colorizeModelLine = function (model, lineNumber, tabSize) {\n    if (tabSize === void 0) {\n      tabSize = 4;\n    }\n\n    var content = model.getLineContent(lineNumber);\n    model.forceTokenization(lineNumber);\n    var tokens = model.getLineTokens(lineNumber);\n    var inflatedTokens = tokens.inflate();\n    return this.colorizeLine(content, model.mightContainNonBasicASCII(), model.mightContainRTL(), inflatedTokens, tabSize);\n  };\n\n  return Colorizer;\n}();\n\nexport { Colorizer };\n\nfunction _colorize(lines, tabSize, tokenizationSupport) {\n  return new Promise(function (c, e) {\n    var execute = function () {\n      var result = _actualColorize(lines, tabSize, tokenizationSupport);\n\n      if (tokenizationSupport instanceof MonarchTokenizer) {\n        var status_1 = tokenizationSupport.getLoadStatus();\n\n        if (status_1.loaded === false) {\n          status_1.promise.then(execute, e);\n          return;\n        }\n      }\n\n      c(result);\n    };\n\n    execute();\n  });\n}\n\nfunction _fakeColorize(lines, tabSize) {\n  var html = [];\n  var defaultMetadata = (0\n  /* None */\n  << 11\n  /* FONT_STYLE_OFFSET */\n  | 1\n  /* DefaultForeground */\n  << 14\n  /* FOREGROUND_OFFSET */\n  | 2\n  /* DefaultBackground */\n  << 23\n  /* BACKGROUND_OFFSET */\n  ) >>> 0;\n  var tokens = new Uint32Array(2);\n  tokens[0] = 0;\n  tokens[1] = defaultMetadata;\n\n  for (var i = 0, length_1 = lines.length; i < length_1; i++) {\n    var line = lines[i];\n    tokens[0] = line.length;\n    var lineTokens = new LineTokens(tokens, line);\n    var isBasicASCII = ViewLineRenderingData.isBasicASCII(line,\n    /* check for basic ASCII */\n    true);\n    var containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII,\n    /* check for RTL */\n    true);\n    var renderResult = renderViewLine(new RenderLineInput(false, true, line, false, isBasicASCII, containsRTL, 0, lineTokens, [], tabSize, 0, -1, 'none', false, false, null));\n    html = html.concat(renderResult.html);\n    html.push('<br/>');\n  }\n\n  return html.join('');\n}\n\nfunction _actualColorize(lines, tabSize, tokenizationSupport) {\n  var html = [];\n  var state = tokenizationSupport.getInitialState();\n\n  for (var i = 0, length_2 = lines.length; i < length_2; i++) {\n    var line = lines[i];\n    var tokenizeResult = tokenizationSupport.tokenize2(line, state, 0);\n    LineTokens.convertToEndOffset(tokenizeResult.tokens, line.length);\n    var lineTokens = new LineTokens(tokenizeResult.tokens, line);\n    var isBasicASCII = ViewLineRenderingData.isBasicASCII(line,\n    /* check for basic ASCII */\n    true);\n    var containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII,\n    /* check for RTL */\n    true);\n    var renderResult = renderViewLine(new RenderLineInput(false, true, line, false, isBasicASCII, containsRTL, 0, lineTokens.inflate(), [], tabSize, 0, -1, 'none', false, false, null));\n    html = html.concat(renderResult.html);\n    html.push('<br/>');\n    state = tokenizeResult.endState;\n  }\n\n  return html.join('');\n}","map":null,"metadata":{},"sourceType":"module"}