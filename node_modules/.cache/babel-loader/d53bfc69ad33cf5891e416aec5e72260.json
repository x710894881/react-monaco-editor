{"ast":null,"code":"import { ContextKeyOrExpr } from '../../contextkey/common/contextkey.js';\n\nvar KeybindingResolver =\n/** @class */\nfunction () {\n  function KeybindingResolver(defaultKeybindings, overrides) {\n    this._defaultKeybindings = defaultKeybindings;\n    this._defaultBoundCommands = new Map();\n\n    for (var i = 0, len = defaultKeybindings.length; i < len; i++) {\n      var command = defaultKeybindings[i].command;\n\n      if (command) {\n        this._defaultBoundCommands.set(command, true);\n      }\n    }\n\n    this._map = new Map();\n    this._lookupMap = new Map();\n    this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\n\n    for (var i = 0, len = this._keybindings.length; i < len; i++) {\n      var k = this._keybindings[i];\n\n      if (k.keypressParts.length === 0) {\n        // unbound\n        continue;\n      } // TODO@chords\n\n\n      this._addKeyPress(k.keypressParts[0], k);\n    }\n  }\n\n  KeybindingResolver._isTargetedForRemoval = function (defaultKb, keypressFirstPart, keypressChordPart, command, when) {\n    if (defaultKb.command !== command) {\n      return false;\n    } // TODO@chords\n\n\n    if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n      return false;\n    } // TODO@chords\n\n\n    if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n      return false;\n    }\n\n    if (when) {\n      if (!defaultKb.when) {\n        return false;\n      }\n\n      if (!when.equals(defaultKb.when)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\n   */\n\n\n  KeybindingResolver.combine = function (defaults, rawOverrides) {\n    defaults = defaults.slice(0);\n    var overrides = [];\n\n    for (var _i = 0, rawOverrides_1 = rawOverrides; _i < rawOverrides_1.length; _i++) {\n      var override = rawOverrides_1[_i];\n\n      if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\n        overrides.push(override);\n        continue;\n      }\n\n      var command = override.command.substr(1); // TODO@chords\n\n      var keypressFirstPart = override.keypressParts[0];\n      var keypressChordPart = override.keypressParts[1];\n      var when = override.when;\n\n      for (var j = defaults.length - 1; j >= 0; j--) {\n        if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\n          defaults.splice(j, 1);\n        }\n      }\n    }\n\n    return defaults.concat(overrides);\n  };\n\n  KeybindingResolver.prototype._addKeyPress = function (keypress, item) {\n    var conflicts = this._map.get(keypress);\n\n    if (typeof conflicts === 'undefined') {\n      // There is no conflict so far\n      this._map.set(keypress, [item]);\n\n      this._addToLookupMap(item);\n\n      return;\n    }\n\n    for (var i = conflicts.length - 1; i >= 0; i--) {\n      var conflict = conflicts[i];\n\n      if (conflict.command === item.command) {\n        continue;\n      }\n\n      var conflictIsChord = conflict.keypressParts.length > 1;\n      var itemIsChord = item.keypressParts.length > 1; // TODO@chords\n\n      if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n        // The conflict only shares the chord start with this command\n        continue;\n      }\n\n      if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n        // `item` completely overwrites `conflict`\n        // Remove conflict from the lookupMap\n        this._removeFromLookupMap(conflict);\n      }\n    }\n\n    conflicts.push(item);\n\n    this._addToLookupMap(item);\n  };\n\n  KeybindingResolver.prototype._addToLookupMap = function (item) {\n    if (!item.command) {\n      return;\n    }\n\n    var arr = this._lookupMap.get(item.command);\n\n    if (typeof arr === 'undefined') {\n      arr = [item];\n\n      this._lookupMap.set(item.command, arr);\n    } else {\n      arr.push(item);\n    }\n  };\n\n  KeybindingResolver.prototype._removeFromLookupMap = function (item) {\n    if (!item.command) {\n      return;\n    }\n\n    var arr = this._lookupMap.get(item.command);\n\n    if (typeof arr === 'undefined') {\n      return;\n    }\n\n    for (var i = 0, len = arr.length; i < len; i++) {\n      if (arr[i] === item) {\n        arr.splice(i, 1);\n        return;\n      }\n    }\n  };\n  /**\n   * Returns true if it is provable `a` implies `b`.\n   */\n\n\n  KeybindingResolver.whenIsEntirelyIncluded = function (a, b) {\n    if (!b) {\n      return true;\n    }\n\n    if (!a) {\n      return false;\n    }\n\n    return this._implies(a, b);\n  };\n  /**\n   * Returns true if it is provable `p` implies `q`.\n   */\n\n\n  KeybindingResolver._implies = function (p, q) {\n    var notP = p.negate();\n\n    var terminals = function (node) {\n      if (node instanceof ContextKeyOrExpr) {\n        return node.expr;\n      }\n\n      return [node];\n    };\n\n    var expr = terminals(notP).concat(terminals(q));\n\n    for (var i = 0; i < expr.length; i++) {\n      var a = expr[i];\n      var notA = a.negate();\n\n      for (var j = i + 1; j < expr.length; j++) {\n        var b = expr[j];\n\n        if (notA.equals(b)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  KeybindingResolver.prototype.lookupPrimaryKeybinding = function (commandId) {\n    var items = this._lookupMap.get(commandId);\n\n    if (typeof items === 'undefined' || items.length === 0) {\n      return null;\n    }\n\n    return items[items.length - 1];\n  };\n\n  KeybindingResolver.prototype.resolve = function (context, currentChord, keypress) {\n    var lookupMap = null;\n\n    if (currentChord !== null) {\n      // Fetch all chord bindings for `currentChord`\n      var candidates = this._map.get(currentChord);\n\n      if (typeof candidates === 'undefined') {\n        // No chords starting with `currentChord`\n        return null;\n      }\n\n      lookupMap = [];\n\n      for (var i = 0, len = candidates.length; i < len; i++) {\n        var candidate = candidates[i]; // TODO@chords\n\n        if (candidate.keypressParts[1] === keypress) {\n          lookupMap.push(candidate);\n        }\n      }\n    } else {\n      var candidates = this._map.get(keypress);\n\n      if (typeof candidates === 'undefined') {\n        // No bindings with `keypress`\n        return null;\n      }\n\n      lookupMap = candidates;\n    }\n\n    var result = this._findCommand(context, lookupMap);\n\n    if (!result) {\n      return null;\n    } // TODO@chords\n\n\n    if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n      return {\n        enterChord: true,\n        commandId: null,\n        commandArgs: null,\n        bubble: false\n      };\n    }\n\n    return {\n      enterChord: false,\n      commandId: result.command,\n      commandArgs: result.commandArgs,\n      bubble: result.bubble\n    };\n  };\n\n  KeybindingResolver.prototype._findCommand = function (context, matches) {\n    for (var i = matches.length - 1; i >= 0; i--) {\n      var k = matches[i];\n\n      if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\n        continue;\n      }\n\n      return k;\n    }\n\n    return null;\n  };\n\n  KeybindingResolver.contextMatchesRules = function (context, rules) {\n    if (!rules) {\n      return true;\n    }\n\n    return rules.evaluate(context);\n  };\n\n  return KeybindingResolver;\n}();\n\nexport { KeybindingResolver };","map":null,"metadata":{},"sourceType":"module"}