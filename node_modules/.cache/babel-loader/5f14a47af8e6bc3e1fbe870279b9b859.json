{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\n\nvar PieceTreeTextBuffer =\n/** @class */\nfunction () {\n  function PieceTreeTextBuffer(chunks, BOM, eol, containsRTL, isBasicASCII, eolNormalized) {\n    this._BOM = BOM;\n    this._mightContainNonBasicASCII = !isBasicASCII;\n    this._mightContainRTL = containsRTL;\n    this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n  }\n\n  PieceTreeTextBuffer.prototype.mightContainRTL = function () {\n    return this._mightContainRTL;\n  };\n\n  PieceTreeTextBuffer.prototype.mightContainNonBasicASCII = function () {\n    return this._mightContainNonBasicASCII;\n  };\n\n  PieceTreeTextBuffer.prototype.getBOM = function () {\n    return this._BOM;\n  };\n\n  PieceTreeTextBuffer.prototype.getEOL = function () {\n    return this._pieceTree.getEOL();\n  };\n\n  PieceTreeTextBuffer.prototype.getOffsetAt = function (lineNumber, column) {\n    return this._pieceTree.getOffsetAt(lineNumber, column);\n  };\n\n  PieceTreeTextBuffer.prototype.getPositionAt = function (offset) {\n    return this._pieceTree.getPositionAt(offset);\n  };\n\n  PieceTreeTextBuffer.prototype.getRangeAt = function (start, length) {\n    var end = start + length;\n    var startPosition = this.getPositionAt(start);\n    var endPosition = this.getPositionAt(end);\n    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n  };\n\n  PieceTreeTextBuffer.prototype.getValueInRange = function (range, eol) {\n    if (eol === void 0) {\n      eol = 0\n      /* TextDefined */\n      ;\n    }\n\n    if (range.isEmpty()) {\n      return '';\n    }\n\n    var lineEnding = this._getEndOfLine(eol);\n\n    return this._pieceTree.getValueInRange(range, lineEnding);\n  };\n\n  PieceTreeTextBuffer.prototype.getValueLengthInRange = function (range, eol) {\n    if (eol === void 0) {\n      eol = 0\n      /* TextDefined */\n      ;\n    }\n\n    if (range.isEmpty()) {\n      return 0;\n    }\n\n    if (range.startLineNumber === range.endLineNumber) {\n      return range.endColumn - range.startColumn;\n    }\n\n    var startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n    var endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n    return endOffset - startOffset;\n  };\n\n  PieceTreeTextBuffer.prototype.getLength = function () {\n    return this._pieceTree.getLength();\n  };\n\n  PieceTreeTextBuffer.prototype.getLineCount = function () {\n    return this._pieceTree.getLineCount();\n  };\n\n  PieceTreeTextBuffer.prototype.getLinesContent = function () {\n    return this._pieceTree.getLinesContent();\n  };\n\n  PieceTreeTextBuffer.prototype.getLineContent = function (lineNumber) {\n    return this._pieceTree.getLineContent(lineNumber);\n  };\n\n  PieceTreeTextBuffer.prototype.getLineCharCode = function (lineNumber, index) {\n    return this._pieceTree.getLineCharCode(lineNumber, index);\n  };\n\n  PieceTreeTextBuffer.prototype.getLineLength = function (lineNumber) {\n    return this._pieceTree.getLineLength(lineNumber);\n  };\n\n  PieceTreeTextBuffer.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {\n    var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n    if (result === -1) {\n      return 0;\n    }\n\n    return result + 1;\n  };\n\n  PieceTreeTextBuffer.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {\n    var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n    if (result === -1) {\n      return 0;\n    }\n\n    return result + 2;\n  };\n\n  PieceTreeTextBuffer.prototype._getEndOfLine = function (eol) {\n    switch (eol) {\n      case 1\n      /* LF */\n      :\n        return '\\n';\n\n      case 2\n      /* CRLF */\n      :\n        return '\\r\\n';\n\n      case 0\n      /* TextDefined */\n      :\n        return this.getEOL();\n    }\n\n    throw new Error('Unknown EOL preference');\n  };\n\n  PieceTreeTextBuffer.prototype.setEOL = function (newEOL) {\n    this._pieceTree.setEOL(newEOL);\n  };\n\n  PieceTreeTextBuffer.prototype.applyEdits = function (rawOperations, recordTrimAutoWhitespace) {\n    var mightContainRTL = this._mightContainRTL;\n    var mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n    var canReduceOperations = true;\n    var operations = [];\n\n    for (var i = 0; i < rawOperations.length; i++) {\n      var op = rawOperations[i];\n\n      if (canReduceOperations && op._isTracked) {\n        canReduceOperations = false;\n      }\n\n      var validatedRange = op.range;\n\n      if (!mightContainRTL && op.text) {\n        // check if the new inserted text contains RTL\n        mightContainRTL = strings.containsRTL(op.text);\n      }\n\n      if (!mightContainNonBasicASCII && op.text) {\n        mightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n      }\n\n      operations[i] = {\n        sortIndex: i,\n        identifier: op.identifier || null,\n        range: validatedRange,\n        rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n        rangeLength: this.getValueLengthInRange(validatedRange),\n        lines: op.text ? op.text.split(/\\r\\n|\\r|\\n/) : null,\n        forceMoveMarkers: Boolean(op.forceMoveMarkers),\n        isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n      };\n    } // Sort operations ascending\n\n\n    operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n    var hasTouchingRanges = false;\n\n    for (var i = 0, count = operations.length - 1; i < count; i++) {\n      var rangeEnd = operations[i].range.getEndPosition();\n      var nextRangeStart = operations[i + 1].range.getStartPosition();\n\n      if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n        if (nextRangeStart.isBefore(rangeEnd)) {\n          // overlapping ranges\n          throw new Error('Overlapping ranges are not allowed!');\n        }\n\n        hasTouchingRanges = true;\n      }\n    }\n\n    if (canReduceOperations) {\n      operations = this._reduceOperations(operations);\n    } // Delta encode operations\n\n\n    var reverseRanges = PieceTreeTextBuffer._getInverseEditRanges(operations);\n\n    var newTrimAutoWhitespaceCandidates = [];\n\n    for (var i = 0; i < operations.length; i++) {\n      var op = operations[i];\n      var reverseRange = reverseRanges[i];\n\n      if (recordTrimAutoWhitespace && op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n        // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n        for (var lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n          var currentLineContent = '';\n\n          if (lineNumber === reverseRange.startLineNumber) {\n            currentLineContent = this.getLineContent(op.range.startLineNumber);\n\n            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n              continue;\n            }\n          }\n\n          newTrimAutoWhitespaceCandidates.push({\n            lineNumber: lineNumber,\n            oldContent: currentLineContent\n          });\n        }\n      }\n    }\n\n    var reverseOperations = [];\n\n    for (var i = 0; i < operations.length; i++) {\n      var op = operations[i];\n      var reverseRange = reverseRanges[i];\n      reverseOperations[i] = {\n        sortIndex: op.sortIndex,\n        identifier: op.identifier,\n        range: reverseRange,\n        text: this.getValueInRange(op.range),\n        forceMoveMarkers: op.forceMoveMarkers\n      };\n    } // Can only sort reverse operations when the order is not significant\n\n\n    if (!hasTouchingRanges) {\n      reverseOperations.sort(function (a, b) {\n        return a.sortIndex - b.sortIndex;\n      });\n    }\n\n    this._mightContainRTL = mightContainRTL;\n    this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n    var contentChanges = this._doApplyEdits(operations);\n\n    var trimAutoWhitespaceLineNumbers = null;\n\n    if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n      // sort line numbers auto whitespace removal candidates for next edit descending\n      newTrimAutoWhitespaceCandidates.sort(function (a, b) {\n        return b.lineNumber - a.lineNumber;\n      });\n      trimAutoWhitespaceLineNumbers = [];\n\n      for (var i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n        var lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n\n        if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n          // Do not have the same line number twice\n          continue;\n        }\n\n        var prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n        var lineContent = this.getLineContent(lineNumber);\n\n        if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n          continue;\n        }\n\n        trimAutoWhitespaceLineNumbers.push(lineNumber);\n      }\n    }\n\n    return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n  };\n  /**\n   * Transform operations such that they represent the same logic edit,\n   * but that they also do not cause OOM crashes.\n   */\n\n\n  PieceTreeTextBuffer.prototype._reduceOperations = function (operations) {\n    if (operations.length < 1000) {\n      // We know from empirical testing that a thousand edits work fine regardless of their shape.\n      return operations;\n    } // At one point, due to how events are emitted and how each operation is handled,\n    // some operations can trigger a high amount of temporary string allocations,\n    // that will immediately get edited again.\n    // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n    // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\n\n    return [this._toSingleEditOperation(operations)];\n  };\n\n  PieceTreeTextBuffer.prototype._toSingleEditOperation = function (operations) {\n    var forceMoveMarkers = false,\n        firstEditRange = operations[0].range,\n        lastEditRange = operations[operations.length - 1].range,\n        entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn),\n        lastEndLineNumber = firstEditRange.startLineNumber,\n        lastEndColumn = firstEditRange.startColumn,\n        result = [];\n\n    for (var i = 0, len = operations.length; i < len; i++) {\n      var operation = operations[i],\n          range = operation.range;\n      forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers; // (1) -- Push old text\n\n      for (var lineNumber = lastEndLineNumber; lineNumber < range.startLineNumber; lineNumber++) {\n        if (lineNumber === lastEndLineNumber) {\n          result.push(this.getLineContent(lineNumber).substring(lastEndColumn - 1));\n        } else {\n          result.push('\\n');\n          result.push(this.getLineContent(lineNumber));\n        }\n      }\n\n      if (range.startLineNumber === lastEndLineNumber) {\n        result.push(this.getLineContent(range.startLineNumber).substring(lastEndColumn - 1, range.startColumn - 1));\n      } else {\n        result.push('\\n');\n        result.push(this.getLineContent(range.startLineNumber).substring(0, range.startColumn - 1));\n      } // (2) -- Push new text\n\n\n      if (operation.lines) {\n        for (var j = 0, lenJ = operation.lines.length; j < lenJ; j++) {\n          if (j !== 0) {\n            result.push('\\n');\n          }\n\n          result.push(operation.lines[j]);\n        }\n      }\n\n      lastEndLineNumber = operation.range.endLineNumber;\n      lastEndColumn = operation.range.endColumn;\n    }\n\n    return {\n      sortIndex: 0,\n      identifier: operations[0].identifier,\n      range: entireEditRange,\n      rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n      rangeLength: this.getValueLengthInRange(entireEditRange, 0\n      /* TextDefined */\n      ),\n      lines: result.join('').split('\\n'),\n      forceMoveMarkers: forceMoveMarkers,\n      isAutoWhitespaceEdit: false\n    };\n  };\n\n  PieceTreeTextBuffer.prototype._doApplyEdits = function (operations) {\n    operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n    var contentChanges = []; // operations are from bottom to top\n\n    for (var i = 0; i < operations.length; i++) {\n      var op = operations[i];\n      var startLineNumber = op.range.startLineNumber;\n      var startColumn = op.range.startColumn;\n      var endLineNumber = op.range.endLineNumber;\n      var endColumn = op.range.endColumn;\n\n      if (startLineNumber === endLineNumber && startColumn === endColumn && (!op.lines || op.lines.length === 0)) {\n        // no-op\n        continue;\n      }\n\n      var deletingLinesCnt = endLineNumber - startLineNumber;\n      var insertingLinesCnt = op.lines ? op.lines.length - 1 : 0;\n      var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n      var text = op.lines ? op.lines.join(this.getEOL()) : '';\n\n      if (text) {\n        // replacement\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\n        this._pieceTree.insert(op.rangeOffset, text, true);\n      } else {\n        // deletion\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n      }\n\n      if (editingLinesCnt < insertingLinesCnt) {\n        var newLinesContent = [];\n\n        for (var j = editingLinesCnt + 1; j <= insertingLinesCnt; j++) {\n          newLinesContent.push(op.lines[j]);\n        }\n\n        newLinesContent[newLinesContent.length - 1] = this.getLineContent(startLineNumber + insertingLinesCnt - 1);\n      }\n\n      var contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      contentChanges.push({\n        range: contentChangeRange,\n        rangeLength: op.rangeLength,\n        text: text,\n        rangeOffset: op.rangeOffset,\n        forceMoveMarkers: op.forceMoveMarkers\n      });\n    }\n\n    return contentChanges;\n  };\n\n  PieceTreeTextBuffer.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\n    return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  };\n  /**\n   * Assumes `operations` are validated and sorted ascending\n   */\n\n\n  PieceTreeTextBuffer._getInverseEditRanges = function (operations) {\n    var result = [];\n    var prevOpEndLineNumber = 0;\n    var prevOpEndColumn = 0;\n    var prevOp = null;\n\n    for (var i = 0, len = operations.length; i < len; i++) {\n      var op = operations[i];\n      var startLineNumber = void 0;\n      var startColumn = void 0;\n\n      if (prevOp) {\n        if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n          startLineNumber = prevOpEndLineNumber;\n          startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n        } else {\n          startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n          startColumn = op.range.startColumn;\n        }\n      } else {\n        startLineNumber = op.range.startLineNumber;\n        startColumn = op.range.startColumn;\n      }\n\n      var resultRange = void 0;\n\n      if (op.lines && op.lines.length > 0) {\n        // the operation inserts something\n        var lineCount = op.lines.length;\n        var firstLine = op.lines[0];\n        var lastLine = op.lines[lineCount - 1];\n\n        if (lineCount === 1) {\n          // single line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLine.length);\n        } else {\n          // multi line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLine.length + 1);\n        }\n      } else {\n        // There is nothing to insert\n        resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n      }\n\n      prevOpEndLineNumber = resultRange.endLineNumber;\n      prevOpEndColumn = resultRange.endColumn;\n      result.push(resultRange);\n      prevOp = op;\n    }\n\n    return result;\n  };\n\n  PieceTreeTextBuffer._sortOpsAscending = function (a, b) {\n    var r = Range.compareRangesUsingEnds(a.range, b.range);\n\n    if (r === 0) {\n      return a.sortIndex - b.sortIndex;\n    }\n\n    return r;\n  };\n\n  PieceTreeTextBuffer._sortOpsDescending = function (a, b) {\n    var r = Range.compareRangesUsingEnds(a.range, b.range);\n\n    if (r === 0) {\n      return b.sortIndex - a.sortIndex;\n    }\n\n    return -r;\n  };\n\n  return PieceTreeTextBuffer;\n}();\n\nexport { PieceTreeTextBuffer };","map":null,"metadata":{},"sourceType":"module"}