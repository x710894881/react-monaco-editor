{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ShiftCommand } from '../../common/commands/shiftCommand.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { IndentAction } from '../../common/modes/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport * as indentUtils from '../indentation/indentUtils.js';\n\nvar MoveLinesCommand =\n/** @class */\nfunction () {\n  function MoveLinesCommand(selection, isMovingDown, autoIndent) {\n    this._selection = selection;\n    this._isMovingDown = isMovingDown;\n    this._autoIndent = autoIndent;\n    this._selectionId = null;\n    this._moveEndLineSelectionShrink = false;\n  }\n\n  MoveLinesCommand.prototype.getEditOperations = function (model, builder) {\n    var modelLineCount = model.getLineCount();\n\n    if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n      this._selectionId = builder.trackSelection(this._selection);\n      return;\n    }\n\n    if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n      this._selectionId = builder.trackSelection(this._selection);\n      return;\n    }\n\n    this._moveEndPositionDown = false;\n    var s = this._selection;\n\n    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n      this._moveEndPositionDown = true;\n      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n    }\n\n    var _a = model.getOptions(),\n        tabSize = _a.tabSize,\n        indentSize = _a.indentSize,\n        insertSpaces = _a.insertSpaces;\n\n    var indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n    var virtualModel = {\n      getLineTokens: function (lineNumber) {\n        return model.getLineTokens(lineNumber);\n      },\n      getLanguageIdentifier: function () {\n        return model.getLanguageIdentifier();\n      },\n      getLanguageIdAtPosition: function (lineNumber, column) {\n        return model.getLanguageIdAtPosition(lineNumber, column);\n      },\n      getLineContent: null\n    };\n\n    if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n      // Current line is empty\n      var lineNumber = s.startLineNumber;\n      var otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;\n\n      if (model.getLineMaxColumn(otherLineNumber) === 1) {\n        // Other line number is empty too, so no editing is needed\n        // Add a no-op to force running by the model\n        builder.addEditOperation(new Range(1, 1, 1, 1), null);\n      } else {\n        // Type content from other line number on line number\n        builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber)); // Remove content from other line number\n\n        builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n      } // Track selection at the other line number\n\n\n      s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\n    } else {\n      var movingLineNumber_1;\n      var movingLineText = void 0;\n\n      if (this._isMovingDown) {\n        movingLineNumber_1 = s.endLineNumber + 1;\n        movingLineText = model.getLineContent(movingLineNumber_1); // Delete line that needs to be moved\n\n        builder.addEditOperation(new Range(movingLineNumber_1 - 1, model.getLineMaxColumn(movingLineNumber_1 - 1), movingLineNumber_1, model.getLineMaxColumn(movingLineNumber_1)), null);\n        var insertingText_1 = movingLineText;\n\n        if (this.shouldAutoIndent(model, s)) {\n          var movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber_1, s.startLineNumber - 1); // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n\n          if (movingLineMatchResult !== null) {\n            var oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber_1));\n            var newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n            var newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n            insertingText_1 = newIndentation + this.trimLeft(movingLineText);\n          } else {\n            // no enter rule matches, let's check indentatin rules then.\n            virtualModel.getLineContent = function (lineNumber) {\n              if (lineNumber === s.startLineNumber) {\n                return model.getLineContent(movingLineNumber_1);\n              } else {\n                return model.getLineContent(lineNumber);\n              }\n            };\n\n            var indentOfMovingLine = LanguageConfigurationRegistry.getGoodIndentForLine(virtualModel, model.getLanguageIdAtPosition(movingLineNumber_1, 1), s.startLineNumber, indentConverter);\n\n            if (indentOfMovingLine !== null) {\n              var oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber_1));\n              var newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n              var oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n\n              if (newSpaceCnt !== oldSpaceCnt) {\n                var newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                insertingText_1 = newIndentation + this.trimLeft(movingLineText);\n              }\n            }\n          } // add edit operations for moving line first to make sure it's executed after we make indentation change\n          // to s.startLineNumber\n\n\n          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText_1 + '\\n');\n          var ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber, insertingText_1); // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n\n          if (ret !== null) {\n            if (ret !== 0) {\n              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n            }\n          } else {\n            // it doesn't match onEnter rules, let's check indentation rules then.\n            virtualModel.getLineContent = function (lineNumber) {\n              if (lineNumber === s.startLineNumber) {\n                return insertingText_1;\n              } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                return model.getLineContent(lineNumber - 1);\n              } else {\n                return model.getLineContent(lineNumber);\n              }\n            };\n\n            var newIndentatOfMovingBlock = LanguageConfigurationRegistry.getGoodIndentForLine(virtualModel, model.getLanguageIdAtPosition(movingLineNumber_1, 1), s.startLineNumber + 1, indentConverter);\n\n            if (newIndentatOfMovingBlock !== null) {\n              var oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n              var newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n              var oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n\n              if (newSpaceCnt !== oldSpaceCnt) {\n                var spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n              }\n            }\n          }\n        } else {\n          // Insert line that needs to be moved before\n          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText_1 + '\\n');\n        }\n      } else {\n        movingLineNumber_1 = s.startLineNumber - 1;\n        movingLineText = model.getLineContent(movingLineNumber_1); // Delete line that needs to be moved\n\n        builder.addEditOperation(new Range(movingLineNumber_1, 1, movingLineNumber_1 + 1, 1), null); // Insert line that needs to be moved after\n\n        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n\n        if (this.shouldAutoIndent(model, s)) {\n          virtualModel.getLineContent = function (lineNumber) {\n            if (lineNumber === movingLineNumber_1) {\n              return model.getLineContent(s.startLineNumber);\n            } else {\n              return model.getLineContent(lineNumber);\n            }\n          };\n\n          var ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2); // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n\n          if (ret !== null) {\n            if (ret !== 0) {\n              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n            }\n          } else {\n            // it doesn't match any onEnter rule, let's check indentation rules then.\n            var indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber_1, indentConverter);\n\n            if (indentOfFirstLine !== null) {\n              // adjust the indentation of the moving block\n              var oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n              var newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n              var oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\n\n              if (newSpaceCnt !== oldSpaceCnt) {\n                var spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this._selectionId = builder.trackSelection(s);\n  };\n\n  MoveLinesCommand.prototype.buildIndentConverter = function (tabSize, indentSize, insertSpaces) {\n    return {\n      shiftIndent: function (indentation) {\n        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      },\n      unshiftIndent: function (indentation) {\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      }\n    };\n  };\n\n  MoveLinesCommand.prototype.matchEnterRule = function (model, indentConverter, tabSize, line, oneLineAbove, oneLineAboveText) {\n    var validPrecedingLine = oneLineAbove;\n\n    while (validPrecedingLine >= 1) {\n      // ship empty lines as empty lines just inherit indentation\n      var lineContent = void 0;\n\n      if (validPrecedingLine === oneLineAbove && oneLineAboveText !== undefined) {\n        lineContent = oneLineAboveText;\n      } else {\n        lineContent = model.getLineContent(validPrecedingLine);\n      }\n\n      var nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n\n      if (nonWhitespaceIdx >= 0) {\n        break;\n      }\n\n      validPrecedingLine--;\n    }\n\n    if (validPrecedingLine < 1 || line > model.getLineCount()) {\n      return null;\n    }\n\n    var maxColumn = model.getLineMaxColumn(validPrecedingLine);\n    var enter = LanguageConfigurationRegistry.getEnterAction(model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));\n\n    if (enter) {\n      var enterPrefix = enter.indentation;\n      var enterAction = enter.enterAction;\n\n      if (enterAction.indentAction === IndentAction.None) {\n        enterPrefix = enter.indentation + enterAction.appendText;\n      } else if (enterAction.indentAction === IndentAction.Indent) {\n        enterPrefix = enter.indentation + enterAction.appendText;\n      } else if (enterAction.indentAction === IndentAction.IndentOutdent) {\n        enterPrefix = enter.indentation;\n      } else if (enterAction.indentAction === IndentAction.Outdent) {\n        enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enterAction.appendText;\n      }\n\n      var movingLineText = model.getLineContent(line);\n\n      if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {\n        var oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n        var newIndentation = strings.getLeadingWhitespace(enterPrefix);\n        var indentMetadataOfMovelingLine = LanguageConfigurationRegistry.getIndentMetadata(model, line);\n\n        if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2\n        /* DECREASE_MASK */\n        ) {\n            newIndentation = indentConverter.unshiftIndent(newIndentation);\n          }\n\n        var newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n        var oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n        return newSpaceCnt - oldSpaceCnt;\n      }\n    }\n\n    return null;\n  };\n\n  MoveLinesCommand.prototype.trimLeft = function (str) {\n    return str.replace(/^\\s+/, '');\n  };\n\n  MoveLinesCommand.prototype.shouldAutoIndent = function (model, selection) {\n    if (!this._autoIndent) {\n      return false;\n    } // if it's not easy to tokenize, we stop auto indent.\n\n\n    if (!model.isCheapToTokenize(selection.startLineNumber)) {\n      return false;\n    }\n\n    var languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n    var languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n\n    if (languageAtSelectionStart !== languageAtSelectionEnd) {\n      return false;\n    }\n\n    if (LanguageConfigurationRegistry.getIndentRulesSupport(languageAtSelectionStart) === null) {\n      return false;\n    }\n\n    return true;\n  };\n\n  MoveLinesCommand.prototype.getIndentEditsOfMovingBlock = function (model, builder, s, tabSize, insertSpaces, offset) {\n    for (var i = s.startLineNumber; i <= s.endLineNumber; i++) {\n      var lineContent = model.getLineContent(i);\n      var originalIndent = strings.getLeadingWhitespace(lineContent);\n      var originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n      var newSpacesCnt = originalSpacesCnt + offset;\n      var newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n\n      if (newIndent !== originalIndent) {\n        builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\n\n        if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n          // as users select part of the original indent white spaces\n          // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n          this._moveEndLineSelectionShrink = true;\n        }\n      }\n    }\n  };\n\n  MoveLinesCommand.prototype.computeCursorState = function (model, helper) {\n    var result = helper.getTrackedSelection(this._selectionId);\n\n    if (this._moveEndPositionDown) {\n      result = result.setEndPosition(result.endLineNumber + 1, 1);\n    }\n\n    if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n      result = result.setEndPosition(result.endLineNumber, 2);\n    }\n\n    return result;\n  };\n\n  return MoveLinesCommand;\n}();\n\nexport { MoveLinesCommand };","map":null,"metadata":{},"sourceType":"module"}