{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as Json from '../../jsonc-parser/main.js';\nimport { URI } from '../../vscode-uri/index.js';\nimport * as Strings from '../utils/strings.js';\nimport * as Parser from '../parser/jsonParser.js';\nimport * as nls from '../../../fillers/vscode-nls.js';\nvar localize = nls.loadMessageBundle();\n\nvar FilePatternAssociation =\n/** @class */\nfunction () {\n  function FilePatternAssociation(pattern) {\n    try {\n      this.patternRegExp = new RegExp(Strings.convertSimple2RegExpPattern(pattern) + '$');\n    } catch (e) {\n      // invalid pattern\n      this.patternRegExp = null;\n    }\n\n    this.schemas = [];\n  }\n\n  FilePatternAssociation.prototype.addSchema = function (id) {\n    this.schemas.push(id);\n  };\n\n  FilePatternAssociation.prototype.matchesPattern = function (fileName) {\n    return this.patternRegExp && this.patternRegExp.test(fileName);\n  };\n\n  FilePatternAssociation.prototype.getSchemas = function () {\n    return this.schemas;\n  };\n\n  return FilePatternAssociation;\n}();\n\nvar SchemaHandle =\n/** @class */\nfunction () {\n  function SchemaHandle(service, url, unresolvedSchemaContent) {\n    this.service = service;\n    this.url = url;\n    this.dependencies = {};\n\n    if (unresolvedSchemaContent) {\n      this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));\n    }\n  }\n\n  SchemaHandle.prototype.getUnresolvedSchema = function () {\n    if (!this.unresolvedSchema) {\n      this.unresolvedSchema = this.service.loadSchema(this.url);\n    }\n\n    return this.unresolvedSchema;\n  };\n\n  SchemaHandle.prototype.getResolvedSchema = function () {\n    var _this = this;\n\n    if (!this.resolvedSchema) {\n      this.resolvedSchema = this.getUnresolvedSchema().then(function (unresolved) {\n        return _this.service.resolveSchemaContent(unresolved, _this.url, _this.dependencies);\n      });\n    }\n\n    return this.resolvedSchema;\n  };\n\n  SchemaHandle.prototype.clearSchema = function () {\n    this.resolvedSchema = null;\n    this.unresolvedSchema = null;\n    this.dependencies = {};\n  };\n\n  return SchemaHandle;\n}();\n\nvar UnresolvedSchema =\n/** @class */\nfunction () {\n  function UnresolvedSchema(schema, errors) {\n    if (errors === void 0) {\n      errors = [];\n    }\n\n    this.schema = schema;\n    this.errors = errors;\n  }\n\n  return UnresolvedSchema;\n}();\n\nexport { UnresolvedSchema };\n\nvar ResolvedSchema =\n/** @class */\nfunction () {\n  function ResolvedSchema(schema, errors) {\n    if (errors === void 0) {\n      errors = [];\n    }\n\n    this.schema = schema;\n    this.errors = errors;\n  }\n\n  ResolvedSchema.prototype.getSection = function (path) {\n    return Parser.asSchema(this.getSectionRecursive(path, this.schema));\n  };\n\n  ResolvedSchema.prototype.getSectionRecursive = function (path, schema) {\n    if (!schema || typeof schema === 'boolean' || path.length === 0) {\n      return schema;\n    }\n\n    var next = path.shift();\n\n    if (schema.properties && typeof schema.properties[next]) {\n      return this.getSectionRecursive(path, schema.properties[next]);\n    } else if (schema.patternProperties) {\n      for (var _i = 0, _a = Object.keys(schema.patternProperties); _i < _a.length; _i++) {\n        var pattern = _a[_i];\n        var regex = new RegExp(pattern);\n\n        if (regex.test(next)) {\n          return this.getSectionRecursive(path, schema.patternProperties[pattern]);\n        }\n      }\n    } else if (typeof schema.additionalProperties === 'object') {\n      return this.getSectionRecursive(path, schema.additionalProperties);\n    } else if (next.match('[0-9]+')) {\n      if (Array.isArray(schema.items)) {\n        var index = parseInt(next, 10);\n\n        if (!isNaN(index) && schema.items[index]) {\n          return this.getSectionRecursive(path, schema.items[index]);\n        }\n      } else if (schema.items) {\n        return this.getSectionRecursive(path, schema.items);\n      }\n    }\n\n    return null;\n  };\n\n  return ResolvedSchema;\n}();\n\nexport { ResolvedSchema };\n\nvar JSONSchemaService =\n/** @class */\nfunction () {\n  function JSONSchemaService(requestService, contextService, promiseConstructor) {\n    this.contextService = contextService;\n    this.requestService = requestService;\n    this.promiseConstructor = promiseConstructor || Promise;\n    this.callOnDispose = [];\n    this.contributionSchemas = {};\n    this.contributionAssociations = {};\n    this.schemasById = {};\n    this.filePatternAssociations = [];\n    this.filePatternAssociationById = {};\n    this.registeredSchemasIds = {};\n  }\n\n  JSONSchemaService.prototype.getRegisteredSchemaIds = function (filter) {\n    return Object.keys(this.registeredSchemasIds).filter(function (id) {\n      var scheme = URI.parse(id).scheme;\n      return scheme !== 'schemaservice' && (!filter || filter(scheme));\n    });\n  };\n\n  Object.defineProperty(JSONSchemaService.prototype, \"promise\", {\n    get: function () {\n      return this.promiseConstructor;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  JSONSchemaService.prototype.dispose = function () {\n    while (this.callOnDispose.length > 0) {\n      this.callOnDispose.pop()();\n    }\n  };\n\n  JSONSchemaService.prototype.onResourceChange = function (uri) {\n    var _this = this;\n\n    var hasChanges = false;\n    uri = this.normalizeId(uri);\n    var toWalk = [uri];\n    var all = Object.keys(this.schemasById).map(function (key) {\n      return _this.schemasById[key];\n    });\n\n    while (toWalk.length) {\n      var curr = toWalk.pop();\n\n      for (var i = 0; i < all.length; i++) {\n        var handle = all[i];\n\n        if (handle && (handle.url === curr || handle.dependencies[curr])) {\n          if (handle.url !== curr) {\n            toWalk.push(handle.url);\n          }\n\n          handle.clearSchema();\n          all[i] = undefined;\n          hasChanges = true;\n        }\n      }\n    }\n\n    return hasChanges;\n  };\n\n  JSONSchemaService.prototype.normalizeId = function (id) {\n    // remove trailing '#', normalize drive capitalization\n    try {\n      return URI.parse(id).toString();\n    } catch (e) {\n      return id;\n    }\n  };\n\n  JSONSchemaService.prototype.setSchemaContributions = function (schemaContributions) {\n    if (schemaContributions.schemas) {\n      var schemas = schemaContributions.schemas;\n\n      for (var id in schemas) {\n        var normalizedId = this.normalizeId(id);\n        this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas[id]);\n      }\n    }\n\n    if (schemaContributions.schemaAssociations) {\n      var schemaAssociations = schemaContributions.schemaAssociations;\n\n      for (var pattern in schemaAssociations) {\n        var associations = schemaAssociations[pattern];\n        this.contributionAssociations[pattern] = associations;\n        var fpa = this.getOrAddFilePatternAssociation(pattern);\n\n        for (var _i = 0, associations_1 = associations; _i < associations_1.length; _i++) {\n          var schemaId = associations_1[_i];\n          var id = this.normalizeId(schemaId);\n          fpa.addSchema(id);\n        }\n      }\n    }\n  };\n\n  JSONSchemaService.prototype.addSchemaHandle = function (id, unresolvedSchemaContent) {\n    var schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);\n    this.schemasById[id] = schemaHandle;\n    return schemaHandle;\n  };\n\n  JSONSchemaService.prototype.getOrAddSchemaHandle = function (id, unresolvedSchemaContent) {\n    return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);\n  };\n\n  JSONSchemaService.prototype.getOrAddFilePatternAssociation = function (pattern) {\n    var fpa = this.filePatternAssociationById[pattern];\n\n    if (!fpa) {\n      fpa = new FilePatternAssociation(pattern);\n      this.filePatternAssociationById[pattern] = fpa;\n      this.filePatternAssociations.push(fpa);\n    }\n\n    return fpa;\n  };\n\n  JSONSchemaService.prototype.registerExternalSchema = function (uri, filePatterns, unresolvedSchemaContent) {\n    if (filePatterns === void 0) {\n      filePatterns = null;\n    }\n\n    var id = this.normalizeId(uri);\n    this.registeredSchemasIds[id] = true;\n\n    if (filePatterns) {\n      for (var _i = 0, filePatterns_1 = filePatterns; _i < filePatterns_1.length; _i++) {\n        var pattern = filePatterns_1[_i];\n        this.getOrAddFilePatternAssociation(pattern).addSchema(id);\n      }\n    }\n\n    return unresolvedSchemaContent ? this.addSchemaHandle(id, unresolvedSchemaContent) : this.getOrAddSchemaHandle(id);\n  };\n\n  JSONSchemaService.prototype.clearExternalSchemas = function () {\n    this.schemasById = {};\n    this.filePatternAssociations = [];\n    this.filePatternAssociationById = {};\n    this.registeredSchemasIds = {};\n\n    for (var id in this.contributionSchemas) {\n      this.schemasById[id] = this.contributionSchemas[id];\n      this.registeredSchemasIds[id] = true;\n    }\n\n    for (var pattern in this.contributionAssociations) {\n      var fpa = this.getOrAddFilePatternAssociation(pattern);\n\n      for (var _i = 0, _a = this.contributionAssociations[pattern]; _i < _a.length; _i++) {\n        var schemaId = _a[_i];\n        var id = this.normalizeId(schemaId);\n        fpa.addSchema(id);\n      }\n    }\n  };\n\n  JSONSchemaService.prototype.getResolvedSchema = function (schemaId) {\n    var id = this.normalizeId(schemaId);\n    var schemaHandle = this.schemasById[id];\n\n    if (schemaHandle) {\n      return schemaHandle.getResolvedSchema();\n    }\n\n    return this.promise.resolve(null);\n  };\n\n  JSONSchemaService.prototype.loadSchema = function (url) {\n    if (!this.requestService) {\n      var errorMessage = localize('json.schema.norequestservice', 'Unable to load schema from \\'{0}\\'. No schema request service available', toDisplayString(url));\n      return this.promise.resolve(new UnresolvedSchema({}, [errorMessage]));\n    }\n\n    return this.requestService(url).then(function (content) {\n      if (!content) {\n        var errorMessage = localize('json.schema.nocontent', 'Unable to load schema from \\'{0}\\': No content.', toDisplayString(url));\n        return new UnresolvedSchema({}, [errorMessage]);\n      }\n\n      var schemaContent = {};\n      var jsonErrors = [];\n      schemaContent = Json.parse(content, jsonErrors);\n      var errors = jsonErrors.length ? [localize('json.schema.invalidFormat', 'Unable to parse content from \\'{0}\\': Parse error at offset {1}.', toDisplayString(url), jsonErrors[0].offset)] : [];\n      return new UnresolvedSchema(schemaContent, errors);\n    }, function (error) {\n      var errorMessage = error.toString();\n      var errorSplit = error.toString().split('Error: ');\n\n      if (errorSplit.length > 1) {\n        // more concise error message, URL and context are attached by caller anyways\n        errorMessage = errorSplit[1];\n      }\n\n      return new UnresolvedSchema({}, [errorMessage]);\n    });\n  };\n\n  JSONSchemaService.prototype.resolveSchemaContent = function (schemaToResolve, schemaURL, dependencies) {\n    var _this = this;\n\n    var resolveErrors = schemaToResolve.errors.slice(0);\n    var schema = schemaToResolve.schema;\n    var contextService = this.contextService;\n\n    var findSection = function (schema, path) {\n      if (!path) {\n        return schema;\n      }\n\n      var current = schema;\n\n      if (path[0] === '/') {\n        path = path.substr(1);\n      }\n\n      path.split('/').some(function (part) {\n        current = current[part];\n        return !current;\n      });\n      return current;\n    };\n\n    var merge = function (target, sourceRoot, sourceURI, path) {\n      var section = findSection(sourceRoot, path);\n\n      if (section) {\n        for (var key in section) {\n          if (section.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n            target[key] = section[key];\n          }\n        }\n      } else {\n        resolveErrors.push(localize('json.schema.invalidref', '$ref \\'{0}\\' in \\'{1}\\' can not be resolved.', path, sourceURI));\n      }\n    };\n\n    var resolveExternalLink = function (node, uri, linkPath, parentSchemaURL, parentSchemaDependencies) {\n      if (contextService && !/^\\w+:\\/\\/.*/.test(uri)) {\n        uri = contextService.resolveRelativePath(uri, parentSchemaURL);\n      }\n\n      uri = _this.normalizeId(uri);\n\n      var referencedHandle = _this.getOrAddSchemaHandle(uri);\n\n      return referencedHandle.getUnresolvedSchema().then(function (unresolvedSchema) {\n        parentSchemaDependencies[uri] = true;\n\n        if (unresolvedSchema.errors.length) {\n          var loc = linkPath ? uri + '#' + linkPath : uri;\n          resolveErrors.push(localize('json.schema.problemloadingref', 'Problems loading reference \\'{0}\\': {1}', loc, unresolvedSchema.errors[0]));\n        }\n\n        merge(node, unresolvedSchema.schema, uri, linkPath);\n        return resolveRefs(node, unresolvedSchema.schema, uri, referencedHandle.dependencies);\n      });\n    };\n\n    var resolveRefs = function (node, parentSchema, parentSchemaURL, parentSchemaDependencies) {\n      if (!node || typeof node !== 'object') {\n        return Promise.resolve(null);\n      }\n\n      var toWalk = [node];\n      var seen = [];\n      var openPromises = [];\n\n      var collectEntries = function () {\n        var entries = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          entries[_i] = arguments[_i];\n        }\n\n        for (var _a = 0, entries_1 = entries; _a < entries_1.length; _a++) {\n          var entry = entries_1[_a];\n\n          if (typeof entry === 'object') {\n            toWalk.push(entry);\n          }\n        }\n      };\n\n      var collectMapEntries = function () {\n        var maps = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          maps[_i] = arguments[_i];\n        }\n\n        for (var _a = 0, maps_1 = maps; _a < maps_1.length; _a++) {\n          var map = maps_1[_a];\n\n          if (typeof map === 'object') {\n            for (var key in map) {\n              var entry = map[key];\n\n              if (typeof entry === 'object') {\n                toWalk.push(entry);\n              }\n            }\n          }\n        }\n      };\n\n      var collectArrayEntries = function () {\n        var arrays = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          arrays[_i] = arguments[_i];\n        }\n\n        for (var _a = 0, arrays_1 = arrays; _a < arrays_1.length; _a++) {\n          var array = arrays_1[_a];\n\n          if (Array.isArray(array)) {\n            for (var _b = 0, array_1 = array; _b < array_1.length; _b++) {\n              var entry = array_1[_b];\n\n              if (typeof entry === 'object') {\n                toWalk.push(entry);\n              }\n            }\n          }\n        }\n      };\n\n      var handleRef = function (next) {\n        var seenRefs = [];\n\n        while (next.$ref) {\n          var ref = next.$ref;\n          var segments = ref.split('#', 2);\n          delete next.$ref;\n\n          if (segments[0].length > 0) {\n            openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies));\n            return;\n          } else {\n            if (seenRefs.indexOf(ref) === -1) {\n              merge(next, parentSchema, parentSchemaURL, segments[1]); // can set next.$ref again, use seenRefs to avoid circle\n\n              seenRefs.push(ref);\n            }\n          }\n        }\n\n        collectEntries(next.items, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else);\n        collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);\n        collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items);\n      };\n\n      while (toWalk.length) {\n        var next = toWalk.pop();\n\n        if (seen.indexOf(next) >= 0) {\n          continue;\n        }\n\n        seen.push(next);\n        handleRef(next);\n      }\n\n      return _this.promise.all(openPromises);\n    };\n\n    return resolveRefs(schema, schema, schemaURL, dependencies).then(function (_) {\n      return new ResolvedSchema(schema, resolveErrors);\n    });\n  };\n\n  JSONSchemaService.prototype.getSchemaForResource = function (resource, document) {\n    // first use $schema if present\n    if (document && document.root && document.root.type === 'object') {\n      var schemaProperties = document.root.properties.filter(function (p) {\n        return p.keyNode.value === '$schema' && p.valueNode && p.valueNode.type === 'string';\n      });\n\n      if (schemaProperties.length > 0) {\n        var schemeId = Parser.getNodeValue(schemaProperties[0].valueNode);\n\n        if (schemeId && Strings.startsWith(schemeId, '.') && this.contextService) {\n          schemeId = this.contextService.resolveRelativePath(schemeId, resource);\n        }\n\n        if (schemeId) {\n          var id = this.normalizeId(schemeId);\n          return this.getOrAddSchemaHandle(id).getResolvedSchema();\n        }\n      }\n    }\n\n    var seen = Object.create(null);\n    var schemas = [];\n\n    for (var _i = 0, _a = this.filePatternAssociations; _i < _a.length; _i++) {\n      var entry = _a[_i];\n\n      if (entry.matchesPattern(resource)) {\n        for (var _b = 0, _c = entry.getSchemas(); _b < _c.length; _b++) {\n          var schemaId = _c[_b];\n\n          if (!seen[schemaId]) {\n            schemas.push(schemaId);\n            seen[schemaId] = true;\n          }\n        }\n      }\n    }\n\n    if (schemas.length > 0) {\n      return this.createCombinedSchema(resource, schemas).getResolvedSchema();\n    }\n\n    return this.promise.resolve(null);\n  };\n\n  JSONSchemaService.prototype.createCombinedSchema = function (resource, schemaIds) {\n    if (schemaIds.length === 1) {\n      return this.getOrAddSchemaHandle(schemaIds[0]);\n    } else {\n      var combinedSchemaId = 'schemaservice://combinedSchema/' + encodeURIComponent(resource);\n      var combinedSchema = {\n        allOf: schemaIds.map(function (schemaId) {\n          return {\n            $ref: schemaId\n          };\n        })\n      };\n      return this.addSchemaHandle(combinedSchemaId, combinedSchema);\n    }\n  };\n\n  return JSONSchemaService;\n}();\n\nexport { JSONSchemaService };\n\nfunction toDisplayString(url) {\n  try {\n    var uri = URI.parse(url);\n\n    if (uri.scheme === 'file') {\n      return uri.fsPath;\n    }\n  } catch (e) {// ignore\n  }\n\n  return url;\n}","map":null,"metadata":{},"sourceType":"module"}