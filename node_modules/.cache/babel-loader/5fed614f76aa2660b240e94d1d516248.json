{"ast":null,"code":"/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nvar TRACK_DISPOSABLES = false;\nvar __is_disposable_tracked__ = '__is_disposable_tracked__';\n\nfunction markTracked(x) {\n  if (!TRACK_DISPOSABLES) {\n    return;\n  }\n\n  if (x && x !== Disposable.None) {\n    try {\n      x[__is_disposable_tracked__] = true;\n    } catch (_a) {// noop\n    }\n  }\n}\n\nfunction trackDisposable(x) {\n  if (!TRACK_DISPOSABLES) {\n    return x;\n  }\n\n  var stack = new Error('Potentially leaked disposable').stack;\n  setTimeout(function () {\n    if (!x[__is_disposable_tracked__]) {\n      console.log(stack);\n    }\n  }, 3000);\n  return x;\n}\n\nexport function isDisposable(thing) {\n  return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(disposables) {\n  if (Array.isArray(disposables)) {\n    disposables.forEach(function (d) {\n      if (d) {\n        markTracked(d);\n        d.dispose();\n      }\n    });\n    return [];\n  } else if (disposables) {\n    markTracked(disposables);\n    disposables.dispose();\n    return disposables;\n  } else {\n    return undefined;\n  }\n}\nexport function combinedDisposable() {\n  var disposables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    disposables[_i] = arguments[_i];\n  }\n\n  disposables.forEach(markTracked);\n  return trackDisposable({\n    dispose: function () {\n      return dispose(disposables);\n    }\n  });\n}\nexport function toDisposable(fn) {\n  var self = trackDisposable({\n    dispose: function () {\n      markTracked(self);\n      fn();\n    }\n  });\n  return self;\n}\n\nvar DisposableStore =\n/** @class */\nfunction () {\n  function DisposableStore() {\n    this._toDispose = new Set();\n    this._isDisposed = false;\n  }\n  /**\n   * Dispose of all registered disposables and mark this object as disposed.\n   *\n   * Any future disposables added to this object will be disposed of on `add`.\n   */\n\n\n  DisposableStore.prototype.dispose = function () {\n    if (this._isDisposed) {\n      return;\n    }\n\n    markTracked(this);\n    this._isDisposed = true;\n    this.clear();\n  };\n  /**\n   * Dispose of all registered disposables but do not mark this object as disposed.\n   */\n\n\n  DisposableStore.prototype.clear = function () {\n    this._toDispose.forEach(function (item) {\n      return item.dispose();\n    });\n\n    this._toDispose.clear();\n  };\n\n  DisposableStore.prototype.add = function (t) {\n    if (!t) {\n      return t;\n    }\n\n    if (t === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n\n    markTracked(t);\n\n    if (this._isDisposed) {\n      console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n    } else {\n      this._toDispose.add(t);\n    }\n\n    return t;\n  };\n\n  return DisposableStore;\n}();\n\nexport { DisposableStore };\n\nvar Disposable =\n/** @class */\nfunction () {\n  function Disposable() {\n    this._store = new DisposableStore();\n    trackDisposable(this);\n  }\n\n  Disposable.prototype.dispose = function () {\n    markTracked(this);\n\n    this._store.dispose();\n  };\n\n  Disposable.prototype._register = function (t) {\n    if (t === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n\n    return this._store.add(t);\n  };\n\n  Disposable.None = Object.freeze({\n    dispose: function () {}\n  });\n  return Disposable;\n}();\n\nexport { Disposable };\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\n\nvar MutableDisposable =\n/** @class */\nfunction () {\n  function MutableDisposable() {\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n\n  Object.defineProperty(MutableDisposable.prototype, \"value\", {\n    get: function () {\n      return this._isDisposed ? undefined : this._value;\n    },\n    set: function (value) {\n      if (this._isDisposed || value === this._value) {\n        return;\n      }\n\n      if (this._value) {\n        this._value.dispose();\n      }\n\n      if (value) {\n        markTracked(value);\n      }\n\n      this._value = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MutableDisposable.prototype.clear = function () {\n    this.value = undefined;\n  };\n\n  MutableDisposable.prototype.dispose = function () {\n    this._isDisposed = true;\n    markTracked(this);\n\n    if (this._value) {\n      this._value.dispose();\n    }\n\n    this._value = undefined;\n  };\n\n  return MutableDisposable;\n}();\n\nexport { MutableDisposable };\n\nvar ImmortalReference =\n/** @class */\nfunction () {\n  function ImmortalReference(object) {\n    this.object = object;\n  }\n\n  ImmortalReference.prototype.dispose = function () {};\n\n  return ImmortalReference;\n}();\n\nexport { ImmortalReference };","map":null,"metadata":{},"sourceType":"module"}