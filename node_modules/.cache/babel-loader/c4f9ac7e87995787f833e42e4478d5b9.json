{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nexport var CopyOptions = {\n  forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\n\nvar TextAreaInput =\n/** @class */\nfunction (_super) {\n  __extends(TextAreaInput, _super);\n\n  function TextAreaInput(host, textArea) {\n    var _this = _super.call(this) || this;\n\n    _this._onFocus = _this._register(new Emitter());\n    _this.onFocus = _this._onFocus.event;\n    _this._onBlur = _this._register(new Emitter());\n    _this.onBlur = _this._onBlur.event;\n    _this._onKeyDown = _this._register(new Emitter());\n    _this.onKeyDown = _this._onKeyDown.event;\n    _this._onKeyUp = _this._register(new Emitter());\n    _this.onKeyUp = _this._onKeyUp.event;\n    _this._onCut = _this._register(new Emitter());\n    _this.onCut = _this._onCut.event;\n    _this._onPaste = _this._register(new Emitter());\n    _this.onPaste = _this._onPaste.event;\n    _this._onType = _this._register(new Emitter());\n    _this.onType = _this._onType.event;\n    _this._onCompositionStart = _this._register(new Emitter());\n    _this.onCompositionStart = _this._onCompositionStart.event;\n    _this._onCompositionUpdate = _this._register(new Emitter());\n    _this.onCompositionUpdate = _this._onCompositionUpdate.event;\n    _this._onCompositionEnd = _this._register(new Emitter());\n    _this.onCompositionEnd = _this._onCompositionEnd.event;\n    _this._onSelectionChangeRequest = _this._register(new Emitter());\n    _this.onSelectionChangeRequest = _this._onSelectionChangeRequest.event;\n    _this._host = host;\n    _this._textArea = _this._register(new TextAreaWrapper(textArea));\n    _this._lastTextAreaEvent = 0\n    /* none */\n    ;\n    _this._asyncTriggerCut = _this._register(new RunOnceScheduler(function () {\n      return _this._onCut.fire();\n    }, 0));\n    _this._textAreaState = TextAreaState.EMPTY;\n    _this._selectionChangeListener = null;\n\n    _this.writeScreenReaderContent('ctor');\n\n    _this._hasFocus = false;\n    _this._isDoingComposition = false;\n    _this._nextCommand = 0\n    /* Type */\n    ;\n\n    _this._register(dom.addStandardDisposableListener(textArea.domNode, 'keydown', function (e) {\n      if (_this._isDoingComposition && (e.keyCode === 109\n      /* KEY_IN_COMPOSITION */\n      || e.keyCode === 1\n      /* Backspace */\n      )) {\n        // Stop propagation for keyDown events if the IME is processing key input\n        e.stopPropagation();\n      }\n\n      if (e.equals(9\n      /* Escape */\n      )) {\n        // Prevent default always for `Esc`, otherwise it will generate a keypress\n        // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n        e.preventDefault();\n      }\n\n      _this._onKeyDown.fire(e);\n    }));\n\n    _this._register(dom.addStandardDisposableListener(textArea.domNode, 'keyup', function (e) {\n      _this._onKeyUp.fire(e);\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'compositionstart', function (e) {\n      _this._lastTextAreaEvent = 1\n      /* compositionstart */\n      ;\n\n      if (_this._isDoingComposition) {\n        return;\n      }\n\n      _this._isDoingComposition = true; // In IE we cannot set .value when handling 'compositionstart' because the entire composition will get canceled.\n\n      if (!browser.isEdgeOrIE) {\n        _this._setAndWriteTextAreaState('compositionstart', TextAreaState.EMPTY);\n      }\n\n      _this._onCompositionStart.fire();\n    }));\n    /**\n     * Deduce the typed input from a text area's value and the last observed state.\n     */\n\n\n    var deduceInputFromTextAreaValue = function (couldBeEmojiInput, couldBeTypingAtOffset0) {\n      var oldState = _this._textAreaState;\n      var newState = TextAreaState.readFromTextArea(_this._textArea);\n      return [newState, TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput, couldBeTypingAtOffset0)];\n    };\n    /**\n     * Deduce the composition input from a string.\n     */\n\n\n    var deduceComposition = function (text) {\n      var oldState = _this._textAreaState;\n      var newState = TextAreaState.selectedText(text);\n      var typeInput = {\n        text: newState.value,\n        replaceCharCnt: oldState.selectionEnd - oldState.selectionStart\n      };\n      return [newState, typeInput];\n    };\n\n    var compositionDataInValid = function (locale) {\n      // https://github.com/Microsoft/monaco-editor/issues/339\n      // Multi-part Japanese compositions reset cursor in Edge/IE, Chinese and Korean IME don't have this issue.\n      // The reason that we can't use this path for all CJK IME is IE and Edge behave differently when handling Korean IME,\n      // which breaks this path of code.\n      if (browser.isEdgeOrIE && locale === 'ja') {\n        return true;\n      } // https://github.com/Microsoft/monaco-editor/issues/545\n      // On IE11, we can't trust composition data when typing Chinese as IE11 doesn't emit correct\n      // events when users type numbers in IME.\n      // Chinese: zh-Hans-CN, zh-Hans-SG, zh-Hant-TW, zh-Hant-HK\n\n\n      if (browser.isIE && locale.indexOf('zh-Han') === 0) {\n        return true;\n      }\n\n      return false;\n    };\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'compositionupdate', function (e) {\n      _this._lastTextAreaEvent = 2\n      /* compositionupdate */\n      ;\n\n      if (compositionDataInValid(e.locale)) {\n        var _a = deduceInputFromTextAreaValue(\n        /*couldBeEmojiInput*/\n        false,\n        /*couldBeTypingAtOffset0*/\n        false),\n            newState_1 = _a[0],\n            typeInput_1 = _a[1];\n\n        _this._textAreaState = newState_1;\n\n        _this._onType.fire(typeInput_1);\n\n        _this._onCompositionUpdate.fire(e);\n\n        return;\n      }\n\n      var _b = deduceComposition(e.data),\n          newState = _b[0],\n          typeInput = _b[1];\n\n      _this._textAreaState = newState;\n\n      _this._onType.fire(typeInput);\n\n      _this._onCompositionUpdate.fire(e);\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'compositionend', function (e) {\n      _this._lastTextAreaEvent = 3\n      /* compositionend */\n      ;\n\n      if (compositionDataInValid(e.locale)) {\n        // https://github.com/Microsoft/monaco-editor/issues/339\n        var _a = deduceInputFromTextAreaValue(\n        /*couldBeEmojiInput*/\n        false,\n        /*couldBeTypingAtOffset0*/\n        false),\n            newState = _a[0],\n            typeInput = _a[1];\n\n        _this._textAreaState = newState;\n\n        _this._onType.fire(typeInput);\n      } else {\n        var _b = deduceComposition(e.data),\n            newState = _b[0],\n            typeInput = _b[1];\n\n        _this._textAreaState = newState;\n\n        _this._onType.fire(typeInput);\n      } // Due to isEdgeOrIE (where the textarea was not cleared initially) and isChrome (the textarea is not updated correctly when composition ends)\n      // we cannot assume the text at the end consists only of the composited text\n\n\n      if (browser.isEdgeOrIE || browser.isChrome) {\n        _this._textAreaState = TextAreaState.readFromTextArea(_this._textArea);\n      }\n\n      if (!_this._isDoingComposition) {\n        return;\n      }\n\n      _this._isDoingComposition = false;\n\n      _this._onCompositionEnd.fire();\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'input', function () {\n      // We want to find out if this is the first `input` after a `focus`.\n      var previousEventWasFocus = _this._lastTextAreaEvent === 8\n      /* focus */\n      ;\n      _this._lastTextAreaEvent = 4\n      /* input */\n      ; // Pretend here we touched the text area, as the `input` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n\n      _this._textArea.setIgnoreSelectionChangeTime('received input event');\n\n      if (_this._isDoingComposition) {\n        return;\n      }\n\n      var _a = deduceInputFromTextAreaValue(\n      /*couldBeEmojiInput*/\n      platform.isMacintosh,\n      /*couldBeTypingAtOffset0*/\n      previousEventWasFocus && platform.isMacintosh),\n          newState = _a[0],\n          typeInput = _a[1];\n\n      if (typeInput.replaceCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n        // Ignore invalid input but keep it around for next time\n        return;\n      }\n\n      _this._textAreaState = newState;\n\n      if (_this._nextCommand === 0\n      /* Type */\n      ) {\n          if (typeInput.text !== '') {\n            _this._onType.fire(typeInput);\n          }\n        } else {\n        if (typeInput.text !== '') {\n          _this._onPaste.fire({\n            text: typeInput.text\n          });\n        }\n\n        _this._nextCommand = 0\n        /* Type */\n        ;\n      }\n    })); // --- Clipboard operations\n\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'cut', function (e) {\n      _this._lastTextAreaEvent = 5\n      /* cut */\n      ; // Pretend here we touched the text area, as the `cut` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n\n      _this._textArea.setIgnoreSelectionChangeTime('received cut event');\n\n      _this._ensureClipboardGetsEditorSelection(e);\n\n      _this._asyncTriggerCut.schedule();\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'copy', function (e) {\n      _this._lastTextAreaEvent = 6\n      /* copy */\n      ;\n\n      _this._ensureClipboardGetsEditorSelection(e);\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'paste', function (e) {\n      _this._lastTextAreaEvent = 7\n      /* paste */\n      ; // Pretend here we touched the text area, as the `paste` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n\n      _this._textArea.setIgnoreSelectionChangeTime('received paste event');\n\n      if (ClipboardEventUtils.canUseTextData(e)) {\n        var pastePlainText = ClipboardEventUtils.getTextData(e);\n\n        if (pastePlainText !== '') {\n          _this._onPaste.fire({\n            text: pastePlainText\n          });\n        }\n      } else {\n        if (_this._textArea.getSelectionStart() !== _this._textArea.getSelectionEnd()) {\n          // Clean up the textarea, to get a clean paste\n          _this._setAndWriteTextAreaState('paste', TextAreaState.EMPTY);\n        }\n\n        _this._nextCommand = 1\n        /* Paste */\n        ;\n      }\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'focus', function () {\n      _this._lastTextAreaEvent = 8\n      /* focus */\n      ;\n\n      _this._setHasFocus(true);\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'blur', function () {\n      _this._lastTextAreaEvent = 9\n      /* blur */\n      ;\n\n      _this._setHasFocus(false);\n    }));\n\n    return _this;\n  }\n\n  TextAreaInput.prototype._installSelectionChangeListener = function () {\n    // See https://github.com/Microsoft/vscode/issues/27216\n    // When using a Braille display, it is possible for users to reposition the\n    // system caret. This is reflected in Chrome as a `selectionchange` event.\n    //\n    // The `selectionchange` event appears to be emitted under numerous other circumstances,\n    // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n    // using a Braille display from all the other cases.\n    //\n    // The problems with the `selectionchange` event are:\n    //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n    //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n    //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n    //  * the event is emitted when tabbing into the textarea\n    //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n    //  * the event sometimes comes in bursts for a single logical textarea operation\n    var _this = this; // `selectionchange` events often come multiple times for a single logical change\n    // so throttle multiple `selectionchange` events that burst in a short period of time.\n\n\n    var previousSelectionChangeEventTime = 0;\n    return dom.addDisposableListener(document, 'selectionchange', function (e) {\n      if (!_this._hasFocus) {\n        return;\n      }\n\n      if (_this._isDoingComposition) {\n        return;\n      }\n\n      if (!browser.isChrome || !platform.isWindows) {\n        // Support only for Chrome on Windows until testing happens on other browsers + OS configurations\n        return;\n      }\n\n      var now = Date.now();\n      var delta1 = now - previousSelectionChangeEventTime;\n      previousSelectionChangeEventTime = now;\n\n      if (delta1 < 5) {\n        // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n        // => ignore it\n        return;\n      }\n\n      var delta2 = now - _this._textArea.getIgnoreSelectionChangeTime();\n\n      _this._textArea.resetSelectionChangeTime();\n\n      if (delta2 < 100) {\n        // received a `selectionchange` event within 100ms since we touched the textarea\n        // => ignore it, since we caused it\n        return;\n      }\n\n      if (!_this._textAreaState.selectionStartPosition || !_this._textAreaState.selectionEndPosition) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n\n      var newValue = _this._textArea.getValue();\n\n      if (_this._textAreaState.value !== newValue) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n\n      var newSelectionStart = _this._textArea.getSelectionStart();\n\n      var newSelectionEnd = _this._textArea.getSelectionEnd();\n\n      if (_this._textAreaState.selectionStart === newSelectionStart && _this._textAreaState.selectionEnd === newSelectionEnd) {\n        // Nothing to do...\n        return;\n      }\n\n      var _newSelectionStartPosition = _this._textAreaState.deduceEditorPosition(newSelectionStart);\n\n      var newSelectionStartPosition = _this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n\n      var _newSelectionEndPosition = _this._textAreaState.deduceEditorPosition(newSelectionEnd);\n\n      var newSelectionEndPosition = _this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n\n      var newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n\n      _this._onSelectionChangeRequest.fire(newSelection);\n    });\n  };\n\n  TextAreaInput.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n\n      this._selectionChangeListener = null;\n    }\n  };\n\n  TextAreaInput.prototype.focusTextArea = function () {\n    // Setting this._hasFocus and writing the screen reader content\n    // will result in a focus() and setSelectionRange() in the textarea\n    this._setHasFocus(true);\n  };\n\n  TextAreaInput.prototype.isFocused = function () {\n    return this._hasFocus;\n  };\n\n  TextAreaInput.prototype._setHasFocus = function (newHasFocus) {\n    if (this._hasFocus === newHasFocus) {\n      // no change\n      return;\n    }\n\n    this._hasFocus = newHasFocus;\n\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n\n      this._selectionChangeListener = null;\n    }\n\n    if (this._hasFocus) {\n      this._selectionChangeListener = this._installSelectionChangeListener();\n    }\n\n    if (this._hasFocus) {\n      if (browser.isEdge) {\n        // Edge has a bug where setting the selection range while the focus event\n        // is dispatching doesn't work. To reproduce, \"tab into\" the editor.\n        this._setAndWriteTextAreaState('focusgain', TextAreaState.EMPTY);\n      } else {\n        this.writeScreenReaderContent('focusgain');\n      }\n    }\n\n    if (this._hasFocus) {\n      this._onFocus.fire();\n    } else {\n      this._onBlur.fire();\n    }\n  };\n\n  TextAreaInput.prototype._setAndWriteTextAreaState = function (reason, textAreaState) {\n    if (!this._hasFocus) {\n      textAreaState = textAreaState.collapseSelection();\n    }\n\n    textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n    this._textAreaState = textAreaState;\n  };\n\n  TextAreaInput.prototype.writeScreenReaderContent = function (reason) {\n    if (this._isDoingComposition) {\n      // Do not write to the text area when doing composition\n      return;\n    }\n\n    this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n  };\n\n  TextAreaInput.prototype._ensureClipboardGetsEditorSelection = function (e) {\n    var copyPlainText = this._host.getPlainTextToCopy();\n\n    if (!ClipboardEventUtils.canUseTextData(e)) {\n      // Looks like an old browser. The strategy is to place the text\n      // we'd like to be copied to the clipboard in the textarea and select it.\n      this._setAndWriteTextAreaState('copy or cut', TextAreaState.selectedText(copyPlainText));\n\n      return;\n    }\n\n    var copyHTML = null;\n\n    if (browser.hasClipboardSupport() && (copyPlainText.length < 65536 || CopyOptions.forceCopyWithSyntaxHighlighting)) {\n      copyHTML = this._host.getHTMLToCopy();\n    }\n\n    ClipboardEventUtils.setTextData(e, copyPlainText, copyHTML);\n  };\n\n  return TextAreaInput;\n}(Disposable);\n\nexport { TextAreaInput };\n\nvar ClipboardEventUtils =\n/** @class */\nfunction () {\n  function ClipboardEventUtils() {}\n\n  ClipboardEventUtils.canUseTextData = function (e) {\n    if (e.clipboardData) {\n      return true;\n    }\n\n    if (window.clipboardData) {\n      return true;\n    }\n\n    return false;\n  };\n\n  ClipboardEventUtils.getTextData = function (e) {\n    if (e.clipboardData) {\n      e.preventDefault();\n      return e.clipboardData.getData('text/plain');\n    }\n\n    if (window.clipboardData) {\n      e.preventDefault();\n      return window.clipboardData.getData('Text');\n    }\n\n    throw new Error('ClipboardEventUtils.getTextData: Cannot use text data!');\n  };\n\n  ClipboardEventUtils.setTextData = function (e, text, richText) {\n    if (e.clipboardData) {\n      e.clipboardData.setData('text/plain', text);\n\n      if (richText !== null) {\n        e.clipboardData.setData('text/html', richText);\n      }\n\n      e.preventDefault();\n      return;\n    }\n\n    if (window.clipboardData) {\n      window.clipboardData.setData('Text', text);\n      e.preventDefault();\n      return;\n    }\n\n    throw new Error('ClipboardEventUtils.setTextData: Cannot use text data!');\n  };\n\n  return ClipboardEventUtils;\n}();\n\nvar TextAreaWrapper =\n/** @class */\nfunction (_super) {\n  __extends(TextAreaWrapper, _super);\n\n  function TextAreaWrapper(_textArea) {\n    var _this = _super.call(this) || this;\n\n    _this._actual = _textArea;\n    _this._ignoreSelectionChangeTime = 0;\n    return _this;\n  }\n\n  TextAreaWrapper.prototype.setIgnoreSelectionChangeTime = function (reason) {\n    this._ignoreSelectionChangeTime = Date.now();\n  };\n\n  TextAreaWrapper.prototype.getIgnoreSelectionChangeTime = function () {\n    return this._ignoreSelectionChangeTime;\n  };\n\n  TextAreaWrapper.prototype.resetSelectionChangeTime = function () {\n    this._ignoreSelectionChangeTime = 0;\n  };\n\n  TextAreaWrapper.prototype.getValue = function () {\n    // console.log('current value: ' + this._textArea.value);\n    return this._actual.domNode.value;\n  };\n\n  TextAreaWrapper.prototype.setValue = function (reason, value) {\n    var textArea = this._actual.domNode;\n\n    if (textArea.value === value) {\n      // No change\n      return;\n    } // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n\n\n    this.setIgnoreSelectionChangeTime('setValue');\n    textArea.value = value;\n  };\n\n  TextAreaWrapper.prototype.getSelectionStart = function () {\n    return this._actual.domNode.selectionStart;\n  };\n\n  TextAreaWrapper.prototype.getSelectionEnd = function () {\n    return this._actual.domNode.selectionEnd;\n  };\n\n  TextAreaWrapper.prototype.setSelectionRange = function (reason, selectionStart, selectionEnd) {\n    var textArea = this._actual.domNode;\n    var currentIsFocused = document.activeElement === textArea;\n    var currentSelectionStart = textArea.selectionStart;\n    var currentSelectionEnd = textArea.selectionEnd;\n\n    if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n      // No change\n      // Firefox iframe bug https://github.com/Microsoft/monaco-editor/issues/643#issuecomment-367871377\n      if (browser.isFirefox && window.parent !== window) {\n        textArea.focus();\n      }\n\n      return;\n    } // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n\n\n    if (currentIsFocused) {\n      // No need to focus, only need to change the selection range\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n\n      if (browser.isFirefox && window.parent !== window) {\n        textArea.focus();\n      }\n\n      return;\n    } // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n    // Here, we try to undo the browser's desperate reveal.\n\n\n    try {\n      var scrollState = dom.saveParentsScrollTop(textArea);\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.focus();\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n      dom.restoreParentsScrollTop(textArea, scrollState);\n    } catch (e) {// Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n    }\n  };\n\n  return TextAreaWrapper;\n}(Disposable);","map":null,"metadata":{},"sourceType":"module"}