{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { RunOnceScheduler, TimeoutTimer } from '../../../base/common/async.js';\nimport { dispose, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { ReplaceCommand, ReplaceCommandThatPreservesSelection } from '../../common/commands/replaceCommand.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { SearchParams } from '../../common/model/textModelSearch.js';\nimport { FindDecorations } from './findDecorations.js';\nimport { ReplaceAllCommand } from './replaceAllCommand.js';\nimport { ReplacePattern, parseReplaceString } from './replacePattern.js';\nimport { RawContextKey } from '../../../platform/contextkey/common/contextkey.js';\nexport var CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey('findWidgetVisible', false); // Keep ContextKey use of 'Focussed' to not break when clauses\n\nexport var CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey('findInputFocussed', false);\nexport var CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey('replaceInputFocussed', false);\nexport var ToggleCaseSensitiveKeybinding = {\n  primary: 512\n  /* Alt */\n  | 33\n  /* KEY_C */\n  ,\n  mac: {\n    primary: 2048\n    /* CtrlCmd */\n    | 512\n    /* Alt */\n    | 33\n    /* KEY_C */\n\n  }\n};\nexport var ToggleWholeWordKeybinding = {\n  primary: 512\n  /* Alt */\n  | 53\n  /* KEY_W */\n  ,\n  mac: {\n    primary: 2048\n    /* CtrlCmd */\n    | 512\n    /* Alt */\n    | 53\n    /* KEY_W */\n\n  }\n};\nexport var ToggleRegexKeybinding = {\n  primary: 512\n  /* Alt */\n  | 48\n  /* KEY_R */\n  ,\n  mac: {\n    primary: 2048\n    /* CtrlCmd */\n    | 512\n    /* Alt */\n    | 48\n    /* KEY_R */\n\n  }\n};\nexport var ToggleSearchScopeKeybinding = {\n  primary: 512\n  /* Alt */\n  | 42\n  /* KEY_L */\n  ,\n  mac: {\n    primary: 2048\n    /* CtrlCmd */\n    | 512\n    /* Alt */\n    | 42\n    /* KEY_L */\n\n  }\n};\nexport var FIND_IDS = {\n  StartFindAction: 'actions.find',\n  StartFindWithSelection: 'actions.findWithSelection',\n  NextMatchFindAction: 'editor.action.nextMatchFindAction',\n  PreviousMatchFindAction: 'editor.action.previousMatchFindAction',\n  NextSelectionMatchFindAction: 'editor.action.nextSelectionMatchFindAction',\n  PreviousSelectionMatchFindAction: 'editor.action.previousSelectionMatchFindAction',\n  StartFindReplaceAction: 'editor.action.startFindReplaceAction',\n  CloseFindWidgetCommand: 'closeFindWidget',\n  ToggleCaseSensitiveCommand: 'toggleFindCaseSensitive',\n  ToggleWholeWordCommand: 'toggleFindWholeWord',\n  ToggleRegexCommand: 'toggleFindRegex',\n  ToggleSearchScopeCommand: 'toggleFindInSelection',\n  TogglePreserveCaseCommand: 'togglePreserveCase',\n  ReplaceOneAction: 'editor.action.replaceOne',\n  ReplaceAllAction: 'editor.action.replaceAll',\n  SelectAllMatchesAction: 'editor.action.selectAllMatches'\n};\nexport var MATCHES_LIMIT = 19999;\nvar RESEARCH_DELAY = 240;\n\nvar FindModelBoundToEditorModel =\n/** @class */\nfunction () {\n  function FindModelBoundToEditorModel(editor, state) {\n    var _this = this;\n\n    this._toDispose = new DisposableStore();\n    this._editor = editor;\n    this._state = state;\n    this._isDisposed = false;\n    this._startSearchingTimer = new TimeoutTimer();\n    this._decorations = new FindDecorations(editor);\n\n    this._toDispose.add(this._decorations);\n\n    this._updateDecorationsScheduler = new RunOnceScheduler(function () {\n      return _this.research(false);\n    }, 100);\n\n    this._toDispose.add(this._updateDecorationsScheduler);\n\n    this._toDispose.add(this._editor.onDidChangeCursorPosition(function (e) {\n      if (e.reason === 3\n      /* Explicit */\n      || e.reason === 5\n      /* Undo */\n      || e.reason === 6\n      /* Redo */\n      ) {\n          _this._decorations.setStartPosition(_this._editor.getPosition());\n        }\n    }));\n\n    this._ignoreModelContentChanged = false;\n\n    this._toDispose.add(this._editor.onDidChangeModelContent(function (e) {\n      if (_this._ignoreModelContentChanged) {\n        return;\n      }\n\n      if (e.isFlush) {\n        // a model.setValue() was called\n        _this._decorations.reset();\n      }\n\n      _this._decorations.setStartPosition(_this._editor.getPosition());\n\n      _this._updateDecorationsScheduler.schedule();\n    }));\n\n    this._toDispose.add(this._state.onFindReplaceStateChange(function (e) {\n      return _this._onStateChanged(e);\n    }));\n\n    this.research(false, this._state.searchScope);\n  }\n\n  FindModelBoundToEditorModel.prototype.dispose = function () {\n    this._isDisposed = true;\n    dispose(this._startSearchingTimer);\n\n    this._toDispose.dispose();\n  };\n\n  FindModelBoundToEditorModel.prototype._onStateChanged = function (e) {\n    var _this = this;\n\n    if (this._isDisposed) {\n      // The find model is disposed during a find state changed event\n      return;\n    }\n\n    if (!this._editor.hasModel()) {\n      // The find model will be disposed momentarily\n      return;\n    }\n\n    if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {\n      var model = this._editor.getModel();\n\n      if (model.isTooLargeForSyncing()) {\n        this._startSearchingTimer.cancel();\n\n        this._startSearchingTimer.setIfNotSet(function () {\n          if (e.searchScope) {\n            _this.research(e.moveCursor, _this._state.searchScope);\n          } else {\n            _this.research(e.moveCursor);\n          }\n        }, RESEARCH_DELAY);\n      } else {\n        if (e.searchScope) {\n          this.research(e.moveCursor, this._state.searchScope);\n        } else {\n          this.research(e.moveCursor);\n        }\n      }\n    }\n  };\n\n  FindModelBoundToEditorModel._getSearchRange = function (model, findScope) {\n    // If we have set now or before a find scope, use it for computing the search range\n    if (findScope) {\n      return findScope;\n    }\n\n    return model.getFullModelRange();\n  };\n\n  FindModelBoundToEditorModel.prototype.research = function (moveCursor, newFindScope) {\n    var findScope = null;\n\n    if (typeof newFindScope !== 'undefined') {\n      findScope = newFindScope;\n    } else {\n      findScope = this._decorations.getFindScope();\n    }\n\n    if (findScope !== null) {\n      if (findScope.startLineNumber !== findScope.endLineNumber) {\n        if (findScope.endColumn === 1) {\n          findScope = new Range(findScope.startLineNumber, 1, findScope.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(findScope.endLineNumber - 1));\n        } else {\n          // multiline find scope => expand to line starts / ends\n          findScope = new Range(findScope.startLineNumber, 1, findScope.endLineNumber, this._editor.getModel().getLineMaxColumn(findScope.endLineNumber));\n        }\n      }\n    }\n\n    var findMatches = this._findMatches(findScope, false, MATCHES_LIMIT);\n\n    this._decorations.set(findMatches, findScope);\n\n    this._state.changeMatchInfo(this._decorations.getCurrentMatchesPosition(this._editor.getSelection()), this._decorations.getCount(), undefined);\n\n    if (moveCursor) {\n      this._moveToNextMatch(this._decorations.getStartPosition());\n    }\n  };\n\n  FindModelBoundToEditorModel.prototype._hasMatches = function () {\n    return this._state.matchesCount > 0;\n  };\n\n  FindModelBoundToEditorModel.prototype._cannotFind = function () {\n    if (!this._hasMatches()) {\n      var findScope = this._decorations.getFindScope();\n\n      if (findScope) {\n        // Reveal the selection so user is reminded that 'selection find' is on.\n        this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0\n        /* Smooth */\n        );\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  FindModelBoundToEditorModel.prototype._setCurrentFindMatch = function (match) {\n    var matchesPosition = this._decorations.setCurrentFindMatch(match);\n\n    this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);\n\n    this._editor.setSelection(match);\n\n    this._editor.revealRangeInCenterIfOutsideViewport(match, 0\n    /* Smooth */\n    );\n  };\n\n  FindModelBoundToEditorModel.prototype._prevSearchPosition = function (before) {\n    var isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0 || this._state.searchString.indexOf('$') >= 0);\n    var lineNumber = before.lineNumber,\n        column = before.column;\n\n    var model = this._editor.getModel();\n\n    if (isUsingLineStops || column === 1) {\n      if (lineNumber === 1) {\n        lineNumber = model.getLineCount();\n      } else {\n        lineNumber--;\n      }\n\n      column = model.getLineMaxColumn(lineNumber);\n    } else {\n      column--;\n    }\n\n    return new Position(lineNumber, column);\n  };\n\n  FindModelBoundToEditorModel.prototype._moveToPrevMatch = function (before, isRecursed) {\n    if (isRecursed === void 0) {\n      isRecursed = false;\n    }\n\n    if (this._decorations.getCount() < MATCHES_LIMIT) {\n      var prevMatchRange = this._decorations.matchBeforePosition(before);\n\n      if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {\n        before = this._prevSearchPosition(before);\n        prevMatchRange = this._decorations.matchBeforePosition(before);\n      }\n\n      if (prevMatchRange) {\n        this._setCurrentFindMatch(prevMatchRange);\n      }\n\n      return;\n    }\n\n    if (this._cannotFind()) {\n      return;\n    }\n\n    var findScope = this._decorations.getFindScope();\n\n    var searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope); // ...(----)...|...\n\n\n    if (searchRange.getEndPosition().isBefore(before)) {\n      before = searchRange.getEndPosition();\n    } // ...|...(----)...\n\n\n    if (before.isBefore(searchRange.getStartPosition())) {\n      before = searchRange.getEndPosition();\n    }\n\n    var lineNumber = before.lineNumber,\n        column = before.column;\n\n    var model = this._editor.getModel();\n\n    var position = new Position(lineNumber, column);\n    var prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false);\n\n    if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {\n      // Looks like we're stuck at this position, unacceptable!\n      position = this._prevSearchPosition(position);\n      prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, false);\n    }\n\n    if (!prevMatch) {\n      // there is precisely one match and selection is on top of it\n      return;\n    }\n\n    if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {\n      return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);\n    }\n\n    this._setCurrentFindMatch(prevMatch.range);\n  };\n\n  FindModelBoundToEditorModel.prototype.moveToPrevMatch = function () {\n    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());\n  };\n\n  FindModelBoundToEditorModel.prototype._nextSearchPosition = function (after) {\n    var isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0 || this._state.searchString.indexOf('$') >= 0);\n    var lineNumber = after.lineNumber,\n        column = after.column;\n\n    var model = this._editor.getModel();\n\n    if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {\n      if (lineNumber === model.getLineCount()) {\n        lineNumber = 1;\n      } else {\n        lineNumber++;\n      }\n\n      column = 1;\n    } else {\n      column++;\n    }\n\n    return new Position(lineNumber, column);\n  };\n\n  FindModelBoundToEditorModel.prototype._moveToNextMatch = function (after) {\n    if (this._decorations.getCount() < MATCHES_LIMIT) {\n      var nextMatchRange = this._decorations.matchAfterPosition(after);\n\n      if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {\n        // Looks like we're stuck at this position, unacceptable!\n        after = this._nextSearchPosition(after);\n        nextMatchRange = this._decorations.matchAfterPosition(after);\n      }\n\n      if (nextMatchRange) {\n        this._setCurrentFindMatch(nextMatchRange);\n      }\n\n      return;\n    }\n\n    var nextMatch = this._getNextMatch(after, false, true);\n\n    if (nextMatch) {\n      this._setCurrentFindMatch(nextMatch.range);\n    }\n  };\n\n  FindModelBoundToEditorModel.prototype._getNextMatch = function (after, captureMatches, forceMove, isRecursed) {\n    if (isRecursed === void 0) {\n      isRecursed = false;\n    }\n\n    if (this._cannotFind()) {\n      return null;\n    }\n\n    var findScope = this._decorations.getFindScope();\n\n    var searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope); // ...(----)...|...\n\n\n    if (searchRange.getEndPosition().isBefore(after)) {\n      after = searchRange.getStartPosition();\n    } // ...|...(----)...\n\n\n    if (after.isBefore(searchRange.getStartPosition())) {\n      after = searchRange.getStartPosition();\n    }\n\n    var lineNumber = after.lineNumber,\n        column = after.column;\n\n    var model = this._editor.getModel();\n\n    var position = new Position(lineNumber, column);\n    var nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, captureMatches);\n\n    if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {\n      // Looks like we're stuck at this position, unacceptable!\n      position = this._nextSearchPosition(position);\n      nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, captureMatches);\n    }\n\n    if (!nextMatch) {\n      // there is precisely one match and selection is on top of it\n      return null;\n    }\n\n    if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {\n      return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);\n    }\n\n    return nextMatch;\n  };\n\n  FindModelBoundToEditorModel.prototype.moveToNextMatch = function () {\n    this._moveToNextMatch(this._editor.getSelection().getEndPosition());\n  };\n\n  FindModelBoundToEditorModel.prototype._getReplacePattern = function () {\n    if (this._state.isRegex) {\n      return parseReplaceString(this._state.replaceString);\n    }\n\n    return ReplacePattern.fromStaticValue(this._state.replaceString);\n  };\n\n  FindModelBoundToEditorModel.prototype.replace = function () {\n    if (!this._hasMatches()) {\n      return;\n    }\n\n    var replacePattern = this._getReplacePattern();\n\n    var selection = this._editor.getSelection();\n\n    var nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);\n\n    if (nextMatch) {\n      if (selection.equalsRange(nextMatch.range)) {\n        // selection sits on a find match => replace it!\n        var replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);\n        var command = new ReplaceCommand(selection, replaceString);\n\n        this._executeEditorCommand('replace', command);\n\n        this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));\n\n        this.research(true);\n      } else {\n        this._decorations.setStartPosition(this._editor.getPosition());\n\n        this._setCurrentFindMatch(nextMatch.range);\n      }\n    }\n  };\n\n  FindModelBoundToEditorModel.prototype._findMatches = function (findScope, captureMatches, limitResultCount) {\n    var searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n\n    return this._editor.getModel().findMatches(this._state.searchString, searchRange, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null, captureMatches, limitResultCount);\n  };\n\n  FindModelBoundToEditorModel.prototype.replaceAll = function () {\n    if (!this._hasMatches()) {\n      return;\n    }\n\n    var findScope = this._decorations.getFindScope();\n\n    if (findScope === null && this._state.matchesCount >= MATCHES_LIMIT) {\n      // Doing a replace on the entire file that is over ${MATCHES_LIMIT} matches\n      this._largeReplaceAll();\n    } else {\n      this._regularReplaceAll(findScope);\n    }\n\n    this.research(false);\n  };\n\n  FindModelBoundToEditorModel.prototype._largeReplaceAll = function () {\n    var searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getConfiguration().wordSeparators : null);\n    var searchData = searchParams.parseSearchRequest();\n\n    if (!searchData) {\n      return;\n    }\n\n    var searchRegex = searchData.regex;\n\n    if (!searchRegex.multiline) {\n      var mod = 'm';\n\n      if (searchRegex.ignoreCase) {\n        mod += 'i';\n      }\n\n      if (searchRegex.global) {\n        mod += 'g';\n      }\n\n      searchRegex = new RegExp(searchRegex.source, mod);\n    }\n\n    var model = this._editor.getModel();\n\n    var modelText = model.getValue(1\n    /* LF */\n    );\n    var fullModelRange = model.getFullModelRange();\n\n    var replacePattern = this._getReplacePattern();\n\n    var resultText;\n    var preserveCase = this._state.preserveCase;\n\n    if (replacePattern.hasReplacementPatterns || preserveCase) {\n      resultText = modelText.replace(searchRegex, function () {\n        return replacePattern.buildReplaceString(arguments, preserveCase);\n      });\n    } else {\n      resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));\n    }\n\n    var command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());\n\n    this._executeEditorCommand('replaceAll', command);\n  };\n\n  FindModelBoundToEditorModel.prototype._regularReplaceAll = function (findScope) {\n    var replacePattern = this._getReplacePattern(); // Get all the ranges (even more than the highlighted ones)\n\n\n    var matches = this._findMatches(findScope, replacePattern.hasReplacementPatterns || this._state.preserveCase, 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    );\n\n    var replaceStrings = [];\n\n    for (var i = 0, len = matches.length; i < len; i++) {\n      replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);\n    }\n\n    var command = new ReplaceAllCommand(this._editor.getSelection(), matches.map(function (m) {\n      return m.range;\n    }), replaceStrings);\n\n    this._executeEditorCommand('replaceAll', command);\n  };\n\n  FindModelBoundToEditorModel.prototype.selectAllMatches = function () {\n    if (!this._hasMatches()) {\n      return;\n    }\n\n    var findScope = this._decorations.getFindScope(); // Get all the ranges (even more than the highlighted ones)\n\n\n    var matches = this._findMatches(findScope, false, 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    );\n\n    var selections = matches.map(function (m) {\n      return new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn);\n    }); // If one of the ranges is the editor selection, then maintain it as primary\n\n    var editorSelection = this._editor.getSelection();\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var sel = selections[i];\n\n      if (sel.equalsRange(editorSelection)) {\n        selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));\n        break;\n      }\n    }\n\n    this._editor.setSelections(selections);\n  };\n\n  FindModelBoundToEditorModel.prototype._executeEditorCommand = function (source, command) {\n    try {\n      this._ignoreModelContentChanged = true;\n\n      this._editor.pushUndoStop();\n\n      this._editor.executeCommand(source, command);\n\n      this._editor.pushUndoStop();\n    } finally {\n      this._ignoreModelContentChanged = false;\n    }\n  };\n\n  return FindModelBoundToEditorModel;\n}();\n\nexport { FindModelBoundToEditorModel };","map":null,"metadata":{},"sourceType":"module"}