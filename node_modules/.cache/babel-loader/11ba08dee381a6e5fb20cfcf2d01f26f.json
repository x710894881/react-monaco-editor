{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, TokenizationResult2 } from '../../../common/core/token.js';\nimport * as modes from '../../../common/modes.js';\nimport { NULL_MODE_ID, NULL_STATE } from '../../../common/modes/nullMode.js';\nimport * as monarchCommon from './monarchCommon.js';\nvar CACHE_STACK_DEPTH = 5;\n/**\n * Reuse the same stack elements up to a certain depth.\n */\n\nvar MonarchStackElementFactory =\n/** @class */\nfunction () {\n  function MonarchStackElementFactory(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n\n  MonarchStackElementFactory.create = function (parent, state) {\n    return this._INSTANCE.create(parent, state);\n  };\n\n  MonarchStackElementFactory.prototype.create = function (parent, state) {\n    if (parent !== null && parent.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchStackElement(parent, state);\n    }\n\n    var stackElementId = MonarchStackElement.getStackElementId(parent);\n\n    if (stackElementId.length > 0) {\n      stackElementId += '|';\n    }\n\n    stackElementId += state;\n    var result = this._entries[stackElementId];\n\n    if (result) {\n      return result;\n    }\n\n    result = new MonarchStackElement(parent, state);\n    this._entries[stackElementId] = result;\n    return result;\n  };\n\n  MonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\n  return MonarchStackElementFactory;\n}();\n\nvar MonarchStackElement =\n/** @class */\nfunction () {\n  function MonarchStackElement(parent, state) {\n    this.parent = parent;\n    this.state = state;\n    this.depth = (this.parent ? this.parent.depth : 0) + 1;\n  }\n\n  MonarchStackElement.getStackElementId = function (element) {\n    var result = '';\n\n    while (element !== null) {\n      if (result.length > 0) {\n        result += '|';\n      }\n\n      result += element.state;\n      element = element.parent;\n    }\n\n    return result;\n  };\n\n  MonarchStackElement._equals = function (a, b) {\n    while (a !== null && b !== null) {\n      if (a === b) {\n        return true;\n      }\n\n      if (a.state !== b.state) {\n        return false;\n      }\n\n      a = a.parent;\n      b = b.parent;\n    }\n\n    if (a === null && b === null) {\n      return true;\n    }\n\n    return false;\n  };\n\n  MonarchStackElement.prototype.equals = function (other) {\n    return MonarchStackElement._equals(this, other);\n  };\n\n  MonarchStackElement.prototype.push = function (state) {\n    return MonarchStackElementFactory.create(this, state);\n  };\n\n  MonarchStackElement.prototype.pop = function () {\n    return this.parent;\n  };\n\n  MonarchStackElement.prototype.popall = function () {\n    var result = this;\n\n    while (result.parent) {\n      result = result.parent;\n    }\n\n    return result;\n  };\n\n  MonarchStackElement.prototype.switchTo = function (state) {\n    return MonarchStackElementFactory.create(this.parent, state);\n  };\n\n  return MonarchStackElement;\n}();\n\nvar EmbeddedModeData =\n/** @class */\nfunction () {\n  function EmbeddedModeData(modeId, state) {\n    this.modeId = modeId;\n    this.state = state;\n  }\n\n  EmbeddedModeData.prototype.equals = function (other) {\n    return this.modeId === other.modeId && this.state.equals(other.state);\n  };\n\n  EmbeddedModeData.prototype.clone = function () {\n    var stateClone = this.state.clone(); // save an object\n\n    if (stateClone === this.state) {\n      return this;\n    }\n\n    return new EmbeddedModeData(this.modeId, this.state);\n  };\n\n  return EmbeddedModeData;\n}();\n/**\n * Reuse the same line states up to a certain depth.\n */\n\n\nvar MonarchLineStateFactory =\n/** @class */\nfunction () {\n  function MonarchLineStateFactory(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n\n  MonarchLineStateFactory.create = function (stack, embeddedModeData) {\n    return this._INSTANCE.create(stack, embeddedModeData);\n  };\n\n  MonarchLineStateFactory.prototype.create = function (stack, embeddedModeData) {\n    if (embeddedModeData !== null) {\n      // no caching when embedding\n      return new MonarchLineState(stack, embeddedModeData);\n    }\n\n    if (stack !== null && stack.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchLineState(stack, embeddedModeData);\n    }\n\n    var stackElementId = MonarchStackElement.getStackElementId(stack);\n    var result = this._entries[stackElementId];\n\n    if (result) {\n      return result;\n    }\n\n    result = new MonarchLineState(stack, null);\n    this._entries[stackElementId] = result;\n    return result;\n  };\n\n  MonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\n  return MonarchLineStateFactory;\n}();\n\nvar MonarchLineState =\n/** @class */\nfunction () {\n  function MonarchLineState(stack, embeddedModeData) {\n    this.stack = stack;\n    this.embeddedModeData = embeddedModeData;\n  }\n\n  MonarchLineState.prototype.clone = function () {\n    var embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null; // save an object\n\n    if (embeddedModeDataClone === this.embeddedModeData) {\n      return this;\n    }\n\n    return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);\n  };\n\n  MonarchLineState.prototype.equals = function (other) {\n    if (!(other instanceof MonarchLineState)) {\n      return false;\n    }\n\n    if (!this.stack.equals(other.stack)) {\n      return false;\n    }\n\n    if (this.embeddedModeData === null && other.embeddedModeData === null) {\n      return true;\n    }\n\n    if (this.embeddedModeData === null || other.embeddedModeData === null) {\n      return false;\n    }\n\n    return this.embeddedModeData.equals(other.embeddedModeData);\n  };\n\n  return MonarchLineState;\n}();\n\nvar MonarchClassicTokensCollector =\n/** @class */\nfunction () {\n  function MonarchClassicTokensCollector() {\n    this._tokens = [];\n    this._language = null;\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n  }\n\n  MonarchClassicTokensCollector.prototype.enterMode = function (startOffset, modeId) {\n    this._language = modeId;\n  };\n\n  MonarchClassicTokensCollector.prototype.emit = function (startOffset, type) {\n    if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {\n      return;\n    }\n\n    this._lastTokenType = type;\n    this._lastTokenLanguage = this._language;\n\n    this._tokens.push(new Token(startOffset, type, this._language));\n  };\n\n  MonarchClassicTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {\n    var nestedModeId = embeddedModeData.modeId;\n    var embeddedModeState = embeddedModeData.state;\n    var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n    if (!nestedModeTokenizationSupport) {\n      this.enterMode(offsetDelta, nestedModeId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n\n    var nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, embeddedModeState, offsetDelta);\n    this._tokens = this._tokens.concat(nestedResult.tokens);\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n    this._language = null;\n    return nestedResult.endState;\n  };\n\n  MonarchClassicTokensCollector.prototype.finalize = function (endState) {\n    return new TokenizationResult(this._tokens, endState);\n  };\n\n  return MonarchClassicTokensCollector;\n}();\n\nvar MonarchModernTokensCollector =\n/** @class */\nfunction () {\n  function MonarchModernTokensCollector(modeService, theme) {\n    this._modeService = modeService;\n    this._theme = theme;\n    this._prependTokens = null;\n    this._tokens = [];\n    this._currentLanguageId = 0\n    /* Null */\n    ;\n    this._lastTokenMetadata = 0;\n  }\n\n  MonarchModernTokensCollector.prototype.enterMode = function (startOffset, modeId) {\n    this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;\n  };\n\n  MonarchModernTokensCollector.prototype.emit = function (startOffset, type) {\n    var metadata = this._theme.match(this._currentLanguageId, type);\n\n    if (this._lastTokenMetadata === metadata) {\n      return;\n    }\n\n    this._lastTokenMetadata = metadata;\n\n    this._tokens.push(startOffset);\n\n    this._tokens.push(metadata);\n  };\n\n  MonarchModernTokensCollector._merge = function (a, b, c) {\n    var aLen = a !== null ? a.length : 0;\n    var bLen = b.length;\n    var cLen = c !== null ? c.length : 0;\n\n    if (aLen === 0 && bLen === 0 && cLen === 0) {\n      return new Uint32Array(0);\n    }\n\n    if (aLen === 0 && bLen === 0) {\n      return c;\n    }\n\n    if (bLen === 0 && cLen === 0) {\n      return a;\n    }\n\n    var result = new Uint32Array(aLen + bLen + cLen);\n\n    if (a !== null) {\n      result.set(a);\n    }\n\n    for (var i = 0; i < bLen; i++) {\n      result[aLen + i] = b[i];\n    }\n\n    if (c !== null) {\n      result.set(c, aLen + bLen);\n    }\n\n    return result;\n  };\n\n  MonarchModernTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {\n    var nestedModeId = embeddedModeData.modeId;\n    var embeddedModeState = embeddedModeData.state;\n    var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n    if (!nestedModeTokenizationSupport) {\n      this.enterMode(offsetDelta, nestedModeId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n\n    var nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, embeddedModeState, offsetDelta);\n    this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n    this._tokens = [];\n    this._currentLanguageId = 0;\n    this._lastTokenMetadata = 0;\n    return nestedResult.endState;\n  };\n\n  MonarchModernTokensCollector.prototype.finalize = function (endState) {\n    return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n  };\n\n  return MonarchModernTokensCollector;\n}();\n\nvar MonarchTokenizer =\n/** @class */\nfunction () {\n  function MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer) {\n    var _this = this;\n\n    this._modeService = modeService;\n    this._standaloneThemeService = standaloneThemeService;\n    this._modeId = modeId;\n    this._lexer = lexer;\n    this._embeddedModes = Object.create(null);\n    this.embeddedLoaded = Promise.resolve(undefined); // Set up listening for embedded modes\n\n    var emitting = false;\n    this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange(function (e) {\n      if (emitting) {\n        return;\n      }\n\n      var isOneOfMyEmbeddedModes = false;\n\n      for (var i = 0, len = e.changedLanguages.length; i < len; i++) {\n        var language = e.changedLanguages[i];\n\n        if (_this._embeddedModes[language]) {\n          isOneOfMyEmbeddedModes = true;\n          break;\n        }\n      }\n\n      if (isOneOfMyEmbeddedModes) {\n        emitting = true;\n        modes.TokenizationRegistry.fire([_this._modeId]);\n        emitting = false;\n      }\n    });\n  }\n\n  MonarchTokenizer.prototype.dispose = function () {\n    this._tokenizationRegistryListener.dispose();\n  };\n\n  MonarchTokenizer.prototype.getLoadStatus = function () {\n    var promises = [];\n\n    for (var nestedModeId in this._embeddedModes) {\n      if (this._embeddedModes.hasOwnProperty(nestedModeId)) {\n        var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n        if (tokenizationSupport) {\n          // The nested mode is already loaded\n          if (tokenizationSupport instanceof MonarchTokenizer) {\n            var nestedModeStatus = tokenizationSupport.getLoadStatus();\n\n            if (nestedModeStatus.loaded === false) {\n              promises.push(nestedModeStatus.promise);\n            }\n          }\n\n          continue;\n        }\n\n        var tokenizationSupportPromise = modes.TokenizationRegistry.getPromise(nestedModeId);\n\n        if (tokenizationSupportPromise) {\n          // The nested mode is in the process of being loaded\n          promises.push(tokenizationSupportPromise);\n        }\n      }\n    }\n\n    if (promises.length === 0) {\n      return {\n        loaded: true\n      };\n    }\n\n    return {\n      loaded: false,\n      promise: Promise.all(promises).then(function (_) {\n        return undefined;\n      })\n    };\n  };\n\n  MonarchTokenizer.prototype.getInitialState = function () {\n    var rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n    return MonarchLineStateFactory.create(rootState, null);\n  };\n\n  MonarchTokenizer.prototype.tokenize = function (line, lineState, offsetDelta) {\n    var tokensCollector = new MonarchClassicTokensCollector();\n\n    var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);\n\n    return tokensCollector.finalize(endLineState);\n  };\n\n  MonarchTokenizer.prototype.tokenize2 = function (line, lineState, offsetDelta) {\n    var tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getTheme().tokenTheme);\n\n    var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);\n\n    return tokensCollector.finalize(endLineState);\n  };\n\n  MonarchTokenizer.prototype._tokenize = function (line, lineState, offsetDelta, collector) {\n    if (lineState.embeddedModeData) {\n      return this._nestedTokenize(line, lineState, offsetDelta, collector);\n    } else {\n      return this._myTokenize(line, lineState, offsetDelta, collector);\n    }\n  };\n\n  MonarchTokenizer.prototype._findLeavingNestedModeOffset = function (line, state) {\n    var rules = this._lexer.tokenizer[state.stack.state];\n\n    if (!rules) {\n      rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n\n      if (!rules) {\n        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n      }\n    }\n\n    var popOffset = -1;\n    var hasEmbeddedPopRule = false;\n\n    for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {\n      var rule = rules_1[_i];\n\n      if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n        continue;\n      }\n\n      hasEmbeddedPopRule = true;\n      var regex = rule.regex;\n      var regexSource = rule.regex.source;\n\n      if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n        regex = new RegExp(regexSource.substr(4, regexSource.length - 5), regex.ignoreCase ? 'i' : '');\n      }\n\n      var result = line.search(regex);\n\n      if (result === -1) {\n        continue;\n      }\n\n      if (popOffset === -1 || result < popOffset) {\n        popOffset = result;\n      }\n    }\n\n    if (!hasEmbeddedPopRule) {\n      throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n    }\n\n    return popOffset;\n  };\n\n  MonarchTokenizer.prototype._nestedTokenize = function (line, lineState, offsetDelta, tokensCollector) {\n    var popOffset = this._findLeavingNestedModeOffset(line, lineState);\n\n    if (popOffset === -1) {\n      // tokenization will not leave nested mode\n      var nestedEndState = tokensCollector.nestedModeTokenize(line, lineState.embeddedModeData, offsetDelta);\n      return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));\n    }\n\n    var nestedModeLine = line.substring(0, popOffset);\n\n    if (nestedModeLine.length > 0) {\n      // tokenize with the nested mode\n      tokensCollector.nestedModeTokenize(nestedModeLine, lineState.embeddedModeData, offsetDelta);\n    }\n\n    var restOfTheLine = line.substring(popOffset);\n    return this._myTokenize(restOfTheLine, lineState, offsetDelta + popOffset, tokensCollector);\n  };\n\n  MonarchTokenizer.prototype._safeRuleName = function (rule) {\n    if (rule) {\n      return rule.name;\n    }\n\n    return '(unknown)';\n  };\n\n  MonarchTokenizer.prototype._myTokenize = function (line, lineState, offsetDelta, tokensCollector) {\n    tokensCollector.enterMode(offsetDelta, this._modeId);\n    var lineLength = line.length;\n    var embeddedModeData = lineState.embeddedModeData;\n    var stack = lineState.stack;\n    var pos = 0;\n    var groupMatching = null; // See https://github.com/Microsoft/monaco-editor/issues/1235:\n    // Evaluate rules at least once for an empty line\n\n    var forceEvaluation = true;\n\n    while (forceEvaluation || pos < lineLength) {\n      var pos0 = pos;\n      var stackLen0 = stack.depth;\n      var groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n      var state = stack.state;\n      var matches = null;\n      var matched = null;\n      var action = null;\n      var rule = null;\n      var enteringEmbeddedMode = null; // check if we need to process group matches first\n\n      if (groupMatching) {\n        matches = groupMatching.matches;\n        var groupEntry = groupMatching.groups.shift();\n        matched = groupEntry.matched;\n        action = groupEntry.action;\n        rule = groupMatching.rule; // cleanup if necessary\n\n        if (groupMatching.groups.length === 0) {\n          groupMatching = null;\n        }\n      } else {\n        // otherwise we match on the token stream\n        if (!forceEvaluation && pos >= lineLength) {\n          // nothing to do\n          break;\n        }\n\n        forceEvaluation = false; // get the rules for this state\n\n        var rules = this._lexer.tokenizer[state];\n\n        if (!rules) {\n          rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n\n          if (!rules) {\n            throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n          }\n        } // try each rule until we match\n\n\n        var restOfLine = line.substr(pos);\n\n        for (var _i = 0, rules_2 = rules; _i < rules_2.length; _i++) {\n          var rule_1 = rules_2[_i];\n\n          if (pos === 0 || !rule_1.matchOnlyAtLineStart) {\n            matches = restOfLine.match(rule_1.regex);\n\n            if (matches) {\n              matched = matches[0];\n              action = rule_1.action;\n              break;\n            }\n          }\n        }\n      } // We matched 'rule' with 'matches' and 'action'\n\n\n      if (!matches) {\n        matches = [''];\n        matched = '';\n      }\n\n      if (!action) {\n        // bad: we didn't match anything, and there is no action to take\n        // we need to advance the stream or we get progress trouble\n        if (pos < lineLength) {\n          matches = [line.charAt(pos)];\n          matched = matches[0];\n        }\n\n        action = this._lexer.defaultToken;\n      }\n\n      if (matched === null) {\n        // should never happen, needed for strict null checking\n        break;\n      } // advance stream\n\n\n      pos += matched.length; // maybe call action function (used for 'cases')\n\n      while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n        action = action.test(matched, matches, state, pos === lineLength);\n      }\n\n      var result = null; // set the result: either a string or an array of actions\n\n      if (typeof action === 'string' || Array.isArray(action)) {\n        result = action;\n      } else if (action.group) {\n        result = action.group;\n      } else if (action.token !== null && action.token !== undefined) {\n        // do $n replacements?\n        if (action.tokenSubst) {\n          result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n        } else {\n          result = action.token;\n        } // enter embedded mode?\n\n\n        if (action.nextEmbedded) {\n          if (action.nextEmbedded === '@pop') {\n            if (!embeddedModeData) {\n              throw monarchCommon.createError(this._lexer, 'cannot pop embedded mode if not inside one');\n            }\n\n            embeddedModeData = null;\n          } else if (embeddedModeData) {\n            throw monarchCommon.createError(this._lexer, 'cannot enter embedded mode from within an embedded mode');\n          } else {\n            enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n          }\n        } // state transformations\n\n\n        if (action.goBack) {\n          // back up the stream..\n          pos = Math.max(0, pos - action.goBack);\n        }\n\n        if (action.switchTo && typeof action.switchTo === 'string') {\n          var nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n\n          if (nextState[0] === '@') {\n            nextState = nextState.substr(1); // peel off starting '@'\n          }\n\n          if (!monarchCommon.findRules(this._lexer, nextState)) {\n            throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n          } else {\n            stack = stack.switchTo(nextState);\n          }\n        } else if (action.transform && typeof action.transform === 'function') {\n          throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n        } else if (action.next) {\n          if (action.next === '@push') {\n            if (stack.depth >= this._lexer.maxStack) {\n              throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' + stack.state + ',' + stack.parent.state + ',...]');\n            } else {\n              stack = stack.push(state);\n            }\n          } else if (action.next === '@pop') {\n            if (stack.depth <= 1) {\n              throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.pop();\n            }\n          } else if (action.next === '@popall') {\n            stack = stack.popall();\n          } else {\n            var nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n\n            if (nextState[0] === '@') {\n              nextState = nextState.substr(1); // peel off starting '@'\n            }\n\n            if (!monarchCommon.findRules(this._lexer, nextState)) {\n              throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.push(nextState);\n            }\n          }\n        }\n\n        if (action.log && typeof action.log === 'string') {\n          monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n        }\n      } // check result\n\n\n      if (result === null) {\n        throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n      } // is the result a group match?\n\n\n      if (Array.isArray(result)) {\n        if (groupMatching && groupMatching.groups.length > 0) {\n          throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n        }\n\n        if (matches.length !== result.length + 1) {\n          throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n        }\n\n        var totalLen = 0;\n\n        for (var i = 1; i < matches.length; i++) {\n          totalLen += matches[i].length;\n        }\n\n        if (totalLen !== matched.length) {\n          throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n        }\n\n        groupMatching = {\n          rule: rule,\n          matches: matches,\n          groups: []\n        };\n\n        for (var i = 0; i < result.length; i++) {\n          groupMatching.groups[i] = {\n            action: result[i],\n            matched: matches[i + 1]\n          };\n        }\n\n        pos -= matched.length; // call recursively to initiate first result match\n\n        continue;\n      } else {\n        // regular result\n        // check for '@rematch'\n        if (result === '@rematch') {\n          pos -= matched.length;\n          matched = ''; // better set the next state too..\n\n          matches = null;\n          result = '';\n        } // check progress\n\n\n        if (matched.length === 0) {\n          if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n            continue;\n          } else {\n            throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n          }\n        } // return the result (and check for brace matching)\n        // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n\n\n        var tokenType = null;\n\n        if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n          var rest = result.substr('@brackets'.length);\n          var bracket = findBracket(this._lexer, matched);\n\n          if (!bracket) {\n            throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n          }\n\n          tokenType = monarchCommon.sanitize(bracket.token + rest);\n        } else {\n          var token = result === '' ? '' : result + this._lexer.tokenPostfix;\n          tokenType = monarchCommon.sanitize(token);\n        }\n\n        tokensCollector.emit(pos0 + offsetDelta, tokenType);\n      }\n\n      if (enteringEmbeddedMode !== null) {\n        // substitute language alias to known modes to support syntax highlighting\n        var enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);\n\n        if (enteringEmbeddedModeId) {\n          enteringEmbeddedMode = enteringEmbeddedModeId;\n        }\n\n        var embeddedModeData_1 = this._getNestedEmbeddedModeData(enteringEmbeddedMode);\n\n        if (pos < lineLength) {\n          // there is content from the embedded mode on this line\n          var restOfLine = line.substr(pos);\n          return this._nestedTokenize(restOfLine, MonarchLineStateFactory.create(stack, embeddedModeData_1), offsetDelta + pos, tokensCollector);\n        } else {\n          return MonarchLineStateFactory.create(stack, embeddedModeData_1);\n        }\n      }\n    }\n\n    return MonarchLineStateFactory.create(stack, embeddedModeData);\n  };\n\n  MonarchTokenizer.prototype._getNestedEmbeddedModeData = function (mimetypeOrModeId) {\n    var nestedModeId = this._locateMode(mimetypeOrModeId);\n\n    if (nestedModeId) {\n      var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n      if (tokenizationSupport) {\n        return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());\n      }\n    }\n\n    return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);\n  };\n\n  MonarchTokenizer.prototype._locateMode = function (mimetypeOrModeId) {\n    if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {\n      return null;\n    }\n\n    if (mimetypeOrModeId === this._modeId) {\n      // embedding myself...\n      return mimetypeOrModeId;\n    }\n\n    var modeId = this._modeService.getModeId(mimetypeOrModeId);\n\n    if (modeId) {\n      // Fire mode loading event\n      this._modeService.triggerMode(modeId);\n\n      this._embeddedModes[modeId] = true;\n    }\n\n    return modeId;\n  };\n\n  return MonarchTokenizer;\n}();\n\nexport { MonarchTokenizer };\n/**\n * Searches for a bracket in the 'brackets' attribute that matches the input.\n */\n\nfunction findBracket(lexer, matched) {\n  if (!matched) {\n    return null;\n  }\n\n  matched = monarchCommon.fixCase(lexer, matched);\n  var brackets = lexer.brackets;\n\n  for (var _i = 0, brackets_1 = brackets; _i < brackets_1.length; _i++) {\n    var bracket = brackets_1[_i];\n\n    if (bracket.open === matched) {\n      return {\n        token: bracket.token,\n        bracketType: 1\n        /* Open */\n\n      };\n    } else if (bracket.close === matched) {\n      return {\n        token: bracket.token,\n        bracketType: -1\n        /* Close */\n\n      };\n    }\n  }\n\n  return null;\n}\n\nexport function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {\n  return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);\n}","map":null,"metadata":{},"sourceType":"module"}