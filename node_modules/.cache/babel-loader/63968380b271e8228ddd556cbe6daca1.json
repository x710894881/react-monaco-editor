{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../controller/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch } from '../model.js';\nvar LIMIT_FIND_COUNT = 999;\n\nvar SearchParams =\n/** @class */\nfunction () {\n  function SearchParams(searchString, isRegex, matchCase, wordSeparators) {\n    this.searchString = searchString;\n    this.isRegex = isRegex;\n    this.matchCase = matchCase;\n    this.wordSeparators = wordSeparators;\n  }\n\n  SearchParams.prototype.parseSearchRequest = function () {\n    if (this.searchString === '') {\n      return null;\n    } // Try to create a RegExp out of the params\n\n\n    var multiline;\n\n    if (this.isRegex) {\n      multiline = isMultilineRegexSource(this.searchString);\n    } else {\n      multiline = this.searchString.indexOf('\\n') >= 0;\n    }\n\n    var regex = null;\n\n    try {\n      regex = strings.createRegExp(this.searchString, this.isRegex, {\n        matchCase: this.matchCase,\n        wholeWord: false,\n        multiline: multiline,\n        global: true\n      });\n    } catch (err) {\n      return null;\n    }\n\n    if (!regex) {\n      return null;\n    }\n\n    var canUseSimpleSearch = !this.isRegex && !multiline;\n\n    if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n      // casing might make a difference\n      canUseSimpleSearch = this.matchCase;\n    }\n\n    return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n  };\n\n  return SearchParams;\n}();\n\nexport { SearchParams };\nexport function isMultilineRegexSource(searchString) {\n  if (!searchString || searchString.length === 0) {\n    return false;\n  }\n\n  for (var i = 0, len = searchString.length; i < len; i++) {\n    var chCode = searchString.charCodeAt(i);\n\n    if (chCode === 92\n    /* Backslash */\n    ) {\n        // move to next char\n        i++;\n\n        if (i >= len) {\n          // string ends with a \\\n          break;\n        }\n\n        var nextChCode = searchString.charCodeAt(i);\n\n        if (nextChCode === 110\n        /* n */\n        || nextChCode === 114\n        /* r */\n        || nextChCode === 87\n        /* W */\n        ) {\n            return true;\n          }\n      }\n  }\n\n  return false;\n}\n\nvar SearchData =\n/** @class */\nfunction () {\n  function SearchData(regex, wordSeparators, simpleSearch) {\n    this.regex = regex;\n    this.wordSeparators = wordSeparators;\n    this.simpleSearch = simpleSearch;\n  }\n\n  return SearchData;\n}();\n\nexport { SearchData };\nexport function createFindMatch(range, rawMatches, captureMatches) {\n  if (!captureMatches) {\n    return new FindMatch(range, null);\n  }\n\n  var matches = [];\n\n  for (var i = 0, len = rawMatches.length; i < len; i++) {\n    matches[i] = rawMatches[i];\n  }\n\n  return new FindMatch(range, matches);\n}\n\nvar LineFeedCounter =\n/** @class */\nfunction () {\n  function LineFeedCounter(text) {\n    var lineFeedsOffsets = [];\n    var lineFeedsOffsetsLen = 0;\n\n    for (var i = 0, textLen = text.length; i < textLen; i++) {\n      if (text.charCodeAt(i) === 10\n      /* LineFeed */\n      ) {\n          lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n        }\n    }\n\n    this._lineFeedsOffsets = lineFeedsOffsets;\n  }\n\n  LineFeedCounter.prototype.findLineFeedCountBeforeOffset = function (offset) {\n    var lineFeedsOffsets = this._lineFeedsOffsets;\n    var min = 0;\n    var max = lineFeedsOffsets.length - 1;\n\n    if (max === -1) {\n      // no line feeds\n      return 0;\n    }\n\n    if (offset <= lineFeedsOffsets[0]) {\n      // before first line feed\n      return 0;\n    }\n\n    while (min < max) {\n      var mid = min + ((max - min) / 2 >> 0);\n\n      if (lineFeedsOffsets[mid] >= offset) {\n        max = mid - 1;\n      } else {\n        if (lineFeedsOffsets[mid + 1] >= offset) {\n          // bingo!\n          min = mid;\n          max = mid;\n        } else {\n          min = mid + 1;\n        }\n      }\n    }\n\n    return min + 1;\n  };\n\n  return LineFeedCounter;\n}();\n\nvar TextModelSearch =\n/** @class */\nfunction () {\n  function TextModelSearch() {}\n\n  TextModelSearch.findMatches = function (model, searchParams, searchRange, captureMatches, limitResultCount) {\n    var searchData = searchParams.parseSearchRequest();\n\n    if (!searchData) {\n      return [];\n    }\n\n    if (searchData.regex.multiline) {\n      return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n    }\n\n    return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n  };\n  /**\n   * Multiline search always executes on the lines concatenated with \\n.\n   * We must therefore compensate for the count of \\n in case the model is CRLF\n   */\n\n\n  TextModelSearch._getMultilineMatchRange = function (model, deltaOffset, text, lfCounter, matchIndex, match0) {\n    var startOffset;\n    var lineFeedCountBeforeMatch = 0;\n\n    if (lfCounter) {\n      lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n      startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch\n      /* add as many \\r as there were \\n */\n      ;\n    } else {\n      startOffset = deltaOffset + matchIndex;\n    }\n\n    var endOffset;\n\n    if (lfCounter) {\n      var lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n      var lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n      endOffset = startOffset + match0.length + lineFeedCountInMatch\n      /* add as many \\r as there were \\n */\n      ;\n    } else {\n      endOffset = startOffset + match0.length;\n    }\n\n    var startPosition = model.getPositionAt(startOffset);\n    var endPosition = model.getPositionAt(endOffset);\n    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n  };\n\n  TextModelSearch._doFindMatchesMultiline = function (model, searchRange, searcher, captureMatches, limitResultCount) {\n    var deltaOffset = model.getOffsetAt(searchRange.getStartPosition()); // We always execute multiline search over the lines joined with \\n\n    // This makes it that \\n will match the EOL for both CRLF and LF models\n    // We compensate for offset errors in `_getMultilineMatchRange`\n\n    var text = model.getValueInRange(searchRange, 1\n    /* LF */\n    );\n    var lfCounter = model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null;\n    var result = [];\n    var counter = 0;\n    var m;\n    searcher.reset(0);\n\n    while (m = searcher.next(text)) {\n      result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n\n      if (counter >= limitResultCount) {\n        return result;\n      }\n    }\n\n    return result;\n  };\n\n  TextModelSearch._doFindMatchesLineByLine = function (model, searchRange, searchData, captureMatches, limitResultCount) {\n    var result = [];\n    var resultLen = 0; // Early case for a search range that starts & stops on the same line number\n\n    if (searchRange.startLineNumber === searchRange.endLineNumber) {\n      var text_1 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, text_1, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n      return result;\n    } // Collect results from first line\n\n\n    var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n    resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount); // Collect results from middle lines\n\n    for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n      resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n    } // Collect results from last line\n\n\n    if (resultLen < limitResultCount) {\n      var text_2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, text_2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n    }\n\n    return result;\n  };\n\n  TextModelSearch._findMatchesInLine = function (searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n    var wordSeparators = searchData.wordSeparators;\n\n    if (!captureMatches && searchData.simpleSearch) {\n      var searchString = searchData.simpleSearch;\n      var searchStringLen = searchString.length;\n      var textLength = text.length;\n      var lastMatchIndex = -searchStringLen;\n\n      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n        if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      }\n\n      return resultLen;\n    }\n\n    var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n    var m; // Reset regex to search from the beginning\n\n    searcher.reset(0);\n\n    do {\n      m = searcher.next(text);\n\n      if (m) {\n        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\n        if (resultLen >= limitResultCount) {\n          return resultLen;\n        }\n      }\n    } while (m);\n\n    return resultLen;\n  };\n\n  TextModelSearch.findNextMatch = function (model, searchParams, searchStart, captureMatches) {\n    var searchData = searchParams.parseSearchRequest();\n\n    if (!searchData) {\n      return null;\n    }\n\n    var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n    if (searchData.regex.multiline) {\n      return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n    }\n\n    return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n  };\n\n  TextModelSearch._doFindNextMatchMultiline = function (model, searchStart, searcher, captureMatches) {\n    var searchTextStart = new Position(searchStart.lineNumber, 1);\n    var deltaOffset = model.getOffsetAt(searchTextStart);\n    var lineCount = model.getLineCount(); // We always execute multiline search over the lines joined with \\n\n    // This makes it that \\n will match the EOL for both CRLF and LF models\n    // We compensate for offset errors in `_getMultilineMatchRange`\n\n    var text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1\n    /* LF */\n    );\n    var lfCounter = model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null;\n    searcher.reset(searchStart.column - 1);\n    var m = searcher.next(text);\n\n    if (m) {\n      return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n    }\n\n    if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n      // Try again from the top\n      return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n    }\n\n    return null;\n  };\n\n  TextModelSearch._doFindNextMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\n    var lineCount = model.getLineCount();\n    var startLineNumber = searchStart.lineNumber; // Look in first line\n\n    var text = model.getLineContent(startLineNumber);\n\n    var r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n\n    if (r) {\n      return r;\n    }\n\n    for (var i = 1; i <= lineCount; i++) {\n      var lineIndex = (startLineNumber + i - 1) % lineCount;\n      var text_3 = model.getLineContent(lineIndex + 1);\n\n      var r_1 = this._findFirstMatchInLine(searcher, text_3, lineIndex + 1, 1, captureMatches);\n\n      if (r_1) {\n        return r_1;\n      }\n    }\n\n    return null;\n  };\n\n  TextModelSearch._findFirstMatchInLine = function (searcher, text, lineNumber, fromColumn, captureMatches) {\n    // Set regex to search from column\n    searcher.reset(fromColumn - 1);\n    var m = searcher.next(text);\n\n    if (m) {\n      return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n    }\n\n    return null;\n  };\n\n  TextModelSearch.findPreviousMatch = function (model, searchParams, searchStart, captureMatches) {\n    var searchData = searchParams.parseSearchRequest();\n\n    if (!searchData) {\n      return null;\n    }\n\n    var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n    if (searchData.regex.multiline) {\n      return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n    }\n\n    return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n  };\n\n  TextModelSearch._doFindPreviousMatchMultiline = function (model, searchStart, searcher, captureMatches) {\n    var matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n\n    if (matches.length > 0) {\n      return matches[matches.length - 1];\n    }\n\n    var lineCount = model.getLineCount();\n\n    if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n      // Try again with all content\n      return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n    }\n\n    return null;\n  };\n\n  TextModelSearch._doFindPreviousMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\n    var lineCount = model.getLineCount();\n    var startLineNumber = searchStart.lineNumber; // Look in first line\n\n    var text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n\n    var r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n\n    if (r) {\n      return r;\n    }\n\n    for (var i = 1; i <= lineCount; i++) {\n      var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n      var text_4 = model.getLineContent(lineIndex + 1);\n\n      var r_2 = this._findLastMatchInLine(searcher, text_4, lineIndex + 1, captureMatches);\n\n      if (r_2) {\n        return r_2;\n      }\n    }\n\n    return null;\n  };\n\n  TextModelSearch._findLastMatchInLine = function (searcher, text, lineNumber, captureMatches) {\n    var bestResult = null;\n    var m;\n    searcher.reset(0);\n\n    while (m = searcher.next(text)) {\n      bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n    }\n\n    return bestResult;\n  };\n\n  return TextModelSearch;\n}();\n\nexport { TextModelSearch };\n\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex === 0) {\n    // Match starts at start of string\n    return true;\n  }\n\n  var charBefore = text.charCodeAt(matchStartIndex - 1);\n\n  if (wordSeparators.get(charBefore) !== 0\n  /* Regular */\n  ) {\n      // The character before the match is a word separator\n      return true;\n    }\n\n  if (charBefore === 13\n  /* CarriageReturn */\n  || charBefore === 10\n  /* LineFeed */\n  ) {\n      // The character before the match is line break or carriage return.\n      return true;\n    }\n\n  if (matchLength > 0) {\n    var firstCharInMatch = text.charCodeAt(matchStartIndex);\n\n    if (wordSeparators.get(firstCharInMatch) !== 0\n    /* Regular */\n    ) {\n        // The first character inside the match is a word separator\n        return true;\n      }\n  }\n\n  return false;\n}\n\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex + matchLength === textLength) {\n    // Match ends at end of string\n    return true;\n  }\n\n  var charAfter = text.charCodeAt(matchStartIndex + matchLength);\n\n  if (wordSeparators.get(charAfter) !== 0\n  /* Regular */\n  ) {\n      // The character after the match is a word separator\n      return true;\n    }\n\n  if (charAfter === 13\n  /* CarriageReturn */\n  || charAfter === 10\n  /* LineFeed */\n  ) {\n      // The character after the match is line break or carriage return.\n      return true;\n    }\n\n  if (matchLength > 0) {\n    var lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n\n    if (wordSeparators.get(lastCharInMatch) !== 0\n    /* Regular */\n    ) {\n        // The last character in the match is a word separator\n        return true;\n      }\n  }\n\n  return false;\n}\n\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);\n}\n\nvar Searcher =\n/** @class */\nfunction () {\n  function Searcher(wordSeparators, searchRegex) {\n    this._wordSeparators = wordSeparators;\n    this._searchRegex = searchRegex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  }\n\n  Searcher.prototype.reset = function (lastIndex) {\n    this._searchRegex.lastIndex = lastIndex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  };\n\n  Searcher.prototype.next = function (text) {\n    var textLength = text.length;\n    var m;\n\n    do {\n      if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n        // Reached the end of the line\n        return null;\n      }\n\n      m = this._searchRegex.exec(text);\n\n      if (!m) {\n        return null;\n      }\n\n      var matchStartIndex = m.index;\n      var matchLength = m[0].length;\n\n      if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n        if (matchLength === 0) {\n          // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n          // we attempt to recover from that by advancing by one\n          this._searchRegex.lastIndex += 1;\n          continue;\n        } // Exit early if the regex matches the same range twice\n\n\n        return null;\n      }\n\n      this._prevMatchStartIndex = matchStartIndex;\n      this._prevMatchLength = matchLength;\n\n      if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n        return m;\n      }\n    } while (m);\n\n    return null;\n  };\n\n  return Searcher;\n}();\n\nexport { Searcher };","map":null,"metadata":{},"sourceType":"module"}