{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Range } from '../../common/core/range.js';\nimport { findFirstInSorted } from '../../../base/common/arrays.js';\n\nvar HiddenRangeModel =\n/** @class */\nfunction () {\n  function HiddenRangeModel(model) {\n    var _this = this;\n\n    this._updateEventEmitter = new Emitter();\n    this._foldingModel = model;\n    this._foldingModelListener = model.onDidChange(function (_) {\n      return _this.updateHiddenRanges();\n    });\n    this._hiddenRanges = [];\n\n    if (model.regions.length) {\n      this.updateHiddenRanges();\n    }\n  }\n\n  Object.defineProperty(HiddenRangeModel.prototype, \"onDidChange\", {\n    get: function () {\n      return this._updateEventEmitter.event;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HiddenRangeModel.prototype, \"hiddenRanges\", {\n    get: function () {\n      return this._hiddenRanges;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  HiddenRangeModel.prototype.updateHiddenRanges = function () {\n    var updateHiddenAreas = false;\n    var newHiddenAreas = [];\n    var i = 0; // index into hidden\n\n    var k = 0;\n    var lastCollapsedStart = Number.MAX_VALUE;\n    var lastCollapsedEnd = -1;\n    var ranges = this._foldingModel.regions;\n\n    for (; i < ranges.length; i++) {\n      if (!ranges.isCollapsed(i)) {\n        continue;\n      }\n\n      var startLineNumber = ranges.getStartLineNumber(i) + 1; // the first line is not hidden\n\n      var endLineNumber = ranges.getEndLineNumber(i);\n\n      if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {\n        // ignore ranges contained in collapsed regions\n        continue;\n      }\n\n      if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {\n        // reuse the old ranges\n        newHiddenAreas.push(this._hiddenRanges[k]);\n        k++;\n      } else {\n        updateHiddenAreas = true;\n        newHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));\n      }\n\n      lastCollapsedStart = startLineNumber;\n      lastCollapsedEnd = endLineNumber;\n    }\n\n    if (updateHiddenAreas || k < this._hiddenRanges.length) {\n      this.applyHiddenRanges(newHiddenAreas);\n    }\n  };\n\n  HiddenRangeModel.prototype.applyMemento = function (state) {\n    if (!Array.isArray(state) || state.length === 0) {\n      return false;\n    }\n\n    var hiddenRanges = [];\n\n    for (var _i = 0, state_1 = state; _i < state_1.length; _i++) {\n      var r = state_1[_i];\n\n      if (!r.startLineNumber || !r.endLineNumber) {\n        return false;\n      }\n\n      hiddenRanges.push(new Range(r.startLineNumber + 1, 1, r.endLineNumber, 1));\n    }\n\n    this.applyHiddenRanges(hiddenRanges);\n    return true;\n  };\n  /**\n   * Collapse state memento, for persistence only, only used if folding model is not yet initialized\n   */\n\n\n  HiddenRangeModel.prototype.getMemento = function () {\n    return this._hiddenRanges.map(function (r) {\n      return {\n        startLineNumber: r.startLineNumber - 1,\n        endLineNumber: r.endLineNumber\n      };\n    });\n  };\n\n  HiddenRangeModel.prototype.applyHiddenRanges = function (newHiddenAreas) {\n    this._hiddenRanges = newHiddenAreas;\n\n    this._updateEventEmitter.fire(newHiddenAreas);\n  };\n\n  HiddenRangeModel.prototype.hasRanges = function () {\n    return this._hiddenRanges.length > 0;\n  };\n\n  HiddenRangeModel.prototype.isHidden = function (line) {\n    return findRange(this._hiddenRanges, line) !== null;\n  };\n\n  HiddenRangeModel.prototype.adjustSelections = function (selections) {\n    var _this = this;\n\n    var hasChanges = false;\n    var editorModel = this._foldingModel.textModel;\n    var lastRange = null;\n\n    var adjustLine = function (line) {\n      if (!lastRange || !isInside(line, lastRange)) {\n        lastRange = findRange(_this._hiddenRanges, line);\n      }\n\n      if (lastRange) {\n        return lastRange.startLineNumber - 1;\n      }\n\n      return null;\n    };\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n      var adjustedStartLine = adjustLine(selection.startLineNumber);\n\n      if (adjustedStartLine) {\n        selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));\n        hasChanges = true;\n      }\n\n      var adjustedEndLine = adjustLine(selection.endLineNumber);\n\n      if (adjustedEndLine) {\n        selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));\n        hasChanges = true;\n      }\n\n      selections[i] = selection;\n    }\n\n    return hasChanges;\n  };\n\n  HiddenRangeModel.prototype.dispose = function () {\n    if (this.hiddenRanges.length > 0) {\n      this._hiddenRanges = [];\n\n      this._updateEventEmitter.fire(this._hiddenRanges);\n    }\n\n    if (this._foldingModelListener) {\n      this._foldingModelListener.dispose();\n\n      this._foldingModelListener = null;\n    }\n  };\n\n  return HiddenRangeModel;\n}();\n\nexport { HiddenRangeModel };\n\nfunction isInside(line, range) {\n  return line >= range.startLineNumber && line <= range.endLineNumber;\n}\n\nfunction findRange(ranges, line) {\n  var i = findFirstInSorted(ranges, function (r) {\n    return line < r.startLineNumber;\n  }) - 1;\n\n  if (i >= 0 && ranges[i].endLineNumber >= line) {\n    return ranges[i];\n  }\n\n  return null;\n}","map":null,"metadata":{},"sourceType":"module"}