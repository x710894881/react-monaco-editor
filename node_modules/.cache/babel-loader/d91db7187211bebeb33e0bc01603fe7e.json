{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport * as strings from './strings.js'; // Combined filters\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\n\nexport function or() {\n  var filter = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    filter[_i] = arguments[_i];\n  }\n\n  return function (word, wordToMatchAgainst) {\n    for (var i = 0, len = filter.length; i < len; i++) {\n      var match = filter[i](word, wordToMatchAgainst);\n\n      if (match) {\n        return match;\n      }\n    }\n\n    return null;\n  };\n}\nexport var matchesPrefix = _matchesPrefix.bind(undefined, true);\n\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n    return null;\n  }\n\n  var matches;\n\n  if (ignoreCase) {\n    matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n  } else {\n    matches = wordToMatchAgainst.indexOf(word) === 0;\n  }\n\n  if (!matches) {\n    return null;\n  }\n\n  return word.length > 0 ? [{\n    start: 0,\n    end: word.length\n  }] : [];\n} // Contiguous Substring\n\n\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n  var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\n  if (index === -1) {\n    return null;\n  }\n\n  return [{\n    start: index,\n    end: index + word.length\n  }];\n} // Substring\n\nexport function matchesSubString(word, wordToMatchAgainst) {\n  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\n\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === wordToMatchAgainst.length) {\n    return null;\n  } else {\n    if (word[i] === wordToMatchAgainst[j]) {\n      var result = null;\n\n      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n        return join({\n          start: j,\n          end: j + 1\n        }, result);\n      }\n\n      return null;\n    }\n\n    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n  }\n} // CamelCase\n\n\nfunction isLower(code) {\n  return 97\n  /* a */\n  <= code && code <= 122\n  /* z */\n  ;\n}\n\nexport function isUpper(code) {\n  return 65\n  /* A */\n  <= code && code <= 90\n  /* Z */\n  ;\n}\n\nfunction isNumber(code) {\n  return 48\n  /* Digit0 */\n  <= code && code <= 57\n  /* Digit9 */\n  ;\n}\n\nfunction isWhitespace(code) {\n  return code === 32\n  /* Space */\n  || code === 9\n  /* Tab */\n  || code === 10\n  /* LineFeed */\n  || code === 13\n  /* CarriageReturn */\n  ;\n}\n\nvar wordSeparators = new Set();\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'.split('').forEach(function (s) {\n  return wordSeparators.add(s.charCodeAt(0));\n});\n\nfunction isAlphanumeric(code) {\n  return isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head, tail) {\n  if (tail.length === 0) {\n    tail = [head];\n  } else if (head.end === tail[0].start) {\n    tail[0].start = head.start;\n  } else {\n    tail.unshift(head);\n  }\n\n  return tail;\n}\n\nfunction nextAnchor(camelCaseWord, start) {\n  for (var i = start; i < camelCaseWord.length; i++) {\n    var c = camelCaseWord.charCodeAt(i);\n\n    if (isUpper(c) || isNumber(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n\n  return camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === camelCaseWord.length) {\n    return null;\n  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n    return null;\n  } else {\n    var result = null;\n    var nextUpperIndex = j + 1;\n    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\n    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n      nextUpperIndex++;\n    }\n\n    return result === null ? null : join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n} // Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\n\n\nfunction analyzeCamelCaseWord(word) {\n  var upper = 0,\n      lower = 0,\n      alpha = 0,\n      numeric = 0,\n      code = 0;\n\n  for (var i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n\n    if (isUpper(code)) {\n      upper++;\n    }\n\n    if (isLower(code)) {\n      lower++;\n    }\n\n    if (isAlphanumeric(code)) {\n      alpha++;\n    }\n\n    if (isNumber(code)) {\n      numeric++;\n    }\n  }\n\n  var upperPercent = upper / word.length;\n  var lowerPercent = lower / word.length;\n  var alphaPercent = alpha / word.length;\n  var numericPercent = numeric / word.length;\n  return {\n    upperPercent: upperPercent,\n    lowerPercent: lowerPercent,\n    alphaPercent: alphaPercent,\n    numericPercent: numericPercent\n  };\n}\n\nfunction isUpperCaseWord(analysis) {\n  var upperPercent = analysis.upperPercent,\n      lowerPercent = analysis.lowerPercent;\n  return lowerPercent === 0 && upperPercent > 0.6;\n}\n\nfunction isCamelCaseWord(analysis) {\n  var upperPercent = analysis.upperPercent,\n      lowerPercent = analysis.lowerPercent,\n      alphaPercent = analysis.alphaPercent,\n      numericPercent = analysis.numericPercent;\n  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n} // Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\n\n\nfunction isCamelCasePattern(word) {\n  var upper = 0,\n      lower = 0,\n      code = 0,\n      whitespace = 0;\n\n  for (var i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n\n    if (isUpper(code)) {\n      upper++;\n    }\n\n    if (isLower(code)) {\n      lower++;\n    }\n\n    if (isWhitespace(code)) {\n      whitespace++;\n    }\n  }\n\n  if ((upper === 0 || lower === 0) && whitespace === 0) {\n    return word.length <= 30;\n  } else {\n    return upper <= 5;\n  }\n}\n\nexport function matchesCamelCase(word, camelCaseWord) {\n  if (!camelCaseWord) {\n    return null;\n  }\n\n  camelCaseWord = camelCaseWord.trim();\n\n  if (camelCaseWord.length === 0) {\n    return null;\n  }\n\n  if (!isCamelCasePattern(word)) {\n    return null;\n  }\n\n  if (camelCaseWord.length > 60) {\n    return null;\n  }\n\n  var analysis = analyzeCamelCaseWord(camelCaseWord);\n\n  if (!isCamelCaseWord(analysis)) {\n    if (!isUpperCaseWord(analysis)) {\n      return null;\n    }\n\n    camelCaseWord = camelCaseWord.toLowerCase();\n  }\n\n  var result = null;\n  var i = 0;\n  word = word.toLowerCase();\n\n  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n    i = nextAnchor(camelCaseWord, i + 1);\n  }\n\n  return result;\n} // Fuzzy\n\nvar fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nvar fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nvar fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {\n  if (enableSeparateSubstringMatching === void 0) {\n    enableSeparateSubstringMatching = false;\n  }\n\n  if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n    return null; // return early for invalid input\n  } // Form RegExp for wildcard matches\n\n\n  var regexp = fuzzyRegExpCache.get(word);\n\n  if (!regexp) {\n    regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n    fuzzyRegExpCache.set(word, regexp);\n  } // RegExp Filter\n\n\n  var match = regexp.exec(wordToMatchAgainst);\n\n  if (match) {\n    return [{\n      start: match.index,\n      end: match.index + match[0].length\n    }];\n  } // Default Filter\n\n\n  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\nexport function anyScore(pattern, lowPattern, _patternPos, word, lowWord, _wordPos) {\n  var result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\n\n  if (result) {\n    return result;\n  }\n\n  var matches = 0;\n  var score = 0;\n  var idx = _wordPos;\n\n  for (var patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\n    var wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\n\n    if (wordPos >= 0) {\n      score += 1;\n      matches += Math.pow(2, wordPos);\n      idx = wordPos + 1;\n    } else if (matches !== 0) {\n      // once we have started matching things\n      // we need to match the remaining pattern\n      // characters\n      break;\n    }\n  }\n\n  return [score, matches, _wordPos];\n} //#region --- fuzzyScore ---\n\nexport function createMatches(score) {\n  if (typeof score === 'undefined') {\n    return [];\n  }\n\n  var matches = score[1].toString(2);\n  var wordStart = score[2];\n  var res = [];\n\n  for (var pos = wordStart; pos < _maxLen; pos++) {\n    if (matches[matches.length - (pos + 1)] === '1') {\n      var last = res[res.length - 1];\n\n      if (last && last.end === pos) {\n        last.end = pos + 1;\n      } else {\n        res.push({\n          start: pos,\n          end: pos + 1\n        });\n      }\n    }\n  }\n\n  return res;\n}\nvar _maxLen = 128;\n\nfunction initTable() {\n  var table = [];\n  var row = [0];\n\n  for (var i = 1; i <= _maxLen; i++) {\n    row.push(-i);\n  }\n\n  for (var i = 0; i <= _maxLen; i++) {\n    var thisRow = row.slice(0);\n    thisRow[0] = -i;\n    table.push(thisRow);\n  }\n\n  return table;\n}\n\nvar _table = initTable();\n\nvar _scores = initTable();\n\nvar _arrows = initTable();\n\nvar _debug = false;\n\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n  function pad(s, n, pad) {\n    if (pad === void 0) {\n      pad = ' ';\n    }\n\n    while (s.length < n) {\n      s = pad + s;\n    }\n\n    return s;\n  }\n\n  var ret = \" |   |\" + word.split('').map(function (c) {\n    return pad(c, 3);\n  }).join('|') + \"\\n\";\n\n  for (var i = 0; i <= patternLen; i++) {\n    if (i === 0) {\n      ret += ' |';\n    } else {\n      ret += pattern[i - 1] + \"|\";\n    }\n\n    ret += table[i].slice(0, wordLen + 1).map(function (n) {\n      return pad(n.toString(), 3);\n    }).join('|') + '\\n';\n  }\n\n  return ret;\n}\n\nfunction printTables(pattern, patternStart, word, wordStart) {\n  pattern = pattern.substr(patternStart);\n  word = word.substr(wordStart);\n  console.log(printTable(_table, pattern, pattern.length, word, word.length));\n  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n  console.log(printTable(_scores, pattern, pattern.length, word, word.length));\n}\n\nfunction isSeparatorAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n\n  var code = value.charCodeAt(index);\n\n  switch (code) {\n    case 95\n    /* Underline */\n    :\n    case 45\n    /* Dash */\n    :\n    case 46\n    /* Period */\n    :\n    case 32\n    /* Space */\n    :\n    case 47\n    /* Slash */\n    :\n    case 92\n    /* Backslash */\n    :\n    case 39\n    /* SingleQuote */\n    :\n    case 34\n    /* DoubleQuote */\n    :\n    case 58\n    /* Colon */\n    :\n    case 36\n    /* DollarSign */\n    :\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction isWhitespaceAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n\n  var code = value.charCodeAt(index);\n\n  switch (code) {\n    case 32\n    /* Space */\n    :\n    case 9\n    /* Tab */\n    :\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n  return word[pos] !== wordLow[pos];\n}\n\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen) {\n  while (patternPos < patternLen && wordPos < wordLen) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      patternPos += 1;\n    }\n\n    wordPos += 1;\n  }\n\n  return patternPos === patternLen; // pattern must be exhausted\n}\nexport var FuzzyScore;\n\n(function (FuzzyScore) {\n  /**\n   * No matches and value `-100`\n   */\n  FuzzyScore.Default = Object.freeze([-100, 0, 0]);\n\n  function isDefault(score) {\n    return !score || score[0] === -100 && score[1] === 0 && score[2] === 0;\n  }\n\n  FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\n\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\n  var patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n  var wordLen = word.length > _maxLen ? _maxLen : word.length;\n\n  if (patternStart >= patternLen || wordStart >= wordLen || patternLen > wordLen) {\n    return undefined;\n  } // Run a simple check if the characters of pattern occur\n  // (in order) at all in word. If that isn't the case we\n  // stop because no match will be possible\n\n\n  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen)) {\n    return undefined;\n  }\n\n  var row = 1;\n  var column = 1;\n  var patternPos = patternStart;\n  var wordPos = wordStart; // There will be a match, fill in tables\n\n  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n    for (column = 1, wordPos = wordStart; wordPos < wordLen; column++, wordPos++) {\n      var score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos);\n\n      _scores[row][column] = score;\n      var diag = _table[row - 1][column - 1] + (score > 1 ? 1 : score);\n      var top_1 = _table[row - 1][column] + -1;\n      var left = _table[row][column - 1] + -1;\n\n      if (left >= top_1) {\n        // left or diag\n        if (left > diag) {\n          _table[row][column] = left;\n          _arrows[row][column] = 4\n          /* Left */\n          ;\n        } else if (left === diag) {\n          _table[row][column] = left;\n          _arrows[row][column] = 4\n          /* Left */\n          | 2\n          /* Diag */\n          ;\n        } else {\n          _table[row][column] = diag;\n          _arrows[row][column] = 2\n          /* Diag */\n          ;\n        }\n      } else {\n        // top or diag\n        if (top_1 > diag) {\n          _table[row][column] = top_1;\n          _arrows[row][column] = 1\n          /* Top */\n          ;\n        } else if (top_1 === diag) {\n          _table[row][column] = top_1;\n          _arrows[row][column] = 1\n          /* Top */\n          | 2\n          /* Diag */\n          ;\n        } else {\n          _table[row][column] = diag;\n          _arrows[row][column] = 2\n          /* Diag */\n          ;\n        }\n      }\n    }\n  }\n\n  if (_debug) {\n    printTables(pattern, patternStart, word, wordStart);\n  }\n\n  _matchesCount = 0;\n  _topScore = -100;\n  _wordStart = wordStart;\n  _firstMatchCanBeWeak = firstMatchCanBeWeak;\n\n  _findAllMatches2(row - 1, column - 1, patternLen === wordLen ? 1 : 0, 0, false);\n\n  if (_matchesCount === 0) {\n    return undefined;\n  }\n\n  return [_topScore, _topMatch2, wordStart];\n}\n\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos) {\n  if (patternLow[patternPos] !== wordLow[wordPos]) {\n    return -1;\n  }\n\n  if (wordPos === patternPos - patternStart) {\n    // common prefix: `foobar <-> foobaz`\n    //                            ^^^^^\n    if (pattern[patternPos] === word[wordPos]) {\n      return 7;\n    } else {\n      return 5;\n    }\n  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n    // hitting upper-case: `foo <-> forOthers`\n    //                              ^^ ^\n    if (pattern[patternPos] === word[wordPos]) {\n      return 7;\n    } else {\n      return 5;\n    }\n  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n    // hitting a separator: `. <-> foo.bar`\n    //                                ^\n    return 5;\n  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n    // post separator: `foo <-> bar_foo`\n    //                              ^^^\n    return 5;\n  } else {\n    return 1;\n  }\n}\n\nvar _matchesCount = 0;\nvar _topMatch2 = 0;\nvar _topScore = 0;\nvar _wordStart = 0;\nvar _firstMatchCanBeWeak = false;\n\nfunction _findAllMatches2(row, column, total, matches, lastMatched) {\n  if (_matchesCount >= 10 || total < -25) {\n    // stop when having already 10 results, or\n    // when a potential alignment as already 5 gaps\n    return;\n  }\n\n  var simpleMatchCount = 0;\n\n  while (row > 0 && column > 0) {\n    var score = _scores[row][column];\n    var arrow = _arrows[row][column];\n\n    if (arrow === 4\n    /* Left */\n    ) {\n        // left -> no match, skip a word character\n        column -= 1;\n\n        if (lastMatched) {\n          total -= 5; // new gap penalty\n        } else if (matches !== 0) {\n          total -= 1; // gap penalty after first match\n        }\n\n        lastMatched = false;\n        simpleMatchCount = 0;\n      } else if (arrow & 2\n    /* Diag */\n    ) {\n        if (arrow & 4\n        /* Left */\n        ) {\n            // left\n            _findAllMatches2(row, column - 1, matches !== 0 ? total - 1 : total, // gap penalty after first match\n            matches, lastMatched);\n          } // diag\n\n\n        total += score;\n        row -= 1;\n        column -= 1;\n        lastMatched = true; // match -> set a 1 at the word pos\n\n        matches += Math.pow(2, column + _wordStart); // count simple matches and boost a row of\n        // simple matches when they yield in a\n        // strong match.\n\n        if (score === 1) {\n          simpleMatchCount += 1;\n\n          if (row === 0 && !_firstMatchCanBeWeak) {\n            // when the first match is a weak\n            // match we discard it\n            return undefined;\n          }\n        } else {\n          // boost\n          total += 1 + simpleMatchCount * (score - 1);\n          simpleMatchCount = 0;\n        }\n      } else {\n      return undefined;\n    }\n  }\n\n  total -= column >= 3 ? 9 : column * 3; // late start penalty\n  // dynamically keep track of the current top score\n  // and insert the current best score at head, the rest at tail\n\n  _matchesCount += 1;\n\n  if (total > _topScore) {\n    _topScore = total;\n    _topMatch2 = matches;\n  }\n} //#endregion\n//#region --- graceful ---\n\n\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n}\n\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\n  var top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n\n  if (top && !aggressive) {\n    // when using the original pattern yield a result we`\n    // return it unless we are aggressive and try to find\n    // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n    return top;\n  }\n\n  if (pattern.length >= 3) {\n    // When the pattern is long enough then try a few (max 7)\n    // permutations of the pattern to find a better match. The\n    // permutations only swap neighbouring characters, e.g\n    // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n    var tries = Math.min(7, pattern.length - 1);\n\n    for (var movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n      var newPattern = nextTypoPermutation(pattern, movingPatternPos);\n\n      if (newPattern) {\n        var candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n\n        if (candidate) {\n          candidate[0] -= 3; // permutation penalty\n\n          if (!top || candidate[0] > top[0]) {\n            top = candidate;\n          }\n        }\n      }\n    }\n  }\n\n  return top;\n}\n\nfunction nextTypoPermutation(pattern, patternPos) {\n  if (patternPos + 1 >= pattern.length) {\n    return undefined;\n  }\n\n  var swap1 = pattern[patternPos];\n  var swap2 = pattern[patternPos + 1];\n\n  if (swap1 === swap2) {\n    return undefined;\n  }\n\n  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);\n} //#endregion","map":null,"metadata":{},"sourceType":"module"}