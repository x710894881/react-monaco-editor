{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { basename, posix } from './path.js';\nimport { endsWith, startsWithUTF8BOM } from './strings.js';\nimport { match } from './glob.js';\nimport { Schemas } from './network.js';\nimport { DataUri } from './resources.js';\nexport var MIME_TEXT = 'text/plain';\nexport var MIME_UNKNOWN = 'application/unknown';\nvar registeredAssociations = [];\nvar nonUserRegisteredAssociations = [];\nvar userRegisteredAssociations = [];\n/**\n * Associate a text mime to the registry.\n */\n\nexport function registerTextMime(association, warnOnOverwrite) {\n  if (warnOnOverwrite === void 0) {\n    warnOnOverwrite = false;\n  } // Register\n\n\n  var associationItem = toTextMimeAssociationItem(association);\n  registeredAssociations.push(associationItem);\n\n  if (!associationItem.userConfigured) {\n    nonUserRegisteredAssociations.push(associationItem);\n  } else {\n    userRegisteredAssociations.push(associationItem);\n  } // Check for conflicts unless this is a user configured association\n\n\n  if (warnOnOverwrite && !associationItem.userConfigured) {\n    registeredAssociations.forEach(function (a) {\n      if (a.mime === associationItem.mime || a.userConfigured) {\n        return; // same mime or userConfigured is ok\n      }\n\n      if (associationItem.extension && a.extension === associationItem.extension) {\n        console.warn(\"Overwriting extension <<\" + associationItem.extension + \">> to now point to mime <<\" + associationItem.mime + \">>\");\n      }\n\n      if (associationItem.filename && a.filename === associationItem.filename) {\n        console.warn(\"Overwriting filename <<\" + associationItem.filename + \">> to now point to mime <<\" + associationItem.mime + \">>\");\n      }\n\n      if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {\n        console.warn(\"Overwriting filepattern <<\" + associationItem.filepattern + \">> to now point to mime <<\" + associationItem.mime + \">>\");\n      }\n\n      if (associationItem.firstline && a.firstline === associationItem.firstline) {\n        console.warn(\"Overwriting firstline <<\" + associationItem.firstline + \">> to now point to mime <<\" + associationItem.mime + \">>\");\n      }\n    });\n  }\n}\n\nfunction toTextMimeAssociationItem(association) {\n  return {\n    id: association.id,\n    mime: association.mime,\n    filename: association.filename,\n    extension: association.extension,\n    filepattern: association.filepattern,\n    firstline: association.firstline,\n    userConfigured: association.userConfigured,\n    filenameLowercase: association.filename ? association.filename.toLowerCase() : undefined,\n    extensionLowercase: association.extension ? association.extension.toLowerCase() : undefined,\n    filepatternLowercase: association.filepattern ? association.filepattern.toLowerCase() : undefined,\n    filepatternOnPath: association.filepattern ? association.filepattern.indexOf(posix.sep) >= 0 : false\n  };\n}\n/**\n * Given a file, return the best matching mime type for it\n */\n\n\nexport function guessMimeTypes(resource, firstLine) {\n  var path;\n\n  if (resource) {\n    switch (resource.scheme) {\n      case Schemas.file:\n        path = resource.fsPath;\n        break;\n\n      case Schemas.data:\n        var metadata = DataUri.parseMetaData(resource);\n        path = metadata.get(DataUri.META_DATA_LABEL);\n        break;\n\n      default:\n        path = resource.path;\n    }\n  }\n\n  if (!path) {\n    return [MIME_UNKNOWN];\n  }\n\n  path = path.toLowerCase();\n  var filename = basename(path); // 1.) User configured mappings have highest priority\n\n  var configuredMime = guessMimeTypeByPath(path, filename, userRegisteredAssociations);\n\n  if (configuredMime) {\n    return [configuredMime, MIME_TEXT];\n  } // 2.) Registered mappings have middle priority\n\n\n  var registeredMime = guessMimeTypeByPath(path, filename, nonUserRegisteredAssociations);\n\n  if (registeredMime) {\n    return [registeredMime, MIME_TEXT];\n  } // 3.) Firstline has lowest priority\n\n\n  if (firstLine) {\n    var firstlineMime = guessMimeTypeByFirstline(firstLine);\n\n    if (firstlineMime) {\n      return [firstlineMime, MIME_TEXT];\n    }\n  }\n\n  return [MIME_UNKNOWN];\n}\n\nfunction guessMimeTypeByPath(path, filename, associations) {\n  var filenameMatch = null;\n  var patternMatch = null;\n  var extensionMatch = null; // We want to prioritize associations based on the order they are registered so that the last registered\n  // association wins over all other. This is for https://github.com/Microsoft/vscode/issues/20074\n\n  for (var i = associations.length - 1; i >= 0; i--) {\n    var association = associations[i]; // First exact name match\n\n    if (filename === association.filenameLowercase) {\n      filenameMatch = association;\n      break; // take it!\n    } // Longest pattern match\n\n\n    if (association.filepattern) {\n      if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {\n        var target = association.filepatternOnPath ? path : filename; // match on full path if pattern contains path separator\n\n        if (match(association.filepatternLowercase, target)) {\n          patternMatch = association;\n        }\n      }\n    } // Longest extension match\n\n\n    if (association.extension) {\n      if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {\n        if (endsWith(filename, association.extensionLowercase)) {\n          extensionMatch = association;\n        }\n      }\n    }\n  } // 1.) Exact name match has second highest prio\n\n\n  if (filenameMatch) {\n    return filenameMatch.mime;\n  } // 2.) Match on pattern\n\n\n  if (patternMatch) {\n    return patternMatch.mime;\n  } // 3.) Match on extension comes next\n\n\n  if (extensionMatch) {\n    return extensionMatch.mime;\n  }\n\n  return null;\n}\n\nfunction guessMimeTypeByFirstline(firstLine) {\n  if (startsWithUTF8BOM(firstLine)) {\n    firstLine = firstLine.substr(1);\n  }\n\n  if (firstLine.length > 0) {\n    // We want to prioritize associations based on the order they are registered so that the last registered\n    // association wins over all other. This is for https://github.com/Microsoft/vscode/issues/20074\n    for (var i = registeredAssociations.length - 1; i >= 0; i--) {\n      var association = registeredAssociations[i];\n\n      if (!association.firstline) {\n        continue;\n      }\n\n      var matches = firstLine.match(association.firstline);\n\n      if (matches && matches.length > 0) {\n        return association.mime;\n      }\n    }\n  }\n\n  return null;\n}","map":null,"metadata":{},"sourceType":"module"}