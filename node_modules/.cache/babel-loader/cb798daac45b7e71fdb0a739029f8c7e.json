{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport './quickOutline.css';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { matchesFuzzy } from '../../../../base/common/filters.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { QuickOpenEntryGroup, QuickOpenModel } from '../../../../base/parts/quickopen/browser/quickOpenModel.js';\nimport { registerEditorAction } from '../../../browser/editorExtensions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { EditorContextKeys } from '../../../common/editorContextKeys.js';\nimport { DocumentSymbolProviderRegistry, symbolKindToCssClass } from '../../../common/modes.js';\nimport { getDocumentSymbols } from '../../../contrib/quickOpen/quickOpen.js';\nimport { BaseEditorQuickOpenAction } from './editorQuickOpen.js';\nimport { QuickOutlineNLS } from '../../../common/standaloneStrings.js';\nvar SCOPE_PREFIX = ':';\n\nvar SymbolEntry =\n/** @class */\nfunction (_super) {\n  __extends(SymbolEntry, _super);\n\n  function SymbolEntry(name, type, description, range, highlights, editor, decorator) {\n    var _this = _super.call(this) || this;\n\n    _this.name = name;\n    _this.type = type;\n    _this.description = description;\n    _this.range = range;\n\n    _this.setHighlights(highlights);\n\n    _this.editor = editor;\n    _this.decorator = decorator;\n    return _this;\n  }\n\n  SymbolEntry.prototype.getLabel = function () {\n    return this.name;\n  };\n\n  SymbolEntry.prototype.getAriaLabel = function () {\n    return strings.format(QuickOutlineNLS.entryAriaLabel, this.name);\n  };\n\n  SymbolEntry.prototype.getIcon = function () {\n    return this.type;\n  };\n\n  SymbolEntry.prototype.getDescription = function () {\n    return this.description;\n  };\n\n  SymbolEntry.prototype.getType = function () {\n    return this.type;\n  };\n\n  SymbolEntry.prototype.getRange = function () {\n    return this.range;\n  };\n\n  SymbolEntry.prototype.run = function (mode, context) {\n    if (mode === 1\n    /* OPEN */\n    ) {\n        return this.runOpen(context);\n      }\n\n    return this.runPreview();\n  };\n\n  SymbolEntry.prototype.runOpen = function (_context) {\n    // Apply selection and focus\n    var range = this.toSelection();\n    this.editor.setSelection(range);\n    this.editor.revealRangeInCenter(range, 0\n    /* Smooth */\n    );\n    this.editor.focus();\n    return true;\n  };\n\n  SymbolEntry.prototype.runPreview = function () {\n    // Select Outline Position\n    var range = this.toSelection();\n    this.editor.revealRangeInCenter(range, 0\n    /* Smooth */\n    ); // Decorate if possible\n\n    this.decorator.decorateLine(this.range, this.editor);\n    return false;\n  };\n\n  SymbolEntry.prototype.toSelection = function () {\n    return new Range(this.range.startLineNumber, this.range.startColumn || 1, this.range.startLineNumber, this.range.startColumn || 1);\n  };\n\n  return SymbolEntry;\n}(QuickOpenEntryGroup);\n\nexport { SymbolEntry };\n\nvar QuickOutlineAction =\n/** @class */\nfunction (_super) {\n  __extends(QuickOutlineAction, _super);\n\n  function QuickOutlineAction() {\n    return _super.call(this, QuickOutlineNLS.quickOutlineActionInput, {\n      id: 'editor.action.quickOutline',\n      label: QuickOutlineNLS.quickOutlineActionLabel,\n      alias: 'Go to Symbol...',\n      precondition: EditorContextKeys.hasDocumentSymbolProvider,\n      kbOpts: {\n        kbExpr: EditorContextKeys.focus,\n        primary: 2048\n        /* CtrlCmd */\n        | 1024\n        /* Shift */\n        | 45\n        /* KEY_O */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      },\n      menuOpts: {\n        group: 'navigation',\n        order: 3\n      }\n    }) || this;\n  }\n\n  QuickOutlineAction.prototype.run = function (accessor, editor) {\n    var _this = this;\n\n    if (!editor.hasModel()) {\n      return undefined;\n    }\n\n    var model = editor.getModel();\n\n    if (!DocumentSymbolProviderRegistry.has(model)) {\n      return undefined;\n    } // Resolve outline\n\n\n    return getDocumentSymbols(model, true, CancellationToken.None).then(function (result) {\n      if (result.length === 0) {\n        return;\n      }\n\n      _this._run(editor, result);\n    });\n  };\n\n  QuickOutlineAction.prototype._run = function (editor, result) {\n    var _this = this;\n\n    this._show(this.getController(editor), {\n      getModel: function (value) {\n        return new QuickOpenModel(_this.toQuickOpenEntries(editor, result, value));\n      },\n      getAutoFocus: function (searchValue) {\n        // Remove any type pattern (:) from search value as needed\n        if (searchValue.indexOf(SCOPE_PREFIX) === 0) {\n          searchValue = searchValue.substr(SCOPE_PREFIX.length);\n        }\n\n        return {\n          autoFocusPrefixMatch: searchValue,\n          autoFocusFirstEntry: !!searchValue\n        };\n      }\n    });\n  };\n\n  QuickOutlineAction.prototype.symbolEntry = function (name, type, description, range, highlights, editor, decorator) {\n    return new SymbolEntry(name, type, description, Range.lift(range), highlights, editor, decorator);\n  };\n\n  QuickOutlineAction.prototype.toQuickOpenEntries = function (editor, flattened, searchValue) {\n    var controller = this.getController(editor);\n    var results = []; // Convert to Entries\n\n    var normalizedSearchValue = searchValue;\n\n    if (searchValue.indexOf(SCOPE_PREFIX) === 0) {\n      normalizedSearchValue = normalizedSearchValue.substr(SCOPE_PREFIX.length);\n    }\n\n    for (var _i = 0, flattened_1 = flattened; _i < flattened_1.length; _i++) {\n      var element = flattened_1[_i];\n      var label = strings.trim(element.name); // Check for meatch\n\n      var highlights = matchesFuzzy(normalizedSearchValue, label);\n\n      if (highlights) {\n        // Show parent scope as description\n        var description = undefined;\n\n        if (element.containerName) {\n          description = element.containerName;\n        } // Add\n\n\n        results.push(this.symbolEntry(label, symbolKindToCssClass(element.kind), description, element.range, highlights, editor, controller));\n      }\n    } // Sort properly if actually searching\n\n\n    if (searchValue) {\n      if (searchValue.indexOf(SCOPE_PREFIX) === 0) {\n        results = results.sort(this.sortScoped.bind(this, searchValue.toLowerCase()));\n      } else {\n        results = results.sort(this.sortNormal.bind(this, searchValue.toLowerCase()));\n      }\n    } // Mark all type groups\n\n\n    if (results.length > 0 && searchValue.indexOf(SCOPE_PREFIX) === 0) {\n      var currentType = null;\n      var currentResult = null;\n      var typeCounter = 0;\n\n      for (var i = 0; i < results.length; i++) {\n        var result = results[i]; // Found new type\n\n        if (currentType !== result.getType()) {\n          // Update previous result with count\n          if (currentResult) {\n            currentResult.setGroupLabel(this.typeToLabel(currentType || '', typeCounter));\n          }\n\n          currentType = result.getType();\n          currentResult = result;\n          typeCounter = 1;\n          result.setShowBorder(i > 0);\n        } // Existing type, keep counting\n        else {\n            typeCounter++;\n          }\n      } // Update previous result with count\n\n\n      if (currentResult) {\n        currentResult.setGroupLabel(this.typeToLabel(currentType || '', typeCounter));\n      }\n    } // Mark first entry as outline\n    else if (results.length > 0) {\n        results[0].setGroupLabel(strings.format(QuickOutlineNLS._symbols_, results.length));\n      }\n\n    return results;\n  };\n\n  QuickOutlineAction.prototype.typeToLabel = function (type, count) {\n    switch (type) {\n      case 'module':\n        return strings.format(QuickOutlineNLS._modules_, count);\n\n      case 'class':\n        return strings.format(QuickOutlineNLS._class_, count);\n\n      case 'interface':\n        return strings.format(QuickOutlineNLS._interface_, count);\n\n      case 'method':\n        return strings.format(QuickOutlineNLS._method_, count);\n\n      case 'function':\n        return strings.format(QuickOutlineNLS._function_, count);\n\n      case 'property':\n        return strings.format(QuickOutlineNLS._property_, count);\n\n      case 'variable':\n        return strings.format(QuickOutlineNLS._variable_, count);\n\n      case 'var':\n        return strings.format(QuickOutlineNLS._variable2_, count);\n\n      case 'constructor':\n        return strings.format(QuickOutlineNLS._constructor_, count);\n\n      case 'call':\n        return strings.format(QuickOutlineNLS._call_, count);\n    }\n\n    return type;\n  };\n\n  QuickOutlineAction.prototype.sortNormal = function (searchValue, elementA, elementB) {\n    var elementAName = elementA.getLabel().toLowerCase();\n    var elementBName = elementB.getLabel().toLowerCase(); // Compare by name\n\n    var r = elementAName.localeCompare(elementBName);\n\n    if (r !== 0) {\n      return r;\n    } // If name identical sort by range instead\n\n\n    var elementARange = elementA.getRange();\n    var elementBRange = elementB.getRange();\n    return elementARange.startLineNumber - elementBRange.startLineNumber;\n  };\n\n  QuickOutlineAction.prototype.sortScoped = function (searchValue, elementA, elementB) {\n    // Remove scope char\n    searchValue = searchValue.substr(SCOPE_PREFIX.length); // Sort by type first if scoped search\n\n    var elementAType = elementA.getType();\n    var elementBType = elementB.getType();\n    var r = elementAType.localeCompare(elementBType);\n\n    if (r !== 0) {\n      return r;\n    } // Special sort when searching in scoped mode\n\n\n    if (searchValue) {\n      var elementAName = elementA.getLabel().toLowerCase();\n      var elementBName = elementB.getLabel().toLowerCase(); // Compare by name\n\n      var r_1 = elementAName.localeCompare(elementBName);\n\n      if (r_1 !== 0) {\n        return r_1;\n      }\n    } // Default to sort by range\n\n\n    var elementARange = elementA.getRange();\n    var elementBRange = elementB.getRange();\n    return elementARange.startLineNumber - elementBRange.startLineNumber;\n  };\n\n  return QuickOutlineAction;\n}(BaseEditorQuickOpenAction);\n\nexport { QuickOutlineAction };\nregisterEditorAction(QuickOutlineAction);","map":null,"metadata":{},"sourceType":"module"}