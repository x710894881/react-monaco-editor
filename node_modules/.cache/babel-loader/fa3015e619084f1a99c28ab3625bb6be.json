{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { HorizontalRange } from '../../../common/view/renderingContext.js';\n\nvar FloatHorizontalRange =\n/** @class */\nfunction () {\n  function FloatHorizontalRange(left, width) {\n    this.left = left;\n    this.width = width;\n  }\n\n  FloatHorizontalRange.prototype.toString = function () {\n    return \"[\" + this.left + \",\" + this.width + \"]\";\n  };\n\n  FloatHorizontalRange.compare = function (a, b) {\n    return a.left - b.left;\n  };\n\n  return FloatHorizontalRange;\n}();\n\nvar RangeUtil =\n/** @class */\nfunction () {\n  function RangeUtil() {}\n\n  RangeUtil._createRange = function () {\n    if (!this._handyReadyRange) {\n      this._handyReadyRange = document.createRange();\n    }\n\n    return this._handyReadyRange;\n  };\n\n  RangeUtil._detachRange = function (range, endNode) {\n    // Move range out of the span node, IE doesn't like having many ranges in\n    // the same spot and will act badly for lines containing dashes ('-')\n    range.selectNodeContents(endNode);\n  };\n\n  RangeUtil._readClientRects = function (startElement, startOffset, endElement, endOffset, endNode) {\n    var range = this._createRange();\n\n    try {\n      range.setStart(startElement, startOffset);\n      range.setEnd(endElement, endOffset);\n      return range.getClientRects();\n    } catch (e) {\n      // This is life ...\n      return null;\n    } finally {\n      this._detachRange(range, endNode);\n    }\n  };\n\n  RangeUtil._mergeAdjacentRanges = function (ranges) {\n    if (ranges.length === 1) {\n      // There is nothing to merge\n      return [new HorizontalRange(ranges[0].left, ranges[0].width)];\n    }\n\n    ranges.sort(FloatHorizontalRange.compare);\n    var result = [],\n        resultLen = 0;\n    var prevLeft = ranges[0].left;\n    var prevWidth = ranges[0].width;\n\n    for (var i = 1, len = ranges.length; i < len; i++) {\n      var range = ranges[i];\n      var myLeft = range.left;\n      var myWidth = range.width;\n\n      if (prevLeft + prevWidth + 0.9\n      /* account for browser's rounding errors*/\n      >= myLeft) {\n        prevWidth = Math.max(prevWidth, myLeft + myWidth - prevLeft);\n      } else {\n        result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);\n        prevLeft = myLeft;\n        prevWidth = myWidth;\n      }\n    }\n\n    result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);\n    return result;\n  };\n\n  RangeUtil._createHorizontalRangesFromClientRects = function (clientRects, clientRectDeltaLeft) {\n    if (!clientRects || clientRects.length === 0) {\n      return null;\n    } // We go through FloatHorizontalRange because it has been observed in bi-di text\n    // that the clientRects are not coming in sorted from the browser\n\n\n    var result = [];\n\n    for (var i = 0, len = clientRects.length; i < len; i++) {\n      var clientRect = clientRects[i];\n      result[i] = new FloatHorizontalRange(Math.max(0, clientRect.left - clientRectDeltaLeft), clientRect.width);\n    }\n\n    return this._mergeAdjacentRanges(result);\n  };\n\n  RangeUtil.readHorizontalRanges = function (domNode, startChildIndex, startOffset, endChildIndex, endOffset, clientRectDeltaLeft, endNode) {\n    // Panic check\n    var min = 0;\n    var max = domNode.children.length - 1;\n\n    if (min > max) {\n      return null;\n    }\n\n    startChildIndex = Math.min(max, Math.max(min, startChildIndex));\n    endChildIndex = Math.min(max, Math.max(min, endChildIndex)); // If crossing over to a span only to select offset 0, then use the previous span's maximum offset\n    // Chrome is buggy and doesn't handle 0 offsets well sometimes.\n\n    if (startChildIndex !== endChildIndex) {\n      if (endChildIndex > 0 && endOffset === 0) {\n        endChildIndex--;\n        endOffset = 1073741824\n        /* MAX_SAFE_SMALL_INTEGER */\n        ;\n      }\n    }\n\n    var startElement = domNode.children[startChildIndex].firstChild;\n    var endElement = domNode.children[endChildIndex].firstChild;\n\n    if (!startElement || !endElement) {\n      // When having an empty <span> (without any text content), try to move to the previous <span>\n      if (!startElement && startOffset === 0 && startChildIndex > 0) {\n        startElement = domNode.children[startChildIndex - 1].firstChild;\n        startOffset = 1073741824\n        /* MAX_SAFE_SMALL_INTEGER */\n        ;\n      }\n\n      if (!endElement && endOffset === 0 && endChildIndex > 0) {\n        endElement = domNode.children[endChildIndex - 1].firstChild;\n        endOffset = 1073741824\n        /* MAX_SAFE_SMALL_INTEGER */\n        ;\n      }\n    }\n\n    if (!startElement || !endElement) {\n      return null;\n    }\n\n    startOffset = Math.min(startElement.textContent.length, Math.max(0, startOffset));\n    endOffset = Math.min(endElement.textContent.length, Math.max(0, endOffset));\n\n    var clientRects = this._readClientRects(startElement, startOffset, endElement, endOffset, endNode);\n\n    return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);\n  };\n\n  return RangeUtil;\n}();\n\nexport { RangeUtil };","map":null,"metadata":{},"sourceType":"module"}