{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { FoldingRangeKind } from '../../vscode-languageserver-types/main.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\n\nfunction limitRanges(ranges, rangeLimit) {\n  ranges = ranges.sort(function (r1, r2) {\n    var diff = r1.startLine - r2.startLine;\n\n    if (diff === 0) {\n      diff = r1.endLine - r2.endLine;\n    }\n\n    return diff;\n  }); // compute each range's nesting level in 'nestingLevels'.\n  // count the number of ranges for each level in 'nestingLevelCounts'\n\n  var top = void 0;\n  var previous = [];\n  var nestingLevels = [];\n  var nestingLevelCounts = [];\n\n  var setNestingLevel = function (index, level) {\n    nestingLevels[index] = level;\n\n    if (level < 30) {\n      nestingLevelCounts[level] = (nestingLevelCounts[level] || 0) + 1;\n    }\n  }; // compute nesting levels and sanitize\n\n\n  for (var i = 0; i < ranges.length; i++) {\n    var entry = ranges[i];\n\n    if (!top) {\n      top = entry;\n      setNestingLevel(i, 0);\n    } else {\n      if (entry.startLine > top.startLine) {\n        if (entry.endLine <= top.endLine) {\n          previous.push(top);\n          top = entry;\n          setNestingLevel(i, previous.length);\n        } else if (entry.startLine > top.endLine) {\n          do {\n            top = previous.pop();\n          } while (top && entry.startLine > top.endLine);\n\n          if (top) {\n            previous.push(top);\n          }\n\n          top = entry;\n          setNestingLevel(i, previous.length);\n        }\n      }\n    }\n  }\n\n  var entries = 0;\n  var maxLevel = 0;\n\n  for (var i = 0; i < nestingLevelCounts.length; i++) {\n    var n = nestingLevelCounts[i];\n\n    if (n) {\n      if (n + entries > rangeLimit) {\n        maxLevel = i;\n        break;\n      }\n\n      entries += n;\n    }\n  }\n\n  var result = [];\n\n  for (var i = 0; i < ranges.length; i++) {\n    var level = nestingLevels[i];\n\n    if (typeof level === 'number') {\n      if (level < maxLevel || level === maxLevel && entries++ < rangeLimit) {\n        result.push(ranges[i]);\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function getFoldingRanges(document, context) {\n  var scanner = createScanner(document.getText());\n  var token = scanner.scan();\n  var ranges = [];\n  var stack = [];\n  var lastTagName = null;\n  var prevStart = -1;\n\n  function addRange(range) {\n    ranges.push(range);\n    prevStart = range.startLine;\n  }\n\n  while (token !== TokenType.EOS) {\n    switch (token) {\n      case TokenType.StartTag:\n        {\n          var tagName = scanner.getTokenText();\n          var startLine = document.positionAt(scanner.getTokenOffset()).line;\n          stack.push({\n            startLine: startLine,\n            tagName: tagName\n          });\n          lastTagName = tagName;\n          break;\n        }\n\n      case TokenType.EndTag:\n        {\n          lastTagName = scanner.getTokenText();\n          break;\n        }\n\n      case TokenType.StartTagClose:\n        if (!lastTagName || !isVoidElement(lastTagName)) {\n          break;\n        }\n\n      // fallthrough\n\n      case TokenType.EndTagClose:\n      case TokenType.StartTagSelfClose:\n        {\n          var i = stack.length - 1;\n\n          while (i >= 0 && stack[i].tagName !== lastTagName) {\n            i--;\n          }\n\n          if (i >= 0) {\n            var stackElement = stack[i];\n            stack.length = i;\n            var line = document.positionAt(scanner.getTokenOffset()).line;\n            var startLine = stackElement.startLine;\n            var endLine = line - 1;\n\n            if (endLine > startLine && prevStart !== startLine) {\n              addRange({\n                startLine: startLine,\n                endLine: endLine\n              });\n            }\n          }\n\n          break;\n        }\n\n      case TokenType.Comment:\n        {\n          var startLine = document.positionAt(scanner.getTokenOffset()).line;\n          var text = scanner.getTokenText();\n          var m = text.match(/^\\s*#(region\\b)|(endregion\\b)/);\n\n          if (m) {\n            if (m[1]) {\n              // start pattern match\n              stack.push({\n                startLine: startLine,\n                tagName: ''\n              }); // empty tagName marks region\n            } else {\n              var i = stack.length - 1;\n\n              while (i >= 0 && stack[i].tagName.length) {\n                i--;\n              }\n\n              if (i >= 0) {\n                var stackElement = stack[i];\n                stack.length = i;\n                var endLine = startLine;\n                startLine = stackElement.startLine;\n\n                if (endLine > startLine && prevStart !== startLine) {\n                  addRange({\n                    startLine: startLine,\n                    endLine: endLine,\n                    kind: FoldingRangeKind.Region\n                  });\n                }\n              }\n            }\n          } else {\n            var endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\n\n            if (startLine < endLine) {\n              addRange({\n                startLine: startLine,\n                endLine: endLine,\n                kind: FoldingRangeKind.Comment\n              });\n            }\n          }\n\n          break;\n        }\n    }\n\n    token = scanner.scan();\n  }\n\n  var rangeLimit = context && context.rangeLimit || Number.MAX_VALUE;\n\n  if (ranges.length > rangeLimit) {\n    return limitRanges(ranges, rangeLimit);\n  }\n\n  return ranges;\n}","map":null,"metadata":{},"sourceType":"module"}