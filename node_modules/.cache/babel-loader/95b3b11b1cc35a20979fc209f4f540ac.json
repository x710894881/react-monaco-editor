{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as lessScanner from './lessScanner.js';\nimport { TokenType } from './cssScanner.js';\nimport * as cssParser from './cssParser.js';\nimport * as nodes from './cssNodes.js';\nimport { ParseError } from './cssErrors.js'; /// <summary>\n/// A parser for LESS\n/// http://lesscss.org/\n/// </summary>\n\nvar LESSParser =\n/** @class */\nfunction (_super) {\n  __extends(LESSParser, _super);\n\n  function LESSParser() {\n    return _super.call(this, new lessScanner.LESSScanner()) || this;\n  }\n\n  LESSParser.prototype._parseStylesheetStatement = function (isNested) {\n    if (isNested === void 0) {\n      isNested = false;\n    }\n\n    if (this.peek(TokenType.AtKeyword)) {\n      return this._parseVariableDeclaration() || this._parsePlugin() || _super.prototype._parseStylesheetAtStatement.call(this, isNested);\n    }\n\n    return this._tryParseMixinDeclaration() || this._tryParseMixinReference() || this._parseFunction() || this._parseRuleset(true);\n  };\n\n  LESSParser.prototype._parseImport = function () {\n    if (!this.peekKeyword('@import') && !this.peekKeyword('@import-once')\n    /* deprecated in less 1.4.1 */\n    ) {\n      return null;\n    }\n\n    var node = this.create(nodes.Import);\n    this.consumeToken(); // less 1.4.1: @import (css) \"lib\"\n\n    if (this.accept(TokenType.ParenthesisL)) {\n      if (!this.accept(TokenType.Ident)) {\n        return this.finish(node, ParseError.IdentifierExpected, [TokenType.SemiColon]);\n      }\n\n      do {\n        if (!this.accept(TokenType.Comma)) {\n          break;\n        }\n      } while (this.accept(TokenType.Ident));\n\n      if (!this.accept(TokenType.ParenthesisR)) {\n        return this.finish(node, ParseError.RightParenthesisExpected, [TokenType.SemiColon]);\n      }\n    }\n\n    if (!node.addChild(this._parseURILiteral()) && !node.addChild(this._parseStringLiteral())) {\n      return this.finish(node, ParseError.URIOrStringExpected, [TokenType.SemiColon]);\n    }\n\n    if (!this.peek(TokenType.SemiColon) && !this.peek(TokenType.EOF)) {\n      node.setMedialist(this._parseMediaQueryList());\n    }\n\n    return this.finish(node);\n  };\n\n  LESSParser.prototype._parsePlugin = function () {\n    if (!this.peekKeyword('@plugin')) {\n      return null;\n    }\n\n    var node = this.createNode(nodes.NodeType.Plugin);\n    this.consumeToken(); // @import\n\n    if (!node.addChild(this._parseStringLiteral())) {\n      return this.finish(node, ParseError.StringLiteralExpected);\n    }\n\n    if (!this.accept(TokenType.SemiColon)) {\n      return this.finish(node, ParseError.SemiColonExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  LESSParser.prototype._parseMediaQuery = function (resyncStopToken) {\n    var node = _super.prototype._parseMediaQuery.call(this, resyncStopToken);\n\n    if (!node) {\n      var node_1 = this.create(nodes.MediaQuery);\n\n      if (node_1.addChild(this._parseVariable())) {\n        return this.finish(node_1);\n      }\n\n      return null;\n    }\n\n    return node;\n  };\n\n  LESSParser.prototype._parseMediaDeclaration = function (isNested) {\n    if (isNested === void 0) {\n      isNested = false;\n    }\n\n    return this._tryParseRuleset(isNested) || this._tryToParseDeclaration() || this._tryParseMixinDeclaration() || this._tryParseMixinReference() || this._parseDetachedRuleSetMixin() || this._parseStylesheetStatement(isNested);\n  };\n\n  LESSParser.prototype._parseMediaFeatureName = function () {\n    return this._parseIdent() || this._parseVariable();\n  };\n\n  LESSParser.prototype._parseVariableDeclaration = function (panic) {\n    if (panic === void 0) {\n      panic = [];\n    }\n\n    var node = this.create(nodes.VariableDeclaration);\n    var mark = this.mark();\n\n    if (!this.peekDelim('@') && !this.peek(TokenType.AtKeyword) || !node.setVariable(this._parseVariable())) {\n      return null;\n    }\n\n    if (this.accept(TokenType.Colon)) {\n      node.colonPosition = this.prevToken.offset;\n\n      if (node.setValue(this._parseDetachedRuleSet())) {\n        node.needsSemicolon = false;\n      } else if (!node.setValue(this._parseExpr())) {\n        return this.finish(node, ParseError.VariableValueExpected, [], panic);\n      }\n\n      node.addChild(this._parsePrio());\n    } else {\n      this.restoreAtMark(mark);\n      return null; // at keyword, but no ':', not a variable declaration but some at keyword\n    }\n\n    if (this.peek(TokenType.SemiColon)) {\n      node.semicolonPosition = this.token.offset; // not part of the declaration, but useful information for code assist\n    }\n\n    return this.finish(node);\n  };\n\n  LESSParser.prototype._parseDetachedRuleSet = function () {\n    if (!this.peek(TokenType.CurlyL)) {\n      return null;\n    }\n\n    var content = this.create(nodes.BodyDeclaration);\n\n    this._parseBody(content, this._parseDetachedRuleSetBody.bind(this));\n\n    return this.finish(content);\n  };\n\n  LESSParser.prototype._parseDetachedRuleSetBody = function () {\n    return this._tryParseKeyframeSelector() || this._parseRuleSetDeclaration();\n  };\n\n  LESSParser.prototype._parseVariable = function () {\n    if (!this.peekDelim('@') && !this.peekDelim('$') && !this.peek(TokenType.AtKeyword)) {\n      return null;\n    }\n\n    var node = this.create(nodes.Variable);\n    var mark = this.mark();\n\n    while (this.acceptDelim('@') || this.acceptDelim('$')) {\n      if (this.hasWhitespace()) {\n        this.restoreAtMark(mark);\n        return null;\n      }\n    }\n\n    if (!this.accept(TokenType.AtKeyword) && !this.accept(TokenType.Ident)) {\n      this.restoreAtMark(mark);\n      return null;\n    }\n\n    return node;\n  };\n\n  LESSParser.prototype._parseTerm = function () {\n    var term = _super.prototype._parseTerm.call(this);\n\n    if (term) {\n      return term;\n    }\n\n    term = this.create(nodes.Term);\n\n    if (term.setExpression(this._parseVariable()) || term.setExpression(this._parseEscaped()) || term.setExpression(this._tryParseMixinReference())) {\n      return this.finish(term);\n    }\n\n    return null;\n  };\n\n  LESSParser.prototype._parseEscaped = function () {\n    if (this.peek(TokenType.EscapedJavaScript) || this.peek(TokenType.BadEscapedJavaScript)) {\n      var node = this.createNode(nodes.NodeType.EscapedValue);\n      this.consumeToken();\n      return this.finish(node);\n    }\n\n    if (this.peekDelim('~')) {\n      var node = this.createNode(nodes.NodeType.EscapedValue);\n      this.consumeToken();\n\n      if (this.accept(TokenType.String) || this.accept(TokenType.EscapedJavaScript)) {\n        return this.finish(node);\n      } else {\n        return this.finish(node, ParseError.TermExpected);\n      }\n    }\n\n    return null;\n  };\n\n  LESSParser.prototype._parseOperator = function () {\n    var node = this._parseGuardOperator();\n\n    if (node) {\n      return node;\n    } else {\n      return _super.prototype._parseOperator.call(this);\n    }\n  };\n\n  LESSParser.prototype._parseGuardOperator = function () {\n    if (this.peekDelim('>')) {\n      var node = this.createNode(nodes.NodeType.Operator);\n      this.consumeToken();\n      this.acceptDelim('=');\n      return node;\n    } else if (this.peekDelim('=')) {\n      var node = this.createNode(nodes.NodeType.Operator);\n      this.consumeToken();\n      this.acceptDelim('<');\n      return node;\n    } else if (this.peekDelim('<')) {\n      var node = this.createNode(nodes.NodeType.Operator);\n      this.consumeToken();\n      this.acceptDelim('=');\n      return node;\n    }\n\n    return null;\n  };\n\n  LESSParser.prototype._parseRuleSetDeclaration = function () {\n    if (this.peek(TokenType.AtKeyword)) {\n      return this._parseKeyframe() || this._parseMedia(true) || this._parseImport() || this._parseSupports(true) // @supports\n      || this._parseDetachedRuleSetMixin() // less detached ruleset mixin\n      || this._parseVariableDeclaration() // Variable declarations\n      || this._parseUnknownAtRule();\n    }\n\n    return this._tryParseMixinDeclaration() || this._tryParseRuleset(true) // nested ruleset\n    || this._tryParseMixinReference() // less mixin reference\n    || this._parseFunction() || this._parseExtend() // less extend declaration\n    || _super.prototype._parseRuleSetDeclaration.call(this); // try css ruleset declaration as the last option\n  };\n\n  LESSParser.prototype._parseKeyframeIdent = function () {\n    return this._parseIdent([nodes.ReferenceType.Keyframe]) || this._parseVariable();\n  };\n\n  LESSParser.prototype._parseKeyframeSelector = function () {\n    return this._parseDetachedRuleSetMixin() // less detached ruleset mixin\n    || _super.prototype._parseKeyframeSelector.call(this);\n  };\n\n  LESSParser.prototype._parseSimpleSelectorBody = function () {\n    return this._parseSelectorCombinator() || _super.prototype._parseSimpleSelectorBody.call(this);\n  };\n\n  LESSParser.prototype._parseSelector = function (isNested) {\n    // CSS Guards\n    var node = this.create(nodes.Selector);\n    var hasContent = false;\n\n    if (isNested) {\n      // nested selectors can start with a combinator\n      hasContent = node.addChild(this._parseCombinator());\n    }\n\n    while (node.addChild(this._parseSimpleSelector())) {\n      hasContent = true;\n      var mark = this.mark();\n\n      if (node.addChild(this._parseGuard()) && this.peek(TokenType.CurlyL)) {\n        break;\n      }\n\n      this.restoreAtMark(mark);\n      node.addChild(this._parseCombinator()); // optional\n    }\n\n    return hasContent ? this.finish(node) : null;\n  };\n\n  LESSParser.prototype._parseSelectorCombinator = function () {\n    if (this.peekDelim('&')) {\n      var node = this.createNode(nodes.NodeType.SelectorCombinator);\n      this.consumeToken();\n\n      while (!this.hasWhitespace() && (this.acceptDelim('-') || this.accept(TokenType.Num) || this.accept(TokenType.Dimension) || node.addChild(this._parseIdent()) || this.acceptDelim('&'))) {//  support &-foo\n      }\n\n      return this.finish(node);\n    }\n\n    return null;\n  };\n\n  LESSParser.prototype._parseSelectorIdent = function () {\n    if (!this.peekInterpolatedIdent()) {\n      return null;\n    }\n\n    var node = this.createNode(nodes.NodeType.SelectorInterpolation);\n\n    var hasContent = this._acceptInterpolatedIdent(node);\n\n    return hasContent ? this.finish(node) : null;\n  };\n\n  LESSParser.prototype._parsePropertyIdentifier = function () {\n    if (!this.peekInterpolatedIdent()) {\n      return null;\n    }\n\n    var node = this.create(nodes.Identifier);\n    node.isCustomProperty = this.peekRegExp(TokenType.Ident, /^--/);\n\n    var hasContent = this._acceptInterpolatedIdent(node);\n\n    if (hasContent && !this.hasWhitespace()) {\n      this.acceptDelim('+');\n\n      if (!this.hasWhitespace()) {\n        this.acceptIdent('_');\n      }\n    }\n\n    return hasContent ? this.finish(node) : null;\n  };\n\n  LESSParser.prototype.peekInterpolatedIdent = function () {\n    return this.peek(TokenType.Ident) || this.peekDelim('@') || this.peekDelim('$') || this.peekDelim('-');\n  };\n\n  LESSParser.prototype._acceptInterpolatedIdent = function (node) {\n    var _this = this;\n\n    var hasContent = false;\n\n    var indentInterpolation = function () {\n      var pos = _this.mark();\n\n      if (_this.acceptDelim('-')) {\n        if (!_this.hasWhitespace()) {\n          _this.acceptDelim('-');\n        }\n\n        if (_this.hasWhitespace()) {\n          _this.restoreAtMark(pos);\n\n          return null;\n        }\n      }\n\n      return _this._parseInterpolation();\n    };\n\n    while (this.accept(TokenType.Ident) || node.addChild(indentInterpolation()) || hasContent && (this.acceptDelim('-') || this.accept(TokenType.Num))) {\n      hasContent = true;\n\n      if (this.hasWhitespace()) {\n        break;\n      }\n    }\n\n    return hasContent;\n  };\n\n  LESSParser.prototype._parseInterpolation = function () {\n    // @{name} Variable or \n    // ${name} Property\n    var mark = this.mark();\n\n    if (this.peekDelim('@') || this.peekDelim('$')) {\n      var node = this.createNode(nodes.NodeType.Interpolation);\n      this.consumeToken();\n\n      if (this.hasWhitespace() || !this.accept(TokenType.CurlyL)) {\n        this.restoreAtMark(mark);\n        return null;\n      }\n\n      if (!node.addChild(this._parseIdent())) {\n        return this.finish(node, ParseError.IdentifierExpected);\n      }\n\n      if (!this.accept(TokenType.CurlyR)) {\n        return this.finish(node, ParseError.RightCurlyExpected);\n      }\n\n      return this.finish(node);\n    }\n\n    return null;\n  };\n\n  LESSParser.prototype._tryParseMixinDeclaration = function () {\n    var mark = this.mark();\n    var node = this.create(nodes.MixinDeclaration);\n\n    if (!node.setIdentifier(this._parseMixinDeclarationIdentifier()) || !this.accept(TokenType.ParenthesisL)) {\n      this.restoreAtMark(mark);\n      return null;\n    }\n\n    if (node.getParameters().addChild(this._parseMixinParameter())) {\n      while (this.accept(TokenType.Comma) || this.accept(TokenType.SemiColon)) {\n        if (this.peek(TokenType.ParenthesisR)) {\n          break;\n        }\n\n        if (!node.getParameters().addChild(this._parseMixinParameter())) {\n          this.markError(node, ParseError.IdentifierExpected, [], [TokenType.ParenthesisR]);\n        }\n      }\n    }\n\n    if (!this.accept(TokenType.ParenthesisR)) {\n      this.restoreAtMark(mark);\n      return null;\n    }\n\n    node.setGuard(this._parseGuard());\n\n    if (!this.peek(TokenType.CurlyL)) {\n      this.restoreAtMark(mark);\n      return null;\n    }\n\n    return this._parseBody(node, this._parseMixInBodyDeclaration.bind(this));\n  };\n\n  LESSParser.prototype._parseMixInBodyDeclaration = function () {\n    return this._parseFontFace() || this._parseRuleSetDeclaration();\n  };\n\n  LESSParser.prototype._parseMixinDeclarationIdentifier = function () {\n    var identifier;\n\n    if (this.peekDelim('#') || this.peekDelim('.')) {\n      identifier = this.create(nodes.Identifier);\n      this.consumeToken(); // # or .\n\n      if (this.hasWhitespace() || !identifier.addChild(this._parseIdent())) {\n        return null;\n      }\n    } else if (this.peek(TokenType.Hash)) {\n      identifier = this.create(nodes.Identifier);\n      this.consumeToken(); // TokenType.Hash\n    } else {\n      return null;\n    }\n\n    identifier.referenceTypes = [nodes.ReferenceType.Mixin];\n    return this.finish(identifier);\n  };\n\n  LESSParser.prototype._parsePseudo = function () {\n    if (!this.peek(TokenType.Colon)) {\n      return null;\n    }\n\n    var mark = this.mark();\n    var node = this.create(nodes.ExtendsReference);\n    this.consumeToken(); // :\n\n    if (this.acceptIdent('extend')) {\n      return this._completeExtends(node);\n    }\n\n    this.restoreAtMark(mark);\n    return _super.prototype._parsePseudo.call(this);\n  };\n\n  LESSParser.prototype._parseExtend = function () {\n    if (!this.peekDelim('&')) {\n      return null;\n    }\n\n    var mark = this.mark();\n    var node = this.create(nodes.ExtendsReference);\n    this.consumeToken(); // &\n\n    if (this.hasWhitespace() || !this.accept(TokenType.Colon) || !this.acceptIdent('extend')) {\n      this.restoreAtMark(mark);\n      return null;\n    }\n\n    return this._completeExtends(node);\n  };\n\n  LESSParser.prototype._completeExtends = function (node) {\n    if (!this.accept(TokenType.ParenthesisL)) {\n      return this.finish(node, ParseError.LeftParenthesisExpected);\n    }\n\n    var selectors = node.getSelectors();\n\n    if (!selectors.addChild(this._parseSelector(true))) {\n      return this.finish(node, ParseError.SelectorExpected);\n    }\n\n    while (this.accept(TokenType.Comma)) {\n      if (!selectors.addChild(this._parseSelector(true))) {\n        return this.finish(node, ParseError.SelectorExpected);\n      }\n    }\n\n    if (!this.accept(TokenType.ParenthesisR)) {\n      return this.finish(node, ParseError.RightParenthesisExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  LESSParser.prototype._parseDetachedRuleSetMixin = function () {\n    if (!this.peek(TokenType.AtKeyword)) {\n      return null;\n    }\n\n    var mark = this.mark();\n    var node = this.create(nodes.MixinReference);\n\n    if (node.addChild(this._parseVariable()) && (this.hasWhitespace() || !this.accept(TokenType.ParenthesisL))) {\n      this.restoreAtMark(mark);\n      return null;\n    }\n\n    if (!this.accept(TokenType.ParenthesisR)) {\n      return this.finish(node, ParseError.RightParenthesisExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  LESSParser.prototype._tryParseMixinReference = function () {\n    var mark = this.mark();\n    var node = this.create(nodes.MixinReference);\n\n    var identifier = this._parseMixinDeclarationIdentifier();\n\n    while (identifier) {\n      this.acceptDelim('>');\n\n      var nextId = this._parseMixinDeclarationIdentifier();\n\n      if (nextId) {\n        node.getNamespaces().addChild(identifier);\n        identifier = nextId;\n      } else {\n        break;\n      }\n    }\n\n    if (!node.setIdentifier(identifier)) {\n      this.restoreAtMark(mark);\n      return null;\n    }\n\n    var hasArguments = false;\n\n    if (!this.hasWhitespace() && this.accept(TokenType.ParenthesisL)) {\n      hasArguments = true;\n\n      if (node.getArguments().addChild(this._parseMixinArgument())) {\n        while (this.accept(TokenType.Comma) || this.accept(TokenType.SemiColon)) {\n          if (this.peek(TokenType.ParenthesisR)) {\n            break;\n          }\n\n          if (!node.getArguments().addChild(this._parseMixinArgument())) {\n            return this.finish(node, ParseError.ExpressionExpected);\n          }\n        }\n      }\n\n      if (!this.accept(TokenType.ParenthesisR)) {\n        return this.finish(node, ParseError.RightParenthesisExpected);\n      }\n\n      identifier.referenceTypes = [nodes.ReferenceType.Mixin];\n    } else {\n      identifier.referenceTypes = [nodes.ReferenceType.Mixin, nodes.ReferenceType.Rule];\n    }\n\n    node.addChild(this._parsePrio());\n\n    if (!hasArguments && !this.peek(TokenType.SemiColon) && !this.peek(TokenType.CurlyR) && !this.peek(TokenType.EOF)) {\n      this.restoreAtMark(mark);\n      return null;\n    }\n\n    return this.finish(node);\n  };\n\n  LESSParser.prototype._parseMixinArgument = function () {\n    // [variableName ':'] expression | variableName '...'\n    var node = this.create(nodes.FunctionArgument);\n    var pos = this.mark();\n\n    var argument = this._parseVariable();\n\n    if (argument) {\n      if (!this.accept(TokenType.Colon)) {\n        this.restoreAtMark(pos);\n      } else {\n        node.setIdentifier(argument);\n      }\n    }\n\n    if (node.setValue(this._parseDetachedRuleSet() || this._parseExpr(true))) {\n      return this.finish(node);\n    }\n\n    this.restoreAtMark(pos);\n    return null;\n  };\n\n  LESSParser.prototype._parseMixinParameter = function () {\n    var node = this.create(nodes.FunctionParameter); // special rest variable: @rest...\n\n    if (this.peekKeyword('@rest')) {\n      var restNode = this.create(nodes.Node);\n      this.consumeToken();\n\n      if (!this.accept(lessScanner.Ellipsis)) {\n        return this.finish(node, ParseError.DotExpected, [], [TokenType.Comma, TokenType.ParenthesisR]);\n      }\n\n      node.setIdentifier(this.finish(restNode));\n      return this.finish(node);\n    } // special const args: ...\n\n\n    if (this.peek(lessScanner.Ellipsis)) {\n      var varargsNode = this.create(nodes.Node);\n      this.consumeToken();\n      node.setIdentifier(this.finish(varargsNode));\n      return this.finish(node);\n    }\n\n    var hasContent = false; // default variable declaration: @param: 12 or @name\n\n    if (node.setIdentifier(this._parseVariable())) {\n      this.accept(TokenType.Colon);\n      hasContent = true;\n    }\n\n    if (!node.setDefaultValue(this._parseDetachedRuleSet() || this._parseExpr(true)) && !hasContent) {\n      return null;\n    }\n\n    return this.finish(node);\n  };\n\n  LESSParser.prototype._parseGuard = function () {\n    if (!this.peekIdent('when')) {\n      return null;\n    }\n\n    var node = this.create(nodes.LessGuard);\n    this.consumeToken(); // when\n\n    node.isNegated = this.acceptIdent('not');\n\n    if (!node.getConditions().addChild(this._parseGuardCondition())) {\n      return this.finish(node, ParseError.ConditionExpected);\n    }\n\n    while (this.acceptIdent('and') || this.accept(TokenType.Comma)) {\n      if (!node.getConditions().addChild(this._parseGuardCondition())) {\n        return this.finish(node, ParseError.ConditionExpected);\n      }\n    }\n\n    return this.finish(node);\n  };\n\n  LESSParser.prototype._parseGuardCondition = function () {\n    if (!this.peek(TokenType.ParenthesisL)) {\n      return null;\n    }\n\n    var node = this.create(nodes.GuardCondition);\n    this.consumeToken(); // ParenthesisL\n\n    if (!node.addChild(this._parseExpr())) {// empty (?)\n    }\n\n    if (!this.accept(TokenType.ParenthesisR)) {\n      return this.finish(node, ParseError.RightParenthesisExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  LESSParser.prototype._parseFunction = function () {\n    var pos = this.mark();\n    var node = this.create(nodes.Function);\n\n    if (!node.setIdentifier(this._parseFunctionIdentifier())) {\n      return null;\n    }\n\n    if (this.hasWhitespace() || !this.accept(TokenType.ParenthesisL)) {\n      this.restoreAtMark(pos);\n      return null;\n    }\n\n    if (node.getArguments().addChild(this._parseMixinArgument())) {\n      while (this.accept(TokenType.Comma) || this.accept(TokenType.SemiColon)) {\n        if (this.peek(TokenType.ParenthesisR)) {\n          break;\n        }\n\n        if (!node.getArguments().addChild(this._parseMixinArgument())) {\n          return this.finish(node, ParseError.ExpressionExpected);\n        }\n      }\n    }\n\n    if (!this.accept(TokenType.ParenthesisR)) {\n      return this.finish(node, ParseError.RightParenthesisExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  LESSParser.prototype._parseFunctionIdentifier = function () {\n    if (this.peekDelim('%')) {\n      var node = this.create(nodes.Identifier);\n      node.referenceTypes = [nodes.ReferenceType.Function];\n      this.consumeToken();\n      return this.finish(node);\n    }\n\n    return _super.prototype._parseFunctionIdentifier.call(this);\n  };\n\n  LESSParser.prototype._parseURLArgument = function () {\n    var pos = this.mark();\n\n    var node = _super.prototype._parseURLArgument.call(this);\n\n    if (!node || !this.peek(TokenType.ParenthesisR)) {\n      this.restoreAtMark(pos);\n      var node_2 = this.create(nodes.Node);\n      node_2.addChild(this._parseBinaryExpr());\n      return this.finish(node_2);\n    }\n\n    return node;\n  };\n\n  return LESSParser;\n}(cssParser.Parser);\n\nexport { LESSParser };","map":null,"metadata":{},"sourceType":"module"}