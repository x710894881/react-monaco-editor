{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport './splitview.css';\nimport { toDisposable, Disposable, combinedDisposable } from '../../../common/lifecycle.js';\nimport { Event, Emitter } from '../../../common/event.js';\nimport * as types from '../../../common/types.js';\nimport * as dom from '../../dom.js';\nimport { clamp } from '../../../common/numbers.js';\nimport { range, firstIndex, pushToStart, pushToEnd } from '../../../common/arrays.js';\nimport { Sash } from '../sash/sash.js';\nimport { Color } from '../../../common/color.js';\nimport { domEvent } from '../../event.js';\nvar defaultStyles = {\n  separatorBorder: Color.transparent\n};\n\nvar ViewItem =\n/** @class */\nfunction () {\n  function ViewItem(container, view, size, disposable) {\n    this.container = container;\n    this.view = view;\n    this.disposable = disposable;\n    this._cachedVisibleSize = undefined;\n\n    if (typeof size === 'number') {\n      this._size = size;\n      this._cachedVisibleSize = undefined;\n      dom.addClass(container, 'visible');\n    } else {\n      this._size = 0;\n      this._cachedVisibleSize = size.cachedVisibleSize;\n    }\n  }\n\n  Object.defineProperty(ViewItem.prototype, \"size\", {\n    get: function () {\n      return this._size;\n    },\n    set: function (size) {\n      this._size = size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ViewItem.prototype, \"visible\", {\n    get: function () {\n      return typeof this._cachedVisibleSize === 'undefined';\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ViewItem.prototype.setVisible = function (visible, size) {\n    if (visible === this.visible) {\n      return;\n    }\n\n    if (visible) {\n      this.size = clamp(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize);\n      this._cachedVisibleSize = undefined;\n    } else {\n      this._cachedVisibleSize = typeof size === 'number' ? size : this.size;\n      this.size = 0;\n    }\n\n    dom.toggleClass(this.container, 'visible', visible);\n\n    if (this.view.setVisible) {\n      this.view.setVisible(visible);\n    }\n  };\n\n  Object.defineProperty(ViewItem.prototype, \"minimumSize\", {\n    get: function () {\n      return this.visible ? this.view.minimumSize : 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ViewItem.prototype, \"viewMinimumSize\", {\n    get: function () {\n      return this.view.minimumSize;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ViewItem.prototype, \"maximumSize\", {\n    get: function () {\n      return this.visible ? this.view.maximumSize : 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ViewItem.prototype, \"viewMaximumSize\", {\n    get: function () {\n      return this.view.maximumSize;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ViewItem.prototype, \"priority\", {\n    get: function () {\n      return this.view.priority;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ViewItem.prototype, \"snap\", {\n    get: function () {\n      return !!this.view.snap;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ViewItem.prototype.layout = function (orthogonalSize) {\n    this.view.layout(this.size, orthogonalSize);\n  };\n\n  ViewItem.prototype.dispose = function () {\n    this.disposable.dispose();\n    return this.view;\n  };\n\n  return ViewItem;\n}();\n\nvar VerticalViewItem =\n/** @class */\nfunction (_super) {\n  __extends(VerticalViewItem, _super);\n\n  function VerticalViewItem() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  VerticalViewItem.prototype.layout = function (orthogonalSize) {\n    _super.prototype.layout.call(this, orthogonalSize);\n\n    this.container.style.height = this.size + \"px\";\n  };\n\n  return VerticalViewItem;\n}(ViewItem);\n\nvar HorizontalViewItem =\n/** @class */\nfunction (_super) {\n  __extends(HorizontalViewItem, _super);\n\n  function HorizontalViewItem() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  HorizontalViewItem.prototype.layout = function (orthogonalSize) {\n    _super.prototype.layout.call(this, orthogonalSize);\n\n    this.container.style.width = this.size + \"px\";\n  };\n\n  return HorizontalViewItem;\n}(ViewItem);\n\nvar State;\n\n(function (State) {\n  State[State[\"Idle\"] = 0] = \"Idle\";\n  State[State[\"Busy\"] = 1] = \"Busy\";\n})(State || (State = {}));\n\nexport var Sizing;\n\n(function (Sizing) {\n  Sizing.Distribute = {\n    type: 'distribute'\n  };\n\n  function Split(index) {\n    return {\n      type: 'split',\n      index: index\n    };\n  }\n\n  Sizing.Split = Split;\n\n  function Invisible(cachedVisibleSize) {\n    return {\n      type: 'invisible',\n      cachedVisibleSize: cachedVisibleSize\n    };\n  }\n\n  Sizing.Invisible = Invisible;\n})(Sizing || (Sizing = {}));\n\nvar SplitView =\n/** @class */\nfunction (_super) {\n  __extends(SplitView, _super);\n\n  function SplitView(container, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.size = 0;\n    _this.contentSize = 0;\n    _this.proportions = undefined;\n    _this.viewItems = [];\n    _this.sashItems = [];\n    _this.state = State.Idle;\n    _this._onDidSashChange = _this._register(new Emitter());\n    _this.onDidSashChange = _this._onDidSashChange.event;\n    _this._onDidSashReset = _this._register(new Emitter());\n    _this.orientation = types.isUndefined(options.orientation) ? 0\n    /* VERTICAL */\n    : options.orientation;\n    _this.inverseAltBehavior = !!options.inverseAltBehavior;\n    _this.proportionalLayout = types.isUndefined(options.proportionalLayout) ? true : !!options.proportionalLayout;\n    _this.el = document.createElement('div');\n    dom.addClass(_this.el, 'monaco-split-view2');\n    dom.addClass(_this.el, _this.orientation === 0\n    /* VERTICAL */\n    ? 'vertical' : 'horizontal');\n    container.appendChild(_this.el);\n    _this.sashContainer = dom.append(_this.el, dom.$('.sash-container'));\n    _this.viewContainer = dom.append(_this.el, dom.$('.split-view-container'));\n\n    _this.style(options.styles || defaultStyles); // We have an existing set of view, add them now\n\n\n    if (options.descriptor) {\n      _this.size = options.descriptor.size;\n      options.descriptor.views.forEach(function (viewDescriptor, index) {\n        var sizing = types.isUndefined(viewDescriptor.visible) || viewDescriptor.visible ? viewDescriptor.size : {\n          type: 'invisible',\n          cachedVisibleSize: viewDescriptor.size\n        };\n        var view = viewDescriptor.view;\n\n        _this.doAddView(view, sizing, index, true);\n      }); // Initialize content size and proportions for first layout\n\n      _this.contentSize = _this.viewItems.reduce(function (r, i) {\n        return r + i.size;\n      }, 0);\n\n      _this.saveProportions();\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(SplitView.prototype, \"orthogonalStartSash\", {\n    get: function () {\n      return this._orthogonalStartSash;\n    },\n    set: function (sash) {\n      for (var _i = 0, _a = this.sashItems; _i < _a.length; _i++) {\n        var sashItem = _a[_i];\n        sashItem.sash.orthogonalStartSash = sash;\n      }\n\n      this._orthogonalStartSash = sash;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SplitView.prototype, \"orthogonalEndSash\", {\n    get: function () {\n      return this._orthogonalEndSash;\n    },\n    set: function (sash) {\n      for (var _i = 0, _a = this.sashItems; _i < _a.length; _i++) {\n        var sashItem = _a[_i];\n        sashItem.sash.orthogonalEndSash = sash;\n      }\n\n      this._orthogonalEndSash = sash;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SplitView.prototype.style = function (styles) {\n    if (styles.separatorBorder.isTransparent()) {\n      dom.removeClass(this.el, 'separator-border');\n      this.el.style.removeProperty('--separator-border');\n    } else {\n      dom.addClass(this.el, 'separator-border');\n      this.el.style.setProperty('--separator-border', styles.separatorBorder.toString());\n    }\n  };\n\n  SplitView.prototype.addView = function (view, size, index) {\n    if (index === void 0) {\n      index = this.viewItems.length;\n    }\n\n    this.doAddView(view, size, index, false);\n  };\n\n  SplitView.prototype.layout = function (size, orthogonalSize) {\n    var _this = this;\n\n    var previousSize = Math.max(this.size, this.contentSize);\n    this.size = size;\n    this.orthogonalSize = orthogonalSize;\n\n    if (!this.proportions) {\n      var indexes = range(this.viewItems.length);\n      var lowPriorityIndexes = indexes.filter(function (i) {\n        return _this.viewItems[i].priority === 1\n        /* Low */\n        ;\n      });\n      var highPriorityIndexes = indexes.filter(function (i) {\n        return _this.viewItems[i].priority === 2\n        /* High */\n        ;\n      });\n      this.resize(this.viewItems.length - 1, size - previousSize, undefined, lowPriorityIndexes, highPriorityIndexes);\n    } else {\n      for (var i = 0; i < this.viewItems.length; i++) {\n        var item = this.viewItems[i];\n        item.size = clamp(Math.round(this.proportions[i] * size), item.minimumSize, item.maximumSize);\n      }\n    }\n\n    this.distributeEmptySpace();\n    this.layoutViews();\n  };\n\n  SplitView.prototype.saveProportions = function () {\n    var _this = this;\n\n    if (this.proportionalLayout && this.contentSize > 0) {\n      this.proportions = this.viewItems.map(function (i) {\n        return i.size / _this.contentSize;\n      });\n    }\n  };\n\n  SplitView.prototype.onSashStart = function (_a) {\n    var _this = this;\n\n    var sash = _a.sash,\n        start = _a.start,\n        alt = _a.alt;\n    var index = firstIndex(this.sashItems, function (item) {\n      return item.sash === sash;\n    }); // This way, we can press Alt while we resize a sash, macOS style!\n\n    var disposable = combinedDisposable(domEvent(document.body, 'keydown')(function (e) {\n      return resetSashDragState(_this.sashDragState.current, e.altKey);\n    }), domEvent(document.body, 'keyup')(function () {\n      return resetSashDragState(_this.sashDragState.current, false);\n    }));\n\n    var resetSashDragState = function (start, alt) {\n      var sizes = _this.viewItems.map(function (i) {\n        return i.size;\n      });\n\n      var minDelta = Number.NEGATIVE_INFINITY;\n      var maxDelta = Number.POSITIVE_INFINITY;\n\n      if (_this.inverseAltBehavior) {\n        alt = !alt;\n      }\n\n      if (alt) {\n        // When we're using the last sash with Alt, we're resizing\n        // the view to the left/up, instead of right/down as usual\n        // Thus, we must do the inverse of the usual\n        var isLastSash = index === _this.sashItems.length - 1;\n\n        if (isLastSash) {\n          var viewItem = _this.viewItems[index];\n          minDelta = (viewItem.minimumSize - viewItem.size) / 2;\n          maxDelta = (viewItem.maximumSize - viewItem.size) / 2;\n        } else {\n          var viewItem = _this.viewItems[index + 1];\n          minDelta = (viewItem.size - viewItem.maximumSize) / 2;\n          maxDelta = (viewItem.size - viewItem.minimumSize) / 2;\n        }\n      }\n\n      var snapBefore;\n      var snapAfter;\n\n      if (!alt) {\n        var upIndexes = range(index, -1);\n        var downIndexes = range(index + 1, _this.viewItems.length);\n        var minDeltaUp = upIndexes.reduce(function (r, i) {\n          return r + (_this.viewItems[i].minimumSize - sizes[i]);\n        }, 0);\n        var maxDeltaUp = upIndexes.reduce(function (r, i) {\n          return r + (_this.viewItems[i].viewMaximumSize - sizes[i]);\n        }, 0);\n        var maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce(function (r, i) {\n          return r + (sizes[i] - _this.viewItems[i].minimumSize);\n        }, 0);\n        var minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce(function (r, i) {\n          return r + (sizes[i] - _this.viewItems[i].viewMaximumSize);\n        }, 0);\n        var minDelta_1 = Math.max(minDeltaUp, minDeltaDown);\n        var maxDelta_1 = Math.min(maxDeltaDown, maxDeltaUp);\n\n        var snapBeforeIndex = _this.findFirstSnapIndex(upIndexes);\n\n        var snapAfterIndex = _this.findFirstSnapIndex(downIndexes);\n\n        if (typeof snapBeforeIndex === 'number') {\n          var viewItem = _this.viewItems[snapBeforeIndex];\n          var halfSize = Math.floor(viewItem.viewMinimumSize / 2);\n          snapBefore = {\n            index: snapBeforeIndex,\n            limitDelta: viewItem.visible ? minDelta_1 - halfSize : minDelta_1 + halfSize,\n            size: viewItem.size\n          };\n        }\n\n        if (typeof snapAfterIndex === 'number') {\n          var viewItem = _this.viewItems[snapAfterIndex];\n          var halfSize = Math.floor(viewItem.viewMinimumSize / 2);\n          snapAfter = {\n            index: snapAfterIndex,\n            limitDelta: viewItem.visible ? maxDelta_1 + halfSize : maxDelta_1 - halfSize,\n            size: viewItem.size\n          };\n        }\n      }\n\n      _this.sashDragState = {\n        start: start,\n        current: start,\n        index: index,\n        sizes: sizes,\n        minDelta: minDelta,\n        maxDelta: maxDelta,\n        alt: alt,\n        snapBefore: snapBefore,\n        snapAfter: snapAfter,\n        disposable: disposable\n      };\n    };\n\n    resetSashDragState(start, alt);\n  };\n\n  SplitView.prototype.onSashChange = function (_a) {\n    var current = _a.current;\n    var _b = this.sashDragState,\n        index = _b.index,\n        start = _b.start,\n        sizes = _b.sizes,\n        alt = _b.alt,\n        minDelta = _b.minDelta,\n        maxDelta = _b.maxDelta,\n        snapBefore = _b.snapBefore,\n        snapAfter = _b.snapAfter;\n    this.sashDragState.current = current;\n    var delta = current - start;\n    var newDelta = this.resize(index, delta, sizes, undefined, undefined, minDelta, maxDelta, snapBefore, snapAfter);\n\n    if (alt) {\n      var isLastSash = index === this.sashItems.length - 1;\n      var newSizes = this.viewItems.map(function (i) {\n        return i.size;\n      });\n      var viewItemIndex = isLastSash ? index : index + 1;\n      var viewItem = this.viewItems[viewItemIndex];\n      var newMinDelta = viewItem.size - viewItem.maximumSize;\n      var newMaxDelta = viewItem.size - viewItem.minimumSize;\n      var resizeIndex = isLastSash ? index - 1 : index + 1;\n      this.resize(resizeIndex, -newDelta, newSizes, undefined, undefined, newMinDelta, newMaxDelta);\n    }\n\n    this.distributeEmptySpace();\n    this.layoutViews();\n  };\n\n  SplitView.prototype.onSashEnd = function (index) {\n    this._onDidSashChange.fire(index);\n\n    this.sashDragState.disposable.dispose();\n    this.saveProportions();\n  };\n\n  SplitView.prototype.onViewChange = function (item, size) {\n    var index = this.viewItems.indexOf(item);\n\n    if (index < 0 || index >= this.viewItems.length) {\n      return;\n    }\n\n    size = typeof size === 'number' ? size : item.size;\n    size = clamp(size, item.minimumSize, item.maximumSize);\n\n    if (this.inverseAltBehavior && index > 0) {\n      // In this case, we want the view to grow or shrink both sides equally\n      // so we just resize the \"left\" side by half and let `resize` do the clamping magic\n      this.resize(index - 1, Math.floor((item.size - size) / 2));\n      this.distributeEmptySpace();\n      this.layoutViews();\n    } else {\n      item.size = size;\n      this.relayout([index], undefined);\n    }\n  };\n\n  SplitView.prototype.resizeView = function (index, size) {\n    var _this = this;\n\n    if (this.state !== State.Idle) {\n      throw new Error('Cant modify splitview');\n    }\n\n    this.state = State.Busy;\n\n    if (index < 0 || index >= this.viewItems.length) {\n      return;\n    }\n\n    var indexes = range(this.viewItems.length).filter(function (i) {\n      return i !== index;\n    });\n    var lowPriorityIndexes = indexes.filter(function (i) {\n      return _this.viewItems[i].priority === 1\n      /* Low */\n      ;\n    }).concat([index]);\n    var highPriorityIndexes = indexes.filter(function (i) {\n      return _this.viewItems[i].priority === 2\n      /* High */\n      ;\n    });\n    var item = this.viewItems[index];\n    size = Math.round(size);\n    size = clamp(size, item.minimumSize, Math.min(item.maximumSize, this.size));\n    item.size = size;\n    this.relayout(lowPriorityIndexes, highPriorityIndexes);\n    this.state = State.Idle;\n  };\n\n  SplitView.prototype.distributeViewSizes = function () {\n    var _this = this;\n\n    var flexibleViewItems = [];\n    var flexibleSize = 0;\n\n    for (var _i = 0, _a = this.viewItems; _i < _a.length; _i++) {\n      var item = _a[_i];\n\n      if (item.maximumSize - item.minimumSize > 0) {\n        flexibleViewItems.push(item);\n        flexibleSize += item.size;\n      }\n    }\n\n    var size = Math.floor(flexibleSize / flexibleViewItems.length);\n\n    for (var _b = 0, flexibleViewItems_1 = flexibleViewItems; _b < flexibleViewItems_1.length; _b++) {\n      var item = flexibleViewItems_1[_b];\n      item.size = clamp(size, item.minimumSize, item.maximumSize);\n    }\n\n    var indexes = range(this.viewItems.length);\n    var lowPriorityIndexes = indexes.filter(function (i) {\n      return _this.viewItems[i].priority === 1\n      /* Low */\n      ;\n    });\n    var highPriorityIndexes = indexes.filter(function (i) {\n      return _this.viewItems[i].priority === 2\n      /* High */\n      ;\n    });\n    this.relayout(lowPriorityIndexes, highPriorityIndexes);\n  };\n\n  SplitView.prototype.getViewSize = function (index) {\n    if (index < 0 || index >= this.viewItems.length) {\n      return -1;\n    }\n\n    return this.viewItems[index].size;\n  };\n\n  SplitView.prototype.doAddView = function (view, size, index, skipLayout) {\n    var _this = this;\n\n    if (index === void 0) {\n      index = this.viewItems.length;\n    }\n\n    if (this.state !== State.Idle) {\n      throw new Error('Cant modify splitview');\n    }\n\n    this.state = State.Busy; // Add view\n\n    var container = dom.$('.split-view-view');\n\n    if (index === this.viewItems.length) {\n      this.viewContainer.appendChild(container);\n    } else {\n      this.viewContainer.insertBefore(container, this.viewContainer.children.item(index));\n    }\n\n    var onChangeDisposable = view.onDidChange(function (size) {\n      return _this.onViewChange(item, size);\n    });\n    var containerDisposable = toDisposable(function () {\n      return _this.viewContainer.removeChild(container);\n    });\n    var disposable = combinedDisposable(onChangeDisposable, containerDisposable);\n    var viewSize;\n\n    if (typeof size === 'number') {\n      viewSize = size;\n    } else if (size.type === 'split') {\n      viewSize = this.getViewSize(size.index) / 2;\n    } else if (size.type === 'invisible') {\n      viewSize = {\n        cachedVisibleSize: size.cachedVisibleSize\n      };\n    } else {\n      viewSize = view.minimumSize;\n    }\n\n    var item = this.orientation === 0\n    /* VERTICAL */\n    ? new VerticalViewItem(container, view, viewSize, disposable) : new HorizontalViewItem(container, view, viewSize, disposable);\n    this.viewItems.splice(index, 0, item); // Add sash\n\n    if (this.viewItems.length > 1) {\n      var orientation_1 = this.orientation === 0\n      /* VERTICAL */\n      ? 1\n      /* HORIZONTAL */\n      : 0\n      /* VERTICAL */\n      ;\n      var layoutProvider = this.orientation === 0\n      /* VERTICAL */\n      ? {\n        getHorizontalSashTop: function (sash) {\n          return _this.getSashPosition(sash);\n        }\n      } : {\n        getVerticalSashLeft: function (sash) {\n          return _this.getSashPosition(sash);\n        }\n      };\n      var sash_1 = new Sash(this.sashContainer, layoutProvider, {\n        orientation: orientation_1,\n        orthogonalStartSash: this.orthogonalStartSash,\n        orthogonalEndSash: this.orthogonalEndSash\n      });\n      var sashEventMapper = this.orientation === 0\n      /* VERTICAL */\n      ? function (e) {\n        return {\n          sash: sash_1,\n          start: e.startY,\n          current: e.currentY,\n          alt: e.altKey\n        };\n      } : function (e) {\n        return {\n          sash: sash_1,\n          start: e.startX,\n          current: e.currentX,\n          alt: e.altKey\n        };\n      };\n      var onStart = Event.map(sash_1.onDidStart, sashEventMapper);\n      var onStartDisposable = onStart(this.onSashStart, this);\n      var onChange = Event.map(sash_1.onDidChange, sashEventMapper);\n      var onChangeDisposable_1 = onChange(this.onSashChange, this);\n      var onEnd = Event.map(sash_1.onDidEnd, function () {\n        return firstIndex(_this.sashItems, function (item) {\n          return item.sash === sash_1;\n        });\n      });\n      var onEndDisposable = onEnd(this.onSashEnd, this);\n      var onDidResetDisposable = sash_1.onDidReset(function () {\n        var index = firstIndex(_this.sashItems, function (item) {\n          return item.sash === sash_1;\n        });\n        var upIndexes = range(index, -1);\n        var downIndexes = range(index + 1, _this.viewItems.length);\n\n        var snapBeforeIndex = _this.findFirstSnapIndex(upIndexes);\n\n        var snapAfterIndex = _this.findFirstSnapIndex(downIndexes);\n\n        if (typeof snapBeforeIndex === 'number' && !_this.viewItems[snapBeforeIndex].visible) {\n          return;\n        }\n\n        if (typeof snapAfterIndex === 'number' && !_this.viewItems[snapAfterIndex].visible) {\n          return;\n        }\n\n        _this._onDidSashReset.fire(index);\n      });\n      var disposable_1 = combinedDisposable(onStartDisposable, onChangeDisposable_1, onEndDisposable, onDidResetDisposable, sash_1);\n      var sashItem = {\n        sash: sash_1,\n        disposable: disposable_1\n      };\n      this.sashItems.splice(index - 1, 0, sashItem);\n    }\n\n    container.appendChild(view.element);\n    var highPriorityIndexes;\n\n    if (typeof size !== 'number' && size.type === 'split') {\n      highPriorityIndexes = [size.index];\n    }\n\n    if (!skipLayout) {\n      this.relayout([index], highPriorityIndexes);\n    }\n\n    this.state = State.Idle;\n\n    if (!skipLayout && typeof size !== 'number' && size.type === 'distribute') {\n      this.distributeViewSizes();\n    }\n  };\n\n  SplitView.prototype.relayout = function (lowPriorityIndexes, highPriorityIndexes) {\n    var contentSize = this.viewItems.reduce(function (r, i) {\n      return r + i.size;\n    }, 0);\n    this.resize(this.viewItems.length - 1, this.size - contentSize, undefined, lowPriorityIndexes, highPriorityIndexes);\n    this.distributeEmptySpace();\n    this.layoutViews();\n    this.saveProportions();\n  };\n\n  SplitView.prototype.resize = function (index, delta, sizes, lowPriorityIndexes, highPriorityIndexes, overloadMinDelta, overloadMaxDelta, snapBefore, snapAfter) {\n    var _this = this;\n\n    if (sizes === void 0) {\n      sizes = this.viewItems.map(function (i) {\n        return i.size;\n      });\n    }\n\n    if (overloadMinDelta === void 0) {\n      overloadMinDelta = Number.NEGATIVE_INFINITY;\n    }\n\n    if (overloadMaxDelta === void 0) {\n      overloadMaxDelta = Number.POSITIVE_INFINITY;\n    }\n\n    if (index < 0 || index >= this.viewItems.length) {\n      return 0;\n    }\n\n    var upIndexes = range(index, -1);\n    var downIndexes = range(index + 1, this.viewItems.length);\n\n    if (highPriorityIndexes) {\n      for (var _i = 0, highPriorityIndexes_1 = highPriorityIndexes; _i < highPriorityIndexes_1.length; _i++) {\n        var index_1 = highPriorityIndexes_1[_i];\n        pushToStart(upIndexes, index_1);\n        pushToStart(downIndexes, index_1);\n      }\n    }\n\n    if (lowPriorityIndexes) {\n      for (var _a = 0, lowPriorityIndexes_1 = lowPriorityIndexes; _a < lowPriorityIndexes_1.length; _a++) {\n        var index_2 = lowPriorityIndexes_1[_a];\n        pushToEnd(upIndexes, index_2);\n        pushToEnd(downIndexes, index_2);\n      }\n    }\n\n    var upItems = upIndexes.map(function (i) {\n      return _this.viewItems[i];\n    });\n    var upSizes = upIndexes.map(function (i) {\n      return sizes[i];\n    });\n    var downItems = downIndexes.map(function (i) {\n      return _this.viewItems[i];\n    });\n    var downSizes = downIndexes.map(function (i) {\n      return sizes[i];\n    });\n    var minDeltaUp = upIndexes.reduce(function (r, i) {\n      return r + (_this.viewItems[i].minimumSize - sizes[i]);\n    }, 0);\n    var maxDeltaUp = upIndexes.reduce(function (r, i) {\n      return r + (_this.viewItems[i].maximumSize - sizes[i]);\n    }, 0);\n    var maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce(function (r, i) {\n      return r + (sizes[i] - _this.viewItems[i].minimumSize);\n    }, 0);\n    var minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce(function (r, i) {\n      return r + (sizes[i] - _this.viewItems[i].maximumSize);\n    }, 0);\n    var minDelta = Math.max(minDeltaUp, minDeltaDown, overloadMinDelta);\n    var maxDelta = Math.min(maxDeltaDown, maxDeltaUp, overloadMaxDelta);\n    var snapped = false;\n\n    if (snapBefore) {\n      var snapView = this.viewItems[snapBefore.index];\n      var visible = delta >= snapBefore.limitDelta;\n      snapped = visible !== snapView.visible;\n      snapView.setVisible(visible, snapBefore.size);\n    }\n\n    if (!snapped && snapAfter) {\n      var snapView = this.viewItems[snapAfter.index];\n      var visible = delta < snapAfter.limitDelta;\n      snapped = visible !== snapView.visible;\n      snapView.setVisible(visible, snapAfter.size);\n    }\n\n    if (snapped) {\n      return this.resize(index, delta, sizes, lowPriorityIndexes, highPriorityIndexes, overloadMinDelta, overloadMaxDelta);\n    }\n\n    delta = clamp(delta, minDelta, maxDelta);\n\n    for (var i = 0, deltaUp = delta; i < upItems.length; i++) {\n      var item = upItems[i];\n      var size = clamp(upSizes[i] + deltaUp, item.minimumSize, item.maximumSize);\n      var viewDelta = size - upSizes[i];\n      deltaUp -= viewDelta;\n      item.size = size;\n    }\n\n    for (var i = 0, deltaDown = delta; i < downItems.length; i++) {\n      var item = downItems[i];\n      var size = clamp(downSizes[i] - deltaDown, item.minimumSize, item.maximumSize);\n      var viewDelta = size - downSizes[i];\n      deltaDown += viewDelta;\n      item.size = size;\n    }\n\n    return delta;\n  };\n\n  SplitView.prototype.distributeEmptySpace = function (lowPriorityIndex) {\n    var _this = this;\n\n    var contentSize = this.viewItems.reduce(function (r, i) {\n      return r + i.size;\n    }, 0);\n    var emptyDelta = this.size - contentSize;\n    var indexes = range(this.viewItems.length - 1, -1);\n    var lowPriorityIndexes = indexes.filter(function (i) {\n      return _this.viewItems[i].priority === 1\n      /* Low */\n      ;\n    });\n    var highPriorityIndexes = indexes.filter(function (i) {\n      return _this.viewItems[i].priority === 2\n      /* High */\n      ;\n    });\n\n    for (var _i = 0, highPriorityIndexes_2 = highPriorityIndexes; _i < highPriorityIndexes_2.length; _i++) {\n      var index = highPriorityIndexes_2[_i];\n      pushToStart(indexes, index);\n    }\n\n    for (var _a = 0, lowPriorityIndexes_2 = lowPriorityIndexes; _a < lowPriorityIndexes_2.length; _a++) {\n      var index = lowPriorityIndexes_2[_a];\n      pushToEnd(indexes, index);\n    }\n\n    if (typeof lowPriorityIndex === 'number') {\n      pushToEnd(indexes, lowPriorityIndex);\n    }\n\n    for (var i = 0; emptyDelta !== 0 && i < indexes.length; i++) {\n      var item = this.viewItems[indexes[i]];\n      var size = clamp(item.size + emptyDelta, item.minimumSize, item.maximumSize);\n      var viewDelta = size - item.size;\n      emptyDelta -= viewDelta;\n      item.size = size;\n    }\n  };\n\n  SplitView.prototype.layoutViews = function () {\n    var _this = this; // Save new content size\n\n\n    this.contentSize = this.viewItems.reduce(function (r, i) {\n      return r + i.size;\n    }, 0); // Layout views\n\n    this.viewItems.forEach(function (item) {\n      return item.layout(_this.orthogonalSize);\n    }); // Layout sashes\n\n    this.sashItems.forEach(function (item) {\n      return item.sash.layout();\n    }); // Update sashes enablement\n\n    var previous = false;\n    var collapsesDown = this.viewItems.map(function (i) {\n      return previous = i.size - i.minimumSize > 0 || previous;\n    });\n    previous = false;\n    var expandsDown = this.viewItems.map(function (i) {\n      return previous = i.maximumSize - i.size > 0 || previous;\n    });\n    var reverseViews = this.viewItems.slice().reverse();\n    previous = false;\n    var collapsesUp = reverseViews.map(function (i) {\n      return previous = i.size - i.minimumSize > 0 || previous;\n    }).reverse();\n    previous = false;\n    var expandsUp = reverseViews.map(function (i) {\n      return previous = i.maximumSize - i.size > 0 || previous;\n    }).reverse();\n    this.sashItems.forEach(function (_a, index) {\n      var sash = _a.sash;\n      var min = !(collapsesDown[index] && expandsUp[index + 1]);\n      var max = !(expandsDown[index] && collapsesUp[index + 1]);\n\n      if (min && max) {\n        var upIndexes = range(index, -1);\n        var downIndexes = range(index + 1, _this.viewItems.length);\n\n        var snapBeforeIndex = _this.findFirstSnapIndex(upIndexes);\n\n        var snapAfterIndex = _this.findFirstSnapIndex(downIndexes);\n\n        var snappedBefore = typeof snapBeforeIndex === 'number' && !_this.viewItems[snapBeforeIndex].visible;\n        var snappedAfter = typeof snapAfterIndex === 'number' && !_this.viewItems[snapAfterIndex].visible;\n\n        if (snappedBefore && collapsesUp[index]) {\n          sash.state = 1\n          /* Minimum */\n          ;\n        } else if (snappedAfter && collapsesDown[index]) {\n          sash.state = 2\n          /* Maximum */\n          ;\n        } else {\n          sash.state = 0\n          /* Disabled */\n          ;\n        }\n      } else if (min && !max) {\n        sash.state = 1\n        /* Minimum */\n        ;\n      } else if (!min && max) {\n        sash.state = 2\n        /* Maximum */\n        ;\n      } else {\n        sash.state = 3\n        /* Enabled */\n        ;\n      } // }\n\n    });\n  };\n\n  SplitView.prototype.getSashPosition = function (sash) {\n    var position = 0;\n\n    for (var i = 0; i < this.sashItems.length; i++) {\n      position += this.viewItems[i].size;\n\n      if (this.sashItems[i].sash === sash) {\n        return position;\n      }\n    }\n\n    return 0;\n  };\n\n  SplitView.prototype.findFirstSnapIndex = function (indexes) {\n    // visible views first\n    for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {\n      var index = indexes_1[_i];\n      var viewItem = this.viewItems[index];\n\n      if (!viewItem.visible) {\n        continue;\n      }\n\n      if (viewItem.snap) {\n        return index;\n      }\n    } // then, hidden views\n\n\n    for (var _a = 0, indexes_2 = indexes; _a < indexes_2.length; _a++) {\n      var index = indexes_2[_a];\n      var viewItem = this.viewItems[index];\n\n      if (viewItem.visible && viewItem.maximumSize - viewItem.minimumSize > 0) {\n        return undefined;\n      }\n\n      if (!viewItem.visible && viewItem.snap) {\n        return index;\n      }\n    }\n\n    return undefined;\n  };\n\n  SplitView.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.viewItems.forEach(function (i) {\n      return i.dispose();\n    });\n    this.viewItems = [];\n    this.sashItems.forEach(function (i) {\n      return i.disposable.dispose();\n    });\n    this.sashItems = [];\n  };\n\n  return SplitView;\n}(Disposable);\n\nexport { SplitView };","map":null,"metadata":{},"sourceType":"module"}