{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isObject, isUndefinedOrNull, isArray } from './types.js';\nexport function deepClone(obj) {\n  if (!obj || typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (obj instanceof RegExp) {\n    // See https://github.com/Microsoft/TypeScript/issues/10990\n    return obj;\n  }\n\n  var result = Array.isArray(obj) ? [] : {};\n  Object.keys(obj).forEach(function (key) {\n    if (obj[key] && typeof obj[key] === 'object') {\n      result[key] = deepClone(obj[key]);\n    } else {\n      result[key] = obj[key];\n    }\n  });\n  return result;\n}\nexport function deepFreeze(obj) {\n  if (!obj || typeof obj !== 'object') {\n    return obj;\n  }\n\n  var stack = [obj];\n\n  while (stack.length > 0) {\n    var obj_1 = stack.shift();\n    Object.freeze(obj_1);\n\n    for (var key in obj_1) {\n      if (_hasOwnProperty.call(obj_1, key)) {\n        var prop = obj_1[key];\n\n        if (typeof prop === 'object' && !Object.isFrozen(prop)) {\n          stack.push(prop);\n        }\n      }\n    }\n  }\n\n  return obj;\n}\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function cloneAndChange(obj, changer) {\n  return _cloneAndChange(obj, changer, new Set());\n}\n\nfunction _cloneAndChange(obj, changer, seen) {\n  if (isUndefinedOrNull(obj)) {\n    return obj;\n  }\n\n  var changed = changer(obj);\n\n  if (typeof changed !== 'undefined') {\n    return changed;\n  }\n\n  if (isArray(obj)) {\n    var r1 = [];\n\n    for (var _i = 0, obj_2 = obj; _i < obj_2.length; _i++) {\n      var e = obj_2[_i];\n      r1.push(_cloneAndChange(e, changer, seen));\n    }\n\n    return r1;\n  }\n\n  if (isObject(obj)) {\n    if (seen.has(obj)) {\n      throw new Error('Cannot clone recursive data-structure');\n    }\n\n    seen.add(obj);\n    var r2 = {};\n\n    for (var i2 in obj) {\n      if (_hasOwnProperty.call(obj, i2)) {\n        r2[i2] = _cloneAndChange(obj[i2], changer, seen);\n      }\n    }\n\n    seen.delete(obj);\n    return r2;\n  }\n\n  return obj;\n}\n/**\n * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\n */\n\n\nexport function mixin(destination, source, overwrite) {\n  if (overwrite === void 0) {\n    overwrite = true;\n  }\n\n  if (!isObject(destination)) {\n    return source;\n  }\n\n  if (isObject(source)) {\n    Object.keys(source).forEach(function (key) {\n      if (key in destination) {\n        if (overwrite) {\n          if (isObject(destination[key]) && isObject(source[key])) {\n            mixin(destination[key], source[key], overwrite);\n          } else {\n            destination[key] = source[key];\n          }\n        }\n      } else {\n        destination[key] = source[key];\n      }\n    });\n  }\n\n  return destination;\n}\nexport function assign(destination) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  sources.forEach(function (source) {\n    return Object.keys(source).forEach(function (key) {\n      return destination[key] = source[key];\n    });\n  });\n  return destination;\n}\nexport function equals(one, other) {\n  if (one === other) {\n    return true;\n  }\n\n  if (one === null || one === undefined || other === null || other === undefined) {\n    return false;\n  }\n\n  if (typeof one !== typeof other) {\n    return false;\n  }\n\n  if (typeof one !== 'object') {\n    return false;\n  }\n\n  if (Array.isArray(one) !== Array.isArray(other)) {\n    return false;\n  }\n\n  var i;\n  var key;\n\n  if (Array.isArray(one)) {\n    if (one.length !== other.length) {\n      return false;\n    }\n\n    for (i = 0; i < one.length; i++) {\n      if (!equals(one[i], other[i])) {\n        return false;\n      }\n    }\n  } else {\n    var oneKeys = [];\n\n    for (key in one) {\n      oneKeys.push(key);\n    }\n\n    oneKeys.sort();\n    var otherKeys = [];\n\n    for (key in other) {\n      otherKeys.push(key);\n    }\n\n    otherKeys.sort();\n\n    if (!equals(oneKeys, otherKeys)) {\n      return false;\n    }\n\n    for (i = 0; i < oneKeys.length; i++) {\n      if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\nexport function getOrDefault(obj, fn, defaultValue) {\n  var result = fn(obj);\n  return typeof result === 'undefined' ? defaultValue : result;\n}","map":null,"metadata":{},"sourceType":"module"}