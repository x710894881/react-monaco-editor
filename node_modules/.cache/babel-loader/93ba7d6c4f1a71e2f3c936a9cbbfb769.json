{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { illegalState } from '../../../base/common/errors.js';\nimport { Graph } from './graph.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { IInstantiationService, _util, optional } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\nimport { IdleValue } from '../../../base/common/async.js'; // TRACING\n\nvar _enableTracing = false;\n\nvar _canUseProxy = typeof Proxy === 'function';\n\nvar CyclicDependencyError =\n/** @class */\nfunction (_super) {\n  __extends(CyclicDependencyError, _super);\n\n  function CyclicDependencyError(graph) {\n    var _this = _super.call(this, 'cyclic dependency between services') || this;\n\n    _this.message = graph.toString();\n    return _this;\n  }\n\n  return CyclicDependencyError;\n}(Error);\n\nvar InstantiationService =\n/** @class */\nfunction () {\n  function InstantiationService(services, strict, parent) {\n    if (services === void 0) {\n      services = new ServiceCollection();\n    }\n\n    if (strict === void 0) {\n      strict = false;\n    }\n\n    this._services = services;\n    this._strict = strict;\n    this._parent = parent;\n\n    this._services.set(IInstantiationService, this);\n  }\n\n  InstantiationService.prototype.createChild = function (services) {\n    return new InstantiationService(services, this._strict, this);\n  };\n\n  InstantiationService.prototype.invokeFunction = function (fn) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var _trace = Trace.traceInvocation(fn);\n\n    var _done = false;\n\n    try {\n      var accessor = {\n        get: function (id, isOptional) {\n          if (_done) {\n            throw illegalState('service accessor is only valid during the invocation of its target method');\n          }\n\n          var result = _this._getOrCreateServiceInstance(id, _trace);\n\n          if (!result && isOptional !== optional) {\n            throw new Error(\"[invokeFunction] unknown service '\" + id + \"'\");\n          }\n\n          return result;\n        }\n      };\n      return fn.apply(undefined, [accessor].concat(args));\n    } finally {\n      _done = true;\n\n      _trace.stop();\n    }\n  };\n\n  InstantiationService.prototype.createInstance = function (ctorOrDescriptor) {\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    var _trace;\n\n    var result;\n\n    if (ctorOrDescriptor instanceof SyncDescriptor) {\n      _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n      result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n    } else {\n      _trace = Trace.traceCreation(ctorOrDescriptor);\n      result = this._createInstance(ctorOrDescriptor, rest, _trace);\n    }\n\n    _trace.stop();\n\n    return result;\n  };\n\n  InstantiationService.prototype._createInstance = function (ctor, args, _trace) {\n    if (args === void 0) {\n      args = [];\n    } // arguments defined by service decorators\n\n\n    var serviceDependencies = _util.getServiceDependencies(ctor).sort(function (a, b) {\n      return a.index - b.index;\n    });\n\n    var serviceArgs = [];\n\n    for (var _i = 0, serviceDependencies_1 = serviceDependencies; _i < serviceDependencies_1.length; _i++) {\n      var dependency = serviceDependencies_1[_i];\n\n      var service = this._getOrCreateServiceInstance(dependency.id, _trace);\n\n      if (!service && this._strict && !dependency.optional) {\n        throw new Error(\"[createInstance] \" + ctor.name + \" depends on UNKNOWN service \" + dependency.id + \".\");\n      }\n\n      serviceArgs.push(service);\n    }\n\n    var firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length; // check for argument mismatches, adjust static args if needed\n\n    if (args.length !== firstServiceArgPos) {\n      console.warn(\"[createInstance] First service dependency of \" + ctor.name + \" at position \" + (firstServiceArgPos + 1) + \" conflicts with \" + args.length + \" static arguments\");\n      var delta = firstServiceArgPos - args.length;\n\n      if (delta > 0) {\n        args = args.concat(new Array(delta));\n      } else {\n        args = args.slice(0, firstServiceArgPos);\n      }\n    } // now create the instance\n\n\n    return new (ctor.bind.apply(ctor, [void 0].concat(args.concat(serviceArgs))))();\n  };\n\n  InstantiationService.prototype._setServiceInstance = function (id, instance) {\n    if (this._services.get(id) instanceof SyncDescriptor) {\n      this._services.set(id, instance);\n    } else if (this._parent) {\n      this._parent._setServiceInstance(id, instance);\n    } else {\n      throw new Error('illegalState - setting UNKNOWN service instance');\n    }\n  };\n\n  InstantiationService.prototype._getServiceInstanceOrDescriptor = function (id) {\n    var instanceOrDesc = this._services.get(id);\n\n    if (!instanceOrDesc && this._parent) {\n      return this._parent._getServiceInstanceOrDescriptor(id);\n    } else {\n      return instanceOrDesc;\n    }\n  };\n\n  InstantiationService.prototype._getOrCreateServiceInstance = function (id, _trace) {\n    var thing = this._getServiceInstanceOrDescriptor(id);\n\n    if (thing instanceof SyncDescriptor) {\n      return this._createAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n    } else {\n      _trace.branch(id, false);\n\n      return thing;\n    }\n  };\n\n  InstantiationService.prototype._createAndCacheServiceInstance = function (id, desc, _trace) {\n    var graph = new Graph(function (data) {\n      return data.id.toString();\n    });\n    var cycleCount = 0;\n    var stack = [{\n      id: id,\n      desc: desc,\n      _trace: _trace\n    }];\n\n    while (stack.length) {\n      var item = stack.pop();\n      graph.lookupOrInsertNode(item); // a weak but working heuristic for cycle checks\n\n      if (cycleCount++ > 100) {\n        throw new CyclicDependencyError(graph);\n      } // check all dependencies for existence and if they need to be created first\n\n\n      for (var _i = 0, _a = _util.getServiceDependencies(item.desc.ctor); _i < _a.length; _i++) {\n        var dependency = _a[_i];\n\n        var instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n\n        if (!instanceOrDesc && !dependency.optional) {\n          console.warn(\"[createInstance] \" + id + \" depends on \" + dependency.id + \" which is NOT registered.\");\n        }\n\n        if (instanceOrDesc instanceof SyncDescriptor) {\n          var d = {\n            id: dependency.id,\n            desc: instanceOrDesc,\n            _trace: item._trace.branch(dependency.id, true)\n          };\n          graph.insertEdge(item, d);\n          stack.push(d);\n        }\n      }\n    }\n\n    while (true) {\n      var roots = graph.roots(); // if there is no more roots but still\n      // nodes in the graph we have a cycle\n\n      if (roots.length === 0) {\n        if (!graph.isEmpty()) {\n          throw new CyclicDependencyError(graph);\n        }\n\n        break;\n      }\n\n      for (var _b = 0, roots_1 = roots; _b < roots_1.length; _b++) {\n        var data = roots_1[_b].data; // create instance and overwrite the service collections\n\n        var instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n\n        this._setServiceInstance(data.id, instance);\n\n        graph.removeNode(data);\n      }\n    }\n\n    return this._getServiceInstanceOrDescriptor(id);\n  };\n\n  InstantiationService.prototype._createServiceInstanceWithOwner = function (id, ctor, args, supportsDelayedInstantiation, _trace) {\n    if (args === void 0) {\n      args = [];\n    }\n\n    if (this._services.get(id) instanceof SyncDescriptor) {\n      return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n    } else if (this._parent) {\n      return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n    } else {\n      throw new Error('illegalState - creating UNKNOWN service instance');\n    }\n  };\n\n  InstantiationService.prototype._createServiceInstance = function (ctor, args, _supportsDelayedInstantiation, _trace) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = [];\n    }\n\n    if (!_supportsDelayedInstantiation || !_canUseProxy) {\n      // eager instantiation or no support JS proxies (e.g. IE11)\n      return this._createInstance(ctor, args, _trace);\n    } else {\n      // Return a proxy object that's backed by an idle value. That\n      // strategy is to instantiate services in our idle time or when actually\n      // needed but not when injected into a consumer\n      var idle_1 = new IdleValue(function () {\n        return _this._createInstance(ctor, args, _trace);\n      });\n      return new Proxy(Object.create(null), {\n        get: function (_target, prop) {\n          return idle_1.getValue()[prop];\n        },\n        set: function (_target, p, value) {\n          idle_1.getValue()[p] = value;\n          return true;\n        }\n      });\n    }\n  };\n\n  return InstantiationService;\n}();\n\nexport { InstantiationService };\n\nvar Trace =\n/** @class */\nfunction () {\n  function Trace(type, name) {\n    this.type = type;\n    this.name = name;\n    this._start = Date.now();\n    this._dep = [];\n  }\n\n  Trace.traceInvocation = function (ctor) {\n    return !_enableTracing ? Trace._None : new Trace(1\n    /* Invocation */\n    , ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n  };\n\n  Trace.traceCreation = function (ctor) {\n    return !_enableTracing ? Trace._None : new Trace(0\n    /* Creation */\n    , ctor.name);\n  };\n\n  Trace.prototype.branch = function (id, first) {\n    var child = new Trace(2\n    /* Branch */\n    , id.toString());\n\n    this._dep.push([id, first, child]);\n\n    return child;\n  };\n\n  Trace.prototype.stop = function () {\n    var dur = Date.now() - this._start;\n\n    Trace._totals += dur;\n    var causedCreation = false;\n\n    function printChild(n, trace) {\n      var res = [];\n      var prefix = new Array(n + 1).join('\\t');\n\n      for (var _i = 0, _a = trace._dep; _i < _a.length; _i++) {\n        var _b = _a[_i],\n            id = _b[0],\n            first = _b[1],\n            child = _b[2];\n\n        if (first && child) {\n          causedCreation = true;\n          res.push(prefix + \"CREATES -> \" + id);\n          var nested = printChild(n + 1, child);\n\n          if (nested) {\n            res.push(nested);\n          }\n        } else {\n          res.push(prefix + \"uses -> \" + id);\n        }\n      }\n\n      return res.join('\\n');\n    }\n\n    var lines = [(this.type === 0\n    /* Creation */\n    ? 'CREATE' : 'CALL') + \" \" + this.name, \"\" + printChild(1, this), \"DONE, took \" + dur.toFixed(2) + \"ms (grand total \" + Trace._totals.toFixed(2) + \"ms)\"];\n\n    if (dur > 2 || causedCreation) {\n      console.log(lines.join('\\n'));\n    }\n  };\n\n  Trace._None = new (\n  /** @class */\n  function (_super) {\n    __extends(class_1, _super);\n\n    function class_1() {\n      return _super.call(this, -1, null) || this;\n    }\n\n    class_1.prototype.stop = function () {};\n\n    class_1.prototype.branch = function () {\n      return this;\n    };\n\n    return class_1;\n  }(Trace))();\n  Trace._totals = 0;\n  return Trace;\n}(); //#endregion","map":null,"metadata":{},"sourceType":"module"}