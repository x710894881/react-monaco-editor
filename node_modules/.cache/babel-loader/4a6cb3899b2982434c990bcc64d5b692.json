{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Emitter } from './event.js';\nimport { Disposable } from './lifecycle.js';\n\nvar ScrollState =\n/** @class */\nfunction () {\n  function ScrollState(width, scrollWidth, scrollLeft, height, scrollHeight, scrollTop) {\n    width = width | 0;\n    scrollWidth = scrollWidth | 0;\n    scrollLeft = scrollLeft | 0;\n    height = height | 0;\n    scrollHeight = scrollHeight | 0;\n    scrollTop = scrollTop | 0;\n\n    if (width < 0) {\n      width = 0;\n    }\n\n    if (scrollLeft + width > scrollWidth) {\n      scrollLeft = scrollWidth - width;\n    }\n\n    if (scrollLeft < 0) {\n      scrollLeft = 0;\n    }\n\n    if (height < 0) {\n      height = 0;\n    }\n\n    if (scrollTop + height > scrollHeight) {\n      scrollTop = scrollHeight - height;\n    }\n\n    if (scrollTop < 0) {\n      scrollTop = 0;\n    }\n\n    this.width = width;\n    this.scrollWidth = scrollWidth;\n    this.scrollLeft = scrollLeft;\n    this.height = height;\n    this.scrollHeight = scrollHeight;\n    this.scrollTop = scrollTop;\n  }\n\n  ScrollState.prototype.equals = function (other) {\n    return this.width === other.width && this.scrollWidth === other.scrollWidth && this.scrollLeft === other.scrollLeft && this.height === other.height && this.scrollHeight === other.scrollHeight && this.scrollTop === other.scrollTop;\n  };\n\n  ScrollState.prototype.withScrollDimensions = function (update) {\n    return new ScrollState(typeof update.width !== 'undefined' ? update.width : this.width, typeof update.scrollWidth !== 'undefined' ? update.scrollWidth : this.scrollWidth, this.scrollLeft, typeof update.height !== 'undefined' ? update.height : this.height, typeof update.scrollHeight !== 'undefined' ? update.scrollHeight : this.scrollHeight, this.scrollTop);\n  };\n\n  ScrollState.prototype.withScrollPosition = function (update) {\n    return new ScrollState(this.width, this.scrollWidth, typeof update.scrollLeft !== 'undefined' ? update.scrollLeft : this.scrollLeft, this.height, this.scrollHeight, typeof update.scrollTop !== 'undefined' ? update.scrollTop : this.scrollTop);\n  };\n\n  ScrollState.prototype.createScrollEvent = function (previous) {\n    var widthChanged = this.width !== previous.width;\n    var scrollWidthChanged = this.scrollWidth !== previous.scrollWidth;\n    var scrollLeftChanged = this.scrollLeft !== previous.scrollLeft;\n    var heightChanged = this.height !== previous.height;\n    var scrollHeightChanged = this.scrollHeight !== previous.scrollHeight;\n    var scrollTopChanged = this.scrollTop !== previous.scrollTop;\n    return {\n      width: this.width,\n      scrollWidth: this.scrollWidth,\n      scrollLeft: this.scrollLeft,\n      height: this.height,\n      scrollHeight: this.scrollHeight,\n      scrollTop: this.scrollTop,\n      widthChanged: widthChanged,\n      scrollWidthChanged: scrollWidthChanged,\n      scrollLeftChanged: scrollLeftChanged,\n      heightChanged: heightChanged,\n      scrollHeightChanged: scrollHeightChanged,\n      scrollTopChanged: scrollTopChanged\n    };\n  };\n\n  return ScrollState;\n}();\n\nexport { ScrollState };\n\nvar Scrollable =\n/** @class */\nfunction (_super) {\n  __extends(Scrollable, _super);\n\n  function Scrollable(smoothScrollDuration, scheduleAtNextAnimationFrame) {\n    var _this = _super.call(this) || this;\n\n    _this._onScroll = _this._register(new Emitter());\n    _this.onScroll = _this._onScroll.event;\n    _this._smoothScrollDuration = smoothScrollDuration;\n    _this._scheduleAtNextAnimationFrame = scheduleAtNextAnimationFrame;\n    _this._state = new ScrollState(0, 0, 0, 0, 0, 0);\n    _this._smoothScrolling = null;\n    return _this;\n  }\n\n  Scrollable.prototype.dispose = function () {\n    if (this._smoothScrolling) {\n      this._smoothScrolling.dispose();\n\n      this._smoothScrolling = null;\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n\n  Scrollable.prototype.setSmoothScrollDuration = function (smoothScrollDuration) {\n    this._smoothScrollDuration = smoothScrollDuration;\n  };\n\n  Scrollable.prototype.validateScrollPosition = function (scrollPosition) {\n    return this._state.withScrollPosition(scrollPosition);\n  };\n\n  Scrollable.prototype.getScrollDimensions = function () {\n    return this._state;\n  };\n\n  Scrollable.prototype.setScrollDimensions = function (dimensions) {\n    var newState = this._state.withScrollDimensions(dimensions);\n\n    this._setState(newState); // Validate outstanding animated scroll position target\n\n\n    if (this._smoothScrolling) {\n      this._smoothScrolling.acceptScrollDimensions(this._state);\n    }\n  };\n  /**\n   * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.\n   * If no scroll animation is occurring, it will return the current scroll position instead.\n   */\n\n\n  Scrollable.prototype.getFutureScrollPosition = function () {\n    if (this._smoothScrolling) {\n      return this._smoothScrolling.to;\n    }\n\n    return this._state;\n  };\n  /**\n   * Returns the current scroll position.\n   * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.\n   */\n\n\n  Scrollable.prototype.getCurrentScrollPosition = function () {\n    return this._state;\n  };\n\n  Scrollable.prototype.setScrollPositionNow = function (update) {\n    // no smooth scrolling requested\n    var newState = this._state.withScrollPosition(update); // Terminate any outstanding smooth scrolling\n\n\n    if (this._smoothScrolling) {\n      this._smoothScrolling.dispose();\n\n      this._smoothScrolling = null;\n    }\n\n    this._setState(newState);\n  };\n\n  Scrollable.prototype.setScrollPositionSmooth = function (update) {\n    var _this = this;\n\n    if (this._smoothScrollDuration === 0) {\n      // Smooth scrolling not supported.\n      return this.setScrollPositionNow(update);\n    }\n\n    if (this._smoothScrolling) {\n      // Combine our pending scrollLeft/scrollTop with incoming scrollLeft/scrollTop\n      update = {\n        scrollLeft: typeof update.scrollLeft === 'undefined' ? this._smoothScrolling.to.scrollLeft : update.scrollLeft,\n        scrollTop: typeof update.scrollTop === 'undefined' ? this._smoothScrolling.to.scrollTop : update.scrollTop\n      }; // Validate `update`\n\n      var validTarget = this._state.withScrollPosition(update);\n\n      if (this._smoothScrolling.to.scrollLeft === validTarget.scrollLeft && this._smoothScrolling.to.scrollTop === validTarget.scrollTop) {\n        // No need to interrupt or extend the current animation since we're going to the same place\n        return;\n      }\n\n      var newSmoothScrolling = this._smoothScrolling.combine(this._state, validTarget, this._smoothScrollDuration);\n\n      this._smoothScrolling.dispose();\n\n      this._smoothScrolling = newSmoothScrolling;\n    } else {\n      // Validate `update`\n      var validTarget = this._state.withScrollPosition(update);\n\n      this._smoothScrolling = SmoothScrollingOperation.start(this._state, validTarget, this._smoothScrollDuration);\n    } // Begin smooth scrolling animation\n\n\n    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(function () {\n      if (!_this._smoothScrolling) {\n        return;\n      }\n\n      _this._smoothScrolling.animationFrameDisposable = null;\n\n      _this._performSmoothScrolling();\n    });\n  };\n\n  Scrollable.prototype._performSmoothScrolling = function () {\n    var _this = this;\n\n    if (!this._smoothScrolling) {\n      return;\n    }\n\n    var update = this._smoothScrolling.tick();\n\n    var newState = this._state.withScrollPosition(update);\n\n    this._setState(newState);\n\n    if (update.isDone) {\n      this._smoothScrolling.dispose();\n\n      this._smoothScrolling = null;\n      return;\n    } // Continue smooth scrolling animation\n\n\n    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(function () {\n      if (!_this._smoothScrolling) {\n        return;\n      }\n\n      _this._smoothScrolling.animationFrameDisposable = null;\n\n      _this._performSmoothScrolling();\n    });\n  };\n\n  Scrollable.prototype._setState = function (newState) {\n    var oldState = this._state;\n\n    if (oldState.equals(newState)) {\n      // no change\n      return;\n    }\n\n    this._state = newState;\n\n    this._onScroll.fire(this._state.createScrollEvent(oldState));\n  };\n\n  return Scrollable;\n}(Disposable);\n\nexport { Scrollable };\n\nvar SmoothScrollingUpdate =\n/** @class */\nfunction () {\n  function SmoothScrollingUpdate(scrollLeft, scrollTop, isDone) {\n    this.scrollLeft = scrollLeft;\n    this.scrollTop = scrollTop;\n    this.isDone = isDone;\n  }\n\n  return SmoothScrollingUpdate;\n}();\n\nexport { SmoothScrollingUpdate };\n\nfunction createEaseOutCubic(from, to) {\n  var delta = to - from;\n  return function (completion) {\n    return from + delta * easeOutCubic(completion);\n  };\n}\n\nfunction createComposed(a, b, cut) {\n  return function (completion) {\n    if (completion < cut) {\n      return a(completion / cut);\n    }\n\n    return b((completion - cut) / (1 - cut));\n  };\n}\n\nvar SmoothScrollingOperation =\n/** @class */\nfunction () {\n  function SmoothScrollingOperation(from, to, startTime, duration) {\n    this.from = from;\n    this.to = to;\n    this.duration = duration;\n    this._startTime = startTime;\n    this.animationFrameDisposable = null;\n\n    this._initAnimations();\n  }\n\n  SmoothScrollingOperation.prototype._initAnimations = function () {\n    this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width);\n    this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);\n  };\n\n  SmoothScrollingOperation.prototype._initAnimation = function (from, to, viewportSize) {\n    var delta = Math.abs(from - to);\n\n    if (delta > 2.5 * viewportSize) {\n      var stop1 = void 0,\n          stop2 = void 0;\n\n      if (from < to) {\n        // scroll to 75% of the viewportSize\n        stop1 = from + 0.75 * viewportSize;\n        stop2 = to - 0.75 * viewportSize;\n      } else {\n        stop1 = from - 0.75 * viewportSize;\n        stop2 = to + 0.75 * viewportSize;\n      }\n\n      return createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(stop2, to), 0.33);\n    }\n\n    return createEaseOutCubic(from, to);\n  };\n\n  SmoothScrollingOperation.prototype.dispose = function () {\n    if (this.animationFrameDisposable !== null) {\n      this.animationFrameDisposable.dispose();\n      this.animationFrameDisposable = null;\n    }\n  };\n\n  SmoothScrollingOperation.prototype.acceptScrollDimensions = function (state) {\n    this.to = state.withScrollPosition(this.to);\n\n    this._initAnimations();\n  };\n\n  SmoothScrollingOperation.prototype.tick = function () {\n    return this._tick(Date.now());\n  };\n\n  SmoothScrollingOperation.prototype._tick = function (now) {\n    var completion = (now - this._startTime) / this.duration;\n\n    if (completion < 1) {\n      var newScrollLeft = this.scrollLeft(completion);\n      var newScrollTop = this.scrollTop(completion);\n      return new SmoothScrollingUpdate(newScrollLeft, newScrollTop, false);\n    }\n\n    return new SmoothScrollingUpdate(this.to.scrollLeft, this.to.scrollTop, true);\n  };\n\n  SmoothScrollingOperation.prototype.combine = function (from, to, duration) {\n    return SmoothScrollingOperation.start(from, to, duration);\n  };\n\n  SmoothScrollingOperation.start = function (from, to, duration) {\n    // +10 / -10 : pretend the animation already started for a quicker response to a scroll request\n    duration = duration + 10;\n    var startTime = Date.now() - 10;\n    return new SmoothScrollingOperation(from, to, startTime, duration);\n  };\n\n  return SmoothScrollingOperation;\n}();\n\nexport { SmoothScrollingOperation };\n\nfunction easeInCubic(t) {\n  return Math.pow(t, 3);\n}\n\nfunction easeOutCubic(t) {\n  return 1 - easeInCubic(1 - t);\n}","map":null,"metadata":{},"sourceType":"module"}