{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { CursorColumns, EditOperationResult, isQuote } from './cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\n\nvar DeleteOperations =\n/** @class */\nfunction () {\n  function DeleteOperations() {}\n\n  DeleteOperations.deleteRight = function (prevEditOperationType, config, model, selections) {\n    var commands = [];\n    var shouldPushStackElementBefore = prevEditOperationType !== 3\n    /* DeletingRight */\n    ;\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n      var deleteSelection = selection;\n\n      if (deleteSelection.isEmpty()) {\n        var position = selection.getPosition();\n        var rightOfPosition = MoveOperations.right(config, model, position.lineNumber, position.column);\n        deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n      }\n\n      if (deleteSelection.isEmpty()) {\n        // Probably at end of file => ignore\n        commands[i] = null;\n        continue;\n      }\n\n      if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n        shouldPushStackElementBefore = true;\n      }\n\n      commands[i] = new ReplaceCommand(deleteSelection, '');\n    }\n\n    return [shouldPushStackElementBefore, commands];\n  };\n\n  DeleteOperations._isAutoClosingPairDelete = function (config, model, selections) {\n    if (config.autoClosingBrackets === 'never' && config.autoClosingQuotes === 'never') {\n      return false;\n    }\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n      var position = selection.getPosition();\n\n      if (!selection.isEmpty()) {\n        return false;\n      }\n\n      var lineText = model.getLineContent(position.lineNumber);\n      var character = lineText[position.column - 2];\n      var autoClosingPairCandidates = config.autoClosingPairsOpen2.get(character);\n\n      if (!autoClosingPairCandidates) {\n        return false;\n      }\n\n      if (isQuote(character)) {\n        if (config.autoClosingQuotes === 'never') {\n          return false;\n        }\n      } else {\n        if (config.autoClosingBrackets === 'never') {\n          return false;\n        }\n      }\n\n      var afterCharacter = lineText[position.column - 1];\n      var foundAutoClosingPair = false;\n\n      for (var _i = 0, autoClosingPairCandidates_1 = autoClosingPairCandidates; _i < autoClosingPairCandidates_1.length; _i++) {\n        var autoClosingPairCandidate = autoClosingPairCandidates_1[_i];\n\n        if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n          foundAutoClosingPair = true;\n        }\n      }\n\n      if (!foundAutoClosingPair) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  DeleteOperations._runAutoClosingPairDelete = function (config, model, selections) {\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var position = selections[i].getPosition();\n      var deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n      commands[i] = new ReplaceCommand(deleteSelection, '');\n    }\n\n    return [true, commands];\n  };\n\n  DeleteOperations.deleteLeft = function (prevEditOperationType, config, model, selections) {\n    if (this._isAutoClosingPairDelete(config, model, selections)) {\n      return this._runAutoClosingPairDelete(config, model, selections);\n    }\n\n    var commands = [];\n    var shouldPushStackElementBefore = prevEditOperationType !== 2\n    /* DeletingLeft */\n    ;\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n      var deleteSelection = selection;\n\n      if (deleteSelection.isEmpty()) {\n        var position = selection.getPosition();\n\n        if (config.useTabStops && position.column > 1) {\n          var lineContent = model.getLineContent(position.lineNumber);\n          var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n          var lastIndentationColumn = firstNonWhitespaceIndex === -1 ?\n          /* entire string is whitespace */\n          lineContent.length + 1 : firstNonWhitespaceIndex + 1;\n\n          if (position.column <= lastIndentationColumn) {\n            var fromVisibleColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\n            var toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n            var toColumn = CursorColumns.columnFromVisibleColumn2(config, model, position.lineNumber, toVisibleColumn);\n            deleteSelection = new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n          } else {\n            deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column);\n          }\n        } else {\n          var leftOfPosition = MoveOperations.left(config, model, position.lineNumber, position.column);\n          deleteSelection = new Range(leftOfPosition.lineNumber, leftOfPosition.column, position.lineNumber, position.column);\n        }\n      }\n\n      if (deleteSelection.isEmpty()) {\n        // Probably at beginning of file => ignore\n        commands[i] = null;\n        continue;\n      }\n\n      if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n        shouldPushStackElementBefore = true;\n      }\n\n      commands[i] = new ReplaceCommand(deleteSelection, '');\n    }\n\n    return [shouldPushStackElementBefore, commands];\n  };\n\n  DeleteOperations.cut = function (config, model, selections) {\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n\n      if (selection.isEmpty()) {\n        if (config.emptySelectionClipboard) {\n          // This is a full line cut\n          var position = selection.getPosition();\n          var startLineNumber = void 0,\n              startColumn = void 0,\n              endLineNumber = void 0,\n              endColumn = void 0;\n\n          if (position.lineNumber < model.getLineCount()) {\n            // Cutting a line in the middle of the model\n            startLineNumber = position.lineNumber;\n            startColumn = 1;\n            endLineNumber = position.lineNumber + 1;\n            endColumn = 1;\n          } else if (position.lineNumber > 1) {\n            // Cutting the last line & there are more than 1 lines in the model\n            startLineNumber = position.lineNumber - 1;\n            startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n            endLineNumber = position.lineNumber;\n            endColumn = model.getLineMaxColumn(position.lineNumber);\n          } else {\n            // Cutting the single line that the model contains\n            startLineNumber = position.lineNumber;\n            startColumn = 1;\n            endLineNumber = position.lineNumber;\n            endColumn = model.getLineMaxColumn(position.lineNumber);\n          }\n\n          var deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\n          if (!deleteSelection.isEmpty()) {\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n          } else {\n            commands[i] = null;\n          }\n        } else {\n          // Cannot cut empty selection\n          commands[i] = null;\n        }\n      } else {\n        commands[i] = new ReplaceCommand(selection, '');\n      }\n    }\n\n    return new EditOperationResult(0\n    /* Other */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  };\n\n  return DeleteOperations;\n}();\n\nexport { DeleteOperations };","map":null,"metadata":{},"sourceType":"module"}