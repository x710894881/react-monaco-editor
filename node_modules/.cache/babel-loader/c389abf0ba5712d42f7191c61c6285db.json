{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport './textAreaHandler.css';\nimport * as browser from '../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Configuration } from '../config/configuration.js';\nimport { CopyOptions, TextAreaInput } from './textAreaInput.js';\nimport { PagedScreenReaderStrategy, TextAreaState } from './textAreaState.js';\nimport { PartFingerprints, ViewPart } from '../view/viewPart.js';\nimport { LineNumbersOverlay } from '../viewParts/lineNumbers/lineNumbers.js';\nimport { Margin } from '../viewParts/margin/margin.js';\nimport { getMapForWordSeparators } from '../../common/controller/wordCharacterClassifier.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport * as viewEvents from '../../common/view/viewEvents.js';\n\nvar VisibleTextAreaData =\n/** @class */\nfunction () {\n  function VisibleTextAreaData(top, left, width) {\n    this.top = top;\n    this.left = left;\n    this.width = width;\n  }\n\n  VisibleTextAreaData.prototype.setWidth = function (width) {\n    return new VisibleTextAreaData(this.top, this.left, width);\n  };\n\n  return VisibleTextAreaData;\n}();\n\nvar canUseZeroSizeTextarea = browser.isEdgeOrIE || browser.isFirefox;\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\n\nvar LocalClipboardMetadataManager =\n/** @class */\nfunction () {\n  function LocalClipboardMetadataManager() {\n    this._lastState = null;\n  }\n\n  LocalClipboardMetadataManager.prototype.set = function (state) {\n    this._lastState = state;\n  };\n\n  LocalClipboardMetadataManager.prototype.get = function (pastedText) {\n    if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n      // match!\n      return this._lastState;\n    }\n\n    this._lastState = null;\n    return null;\n  };\n\n  LocalClipboardMetadataManager.INSTANCE = new LocalClipboardMetadataManager();\n  return LocalClipboardMetadataManager;\n}();\n\nvar TextAreaHandler =\n/** @class */\nfunction (_super) {\n  __extends(TextAreaHandler, _super);\n\n  function TextAreaHandler(context, viewController, viewHelper) {\n    var _this = _super.call(this, context) || this; // --- end view API\n\n\n    _this._primaryCursorVisibleRange = null;\n    _this._viewController = viewController;\n    _this._viewHelper = viewHelper;\n    var conf = _this._context.configuration.editor;\n    _this._accessibilitySupport = conf.accessibilitySupport;\n    _this._contentLeft = conf.layoutInfo.contentLeft;\n    _this._contentWidth = conf.layoutInfo.contentWidth;\n    _this._contentHeight = conf.layoutInfo.contentHeight;\n    _this._scrollLeft = 0;\n    _this._scrollTop = 0;\n    _this._fontInfo = conf.fontInfo;\n    _this._lineHeight = conf.lineHeight;\n    _this._emptySelectionClipboard = conf.emptySelectionClipboard;\n    _this._copyWithSyntaxHighlighting = conf.copyWithSyntaxHighlighting;\n    _this._visibleTextArea = null;\n    _this._selections = [new Selection(1, 1, 1, 1)]; // Text Area (The focus will always be in the textarea when the cursor is blinking)\n\n    _this.textArea = createFastDomNode(document.createElement('textarea'));\n    PartFingerprints.write(_this.textArea, 6\n    /* TextArea */\n    );\n\n    _this.textArea.setClassName('inputarea');\n\n    _this.textArea.setAttribute('wrap', 'off');\n\n    _this.textArea.setAttribute('autocorrect', 'off');\n\n    _this.textArea.setAttribute('autocapitalize', 'off');\n\n    _this.textArea.setAttribute('autocomplete', 'off');\n\n    _this.textArea.setAttribute('spellcheck', 'false');\n\n    _this.textArea.setAttribute('aria-label', conf.viewInfo.ariaLabel);\n\n    _this.textArea.setAttribute('role', 'textbox');\n\n    _this.textArea.setAttribute('aria-multiline', 'true');\n\n    _this.textArea.setAttribute('aria-haspopup', 'false');\n\n    _this.textArea.setAttribute('aria-autocomplete', 'both');\n\n    _this.textAreaCover = createFastDomNode(document.createElement('div'));\n\n    _this.textAreaCover.setPosition('absolute');\n\n    var simpleModel = {\n      getLineCount: function () {\n        return _this._context.model.getLineCount();\n      },\n      getLineMaxColumn: function (lineNumber) {\n        return _this._context.model.getLineMaxColumn(lineNumber);\n      },\n      getValueInRange: function (range, eol) {\n        return _this._context.model.getValueInRange(range, eol);\n      }\n    };\n    var textAreaInputHost = {\n      getPlainTextToCopy: function () {\n        var rawWhatToCopy = _this._context.model.getPlainTextToCopy(_this._selections, _this._emptySelectionClipboard, platform.isWindows);\n\n        var newLineCharacter = _this._context.model.getEOL();\n\n        var isFromEmptySelection = _this._emptySelectionClipboard && _this._selections.length === 1 && _this._selections[0].isEmpty();\n\n        var multicursorText = Array.isArray(rawWhatToCopy) ? rawWhatToCopy : null;\n        var whatToCopy = Array.isArray(rawWhatToCopy) ? rawWhatToCopy.join(newLineCharacter) : rawWhatToCopy;\n        var metadata = null;\n\n        if (isFromEmptySelection || multicursorText) {\n          // Only store the non-default metadata\n          // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n          // Firefox pastes \"LINE\\n\", so let's work around this quirk\n          var lastCopiedValue = browser.isFirefox ? whatToCopy.replace(/\\r\\n/g, '\\n') : whatToCopy;\n          metadata = {\n            lastCopiedValue: lastCopiedValue,\n            isFromEmptySelection: _this._emptySelectionClipboard && _this._selections.length === 1 && _this._selections[0].isEmpty(),\n            multicursorText: multicursorText\n          };\n        }\n\n        LocalClipboardMetadataManager.INSTANCE.set(metadata);\n        return whatToCopy;\n      },\n      getHTMLToCopy: function () {\n        if (!_this._copyWithSyntaxHighlighting && !CopyOptions.forceCopyWithSyntaxHighlighting) {\n          return null;\n        }\n\n        return _this._context.model.getHTMLToCopy(_this._selections, _this._emptySelectionClipboard);\n      },\n      getScreenReaderContent: function (currentState) {\n        if (browser.isIPad) {\n          // Do not place anything in the textarea for the iPad\n          return TextAreaState.EMPTY;\n        }\n\n        if (_this._accessibilitySupport === 1\n        /* Disabled */\n        ) {\n            // We know for a fact that a screen reader is not attached\n            // On OSX, we write the character before the cursor to allow for \"long-press\" composition\n            // Also on OSX, we write the word before the cursor to allow for the Accessibility Keyboard to give good hints\n            if (platform.isMacintosh) {\n              var selection = _this._selections[0];\n\n              if (selection.isEmpty()) {\n                var position = selection.getStartPosition();\n\n                var textBefore = _this._getWordBeforePosition(position);\n\n                if (textBefore.length === 0) {\n                  textBefore = _this._getCharacterBeforePosition(position);\n                }\n\n                if (textBefore.length > 0) {\n                  return new TextAreaState(textBefore, textBefore.length, textBefore.length, position, position);\n                }\n              }\n            }\n\n            return TextAreaState.EMPTY;\n          }\n\n        return PagedScreenReaderStrategy.fromEditorSelection(currentState, simpleModel, _this._selections[0], _this._accessibilitySupport === 0\n        /* Unknown */\n        );\n      },\n      deduceModelPosition: function (viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        return _this._context.model.deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt);\n      }\n    };\n    _this._textAreaInput = _this._register(new TextAreaInput(textAreaInputHost, _this.textArea));\n\n    _this._register(_this._textAreaInput.onKeyDown(function (e) {\n      _this._viewController.emitKeyDown(e);\n    }));\n\n    _this._register(_this._textAreaInput.onKeyUp(function (e) {\n      _this._viewController.emitKeyUp(e);\n    }));\n\n    _this._register(_this._textAreaInput.onPaste(function (e) {\n      var metadata = LocalClipboardMetadataManager.INSTANCE.get(e.text);\n      var pasteOnNewLine = false;\n      var multicursorText = null;\n\n      if (metadata) {\n        pasteOnNewLine = _this._emptySelectionClipboard && metadata.isFromEmptySelection;\n        multicursorText = metadata.multicursorText;\n      }\n\n      _this._viewController.paste('keyboard', e.text, pasteOnNewLine, multicursorText);\n    }));\n\n    _this._register(_this._textAreaInput.onCut(function () {\n      _this._viewController.cut('keyboard');\n    }));\n\n    _this._register(_this._textAreaInput.onType(function (e) {\n      if (e.replaceCharCnt) {\n        _this._viewController.replacePreviousChar('keyboard', e.text, e.replaceCharCnt);\n      } else {\n        _this._viewController.type('keyboard', e.text);\n      }\n    }));\n\n    _this._register(_this._textAreaInput.onSelectionChangeRequest(function (modelSelection) {\n      _this._viewController.setSelection('keyboard', modelSelection);\n    }));\n\n    _this._register(_this._textAreaInput.onCompositionStart(function () {\n      var lineNumber = _this._selections[0].startLineNumber;\n      var column = _this._selections[0].startColumn;\n\n      _this._context.privateViewEventBus.emit(new viewEvents.ViewRevealRangeRequestEvent(new Range(lineNumber, column, lineNumber, column), 0\n      /* Simple */\n      , true, 1\n      /* Immediate */\n      )); // Find range pixel position\n\n\n      var visibleRange = _this._viewHelper.visibleRangeForPositionRelativeToEditor(lineNumber, column);\n\n      if (visibleRange) {\n        _this._visibleTextArea = new VisibleTextAreaData(_this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber), visibleRange.left, canUseZeroSizeTextarea ? 0 : 1);\n\n        _this._render();\n      } // Show the textarea\n\n\n      _this.textArea.setClassName('inputarea ime-input');\n\n      _this._viewController.compositionStart('keyboard');\n    }));\n\n    _this._register(_this._textAreaInput.onCompositionUpdate(function (e) {\n      if (browser.isEdgeOrIE) {\n        // Due to isEdgeOrIE (where the textarea was not cleared initially)\n        // we cannot assume the text consists only of the composited text\n        _this._visibleTextArea = _this._visibleTextArea.setWidth(0);\n      } else {\n        // adjust width by its size\n        _this._visibleTextArea = _this._visibleTextArea.setWidth(measureText(e.data, _this._fontInfo));\n      }\n\n      _this._render();\n    }));\n\n    _this._register(_this._textAreaInput.onCompositionEnd(function () {\n      _this._visibleTextArea = null;\n\n      _this._render();\n\n      _this.textArea.setClassName('inputarea');\n\n      _this._viewController.compositionEnd('keyboard');\n    }));\n\n    _this._register(_this._textAreaInput.onFocus(function () {\n      _this._context.privateViewEventBus.emit(new viewEvents.ViewFocusChangedEvent(true));\n    }));\n\n    _this._register(_this._textAreaInput.onBlur(function () {\n      _this._context.privateViewEventBus.emit(new viewEvents.ViewFocusChangedEvent(false));\n    }));\n\n    return _this;\n  }\n\n  TextAreaHandler.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n  };\n\n  TextAreaHandler.prototype._getWordBeforePosition = function (position) {\n    var lineContent = this._context.model.getLineContent(position.lineNumber);\n\n    var wordSeparators = getMapForWordSeparators(this._context.configuration.editor.wordSeparators);\n    var column = position.column;\n    var distance = 0;\n\n    while (column > 1) {\n      var charCode = lineContent.charCodeAt(column - 2);\n      var charClass = wordSeparators.get(charCode);\n\n      if (charClass !== 0\n      /* Regular */\n      || distance > 50) {\n        return lineContent.substring(column - 1, position.column - 1);\n      }\n\n      distance++;\n      column--;\n    }\n\n    return lineContent.substring(0, position.column - 1);\n  };\n\n  TextAreaHandler.prototype._getCharacterBeforePosition = function (position) {\n    if (position.column > 1) {\n      var lineContent = this._context.model.getLineContent(position.lineNumber);\n\n      var charBefore = lineContent.charAt(position.column - 2);\n\n      if (!strings.isHighSurrogate(charBefore.charCodeAt(0))) {\n        return charBefore;\n      }\n    }\n\n    return '';\n  }; // --- begin event handlers\n\n\n  TextAreaHandler.prototype.onConfigurationChanged = function (e) {\n    var conf = this._context.configuration.editor;\n\n    if (e.fontInfo) {\n      this._fontInfo = conf.fontInfo;\n    }\n\n    if (e.viewInfo) {\n      this.textArea.setAttribute('aria-label', conf.viewInfo.ariaLabel);\n    }\n\n    if (e.layoutInfo) {\n      this._contentLeft = conf.layoutInfo.contentLeft;\n      this._contentWidth = conf.layoutInfo.contentWidth;\n      this._contentHeight = conf.layoutInfo.contentHeight;\n    }\n\n    if (e.lineHeight) {\n      this._lineHeight = conf.lineHeight;\n    }\n\n    if (e.accessibilitySupport) {\n      this._accessibilitySupport = conf.accessibilitySupport;\n\n      this._textAreaInput.writeScreenReaderContent('strategy changed');\n    }\n\n    if (e.emptySelectionClipboard) {\n      this._emptySelectionClipboard = conf.emptySelectionClipboard;\n    }\n\n    if (e.copyWithSyntaxHighlighting) {\n      this._copyWithSyntaxHighlighting = conf.copyWithSyntaxHighlighting;\n    }\n\n    return true;\n  };\n\n  TextAreaHandler.prototype.onCursorStateChanged = function (e) {\n    this._selections = e.selections.slice(0);\n\n    this._textAreaInput.writeScreenReaderContent('selection changed');\n\n    return true;\n  };\n\n  TextAreaHandler.prototype.onDecorationsChanged = function (e) {\n    // true for inline decorations that can end up relayouting text\n    return true;\n  };\n\n  TextAreaHandler.prototype.onFlushed = function (e) {\n    return true;\n  };\n\n  TextAreaHandler.prototype.onLinesChanged = function (e) {\n    return true;\n  };\n\n  TextAreaHandler.prototype.onLinesDeleted = function (e) {\n    return true;\n  };\n\n  TextAreaHandler.prototype.onLinesInserted = function (e) {\n    return true;\n  };\n\n  TextAreaHandler.prototype.onScrollChanged = function (e) {\n    this._scrollLeft = e.scrollLeft;\n    this._scrollTop = e.scrollTop;\n    return true;\n  };\n\n  TextAreaHandler.prototype.onZonesChanged = function (e) {\n    return true;\n  }; // --- end event handlers\n  // --- begin view API\n\n\n  TextAreaHandler.prototype.isFocused = function () {\n    return this._textAreaInput.isFocused();\n  };\n\n  TextAreaHandler.prototype.focusTextArea = function () {\n    this._textAreaInput.focusTextArea();\n  };\n\n  TextAreaHandler.prototype.prepareRender = function (ctx) {\n    var primaryCursorPosition = new Position(this._selections[0].positionLineNumber, this._selections[0].positionColumn);\n    this._primaryCursorVisibleRange = ctx.visibleRangeForPosition(primaryCursorPosition);\n  };\n\n  TextAreaHandler.prototype.render = function (ctx) {\n    this._textAreaInput.writeScreenReaderContent('render');\n\n    this._render();\n  };\n\n  TextAreaHandler.prototype._render = function () {\n    if (this._visibleTextArea) {\n      // The text area is visible for composition reasons\n      this._renderInsideEditor(this._visibleTextArea.top - this._scrollTop, this._contentLeft + this._visibleTextArea.left - this._scrollLeft, this._visibleTextArea.width, this._lineHeight, true);\n\n      return;\n    }\n\n    if (!this._primaryCursorVisibleRange) {\n      // The primary cursor is outside the viewport => place textarea to the top left\n      this._renderAtTopLeft();\n\n      return;\n    }\n\n    var left = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;\n\n    if (left < this._contentLeft || left > this._contentLeft + this._contentWidth) {\n      // cursor is outside the viewport\n      this._renderAtTopLeft();\n\n      return;\n    }\n\n    var top = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;\n\n    if (top < 0 || top > this._contentHeight) {\n      // cursor is outside the viewport\n      this._renderAtTopLeft();\n\n      return;\n    } // The primary cursor is in the viewport (at least vertically) => place textarea on the cursor\n\n\n    this._renderInsideEditor(top, left, canUseZeroSizeTextarea ? 0 : 1, canUseZeroSizeTextarea ? 0 : 1, false);\n  };\n\n  TextAreaHandler.prototype._renderInsideEditor = function (top, left, width, height, useEditorFont) {\n    var ta = this.textArea;\n    var tac = this.textAreaCover;\n\n    if (useEditorFont) {\n      Configuration.applyFontInfo(ta, this._fontInfo);\n    } else {\n      ta.setFontSize(1);\n      ta.setLineHeight(this._fontInfo.lineHeight);\n    }\n\n    ta.setTop(top);\n    ta.setLeft(left);\n    ta.setWidth(width);\n    ta.setHeight(height);\n    tac.setTop(0);\n    tac.setLeft(0);\n    tac.setWidth(0);\n    tac.setHeight(0);\n  };\n\n  TextAreaHandler.prototype._renderAtTopLeft = function () {\n    var ta = this.textArea;\n    var tac = this.textAreaCover;\n    Configuration.applyFontInfo(ta, this._fontInfo);\n    ta.setTop(0);\n    ta.setLeft(0);\n    tac.setTop(0);\n    tac.setLeft(0);\n\n    if (canUseZeroSizeTextarea) {\n      ta.setWidth(0);\n      ta.setHeight(0);\n      tac.setWidth(0);\n      tac.setHeight(0);\n      return;\n    } // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)\n    // specifically, when doing Korean IME, setting the textarea to 0x0 breaks IME badly.\n\n\n    ta.setWidth(1);\n    ta.setHeight(1);\n    tac.setWidth(1);\n    tac.setHeight(1);\n\n    if (this._context.configuration.editor.viewInfo.glyphMargin) {\n      tac.setClassName('monaco-editor-background textAreaCover ' + Margin.OUTER_CLASS_NAME);\n    } else {\n      if (this._context.configuration.editor.viewInfo.renderLineNumbers !== 0\n      /* Off */\n      ) {\n          tac.setClassName('monaco-editor-background textAreaCover ' + LineNumbersOverlay.CLASS_NAME);\n        } else {\n        tac.setClassName('monaco-editor-background textAreaCover');\n      }\n    }\n  };\n\n  return TextAreaHandler;\n}(ViewPart);\n\nexport { TextAreaHandler };\n\nfunction measureText(text, fontInfo) {\n  // adjust width by its size\n  var canvasElem = document.createElement('canvas');\n  var context = canvasElem.getContext('2d');\n  context.font = createFontString(fontInfo);\n  var metrics = context.measureText(text);\n\n  if (browser.isFirefox) {\n    return metrics.width + 2; // +2 for Japanese...\n  } else {\n    return metrics.width;\n  }\n}\n\nfunction createFontString(bareFontInfo) {\n  return doCreateFontString('normal', bareFontInfo.fontWeight, bareFontInfo.fontSize, bareFontInfo.lineHeight, bareFontInfo.fontFamily);\n}\n\nfunction doCreateFontString(fontStyle, fontWeight, fontSize, lineHeight, fontFamily) {\n  // The full font syntax is:\n  // style | variant | weight | stretch | size/line-height | fontFamily\n  // (https://developer.mozilla.org/en-US/docs/Web/CSS/font)\n  // But it appears Edge and IE11 cannot properly parse `stretch`.\n  return fontStyle + \" normal \" + fontWeight + \" \" + fontSize + \"px / \" + lineHeight + \"px \" + fontFamily;\n}","map":null,"metadata":{},"sourceType":"module"}