{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport './actionbar.css';\nimport * as platform from '../../../common/platform.js';\nimport * as nls from '../../../../nls.js';\nimport { Disposable, dispose } from '../../../common/lifecycle.js';\nimport { Action, ActionRunner } from '../../../common/actions.js';\nimport * as DOM from '../../dom.js';\nimport * as types from '../../../common/types.js';\nimport { EventType, Gesture } from '../../touch.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { Emitter } from '../../../common/event.js';\n\nvar BaseActionViewItem =\n/** @class */\nfunction (_super) {\n  __extends(BaseActionViewItem, _super);\n\n  function BaseActionViewItem(context, action, options) {\n    var _this = _super.call(this) || this;\n\n    _this.options = options;\n    _this._context = context || _this;\n    _this._action = action;\n\n    if (action instanceof Action) {\n      _this._register(action.onDidChange(function (event) {\n        if (!_this.element) {\n          // we have not been rendered yet, so there\n          // is no point in updating the UI\n          return;\n        }\n\n        _this.handleActionChangeEvent(event);\n      }));\n    }\n\n    return _this;\n  }\n\n  BaseActionViewItem.prototype.handleActionChangeEvent = function (event) {\n    if (event.enabled !== undefined) {\n      this.updateEnabled();\n    }\n\n    if (event.checked !== undefined) {\n      this.updateChecked();\n    }\n\n    if (event.class !== undefined) {\n      this.updateClass();\n    }\n\n    if (event.label !== undefined) {\n      this.updateLabel();\n      this.updateTooltip();\n    }\n\n    if (event.tooltip !== undefined) {\n      this.updateTooltip();\n    }\n  };\n\n  Object.defineProperty(BaseActionViewItem.prototype, \"actionRunner\", {\n    get: function () {\n      return this._actionRunner;\n    },\n    set: function (actionRunner) {\n      this._actionRunner = actionRunner;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BaseActionViewItem.prototype.getAction = function () {\n    return this._action;\n  };\n\n  BaseActionViewItem.prototype.isEnabled = function () {\n    return this._action.enabled;\n  };\n\n  BaseActionViewItem.prototype.setActionContext = function (newContext) {\n    this._context = newContext;\n  };\n\n  BaseActionViewItem.prototype.render = function (container) {\n    var _this = this;\n\n    this.element = container;\n    Gesture.addTarget(container);\n    var enableDragging = this.options && this.options.draggable;\n\n    if (enableDragging) {\n      container.draggable = true;\n    }\n\n    this._register(DOM.addDisposableListener(this.element, EventType.Tap, function (e) {\n      return _this.onClick(e);\n    }));\n\n    this._register(DOM.addDisposableListener(this.element, DOM.EventType.MOUSE_DOWN, function (e) {\n      if (!enableDragging) {\n        DOM.EventHelper.stop(e, true); // do not run when dragging is on because that would disable it\n      }\n\n      if (_this._action.enabled && e.button === 0 && _this.element) {\n        DOM.addClass(_this.element, 'active');\n      }\n    }));\n\n    this._register(DOM.addDisposableListener(this.element, DOM.EventType.CLICK, function (e) {\n      DOM.EventHelper.stop(e, true); // See https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Interact_with_the_clipboard\n      // > Writing to the clipboard\n      // > You can use the \"cut\" and \"copy\" commands without any special\n      // permission if you are using them in a short-lived event handler\n      // for a user action (for example, a click handler).\n      // => to get the Copy and Paste context menu actions working on Firefox,\n      // there should be no timeout here\n\n      if (_this.options && _this.options.isMenu) {\n        _this.onClick(e);\n      } else {\n        platform.setImmediate(function () {\n          return _this.onClick(e);\n        });\n      }\n    }));\n\n    this._register(DOM.addDisposableListener(this.element, DOM.EventType.DBLCLICK, function (e) {\n      DOM.EventHelper.stop(e, true);\n    }));\n\n    [DOM.EventType.MOUSE_UP, DOM.EventType.MOUSE_OUT].forEach(function (event) {\n      _this._register(DOM.addDisposableListener(_this.element, event, function (e) {\n        DOM.EventHelper.stop(e);\n        DOM.removeClass(_this.element, 'active');\n      }));\n    });\n  };\n\n  BaseActionViewItem.prototype.onClick = function (event) {\n    DOM.EventHelper.stop(event, true);\n    var context;\n\n    if (types.isUndefinedOrNull(this._context)) {\n      context = event;\n    } else {\n      context = this._context;\n\n      if (types.isObject(context)) {\n        context.event = event;\n      }\n    }\n\n    this._actionRunner.run(this._action, context);\n  };\n\n  BaseActionViewItem.prototype.focus = function () {\n    if (this.element) {\n      this.element.focus();\n      DOM.addClass(this.element, 'focused');\n    }\n  };\n\n  BaseActionViewItem.prototype.blur = function () {\n    if (this.element) {\n      this.element.blur();\n      DOM.removeClass(this.element, 'focused');\n    }\n  };\n\n  BaseActionViewItem.prototype.updateEnabled = function () {// implement in subclass\n  };\n\n  BaseActionViewItem.prototype.updateLabel = function () {// implement in subclass\n  };\n\n  BaseActionViewItem.prototype.updateTooltip = function () {// implement in subclass\n  };\n\n  BaseActionViewItem.prototype.updateClass = function () {// implement in subclass\n  };\n\n  BaseActionViewItem.prototype.updateChecked = function () {// implement in subclass\n  };\n\n  BaseActionViewItem.prototype.dispose = function () {\n    if (this.element) {\n      DOM.removeNode(this.element);\n      this.element = undefined;\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n\n  return BaseActionViewItem;\n}(Disposable);\n\nexport { BaseActionViewItem };\n\nvar Separator =\n/** @class */\nfunction (_super) {\n  __extends(Separator, _super);\n\n  function Separator(label) {\n    var _this = _super.call(this, Separator.ID, label, label ? 'separator text' : 'separator') || this;\n\n    _this.checked = false;\n    _this.radio = false;\n    _this.enabled = false;\n    return _this;\n  }\n\n  Separator.ID = 'vs.actions.separator';\n  return Separator;\n}(Action);\n\nexport { Separator };\n\nvar ActionViewItem =\n/** @class */\nfunction (_super) {\n  __extends(ActionViewItem, _super);\n\n  function ActionViewItem(context, action, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this, context, action, options) || this;\n\n    _this.options = options;\n    _this.options.icon = options.icon !== undefined ? options.icon : false;\n    _this.options.label = options.label !== undefined ? options.label : true;\n    _this.cssClass = '';\n    return _this;\n  }\n\n  ActionViewItem.prototype.render = function (container) {\n    _super.prototype.render.call(this, container);\n\n    if (this.element) {\n      this.label = DOM.append(this.element, DOM.$('a.action-label'));\n    }\n\n    if (this._action.id === Separator.ID) {\n      this.label.setAttribute('role', 'presentation'); // A separator is a presentation item\n    } else {\n      if (this.options.isMenu) {\n        this.label.setAttribute('role', 'menuitem');\n      } else {\n        this.label.setAttribute('role', 'button');\n      }\n    }\n\n    if (this.options.label && this.options.keybinding && this.element) {\n      DOM.append(this.element, DOM.$('span.keybinding')).textContent = this.options.keybinding;\n    }\n\n    this.updateClass();\n    this.updateLabel();\n    this.updateTooltip();\n    this.updateEnabled();\n    this.updateChecked();\n  };\n\n  ActionViewItem.prototype.focus = function () {\n    _super.prototype.focus.call(this);\n\n    this.label.focus();\n  };\n\n  ActionViewItem.prototype.updateLabel = function () {\n    if (this.options.label) {\n      this.label.textContent = this.getAction().label;\n    }\n  };\n\n  ActionViewItem.prototype.updateTooltip = function () {\n    var title = null;\n\n    if (this.getAction().tooltip) {\n      title = this.getAction().tooltip;\n    } else if (!this.options.label && this.getAction().label && this.options.icon) {\n      title = this.getAction().label;\n\n      if (this.options.keybinding) {\n        title = nls.localize({\n          key: 'titleLabel',\n          comment: ['action title', 'action keybinding']\n        }, \"{0} ({1})\", title, this.options.keybinding);\n      }\n    }\n\n    if (title) {\n      this.label.title = title;\n    }\n  };\n\n  ActionViewItem.prototype.updateClass = function () {\n    if (this.cssClass) {\n      DOM.removeClasses(this.label, this.cssClass);\n    }\n\n    if (this.options.icon) {\n      this.cssClass = this.getAction().class;\n      DOM.addClass(this.label, 'icon');\n\n      if (this.cssClass) {\n        DOM.addClasses(this.label, this.cssClass);\n      }\n\n      this.updateEnabled();\n    } else {\n      DOM.removeClass(this.label, 'icon');\n    }\n  };\n\n  ActionViewItem.prototype.updateEnabled = function () {\n    if (this.getAction().enabled) {\n      this.label.removeAttribute('aria-disabled');\n\n      if (this.element) {\n        DOM.removeClass(this.element, 'disabled');\n      }\n\n      DOM.removeClass(this.label, 'disabled');\n      this.label.tabIndex = 0;\n    } else {\n      this.label.setAttribute('aria-disabled', 'true');\n\n      if (this.element) {\n        DOM.addClass(this.element, 'disabled');\n      }\n\n      DOM.addClass(this.label, 'disabled');\n      DOM.removeTabIndexAndUpdateFocus(this.label);\n    }\n  };\n\n  ActionViewItem.prototype.updateChecked = function () {\n    if (this.getAction().checked) {\n      DOM.addClass(this.label, 'checked');\n    } else {\n      DOM.removeClass(this.label, 'checked');\n    }\n  };\n\n  return ActionViewItem;\n}(BaseActionViewItem);\n\nexport { ActionViewItem };\nvar defaultOptions = {\n  orientation: 0\n  /* HORIZONTAL */\n  ,\n  context: null,\n  triggerKeys: {\n    keys: [3\n    /* Enter */\n    , 10\n    /* Space */\n    ],\n    keyDown: false\n  }\n};\n\nvar ActionBar =\n/** @class */\nfunction (_super) {\n  __extends(ActionBar, _super);\n\n  function ActionBar(container, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this._onDidBlur = _this._register(new Emitter());\n    _this.onDidBlur = _this._onDidBlur.event;\n    _this._onDidCancel = _this._register(new Emitter());\n    _this.onDidCancel = _this._onDidCancel.event;\n    _this._onDidRun = _this._register(new Emitter());\n    _this.onDidRun = _this._onDidRun.event;\n    _this._onDidBeforeRun = _this._register(new Emitter());\n    _this.onDidBeforeRun = _this._onDidBeforeRun.event;\n    _this.options = options;\n    _this._context = options.context;\n\n    if (!_this.options.triggerKeys) {\n      _this.options.triggerKeys = defaultOptions.triggerKeys;\n    }\n\n    if (_this.options.actionRunner) {\n      _this._actionRunner = _this.options.actionRunner;\n    } else {\n      _this._actionRunner = new ActionRunner();\n\n      _this._register(_this._actionRunner);\n    }\n\n    _this._register(_this._actionRunner.onDidRun(function (e) {\n      return _this._onDidRun.fire(e);\n    }));\n\n    _this._register(_this._actionRunner.onDidBeforeRun(function (e) {\n      return _this._onDidBeforeRun.fire(e);\n    }));\n\n    _this.viewItems = [];\n    _this.focusedItem = undefined;\n    _this.domNode = document.createElement('div');\n    _this.domNode.className = 'monaco-action-bar';\n\n    if (options.animated !== false) {\n      DOM.addClass(_this.domNode, 'animated');\n    }\n\n    var previousKey;\n    var nextKey;\n\n    switch (_this.options.orientation) {\n      case 0\n      /* HORIZONTAL */\n      :\n        previousKey = 15\n        /* LeftArrow */\n        ;\n        nextKey = 17\n        /* RightArrow */\n        ;\n        break;\n\n      case 1\n      /* HORIZONTAL_REVERSE */\n      :\n        previousKey = 17\n        /* RightArrow */\n        ;\n        nextKey = 15\n        /* LeftArrow */\n        ;\n        _this.domNode.className += ' reverse';\n        break;\n\n      case 2\n      /* VERTICAL */\n      :\n        previousKey = 16\n        /* UpArrow */\n        ;\n        nextKey = 18\n        /* DownArrow */\n        ;\n        _this.domNode.className += ' vertical';\n        break;\n\n      case 3\n      /* VERTICAL_REVERSE */\n      :\n        previousKey = 18\n        /* DownArrow */\n        ;\n        nextKey = 16\n        /* UpArrow */\n        ;\n        _this.domNode.className += ' vertical reverse';\n        break;\n    }\n\n    _this._register(DOM.addDisposableListener(_this.domNode, DOM.EventType.KEY_DOWN, function (e) {\n      var event = new StandardKeyboardEvent(e);\n      var eventHandled = true;\n\n      if (event.equals(previousKey)) {\n        _this.focusPrevious();\n      } else if (event.equals(nextKey)) {\n        _this.focusNext();\n      } else if (event.equals(9\n      /* Escape */\n      )) {\n        _this.cancel();\n      } else if (_this.isTriggerKeyEvent(event)) {\n        // Staying out of the else branch even if not triggered\n        if (_this.options.triggerKeys && _this.options.triggerKeys.keyDown) {\n          _this.doTrigger(event);\n        }\n      } else {\n        eventHandled = false;\n      }\n\n      if (eventHandled) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }));\n\n    _this._register(DOM.addDisposableListener(_this.domNode, DOM.EventType.KEY_UP, function (e) {\n      var event = new StandardKeyboardEvent(e); // Run action on Enter/Space\n\n      if (_this.isTriggerKeyEvent(event)) {\n        if (_this.options.triggerKeys && !_this.options.triggerKeys.keyDown) {\n          _this.doTrigger(event);\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n      } // Recompute focused item\n      else if (event.equals(2\n        /* Tab */\n        ) || event.equals(1024\n        /* Shift */\n        | 2\n        /* Tab */\n        )) {\n          _this.updateFocusedItem();\n        }\n    }));\n\n    _this.focusTracker = _this._register(DOM.trackFocus(_this.domNode));\n\n    _this._register(_this.focusTracker.onDidBlur(function () {\n      if (document.activeElement === _this.domNode || !DOM.isAncestor(document.activeElement, _this.domNode)) {\n        _this._onDidBlur.fire();\n\n        _this.focusedItem = undefined;\n      }\n    }));\n\n    _this._register(_this.focusTracker.onDidFocus(function () {\n      return _this.updateFocusedItem();\n    }));\n\n    _this.actionsList = document.createElement('ul');\n    _this.actionsList.className = 'actions-container';\n\n    _this.actionsList.setAttribute('role', 'toolbar');\n\n    if (_this.options.ariaLabel) {\n      _this.actionsList.setAttribute('aria-label', _this.options.ariaLabel);\n    }\n\n    _this.domNode.appendChild(_this.actionsList);\n\n    container.appendChild(_this.domNode);\n    return _this;\n  }\n\n  ActionBar.prototype.isTriggerKeyEvent = function (event) {\n    var ret = false;\n\n    if (this.options.triggerKeys) {\n      this.options.triggerKeys.keys.forEach(function (keyCode) {\n        ret = ret || event.equals(keyCode);\n      });\n    }\n\n    return ret;\n  };\n\n  ActionBar.prototype.updateFocusedItem = function () {\n    for (var i = 0; i < this.actionsList.children.length; i++) {\n      var elem = this.actionsList.children[i];\n\n      if (DOM.isAncestor(document.activeElement, elem)) {\n        this.focusedItem = i;\n        break;\n      }\n    }\n  };\n\n  Object.defineProperty(ActionBar.prototype, \"context\", {\n    get: function () {\n      return this._context;\n    },\n    set: function (context) {\n      this._context = context;\n      this.viewItems.forEach(function (i) {\n        return i.setActionContext(context);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ActionBar.prototype.getContainer = function () {\n    return this.domNode;\n  };\n\n  ActionBar.prototype.push = function (arg, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var actions = Array.isArray(arg) ? arg : [arg];\n    var index = types.isNumber(options.index) ? options.index : null;\n    actions.forEach(function (action) {\n      var actionViewItemElement = document.createElement('li');\n      actionViewItemElement.className = 'action-item';\n      actionViewItemElement.setAttribute('role', 'presentation'); // Prevent native context menu on actions\n\n      _this._register(DOM.addDisposableListener(actionViewItemElement, DOM.EventType.CONTEXT_MENU, function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n      }));\n\n      var item;\n\n      if (_this.options.actionViewItemProvider) {\n        item = _this.options.actionViewItemProvider(action);\n      }\n\n      if (!item) {\n        item = new ActionViewItem(_this.context, action, options);\n      }\n\n      item.actionRunner = _this._actionRunner;\n      item.setActionContext(_this.context);\n      item.render(actionViewItemElement);\n\n      if (index === null || index < 0 || index >= _this.actionsList.children.length) {\n        _this.actionsList.appendChild(actionViewItemElement);\n\n        _this.viewItems.push(item);\n      } else {\n        _this.actionsList.insertBefore(actionViewItemElement, _this.actionsList.children[index]);\n\n        _this.viewItems.splice(index, 0, item);\n\n        index++;\n      }\n    });\n  };\n\n  ActionBar.prototype.clear = function () {\n    this.viewItems = dispose(this.viewItems);\n    DOM.clearNode(this.actionsList);\n  };\n\n  ActionBar.prototype.isEmpty = function () {\n    return this.viewItems.length === 0;\n  };\n\n  ActionBar.prototype.focus = function (arg) {\n    var selectFirst = false;\n    var index = undefined;\n\n    if (arg === undefined) {\n      selectFirst = true;\n    } else if (typeof arg === 'number') {\n      index = arg;\n    } else if (typeof arg === 'boolean') {\n      selectFirst = arg;\n    }\n\n    if (selectFirst && typeof this.focusedItem === 'undefined') {\n      // Focus the first enabled item\n      this.focusedItem = this.viewItems.length - 1;\n      this.focusNext();\n    } else {\n      if (index !== undefined) {\n        this.focusedItem = index;\n      }\n\n      this.updateFocus();\n    }\n  };\n\n  ActionBar.prototype.focusNext = function () {\n    if (typeof this.focusedItem === 'undefined') {\n      this.focusedItem = this.viewItems.length - 1;\n    }\n\n    var startIndex = this.focusedItem;\n    var item;\n\n    do {\n      this.focusedItem = (this.focusedItem + 1) % this.viewItems.length;\n      item = this.viewItems[this.focusedItem];\n    } while (this.focusedItem !== startIndex && !item.isEnabled());\n\n    if (this.focusedItem === startIndex && !item.isEnabled()) {\n      this.focusedItem = undefined;\n    }\n\n    this.updateFocus();\n  };\n\n  ActionBar.prototype.focusPrevious = function () {\n    if (typeof this.focusedItem === 'undefined') {\n      this.focusedItem = 0;\n    }\n\n    var startIndex = this.focusedItem;\n    var item;\n\n    do {\n      this.focusedItem = this.focusedItem - 1;\n\n      if (this.focusedItem < 0) {\n        this.focusedItem = this.viewItems.length - 1;\n      }\n\n      item = this.viewItems[this.focusedItem];\n    } while (this.focusedItem !== startIndex && !item.isEnabled());\n\n    if (this.focusedItem === startIndex && !item.isEnabled()) {\n      this.focusedItem = undefined;\n    }\n\n    this.updateFocus(true);\n  };\n\n  ActionBar.prototype.updateFocus = function (fromRight) {\n    if (typeof this.focusedItem === 'undefined') {\n      this.actionsList.focus();\n    }\n\n    for (var i = 0; i < this.viewItems.length; i++) {\n      var item = this.viewItems[i];\n      var actionViewItem = item;\n\n      if (i === this.focusedItem) {\n        if (types.isFunction(actionViewItem.isEnabled)) {\n          if (actionViewItem.isEnabled() && types.isFunction(actionViewItem.focus)) {\n            actionViewItem.focus(fromRight);\n          } else {\n            this.actionsList.focus();\n          }\n        }\n      } else {\n        if (types.isFunction(actionViewItem.blur)) {\n          actionViewItem.blur();\n        }\n      }\n    }\n  };\n\n  ActionBar.prototype.doTrigger = function (event) {\n    if (typeof this.focusedItem === 'undefined') {\n      return; //nothing to focus\n    } // trigger action\n\n\n    var actionViewItem = this.viewItems[this.focusedItem];\n\n    if (actionViewItem instanceof BaseActionViewItem) {\n      var context = actionViewItem._context === null || actionViewItem._context === undefined ? event : actionViewItem._context;\n      this.run(actionViewItem._action, context);\n    }\n  };\n\n  ActionBar.prototype.cancel = function () {\n    if (document.activeElement instanceof HTMLElement) {\n      document.activeElement.blur(); // remove focus from focused action\n    }\n\n    this._onDidCancel.fire();\n  };\n\n  ActionBar.prototype.run = function (action, context) {\n    return this._actionRunner.run(action, context);\n  };\n\n  ActionBar.prototype.dispose = function () {\n    dispose(this.viewItems);\n    this.viewItems = [];\n    DOM.removeNode(this.getContainer());\n\n    _super.prototype.dispose.call(this);\n  };\n\n  return ActionBar;\n}(Disposable);\n\nexport { ActionBar };","map":null,"metadata":{},"sourceType":"module"}