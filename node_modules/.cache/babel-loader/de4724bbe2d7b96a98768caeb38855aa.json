{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from './cursorCommon.js';\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\n\nvar WordOperations =\n/** @class */\nfunction () {\n  function WordOperations() {}\n\n  WordOperations._createWord = function (lineContent, wordType, nextCharClass, start, end) {\n    // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n    return {\n      start: start,\n      end: end,\n      wordType: wordType,\n      nextCharClass: nextCharClass\n    };\n  };\n\n  WordOperations._findPreviousWordOnLine = function (wordSeparators, model, position) {\n    var lineContent = model.getLineContent(position.lineNumber);\n    return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n  };\n\n  WordOperations._doFindPreviousWordOnLine = function (lineContent, wordSeparators, position) {\n    var wordType = 0\n    /* None */\n    ;\n\n    for (var chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n      var chCode = lineContent.charCodeAt(chIndex);\n      var chClass = wordSeparators.get(chCode);\n\n      if (chClass === 0\n      /* Regular */\n      ) {\n          if (wordType === 2\n          /* Separator */\n          ) {\n              return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n            }\n\n          wordType = 1\n          /* Regular */\n          ;\n        } else if (chClass === 2\n      /* WordSeparator */\n      ) {\n          if (wordType === 1\n          /* Regular */\n          ) {\n              return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n            }\n\n          wordType = 2\n          /* Separator */\n          ;\n        } else if (chClass === 1\n      /* Whitespace */\n      ) {\n          if (wordType !== 0\n          /* None */\n          ) {\n              return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n            }\n        }\n    }\n\n    if (wordType !== 0\n    /* None */\n    ) {\n        return this._createWord(lineContent, wordType, 1\n        /* Whitespace */\n        , 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n      }\n\n    return null;\n  };\n\n  WordOperations._findEndOfWord = function (lineContent, wordSeparators, wordType, startIndex) {\n    var len = lineContent.length;\n\n    for (var chIndex = startIndex; chIndex < len; chIndex++) {\n      var chCode = lineContent.charCodeAt(chIndex);\n      var chClass = wordSeparators.get(chCode);\n\n      if (chClass === 1\n      /* Whitespace */\n      ) {\n          return chIndex;\n        }\n\n      if (wordType === 1\n      /* Regular */\n      && chClass === 2\n      /* WordSeparator */\n      ) {\n          return chIndex;\n        }\n\n      if (wordType === 2\n      /* Separator */\n      && chClass === 0\n      /* Regular */\n      ) {\n          return chIndex;\n        }\n    }\n\n    return len;\n  };\n\n  WordOperations._findNextWordOnLine = function (wordSeparators, model, position) {\n    var lineContent = model.getLineContent(position.lineNumber);\n    return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n  };\n\n  WordOperations._doFindNextWordOnLine = function (lineContent, wordSeparators, position) {\n    var wordType = 0\n    /* None */\n    ;\n    var len = lineContent.length;\n\n    for (var chIndex = position.column - 1; chIndex < len; chIndex++) {\n      var chCode = lineContent.charCodeAt(chIndex);\n      var chClass = wordSeparators.get(chCode);\n\n      if (chClass === 0\n      /* Regular */\n      ) {\n          if (wordType === 2\n          /* Separator */\n          ) {\n              return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n            }\n\n          wordType = 1\n          /* Regular */\n          ;\n        } else if (chClass === 2\n      /* WordSeparator */\n      ) {\n          if (wordType === 1\n          /* Regular */\n          ) {\n              return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n            }\n\n          wordType = 2\n          /* Separator */\n          ;\n        } else if (chClass === 1\n      /* Whitespace */\n      ) {\n          if (wordType !== 0\n          /* None */\n          ) {\n              return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n            }\n        }\n    }\n\n    if (wordType !== 0\n    /* None */\n    ) {\n        return this._createWord(lineContent, wordType, 1\n        /* Whitespace */\n        , this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n      }\n\n    return null;\n  };\n\n  WordOperations._findStartOfWord = function (lineContent, wordSeparators, wordType, startIndex) {\n    for (var chIndex = startIndex; chIndex >= 0; chIndex--) {\n      var chCode = lineContent.charCodeAt(chIndex);\n      var chClass = wordSeparators.get(chCode);\n\n      if (chClass === 1\n      /* Whitespace */\n      ) {\n          return chIndex + 1;\n        }\n\n      if (wordType === 1\n      /* Regular */\n      && chClass === 2\n      /* WordSeparator */\n      ) {\n          return chIndex + 1;\n        }\n\n      if (wordType === 2\n      /* Separator */\n      && chClass === 0\n      /* Regular */\n      ) {\n          return chIndex + 1;\n        }\n    }\n\n    return 0;\n  };\n\n  WordOperations.moveWordLeft = function (wordSeparators, model, position, wordNavigationType) {\n    var lineNumber = position.lineNumber;\n    var column = position.column;\n    var movedToPreviousLine = false;\n\n    if (column === 1) {\n      if (lineNumber > 1) {\n        movedToPreviousLine = true;\n        lineNumber = lineNumber - 1;\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    }\n\n    var prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n    if (wordNavigationType === 0\n    /* WordStart */\n    ) {\n        if (prevWordOnLine && !movedToPreviousLine) {\n          // Special case for Visual Studio compatibility:\n          // when starting in the trim whitespace at the end of a line,\n          // go to the end of the last word\n          var lastWhitespaceColumn = model.getLineLastNonWhitespaceColumn(lineNumber);\n\n          if (lastWhitespaceColumn < column) {\n            return new Position(lineNumber, prevWordOnLine.end + 1);\n          }\n        }\n\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n      }\n\n    if (wordNavigationType === 1\n    /* WordStartFast */\n    ) {\n        if (prevWordOnLine && prevWordOnLine.wordType === 2\n        /* Separator */\n        && prevWordOnLine.end - prevWordOnLine.start === 1 && prevWordOnLine.nextCharClass === 0\n        /* Regular */\n        ) {\n            // Skip over a word made up of one single separator and followed by a regular character\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n          }\n\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n      }\n\n    if (wordNavigationType === 3\n    /* WordAccessibility */\n    ) {\n        while (prevWordOnLine && prevWordOnLine.wordType === 2\n        /* Separator */\n        ) {\n          // Skip over words made up of only separators\n          prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n      } // We are stopping at the ending of words\n\n\n    if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n      prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n    }\n\n    return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n  };\n\n  WordOperations._moveWordPartLeft = function (model, position) {\n    var lineNumber = position.lineNumber;\n    var maxColumn = model.getLineMaxColumn(lineNumber);\n\n    if (position.column === 1) {\n      return lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position;\n    }\n\n    var lineContent = model.getLineContent(lineNumber);\n\n    for (var column = position.column - 1; column > 1; column--) {\n      var left = lineContent.charCodeAt(column - 2);\n      var right = lineContent.charCodeAt(column - 1);\n\n      if (left !== 95\n      /* Underline */\n      && right === 95\n      /* Underline */\n      ) {\n          // snake_case_variables\n          return new Position(lineNumber, column);\n        }\n\n      if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // camelCaseVariables\n        return new Position(lineNumber, column);\n      }\n\n      if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // thisIsACamelCaseWithOneLetterWords\n        if (column + 1 < maxColumn) {\n          var rightRight = lineContent.charCodeAt(column);\n\n          if (strings.isLowerAsciiLetter(rightRight)) {\n            return new Position(lineNumber, column);\n          }\n        }\n      }\n    }\n\n    return new Position(lineNumber, 1);\n  };\n\n  WordOperations.moveWordRight = function (wordSeparators, model, position, wordNavigationType) {\n    var lineNumber = position.lineNumber;\n    var column = position.column;\n    var movedDown = false;\n\n    if (column === model.getLineMaxColumn(lineNumber)) {\n      if (lineNumber < model.getLineCount()) {\n        movedDown = true;\n        lineNumber = lineNumber + 1;\n        column = 1;\n      }\n    }\n\n    var nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n    if (wordNavigationType === 2\n    /* WordEnd */\n    ) {\n        if (nextWordOnLine && nextWordOnLine.wordType === 2\n        /* Separator */\n        ) {\n            if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0\n            /* Regular */\n            ) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n              }\n          }\n\n        if (nextWordOnLine) {\n          column = nextWordOnLine.end + 1;\n        } else {\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      } else if (wordNavigationType === 3\n    /* WordAccessibility */\n    ) {\n        while (nextWordOnLine && nextWordOnLine.wordType === 2\n        /* Separator */\n        ) {\n          // Skip over a word made up of one single separator\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n        }\n\n        if (nextWordOnLine) {\n          column = nextWordOnLine.end + 1;\n        } else {\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      } else {\n      if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    }\n\n    return new Position(lineNumber, column);\n  };\n\n  WordOperations._moveWordPartRight = function (model, position) {\n    var lineNumber = position.lineNumber;\n    var maxColumn = model.getLineMaxColumn(lineNumber);\n\n    if (position.column === maxColumn) {\n      return lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position;\n    }\n\n    var lineContent = model.getLineContent(lineNumber);\n\n    for (var column = position.column + 1; column < maxColumn; column++) {\n      var left = lineContent.charCodeAt(column - 2);\n      var right = lineContent.charCodeAt(column - 1);\n\n      if (left === 95\n      /* Underline */\n      && right !== 95\n      /* Underline */\n      ) {\n          // snake_case_variables\n          return new Position(lineNumber, column);\n        }\n\n      if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // camelCaseVariables\n        return new Position(lineNumber, column);\n      }\n\n      if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // thisIsACamelCaseWithOneLetterWords\n        if (column + 1 < maxColumn) {\n          var rightRight = lineContent.charCodeAt(column);\n\n          if (strings.isLowerAsciiLetter(rightRight)) {\n            return new Position(lineNumber, column);\n          }\n        }\n      }\n    }\n\n    return new Position(lineNumber, maxColumn);\n  };\n\n  WordOperations._deleteWordLeftWhitespace = function (model, position) {\n    var lineContent = model.getLineContent(position.lineNumber);\n    var startIndex = position.column - 2;\n    var lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n\n    if (lastNonWhitespace + 1 < startIndex) {\n      return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n    }\n\n    return null;\n  };\n\n  WordOperations.deleteWordLeft = function (wordSeparators, model, selection, whitespaceHeuristics, wordNavigationType) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n\n    var position = new Position(selection.positionLineNumber, selection.positionColumn);\n    var lineNumber = position.lineNumber;\n    var column = position.column;\n\n    if (lineNumber === 1 && column === 1) {\n      // Ignore deleting at beginning of file\n      return null;\n    }\n\n    if (whitespaceHeuristics) {\n      var r = this._deleteWordLeftWhitespace(model, position);\n\n      if (r) {\n        return r;\n      }\n    }\n\n    var prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n    if (wordNavigationType === 0\n    /* WordStart */\n    ) {\n        if (prevWordOnLine) {\n          column = prevWordOnLine.start + 1;\n        } else {\n          if (column > 1) {\n            column = 1;\n          } else {\n            lineNumber--;\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      } else {\n      if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n\n      if (prevWordOnLine) {\n        column = prevWordOnLine.end + 1;\n      } else {\n        if (column > 1) {\n          column = 1;\n        } else {\n          lineNumber--;\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n    }\n\n    return new Range(lineNumber, column, position.lineNumber, position.column);\n  };\n\n  WordOperations._deleteWordPartLeft = function (model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n\n    var pos = selection.getPosition();\n\n    var toPosition = WordOperations._moveWordPartLeft(model, pos);\n\n    return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n  };\n\n  WordOperations._findFirstNonWhitespaceChar = function (str, startIndex) {\n    var len = str.length;\n\n    for (var chIndex = startIndex; chIndex < len; chIndex++) {\n      var ch = str.charAt(chIndex);\n\n      if (ch !== ' ' && ch !== '\\t') {\n        return chIndex;\n      }\n    }\n\n    return len;\n  };\n\n  WordOperations._deleteWordRightWhitespace = function (model, position) {\n    var lineContent = model.getLineContent(position.lineNumber);\n    var startIndex = position.column - 1;\n\n    var firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n\n    if (startIndex + 1 < firstNonWhitespace) {\n      // bingo\n      return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n    }\n\n    return null;\n  };\n\n  WordOperations.deleteWordRight = function (wordSeparators, model, selection, whitespaceHeuristics, wordNavigationType) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n\n    var position = new Position(selection.positionLineNumber, selection.positionColumn);\n    var lineNumber = position.lineNumber;\n    var column = position.column;\n    var lineCount = model.getLineCount();\n    var maxColumn = model.getLineMaxColumn(lineNumber);\n\n    if (lineNumber === lineCount && column === maxColumn) {\n      // Ignore deleting at end of file\n      return null;\n    }\n\n    if (whitespaceHeuristics) {\n      var r = this._deleteWordRightWhitespace(model, position);\n\n      if (r) {\n        return r;\n      }\n    }\n\n    var nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n    if (wordNavigationType === 2\n    /* WordEnd */\n    ) {\n        if (nextWordOnLine) {\n          column = nextWordOnLine.end + 1;\n        } else {\n          if (column < maxColumn || lineNumber === lineCount) {\n            column = maxColumn;\n          } else {\n            lineNumber++;\n            nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\n            if (nextWordOnLine) {\n              column = nextWordOnLine.start + 1;\n            } else {\n              column = model.getLineMaxColumn(lineNumber);\n            }\n          }\n        }\n      } else {\n      if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        if (column < maxColumn || lineNumber === lineCount) {\n          column = maxColumn;\n        } else {\n          lineNumber++;\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\n          if (nextWordOnLine) {\n            column = nextWordOnLine.start + 1;\n          } else {\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      }\n    }\n\n    return new Range(lineNumber, column, position.lineNumber, position.column);\n  };\n\n  WordOperations._deleteWordPartRight = function (model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n\n    var pos = selection.getPosition();\n\n    var toPosition = WordOperations._moveWordPartRight(model, pos);\n\n    return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n  };\n\n  WordOperations.word = function (config, model, cursor, inSelectionMode, position) {\n    var wordSeparators = getMapForWordSeparators(config.wordSeparators);\n\n    var prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n    var nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n    if (!inSelectionMode) {\n      // Entering word selection for the first time\n      var startColumn_1;\n      var endColumn_1;\n\n      if (prevWord && prevWord.wordType === 1\n      /* Regular */\n      && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n        // isTouchingPrevWord\n        startColumn_1 = prevWord.start + 1;\n        endColumn_1 = prevWord.end + 1;\n      } else if (nextWord && nextWord.wordType === 1\n      /* Regular */\n      && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n        // isTouchingNextWord\n        startColumn_1 = nextWord.start + 1;\n        endColumn_1 = nextWord.end + 1;\n      } else {\n        if (prevWord) {\n          startColumn_1 = prevWord.end + 1;\n        } else {\n          startColumn_1 = 1;\n        }\n\n        if (nextWord) {\n          endColumn_1 = nextWord.start + 1;\n        } else {\n          endColumn_1 = model.getLineMaxColumn(position.lineNumber);\n        }\n      }\n\n      return new SingleCursorState(new Range(position.lineNumber, startColumn_1, position.lineNumber, endColumn_1), 0, new Position(position.lineNumber, endColumn_1), 0);\n    }\n\n    var startColumn;\n    var endColumn;\n\n    if (prevWord && prevWord.wordType === 1\n    /* Regular */\n    && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n      // isInsidePrevWord\n      startColumn = prevWord.start + 1;\n      endColumn = prevWord.end + 1;\n    } else if (nextWord && nextWord.wordType === 1\n    /* Regular */\n    && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n      // isInsideNextWord\n      startColumn = nextWord.start + 1;\n      endColumn = nextWord.end + 1;\n    } else {\n      startColumn = position.column;\n      endColumn = position.column;\n    }\n\n    var lineNumber = position.lineNumber;\n    var column;\n\n    if (cursor.selectionStart.containsPosition(position)) {\n      column = cursor.selectionStart.endColumn;\n    } else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n      column = startColumn;\n      var possiblePosition = new Position(lineNumber, column);\n\n      if (cursor.selectionStart.containsPosition(possiblePosition)) {\n        column = cursor.selectionStart.endColumn;\n      }\n    } else {\n      column = endColumn;\n      var possiblePosition = new Position(lineNumber, column);\n\n      if (cursor.selectionStart.containsPosition(possiblePosition)) {\n        column = cursor.selectionStart.startColumn;\n      }\n    }\n\n    return cursor.move(true, lineNumber, column, 0);\n  };\n\n  return WordOperations;\n}();\n\nexport { WordOperations };\n\nvar WordPartOperations =\n/** @class */\nfunction (_super) {\n  __extends(WordPartOperations, _super);\n\n  function WordPartOperations() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  WordPartOperations.deleteWordPartLeft = function (wordSeparators, model, selection, whitespaceHeuristics) {\n    var candidates = enforceDefined([WordOperations.deleteWordLeft(wordSeparators, model, selection, whitespaceHeuristics, 0\n    /* WordStart */\n    ), WordOperations.deleteWordLeft(wordSeparators, model, selection, whitespaceHeuristics, 2\n    /* WordEnd */\n    ), WordOperations._deleteWordPartLeft(model, selection)]);\n    candidates.sort(Range.compareRangesUsingEnds);\n    return candidates[2];\n  };\n\n  WordPartOperations.deleteWordPartRight = function (wordSeparators, model, selection, whitespaceHeuristics) {\n    var candidates = enforceDefined([WordOperations.deleteWordRight(wordSeparators, model, selection, whitespaceHeuristics, 0\n    /* WordStart */\n    ), WordOperations.deleteWordRight(wordSeparators, model, selection, whitespaceHeuristics, 2\n    /* WordEnd */\n    ), WordOperations._deleteWordPartRight(model, selection)]);\n    candidates.sort(Range.compareRangesUsingStarts);\n    return candidates[0];\n  };\n\n  WordPartOperations.moveWordPartLeft = function (wordSeparators, model, position) {\n    var candidates = enforceDefined([WordOperations.moveWordLeft(wordSeparators, model, position, 0\n    /* WordStart */\n    ), WordOperations.moveWordLeft(wordSeparators, model, position, 2\n    /* WordEnd */\n    ), WordOperations._moveWordPartLeft(model, position)]);\n    candidates.sort(Position.compare);\n    return candidates[2];\n  };\n\n  WordPartOperations.moveWordPartRight = function (wordSeparators, model, position) {\n    var candidates = enforceDefined([WordOperations.moveWordRight(wordSeparators, model, position, 0\n    /* WordStart */\n    ), WordOperations.moveWordRight(wordSeparators, model, position, 2\n    /* WordEnd */\n    ), WordOperations._moveWordPartRight(model, position)]);\n    candidates.sort(Position.compare);\n    return candidates[0];\n  };\n\n  return WordPartOperations;\n}(WordOperations);\n\nexport { WordPartOperations };\n\nfunction enforceDefined(arr) {\n  return arr.filter(function (el) {\n    return Boolean(el);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}