{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { tail2 } from '../../../common/arrays.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterator } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n  return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n  switch (visibility) {\n    case true:\n      return 1\n      /* Visible */\n      ;\n\n    case false:\n      return 0\n      /* Hidden */\n      ;\n\n    default:\n      return visibility;\n  }\n}\n\nfunction treeNodeToElement(node) {\n  var element = node.element,\n      collapsed = node.collapsed;\n  var children = Iterator.map(Iterator.fromArray(node.children), treeNodeToElement);\n  return {\n    element: element,\n    children: children,\n    collapsed: collapsed\n  };\n}\n\nvar IndexTreeModel =\n/** @class */\nfunction () {\n  function IndexTreeModel(list, rootElement, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.list = list;\n    this.rootRef = [];\n    this.eventBufferer = new EventBufferer();\n    this._onDidChangeCollapseState = new Emitter();\n    this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n    this._onDidChangeRenderNodeCount = new Emitter();\n    this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n    this._onDidSplice = new Emitter();\n    this.onDidSplice = this._onDidSplice.event;\n    this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n    this.filter = options.filter;\n    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n    this.root = {\n      parent: undefined,\n      element: rootElement,\n      children: [],\n      depth: 0,\n      visibleChildrenCount: 0,\n      visibleChildIndex: -1,\n      collapsible: false,\n      collapsed: false,\n      renderNodeCount: 0,\n      visible: true,\n      filterData: undefined\n    };\n  }\n\n  IndexTreeModel.prototype.splice = function (location, deleteCount, toInsert, onDidCreateNode, onDidDeleteNode) {\n    var _a;\n\n    var _this = this;\n\n    if (location.length === 0) {\n      throw new Error('Invalid tree location');\n    }\n\n    var _b = this.getParentNodeWithListIndex(location),\n        parentNode = _b.parentNode,\n        listIndex = _b.listIndex,\n        revealed = _b.revealed,\n        visible = _b.visible;\n\n    var treeListElementsToInsert = [];\n    var nodesToInsertIterator = Iterator.map(Iterator.from(toInsert), function (el) {\n      return _this.createTreeNode(el, parentNode, parentNode.visible ? 1\n      /* Visible */\n      : 0\n      /* Hidden */\n      , revealed, treeListElementsToInsert, onDidCreateNode);\n    });\n    var lastIndex = location[location.length - 1]; // figure out what's the visible child start index right before the\n    // splice point\n\n    var visibleChildStartIndex = 0;\n\n    for (var i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n      var child = parentNode.children[i];\n\n      if (child.visible) {\n        visibleChildStartIndex = child.visibleChildIndex;\n        break;\n      }\n    }\n\n    var nodesToInsert = [];\n    var insertedVisibleChildrenCount = 0;\n    var renderNodeCount = 0;\n    Iterator.forEach(nodesToInsertIterator, function (child) {\n      nodesToInsert.push(child);\n      renderNodeCount += child.renderNodeCount;\n\n      if (child.visible) {\n        child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n      }\n    });\n\n    var deletedNodes = (_a = parentNode.children).splice.apply(_a, [lastIndex, deleteCount].concat(nodesToInsert)); // figure out what is the count of deleted visible children\n\n\n    var deletedVisibleChildrenCount = 0;\n\n    for (var _i = 0, deletedNodes_1 = deletedNodes; _i < deletedNodes_1.length; _i++) {\n      var child = deletedNodes_1[_i];\n\n      if (child.visible) {\n        deletedVisibleChildrenCount++;\n      }\n    } // and adjust for all visible children after the splice point\n\n\n    if (deletedVisibleChildrenCount !== 0) {\n      for (var i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n        var child = parentNode.children[i];\n\n        if (child.visible) {\n          child.visibleChildIndex -= deletedVisibleChildrenCount;\n        }\n      }\n    } // update parent's visible children count\n\n\n    parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n\n    if (revealed && visible) {\n      var visibleDeleteCount = deletedNodes.reduce(function (r, node) {\n        return r + node.renderNodeCount;\n      }, 0);\n\n      this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n\n      this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n    }\n\n    if (deletedNodes.length > 0 && onDidDeleteNode) {\n      var visit_1 = function (node) {\n        onDidDeleteNode(node);\n        node.children.forEach(visit_1);\n      };\n\n      deletedNodes.forEach(visit_1);\n    }\n\n    var result = Iterator.map(Iterator.fromArray(deletedNodes), treeNodeToElement);\n\n    this._onDidSplice.fire({\n      insertedNodes: nodesToInsert,\n      deletedNodes: deletedNodes\n    });\n\n    return result;\n  };\n\n  IndexTreeModel.prototype.rerender = function (location) {\n    if (location.length === 0) {\n      throw new Error('Invalid tree location');\n    }\n\n    var _a = this.getTreeNodeWithListIndex(location),\n        node = _a.node,\n        listIndex = _a.listIndex,\n        revealed = _a.revealed;\n\n    if (revealed) {\n      this.list.splice(listIndex, 1, [node]);\n    }\n  };\n\n  IndexTreeModel.prototype.getListIndex = function (location) {\n    var _a = this.getTreeNodeWithListIndex(location),\n        listIndex = _a.listIndex,\n        visible = _a.visible,\n        revealed = _a.revealed;\n\n    return visible && revealed ? listIndex : -1;\n  };\n\n  IndexTreeModel.prototype.getListRenderCount = function (location) {\n    return this.getTreeNode(location).renderNodeCount;\n  };\n\n  IndexTreeModel.prototype.isCollapsed = function (location) {\n    return this.getTreeNode(location).collapsed;\n  };\n\n  IndexTreeModel.prototype.setCollapsed = function (location, collapsed, recursive) {\n    var _this = this;\n\n    var node = this.getTreeNode(location);\n\n    if (typeof collapsed === 'undefined') {\n      collapsed = !node.collapsed;\n    }\n\n    return this.eventBufferer.bufferEvents(function () {\n      return _this._setCollapsed(location, collapsed, recursive);\n    });\n  };\n\n  IndexTreeModel.prototype._setCollapsed = function (location, collapsed, recursive) {\n    var _a = this.getTreeNodeWithListIndex(location),\n        node = _a.node,\n        listIndex = _a.listIndex,\n        revealed = _a.revealed;\n\n    var result = this._setListNodeCollapsed(node, listIndex, revealed, collapsed, recursive || false);\n\n    if (node !== this.root && this.autoExpandSingleChildren && !collapsed && !recursive) {\n      var onlyVisibleChildIndex = -1;\n\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n\n        if (child.visible) {\n          if (onlyVisibleChildIndex > -1) {\n            onlyVisibleChildIndex = -1;\n            break;\n          } else {\n            onlyVisibleChildIndex = i;\n          }\n        }\n      }\n\n      if (onlyVisibleChildIndex > -1) {\n        this._setCollapsed(location.concat([onlyVisibleChildIndex]), false, false);\n      }\n    }\n\n    return result;\n  };\n\n  IndexTreeModel.prototype._setListNodeCollapsed = function (node, listIndex, revealed, collapsed, recursive) {\n    var result = this._setNodeCollapsed(node, collapsed, recursive, false);\n\n    if (!revealed || !node.visible) {\n      return result;\n    }\n\n    var previousRenderNodeCount = node.renderNodeCount;\n    var toInsert = this.updateNodeAfterCollapseChange(node);\n    var deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n    this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n    return result;\n  };\n\n  IndexTreeModel.prototype._setNodeCollapsed = function (node, collapsed, recursive, deep) {\n    var result = node.collapsible && node.collapsed !== collapsed;\n\n    if (node.collapsible) {\n      node.collapsed = collapsed;\n\n      if (result) {\n        this._onDidChangeCollapseState.fire({\n          node: node,\n          deep: deep\n        });\n      }\n    }\n\n    if (recursive) {\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        result = this._setNodeCollapsed(child, collapsed, true, true) || result;\n      }\n    }\n\n    return result;\n  };\n\n  IndexTreeModel.prototype.expandTo = function (location) {\n    var _this = this;\n\n    this.eventBufferer.bufferEvents(function () {\n      var node = _this.getTreeNode(location);\n\n      while (node.parent) {\n        node = node.parent;\n        location = location.slice(0, location.length - 1);\n\n        if (node.collapsed) {\n          _this._setCollapsed(location, false);\n        }\n      }\n    });\n  };\n\n  IndexTreeModel.prototype.refilter = function () {\n    var previousRenderNodeCount = this.root.renderNodeCount;\n    var toInsert = this.updateNodeAfterFilterChange(this.root);\n    this.list.splice(0, previousRenderNodeCount, toInsert);\n  };\n\n  IndexTreeModel.prototype.createTreeNode = function (treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n    var _this = this;\n\n    var node = {\n      parent: parent,\n      element: treeElement.element,\n      children: [],\n      depth: parent.depth + 1,\n      visibleChildrenCount: 0,\n      visibleChildIndex: -1,\n      collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : typeof treeElement.collapsed !== 'undefined',\n      collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n      renderNodeCount: 1,\n      visible: true,\n      filterData: undefined\n    };\n\n    var visibility = this._filterNode(node, parentVisibility);\n\n    if (revealed) {\n      treeListElements.push(node);\n    }\n\n    var childElements = Iterator.from(treeElement.children);\n    var childRevealed = revealed && visibility !== 0\n    /* Hidden */\n    && !node.collapsed;\n    var childNodes = Iterator.map(childElements, function (el) {\n      return _this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode);\n    });\n    var visibleChildrenCount = 0;\n    var renderNodeCount = 1;\n    Iterator.forEach(childNodes, function (child) {\n      node.children.push(child);\n      renderNodeCount += child.renderNodeCount;\n\n      if (child.visible) {\n        child.visibleChildIndex = visibleChildrenCount++;\n      }\n    });\n    node.collapsible = node.collapsible || node.children.length > 0;\n    node.visibleChildrenCount = visibleChildrenCount;\n    node.visible = visibility === 2\n    /* Recurse */\n    ? visibleChildrenCount > 0 : visibility === 1\n    /* Visible */\n    ;\n\n    if (!node.visible) {\n      node.renderNodeCount = 0;\n\n      if (revealed) {\n        treeListElements.pop();\n      }\n    } else if (!node.collapsed) {\n      node.renderNodeCount = renderNodeCount;\n    }\n\n    if (onDidCreateNode) {\n      onDidCreateNode(node);\n    }\n\n    return node;\n  };\n\n  IndexTreeModel.prototype.updateNodeAfterCollapseChange = function (node) {\n    var previousRenderNodeCount = node.renderNodeCount;\n    var result = [];\n\n    this._updateNodeAfterCollapseChange(node, result);\n\n    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n    return result;\n  };\n\n  IndexTreeModel.prototype._updateNodeAfterCollapseChange = function (node, result) {\n    if (node.visible === false) {\n      return 0;\n    }\n\n    result.push(node);\n    node.renderNodeCount = 1;\n\n    if (!node.collapsed) {\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n      }\n    }\n\n    this._onDidChangeRenderNodeCount.fire(node);\n\n    return node.renderNodeCount;\n  };\n\n  IndexTreeModel.prototype.updateNodeAfterFilterChange = function (node) {\n    var previousRenderNodeCount = node.renderNodeCount;\n    var result = [];\n\n    this._updateNodeAfterFilterChange(node, node.visible ? 1\n    /* Visible */\n    : 0\n    /* Hidden */\n    , result);\n\n    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n    return result;\n  };\n\n  IndexTreeModel.prototype._updateNodeAfterFilterChange = function (node, parentVisibility, result, revealed) {\n    if (revealed === void 0) {\n      revealed = true;\n    }\n\n    var visibility;\n\n    if (node !== this.root) {\n      visibility = this._filterNode(node, parentVisibility);\n\n      if (visibility === 0\n      /* Hidden */\n      ) {\n          node.visible = false;\n          return false;\n        }\n\n      if (revealed) {\n        result.push(node);\n      }\n    }\n\n    var resultStartLength = result.length;\n    node.renderNodeCount = node === this.root ? 0 : 1;\n    var hasVisibleDescendants = false;\n\n    if (!node.collapsed || visibility !== 0\n    /* Hidden */\n    ) {\n        var visibleChildIndex = 0;\n\n        for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n          var child = _a[_i];\n          hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n\n          if (child.visible) {\n            child.visibleChildIndex = visibleChildIndex++;\n          }\n        }\n\n        node.visibleChildrenCount = visibleChildIndex;\n      } else {\n      node.visibleChildrenCount = 0;\n    }\n\n    if (node !== this.root) {\n      node.visible = visibility === 2\n      /* Recurse */\n      ? hasVisibleDescendants : visibility === 1\n      /* Visible */\n      ;\n    }\n\n    if (!node.visible) {\n      node.renderNodeCount = 0;\n\n      if (revealed) {\n        result.pop();\n      }\n    } else if (!node.collapsed) {\n      node.renderNodeCount += result.length - resultStartLength;\n    }\n\n    this._onDidChangeRenderNodeCount.fire(node);\n\n    return node.visible;\n  };\n\n  IndexTreeModel.prototype._updateAncestorsRenderNodeCount = function (node, diff) {\n    if (diff === 0) {\n      return;\n    }\n\n    while (node) {\n      node.renderNodeCount += diff;\n\n      this._onDidChangeRenderNodeCount.fire(node);\n\n      node = node.parent;\n    }\n  };\n\n  IndexTreeModel.prototype._filterNode = function (node, parentVisibility) {\n    var result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1\n    /* Visible */\n    ;\n\n    if (typeof result === 'boolean') {\n      node.filterData = undefined;\n      return result ? 1\n      /* Visible */\n      : 0\n      /* Hidden */\n      ;\n    } else if (isFilterResult(result)) {\n      node.filterData = result.data;\n      return getVisibleState(result.visibility);\n    } else {\n      node.filterData = undefined;\n      return getVisibleState(result);\n    }\n  }; // cheap\n\n\n  IndexTreeModel.prototype.getTreeNode = function (location, node) {\n    if (node === void 0) {\n      node = this.root;\n    }\n\n    if (!location || location.length === 0) {\n      return node;\n    }\n\n    var index = location[0],\n        rest = location.slice(1);\n\n    if (index < 0 || index > node.children.length) {\n      throw new Error('Invalid tree location');\n    }\n\n    return this.getTreeNode(rest, node.children[index]);\n  }; // expensive\n\n\n  IndexTreeModel.prototype.getTreeNodeWithListIndex = function (location) {\n    if (location.length === 0) {\n      return {\n        node: this.root,\n        listIndex: -1,\n        revealed: true,\n        visible: false\n      };\n    }\n\n    var _a = this.getParentNodeWithListIndex(location),\n        parentNode = _a.parentNode,\n        listIndex = _a.listIndex,\n        revealed = _a.revealed,\n        visible = _a.visible;\n\n    var index = location[location.length - 1];\n\n    if (index < 0 || index > parentNode.children.length) {\n      throw new Error('Invalid tree location');\n    }\n\n    var node = parentNode.children[index];\n    return {\n      node: node,\n      listIndex: listIndex,\n      revealed: revealed,\n      visible: visible && node.visible\n    };\n  };\n\n  IndexTreeModel.prototype.getParentNodeWithListIndex = function (location, node, listIndex, revealed, visible) {\n    if (node === void 0) {\n      node = this.root;\n    }\n\n    if (listIndex === void 0) {\n      listIndex = 0;\n    }\n\n    if (revealed === void 0) {\n      revealed = true;\n    }\n\n    if (visible === void 0) {\n      visible = true;\n    }\n\n    var index = location[0],\n        rest = location.slice(1);\n\n    if (index < 0 || index > node.children.length) {\n      throw new Error('Invalid tree location');\n    } // TODO@joao perf!\n\n\n    for (var i = 0; i < index; i++) {\n      listIndex += node.children[i].renderNodeCount;\n    }\n\n    revealed = revealed && !node.collapsed;\n    visible = visible && node.visible;\n\n    if (rest.length === 0) {\n      return {\n        parentNode: node,\n        listIndex: listIndex,\n        revealed: revealed,\n        visible: visible\n      };\n    }\n\n    return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n  };\n\n  IndexTreeModel.prototype.getNode = function (location) {\n    if (location === void 0) {\n      location = [];\n    }\n\n    return this.getTreeNode(location);\n  }; // TODO@joao perf!\n\n\n  IndexTreeModel.prototype.getNodeLocation = function (node) {\n    var location = [];\n\n    while (node.parent) {\n      location.push(node.parent.children.indexOf(node));\n      node = node.parent;\n    }\n\n    return location.reverse();\n  };\n\n  IndexTreeModel.prototype.getParentNodeLocation = function (location) {\n    if (location.length <= 1) {\n      return [];\n    }\n\n    return tail2(location)[0];\n  };\n\n  return IndexTreeModel;\n}();\n\nexport { IndexTreeModel };","map":null,"metadata":{},"sourceType":"module"}