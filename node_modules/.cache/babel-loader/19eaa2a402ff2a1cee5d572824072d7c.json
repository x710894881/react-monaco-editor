{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar TreeNode =\n/** @class */\nfunction () {\n  function TreeNode(piece, color) {\n    this.piece = piece;\n    this.color = color;\n    this.size_left = 0;\n    this.lf_left = 0;\n    this.parent = this;\n    this.left = this;\n    this.right = this;\n  }\n\n  TreeNode.prototype.next = function () {\n    if (this.right !== SENTINEL) {\n      return leftest(this.right);\n    }\n\n    var node = this;\n\n    while (node.parent !== SENTINEL) {\n      if (node.parent.left === node) {\n        break;\n      }\n\n      node = node.parent;\n    }\n\n    if (node.parent === SENTINEL) {\n      return SENTINEL;\n    } else {\n      return node.parent;\n    }\n  };\n\n  TreeNode.prototype.prev = function () {\n    if (this.left !== SENTINEL) {\n      return righttest(this.left);\n    }\n\n    var node = this;\n\n    while (node.parent !== SENTINEL) {\n      if (node.parent.right === node) {\n        break;\n      }\n\n      node = node.parent;\n    }\n\n    if (node.parent === SENTINEL) {\n      return SENTINEL;\n    } else {\n      return node.parent;\n    }\n  };\n\n  TreeNode.prototype.detach = function () {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  };\n\n  return TreeNode;\n}();\n\nexport { TreeNode };\nexport var SENTINEL = new TreeNode(null, 0\n/* Black */\n);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0\n/* Black */\n;\nexport function leftest(node) {\n  while (node.left !== SENTINEL) {\n    node = node.left;\n  }\n\n  return node;\n}\nexport function righttest(node) {\n  while (node.right !== SENTINEL) {\n    node = node.right;\n  }\n\n  return node;\n}\nexport function calculateSize(node) {\n  if (node === SENTINEL) {\n    return 0;\n  }\n\n  return node.size_left + node.piece.length + calculateSize(node.right);\n}\nexport function calculateLF(node) {\n  if (node === SENTINEL) {\n    return 0;\n  }\n\n  return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nexport function resetSentinel() {\n  SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n  var y = x.right; // fix size_left\n\n  y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n  y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n  x.right = y.left;\n\n  if (y.left !== SENTINEL) {\n    y.left.parent = x;\n  }\n\n  y.parent = x.parent;\n\n  if (x.parent === SENTINEL) {\n    tree.root = y;\n  } else if (x.parent.left === x) {\n    x.parent.left = y;\n  } else {\n    x.parent.right = y;\n  }\n\n  y.left = x;\n  x.parent = y;\n}\nexport function rightRotate(tree, y) {\n  var x = y.left;\n  y.left = x.right;\n\n  if (x.right !== SENTINEL) {\n    x.right.parent = y;\n  }\n\n  x.parent = y.parent; // fix size_left\n\n  y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n  y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n\n  if (y.parent === SENTINEL) {\n    tree.root = x;\n  } else if (y === y.parent.right) {\n    y.parent.right = x;\n  } else {\n    y.parent.left = x;\n  }\n\n  x.right = y;\n  y.parent = x;\n}\nexport function rbDelete(tree, z) {\n  var x;\n  var y;\n\n  if (z.left === SENTINEL) {\n    y = z;\n    x = y.right;\n  } else if (z.right === SENTINEL) {\n    y = z;\n    x = y.left;\n  } else {\n    y = leftest(z.right);\n    x = y.right;\n  }\n\n  if (y === tree.root) {\n    tree.root = x; // if x is null, we are removing the only node\n\n    x.color = 0\n    /* Black */\n    ;\n    z.detach();\n    resetSentinel();\n    tree.root.parent = SENTINEL;\n    return;\n  }\n\n  var yWasRed = y.color === 1\n  /* Red */\n  ;\n\n  if (y === y.parent.left) {\n    y.parent.left = x;\n  } else {\n    y.parent.right = x;\n  }\n\n  if (y === z) {\n    x.parent = y.parent;\n    recomputeTreeMetadata(tree, x);\n  } else {\n    if (y.parent === z) {\n      x.parent = y;\n    } else {\n      x.parent = y.parent;\n    } // as we make changes to x's hierarchy, update size_left of subtree first\n\n\n    recomputeTreeMetadata(tree, x);\n    y.left = z.left;\n    y.right = z.right;\n    y.parent = z.parent;\n    y.color = z.color;\n\n    if (z === tree.root) {\n      tree.root = y;\n    } else {\n      if (z === z.parent.left) {\n        z.parent.left = y;\n      } else {\n        z.parent.right = y;\n      }\n    }\n\n    if (y.left !== SENTINEL) {\n      y.left.parent = y;\n    }\n\n    if (y.right !== SENTINEL) {\n      y.right.parent = y;\n    } // update metadata\n    // we replace z with y, so in this sub tree, the length change is z.item.length\n\n\n    y.size_left = z.size_left;\n    y.lf_left = z.lf_left;\n    recomputeTreeMetadata(tree, y);\n  }\n\n  z.detach();\n\n  if (x.parent.left === x) {\n    var newSizeLeft = calculateSize(x);\n    var newLFLeft = calculateLF(x);\n\n    if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n      var delta = newSizeLeft - x.parent.size_left;\n      var lf_delta = newLFLeft - x.parent.lf_left;\n      x.parent.size_left = newSizeLeft;\n      x.parent.lf_left = newLFLeft;\n      updateTreeMetadata(tree, x.parent, delta, lf_delta);\n    }\n  }\n\n  recomputeTreeMetadata(tree, x.parent);\n\n  if (yWasRed) {\n    resetSentinel();\n    return;\n  } // RB-DELETE-FIXUP\n\n\n  var w;\n\n  while (x !== tree.root && x.color === 0\n  /* Black */\n  ) {\n    if (x === x.parent.left) {\n      w = x.parent.right;\n\n      if (w.color === 1\n      /* Red */\n      ) {\n          w.color = 0\n          /* Black */\n          ;\n          x.parent.color = 1\n          /* Red */\n          ;\n          leftRotate(tree, x.parent);\n          w = x.parent.right;\n        }\n\n      if (w.left.color === 0\n      /* Black */\n      && w.right.color === 0\n      /* Black */\n      ) {\n          w.color = 1\n          /* Red */\n          ;\n          x = x.parent;\n        } else {\n        if (w.right.color === 0\n        /* Black */\n        ) {\n            w.left.color = 0\n            /* Black */\n            ;\n            w.color = 1\n            /* Red */\n            ;\n            rightRotate(tree, w);\n            w = x.parent.right;\n          }\n\n        w.color = x.parent.color;\n        x.parent.color = 0\n        /* Black */\n        ;\n        w.right.color = 0\n        /* Black */\n        ;\n        leftRotate(tree, x.parent);\n        x = tree.root;\n      }\n    } else {\n      w = x.parent.left;\n\n      if (w.color === 1\n      /* Red */\n      ) {\n          w.color = 0\n          /* Black */\n          ;\n          x.parent.color = 1\n          /* Red */\n          ;\n          rightRotate(tree, x.parent);\n          w = x.parent.left;\n        }\n\n      if (w.left.color === 0\n      /* Black */\n      && w.right.color === 0\n      /* Black */\n      ) {\n          w.color = 1\n          /* Red */\n          ;\n          x = x.parent;\n        } else {\n        if (w.left.color === 0\n        /* Black */\n        ) {\n            w.right.color = 0\n            /* Black */\n            ;\n            w.color = 1\n            /* Red */\n            ;\n            leftRotate(tree, w);\n            w = x.parent.left;\n          }\n\n        w.color = x.parent.color;\n        x.parent.color = 0\n        /* Black */\n        ;\n        w.left.color = 0\n        /* Black */\n        ;\n        rightRotate(tree, x.parent);\n        x = tree.root;\n      }\n    }\n  }\n\n  x.color = 0\n  /* Black */\n  ;\n  resetSentinel();\n}\nexport function fixInsert(tree, x) {\n  recomputeTreeMetadata(tree, x);\n\n  while (x !== tree.root && x.parent.color === 1\n  /* Red */\n  ) {\n    if (x.parent === x.parent.parent.left) {\n      var y = x.parent.parent.right;\n\n      if (y.color === 1\n      /* Red */\n      ) {\n          x.parent.color = 0\n          /* Black */\n          ;\n          y.color = 0\n          /* Black */\n          ;\n          x.parent.parent.color = 1\n          /* Red */\n          ;\n          x = x.parent.parent;\n        } else {\n        if (x === x.parent.right) {\n          x = x.parent;\n          leftRotate(tree, x);\n        }\n\n        x.parent.color = 0\n        /* Black */\n        ;\n        x.parent.parent.color = 1\n        /* Red */\n        ;\n        rightRotate(tree, x.parent.parent);\n      }\n    } else {\n      var y = x.parent.parent.left;\n\n      if (y.color === 1\n      /* Red */\n      ) {\n          x.parent.color = 0\n          /* Black */\n          ;\n          y.color = 0\n          /* Black */\n          ;\n          x.parent.parent.color = 1\n          /* Red */\n          ;\n          x = x.parent.parent;\n        } else {\n        if (x === x.parent.left) {\n          x = x.parent;\n          rightRotate(tree, x);\n        }\n\n        x.parent.color = 0\n        /* Black */\n        ;\n        x.parent.parent.color = 1\n        /* Red */\n        ;\n        leftRotate(tree, x.parent.parent);\n      }\n    }\n  }\n\n  tree.root.color = 0\n  /* Black */\n  ;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n  // node length change or line feed count change\n  while (x !== tree.root && x !== SENTINEL) {\n    if (x.parent.left === x) {\n      x.parent.size_left += delta;\n      x.parent.lf_left += lineFeedCntDelta;\n    }\n\n    x = x.parent;\n  }\n}\nexport function recomputeTreeMetadata(tree, x) {\n  var delta = 0;\n  var lf_delta = 0;\n\n  if (x === tree.root) {\n    return;\n  }\n\n  if (delta === 0) {\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n      x = x.parent;\n    }\n\n    if (x === tree.root) {\n      // well, it means we add a node to the end (inorder)\n      return;\n    } // x is the node whose right subtree is changed.\n\n\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n  } // go upwards till root. O(logN)\n\n\n  while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n    if (x.parent.left === x) {\n      x.parent.size_left += delta;\n      x.parent.lf_left += lf_delta;\n    }\n\n    x = x.parent;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}