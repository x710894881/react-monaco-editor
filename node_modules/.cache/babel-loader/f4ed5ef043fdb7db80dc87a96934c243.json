{"ast":null,"code":"/**\n * Until SelectionRange lands in LSP, we'll return Range from server and convert it to\n * SelectionRange on client side\n */\nimport { Range } from '../../vscode-languageserver-types/main.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { parse } from '../parser/htmlParser.js';\nimport { TokenType, SelectionRangeKind } from '../htmlLanguageTypes.js';\nexport function getSelectionRanges(document, positions) {\n  function getSelectionRange(position) {\n    var applicableRanges = getApplicableRanges(document, position);\n    var ranges = applicableRanges\n    /**\n     * Filter duplicated ranges\n     */\n    .filter(function (pair, i) {\n      if (i === 0) {\n        return true;\n      }\n\n      var prev = applicableRanges[i - 1];\n\n      if (pair[0] === prev[0] && pair[1] === prev[1]) {\n        return false;\n      }\n\n      return true;\n    }).map(function (pair) {\n      return {\n        range: Range.create(document.positionAt(pair[0]), document.positionAt(pair[1])),\n        kind: SelectionRangeKind.Declaration\n      };\n    });\n    return ranges;\n  }\n\n  return positions.map(getSelectionRange);\n}\n\nfunction getApplicableRanges(document, position) {\n  var htmlDoc = parse(document.getText());\n  var currOffset = document.offsetAt(position);\n  var currNode = htmlDoc.findNodeAt(currOffset);\n  var result = getAllParentTagRanges(currNode); // Self-closing or void elements\n\n  if (currNode.startTagEnd && !currNode.endTagStart) {\n    var closeRange = Range.create(document.positionAt(currNode.startTagEnd - 2), document.positionAt(currNode.startTagEnd));\n    var closeText = document.getText(closeRange); // Self-closing element\n\n    if (closeText === '/>') {\n      result.unshift([currNode.start + 1, currNode.startTagEnd - 2]);\n    } // Void element\n    else {\n        result.unshift([currNode.start + 1, currNode.startTagEnd - 1]);\n      }\n\n    var attributeLevelRanges = getAttributeLevelRanges(document, currNode, currOffset);\n    result = attributeLevelRanges.concat(result);\n    return result;\n  }\n\n  if (!currNode.startTagEnd || !currNode.endTagStart) {\n    return result;\n  }\n  /**\n   * For html like\n   * `<div class=\"foo\">bar</div>`\n   */\n\n\n  result.unshift([currNode.start, currNode.end]);\n  /**\n   * Cursor inside `<div class=\"foo\">`\n   */\n\n  if (currNode.start < currOffset && currOffset < currNode.startTagEnd) {\n    result.unshift([currNode.start + 1, currNode.startTagEnd - 1]);\n    var attributeLevelRanges = getAttributeLevelRanges(document, currNode, currOffset);\n    result = attributeLevelRanges.concat(result);\n    return result;\n  }\n  /**\n   * Cursor inside `bar`\n   */\n  else if (currNode.startTagEnd <= currOffset && currOffset <= currNode.endTagStart) {\n      result.unshift([currNode.startTagEnd, currNode.endTagStart]);\n      return result;\n    }\n    /**\n     * Cursor inside `</div>`\n     */\n    else {\n        // `div` inside `</div>`\n        if (currOffset >= currNode.endTagStart + 2) {\n          result.unshift([currNode.endTagStart + 2, currNode.end - 1]);\n        }\n\n        return result;\n      }\n}\n\nfunction getAllParentTagRanges(initialNode) {\n  var currNode = initialNode;\n\n  var getNodeRanges = function (n) {\n    if (n.startTagEnd && n.endTagStart && n.startTagEnd < n.endTagStart) {\n      return [[n.startTagEnd, n.endTagStart], [n.start, n.end]];\n    }\n\n    return [[n.start, n.end]];\n  };\n\n  var result = [];\n\n  while (currNode.parent) {\n    currNode = currNode.parent;\n    getNodeRanges(currNode).forEach(function (r) {\n      return result.push(r);\n    });\n  }\n\n  return result;\n}\n\nfunction getAttributeLevelRanges(document, currNode, currOffset) {\n  var currNodeRange = Range.create(document.positionAt(currNode.start), document.positionAt(currNode.end));\n  var currNodeText = document.getText(currNodeRange);\n  var relativeOffset = currOffset - currNode.start;\n  /**\n   * Tag level semantic selection\n   */\n\n  var scanner = createScanner(currNodeText);\n  var token = scanner.scan();\n  /**\n   * For text like\n   * <div class=\"foo\">bar</div>\n   */\n\n  var positionOffset = currNode.start;\n  var result = [];\n  var isInsideAttribute = false;\n  var attrStart = -1;\n\n  while (token !== TokenType.EOS) {\n    switch (token) {\n      case TokenType.AttributeName:\n        {\n          if (relativeOffset < scanner.getTokenOffset()) {\n            isInsideAttribute = false;\n            break;\n          }\n\n          if (relativeOffset <= scanner.getTokenEnd()) {\n            // `class`\n            result.unshift([scanner.getTokenOffset(), scanner.getTokenEnd()]);\n          }\n\n          isInsideAttribute = true;\n          attrStart = scanner.getTokenOffset();\n          break;\n        }\n\n      case TokenType.AttributeValue:\n        {\n          if (!isInsideAttribute) {\n            break;\n          }\n\n          var valueText = scanner.getTokenText();\n\n          if (relativeOffset < scanner.getTokenOffset()) {\n            // `class=\"foo\"`\n            result.push([attrStart, scanner.getTokenEnd()]);\n            break;\n          }\n\n          if (relativeOffset >= scanner.getTokenOffset() && relativeOffset <= scanner.getTokenEnd()) {\n            // `\"foo\"`\n            result.unshift([scanner.getTokenOffset(), scanner.getTokenEnd()]); // `foo`\n\n            if (valueText[0] === \"\\\"\" && valueText[valueText.length - 1] === \"\\\"\" || valueText[0] === \"'\" && valueText[valueText.length - 1] === \"'\") {\n              if (relativeOffset >= scanner.getTokenOffset() + 1 && relativeOffset <= scanner.getTokenEnd() - 1) {\n                result.unshift([scanner.getTokenOffset() + 1, scanner.getTokenEnd() - 1]);\n              }\n            } // `class=\"foo\"`\n\n\n            result.push([attrStart, scanner.getTokenEnd()]);\n          }\n\n          break;\n        }\n    }\n\n    token = scanner.scan();\n  }\n\n  return result.map(function (pair) {\n    return [pair[0] + positionOffset, pair[1] + positionOffset];\n  });\n}","map":null,"metadata":{},"sourceType":"module"}