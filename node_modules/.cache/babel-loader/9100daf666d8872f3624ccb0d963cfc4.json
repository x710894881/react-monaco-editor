{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalMouseMoveMonitor, standardMouseMoveMerger } from '../../../../base/browser/globalMouseMoveMonitor.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { Range } from '../../../common/core/range.js';\nimport { MinimapTokensColorTracker } from '../../../common/view/minimapCharRenderer.js';\nimport { getOrCreateMinimapCharRenderer } from '../../../common/view/runtimeMinimapCharRenderer.js';\nimport * as viewEvents from '../../../common/view/viewEvents.js';\nimport { scrollbarShadow, scrollbarSliderActiveBackground, scrollbarSliderBackground, scrollbarSliderHoverBackground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\n\nfunction getMinimapLineHeight(renderMinimap) {\n  if (renderMinimap === 2\n  /* Large */\n  ) {\n      return 4\n      /* x2_CHAR_HEIGHT */\n      ;\n    }\n\n  if (renderMinimap === 4\n  /* LargeBlocks */\n  ) {\n      return 4\n      /* x2_CHAR_HEIGHT */\n      + 2;\n    }\n\n  if (renderMinimap === 1\n  /* Small */\n  ) {\n      return 2\n      /* x1_CHAR_HEIGHT */\n      ;\n    } // RenderMinimap.SmallBlocks\n\n\n  return 2\n  /* x1_CHAR_HEIGHT */\n  + 1;\n}\n\nfunction getMinimapCharWidth(renderMinimap) {\n  if (renderMinimap === 2\n  /* Large */\n  ) {\n      return 2\n      /* x2_CHAR_WIDTH */\n      ;\n    }\n\n  if (renderMinimap === 4\n  /* LargeBlocks */\n  ) {\n      return 2\n      /* x2_CHAR_WIDTH */\n      ;\n    }\n\n  if (renderMinimap === 1\n  /* Small */\n  ) {\n      return 1\n      /* x1_CHAR_WIDTH */\n      ;\n    } // RenderMinimap.SmallBlocks\n\n\n  return 1\n  /* x1_CHAR_WIDTH */\n  ;\n}\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\n\n\nvar MOUSE_DRAG_RESET_DISTANCE = 140;\n\nvar MinimapOptions =\n/** @class */\nfunction () {\n  function MinimapOptions(configuration) {\n    var pixelRatio = configuration.editor.pixelRatio;\n    var layoutInfo = configuration.editor.layoutInfo;\n    var viewInfo = configuration.editor.viewInfo;\n    var fontInfo = configuration.editor.fontInfo;\n    this.renderMinimap = layoutInfo.renderMinimap | 0;\n    this.scrollBeyondLastLine = viewInfo.scrollBeyondLastLine;\n    this.showSlider = viewInfo.minimap.showSlider;\n    this.pixelRatio = pixelRatio;\n    this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this.lineHeight = configuration.editor.lineHeight;\n    this.minimapLeft = layoutInfo.minimapLeft;\n    this.minimapWidth = layoutInfo.minimapWidth;\n    this.minimapHeight = layoutInfo.height;\n    this.canvasInnerWidth = Math.max(1, Math.floor(pixelRatio * this.minimapWidth));\n    this.canvasInnerHeight = Math.max(1, Math.floor(pixelRatio * this.minimapHeight));\n    this.canvasOuterWidth = this.canvasInnerWidth / pixelRatio;\n    this.canvasOuterHeight = this.canvasInnerHeight / pixelRatio;\n  }\n\n  MinimapOptions.prototype.equals = function (other) {\n    return this.renderMinimap === other.renderMinimap && this.scrollBeyondLastLine === other.scrollBeyondLastLine && this.showSlider === other.showSlider && this.pixelRatio === other.pixelRatio && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth && this.lineHeight === other.lineHeight && this.minimapLeft === other.minimapLeft && this.minimapWidth === other.minimapWidth && this.minimapHeight === other.minimapHeight && this.canvasInnerWidth === other.canvasInnerWidth && this.canvasInnerHeight === other.canvasInnerHeight && this.canvasOuterWidth === other.canvasOuterWidth && this.canvasOuterHeight === other.canvasOuterHeight;\n  };\n\n  return MinimapOptions;\n}();\n\nvar MinimapLayout =\n/** @class */\nfunction () {\n  function MinimapLayout(scrollTop, scrollHeight, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber) {\n    this.scrollTop = scrollTop;\n    this.scrollHeight = scrollHeight;\n    this._computedSliderRatio = computedSliderRatio;\n    this.sliderTop = sliderTop;\n    this.sliderHeight = sliderHeight;\n    this.startLineNumber = startLineNumber;\n    this.endLineNumber = endLineNumber;\n  }\n  /**\n   * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n   */\n\n\n  MinimapLayout.prototype.getDesiredScrollTopFromDelta = function (delta) {\n    var desiredSliderPosition = this.sliderTop + delta;\n    return Math.round(desiredSliderPosition / this._computedSliderRatio);\n  };\n\n  MinimapLayout.create = function (options, viewportStartLineNumber, viewportEndLineNumber, viewportHeight, viewportContainsWhitespaceGaps, lineCount, scrollTop, scrollHeight, previousLayout) {\n    var pixelRatio = options.pixelRatio;\n    var minimapLineHeight = getMinimapLineHeight(options.renderMinimap);\n    var minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n    var lineHeight = options.lineHeight; // The visible line count in a viewport can change due to a number of reasons:\n    //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n    //    e.g. for a line height of 20, and a viewport height of 600\n    //          * scrollTop = 0  => visible lines are [1, 30]\n    //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n    //          * scrollTop = 20 => visible lines are [2, 31]\n    //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n    //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n    // We must first establish a desirable slider height.\n\n    var sliderHeight;\n\n    if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n      // case b) from above: there are whitespace gaps in the viewport.\n      // In this case, the height of the slider directly reflects the visible line count.\n      var viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n      sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n    } else {\n      // The slider has a stable height\n      var expectedViewportLineCount = viewportHeight / lineHeight;\n      sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n    }\n\n    var maxMinimapSliderTop;\n\n    if (options.scrollBeyondLastLine) {\n      // The minimap slider, when dragged all the way down, will contain the last line at its top\n      maxMinimapSliderTop = (lineCount - 1) * minimapLineHeight / pixelRatio;\n    } else {\n      // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n      maxMinimapSliderTop = Math.max(0, lineCount * minimapLineHeight / pixelRatio - sliderHeight);\n    }\n\n    maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop); // The slider can move from 0 to `maxMinimapSliderTop`\n    // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n\n    var computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n    var sliderTop = scrollTop * computedSliderRatio;\n    var extraLinesAtTheBottom = 0;\n\n    if (options.scrollBeyondLastLine) {\n      var expectedViewportLineCount = viewportHeight / lineHeight;\n      extraLinesAtTheBottom = expectedViewportLineCount;\n    }\n\n    if (minimapLinesFitting >= lineCount + extraLinesAtTheBottom) {\n      // All lines fit in the minimap\n      var startLineNumber = 1;\n      var endLineNumber = lineCount;\n      return new MinimapLayout(scrollTop, scrollHeight, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);\n    } else {\n      var startLineNumber = Math.max(1, Math.floor(viewportStartLineNumber - sliderTop * pixelRatio / minimapLineHeight)); // Avoid flickering caused by a partial viewport start line\n      // by being consistent w.r.t. the previous layout decision\n\n      if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n        if (previousLayout.scrollTop > scrollTop) {\n          // Scrolling up => never increase `startLineNumber`\n          startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n        }\n\n        if (previousLayout.scrollTop < scrollTop) {\n          // Scrolling down => never decrease `startLineNumber`\n          startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n        }\n      }\n\n      var endLineNumber = Math.min(lineCount, startLineNumber + minimapLinesFitting - 1);\n      return new MinimapLayout(scrollTop, scrollHeight, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);\n    }\n  };\n\n  return MinimapLayout;\n}();\n\nvar MinimapLine =\n/** @class */\nfunction () {\n  function MinimapLine(dy) {\n    this.dy = dy;\n  }\n\n  MinimapLine.prototype.onContentChanged = function () {\n    this.dy = -1;\n  };\n\n  MinimapLine.prototype.onTokensChanged = function () {\n    this.dy = -1;\n  };\n\n  MinimapLine.INVALID = new MinimapLine(-1);\n  return MinimapLine;\n}();\n\nvar RenderData =\n/** @class */\nfunction () {\n  function RenderData(renderedLayout, imageData, lines) {\n    this.renderedLayout = renderedLayout;\n    this._imageData = imageData;\n    this._renderedLines = new RenderedLinesCollection(function () {\n      return MinimapLine.INVALID;\n    });\n\n    this._renderedLines._set(renderedLayout.startLineNumber, lines);\n  }\n  /**\n   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n   */\n\n\n  RenderData.prototype.linesEquals = function (layout) {\n    if (!this.scrollEquals(layout)) {\n      return false;\n    }\n\n    var tmp = this._renderedLines._get();\n\n    var lines = tmp.lines;\n\n    for (var i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].dy === -1) {\n        // This line is invalid\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Check if the current RenderData matches the new layout's scroll position\n   */\n\n\n  RenderData.prototype.scrollEquals = function (layout) {\n    return this.renderedLayout.startLineNumber === layout.startLineNumber && this.renderedLayout.endLineNumber === layout.endLineNumber;\n  };\n\n  RenderData.prototype._get = function () {\n    var tmp = this._renderedLines._get();\n\n    return {\n      imageData: this._imageData,\n      rendLineNumberStart: tmp.rendLineNumberStart,\n      lines: tmp.lines\n    };\n  };\n\n  RenderData.prototype.onLinesChanged = function (e) {\n    return this._renderedLines.onLinesChanged(e.fromLineNumber, e.toLineNumber);\n  };\n\n  RenderData.prototype.onLinesDeleted = function (e) {\n    this._renderedLines.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n  };\n\n  RenderData.prototype.onLinesInserted = function (e) {\n    this._renderedLines.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n  };\n\n  RenderData.prototype.onTokensChanged = function (e) {\n    return this._renderedLines.onTokensChanged(e.ranges);\n  };\n\n  return RenderData;\n}();\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\n\n\nvar MinimapBuffers =\n/** @class */\nfunction () {\n  function MinimapBuffers(ctx, WIDTH, HEIGHT, background) {\n    this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n    this._buffers = [ctx.createImageData(WIDTH, HEIGHT), ctx.createImageData(WIDTH, HEIGHT)];\n    this._lastUsedBuffer = 0;\n  }\n\n  MinimapBuffers.prototype.getBuffer = function () {\n    // rotate buffers\n    this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n    var result = this._buffers[this._lastUsedBuffer]; // fill with background color\n\n    result.data.set(this._backgroundFillData);\n    return result;\n  };\n\n  MinimapBuffers._createBackgroundFillData = function (WIDTH, HEIGHT, background) {\n    var backgroundR = background.r;\n    var backgroundG = background.g;\n    var backgroundB = background.b;\n    var result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n    var offset = 0;\n\n    for (var i = 0; i < HEIGHT; i++) {\n      for (var j = 0; j < WIDTH; j++) {\n        result[offset] = backgroundR;\n        result[offset + 1] = backgroundG;\n        result[offset + 2] = backgroundB;\n        result[offset + 3] = 255;\n        offset += 4;\n      }\n    }\n\n    return result;\n  };\n\n  return MinimapBuffers;\n}();\n\nvar Minimap =\n/** @class */\nfunction (_super) {\n  __extends(Minimap, _super);\n\n  function Minimap(context) {\n    var _this = _super.call(this, context) || this;\n\n    _this._renderDecorations = false;\n    _this._options = new MinimapOptions(_this._context.configuration);\n    _this._lastRenderData = null;\n    _this._buffers = null;\n    _this._domNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(_this._domNode, 8\n    /* Minimap */\n    );\n\n    _this._domNode.setClassName(_this._getMinimapDomNodeClassName());\n\n    _this._domNode.setPosition('absolute');\n\n    _this._domNode.setAttribute('role', 'presentation');\n\n    _this._domNode.setAttribute('aria-hidden', 'true');\n\n    _this._shadow = createFastDomNode(document.createElement('div'));\n\n    _this._shadow.setClassName('minimap-shadow-hidden');\n\n    _this._domNode.appendChild(_this._shadow);\n\n    _this._canvas = createFastDomNode(document.createElement('canvas'));\n\n    _this._canvas.setPosition('absolute');\n\n    _this._canvas.setLeft(0);\n\n    _this._domNode.appendChild(_this._canvas);\n\n    _this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n\n    _this._decorationsCanvas.setPosition('absolute');\n\n    _this._decorationsCanvas.setClassName('minimap-decorations-layer');\n\n    _this._decorationsCanvas.setLeft(0);\n\n    _this._domNode.appendChild(_this._decorationsCanvas);\n\n    _this._slider = createFastDomNode(document.createElement('div'));\n\n    _this._slider.setPosition('absolute');\n\n    _this._slider.setClassName('minimap-slider');\n\n    _this._slider.setLayerHinting(true);\n\n    _this._domNode.appendChild(_this._slider);\n\n    _this._sliderHorizontal = createFastDomNode(document.createElement('div'));\n\n    _this._sliderHorizontal.setPosition('absolute');\n\n    _this._sliderHorizontal.setClassName('minimap-slider-horizontal');\n\n    _this._slider.appendChild(_this._sliderHorizontal);\n\n    _this._tokensColorTracker = MinimapTokensColorTracker.getInstance();\n\n    _this._applyLayout();\n\n    _this._mouseDownListener = dom.addStandardDisposableListener(_this._domNode.domNode, 'mousedown', function (e) {\n      e.preventDefault();\n      var renderMinimap = _this._options.renderMinimap;\n\n      if (renderMinimap === 0\n      /* None */\n      ) {\n          return;\n        }\n\n      if (!_this._lastRenderData) {\n        return;\n      }\n\n      var minimapLineHeight = getMinimapLineHeight(renderMinimap);\n      var internalOffsetY = _this._options.pixelRatio * e.browserEvent.offsetY;\n      var lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n      var lineNumber = lineIndex + _this._lastRenderData.renderedLayout.startLineNumber;\n      lineNumber = Math.min(lineNumber, _this._context.model.getLineCount());\n\n      _this._context.privateViewEventBus.emit(new viewEvents.ViewRevealRangeRequestEvent(new Range(lineNumber, 1, lineNumber, 1), 1\n      /* Center */\n      , false, 0\n      /* Smooth */\n      ));\n    });\n    _this._sliderMouseMoveMonitor = new GlobalMouseMoveMonitor();\n    _this._sliderMouseDownListener = dom.addStandardDisposableListener(_this._slider.domNode, 'mousedown', function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (e.leftButton && _this._lastRenderData) {\n        var initialMousePosition_1 = e.posy;\n        var initialMouseOrthogonalPosition_1 = e.posx;\n        var initialSliderState_1 = _this._lastRenderData.renderedLayout;\n\n        _this._slider.toggleClassName('active', true);\n\n        _this._sliderMouseMoveMonitor.startMonitoring(standardMouseMoveMerger, function (mouseMoveData) {\n          var mouseOrthogonalDelta = Math.abs(mouseMoveData.posx - initialMouseOrthogonalPosition_1);\n\n          if (platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {\n            // The mouse has wondered away from the scrollbar => reset dragging\n            _this._context.viewLayout.setScrollPositionNow({\n              scrollTop: initialSliderState_1.scrollTop\n            });\n\n            return;\n          }\n\n          var mouseDelta = mouseMoveData.posy - initialMousePosition_1;\n\n          _this._context.viewLayout.setScrollPositionNow({\n            scrollTop: initialSliderState_1.getDesiredScrollTopFromDelta(mouseDelta)\n          });\n        }, function () {\n          _this._slider.toggleClassName('active', false);\n        });\n      }\n    });\n    return _this;\n  }\n\n  Minimap.prototype.dispose = function () {\n    this._mouseDownListener.dispose();\n\n    this._sliderMouseMoveMonitor.dispose();\n\n    this._sliderMouseDownListener.dispose();\n\n    _super.prototype.dispose.call(this);\n  };\n\n  Minimap.prototype._getMinimapDomNodeClassName = function () {\n    if (this._options.showSlider === 'always') {\n      return 'minimap slider-always';\n    }\n\n    return 'minimap slider-mouseover';\n  };\n\n  Minimap.prototype.getDomNode = function () {\n    return this._domNode;\n  };\n\n  Minimap.prototype._applyLayout = function () {\n    this._domNode.setLeft(this._options.minimapLeft);\n\n    this._domNode.setWidth(this._options.minimapWidth);\n\n    this._domNode.setHeight(this._options.minimapHeight);\n\n    this._shadow.setHeight(this._options.minimapHeight);\n\n    this._canvas.setWidth(this._options.canvasOuterWidth);\n\n    this._canvas.setHeight(this._options.canvasOuterHeight);\n\n    this._canvas.domNode.width = this._options.canvasInnerWidth;\n    this._canvas.domNode.height = this._options.canvasInnerHeight;\n\n    this._decorationsCanvas.setWidth(this._options.canvasOuterWidth);\n\n    this._decorationsCanvas.setHeight(this._options.canvasOuterHeight);\n\n    this._decorationsCanvas.domNode.width = this._options.canvasInnerWidth;\n    this._decorationsCanvas.domNode.height = this._options.canvasInnerHeight;\n\n    this._slider.setWidth(this._options.minimapWidth);\n  };\n\n  Minimap.prototype._getBuffer = function () {\n    if (!this._buffers) {\n      this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._options.canvasInnerWidth, this._options.canvasInnerHeight, this._tokensColorTracker.getColor(2\n      /* DefaultBackground */\n      ));\n    }\n\n    return this._buffers.getBuffer();\n  };\n\n  Minimap.prototype._onOptionsMaybeChanged = function () {\n    var opts = new MinimapOptions(this._context.configuration);\n\n    if (this._options.equals(opts)) {\n      return false;\n    }\n\n    this._options = opts;\n    this._lastRenderData = null;\n    this._buffers = null;\n\n    this._applyLayout();\n\n    this._domNode.setClassName(this._getMinimapDomNodeClassName());\n\n    return true;\n  }; // ---- begin view event handlers\n\n\n  Minimap.prototype.onConfigurationChanged = function (e) {\n    return this._onOptionsMaybeChanged();\n  };\n\n  Minimap.prototype.onFlushed = function (e) {\n    this._lastRenderData = null;\n    return true;\n  };\n\n  Minimap.prototype.onLinesChanged = function (e) {\n    if (this._lastRenderData) {\n      return this._lastRenderData.onLinesChanged(e);\n    }\n\n    return false;\n  };\n\n  Minimap.prototype.onLinesDeleted = function (e) {\n    if (this._lastRenderData) {\n      this._lastRenderData.onLinesDeleted(e);\n    }\n\n    return true;\n  };\n\n  Minimap.prototype.onLinesInserted = function (e) {\n    if (this._lastRenderData) {\n      this._lastRenderData.onLinesInserted(e);\n    }\n\n    return true;\n  };\n\n  Minimap.prototype.onScrollChanged = function (e) {\n    this._renderDecorations = true;\n    return true;\n  };\n\n  Minimap.prototype.onTokensChanged = function (e) {\n    if (this._lastRenderData) {\n      return this._lastRenderData.onTokensChanged(e);\n    }\n\n    return false;\n  };\n\n  Minimap.prototype.onTokensColorsChanged = function (e) {\n    this._lastRenderData = null;\n    this._buffers = null;\n    return true;\n  };\n\n  Minimap.prototype.onZonesChanged = function (e) {\n    this._lastRenderData = null;\n    return true;\n  };\n\n  Minimap.prototype.onDecorationsChanged = function (e) {\n    this._renderDecorations = true;\n    return true;\n  };\n\n  Minimap.prototype.onThemeChanged = function (e) {\n    this._context.model.invalidateMinimapColorCache(); // Only bother calling render if decorations are currently shown\n\n\n    this._renderDecorations = !!this._lastDecorations;\n    return !!this._lastDecorations;\n  }; // --- end event handlers\n\n\n  Minimap.prototype.prepareRender = function (ctx) {// Nothing to read\n  };\n\n  Minimap.prototype.render = function (renderingCtx) {\n    var renderMinimap = this._options.renderMinimap;\n\n    if (renderMinimap === 0\n    /* None */\n    ) {\n        this._shadow.setClassName('minimap-shadow-hidden');\n\n        this._sliderHorizontal.setWidth(0);\n\n        this._sliderHorizontal.setHeight(0);\n\n        return;\n      }\n\n    if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n      this._shadow.setClassName('minimap-shadow-hidden');\n    } else {\n      this._shadow.setClassName('minimap-shadow-visible');\n    }\n\n    var layout = MinimapLayout.create(this._options, renderingCtx.visibleRange.startLineNumber, renderingCtx.visibleRange.endLineNumber, renderingCtx.viewportHeight, renderingCtx.viewportData.whitespaceViewportData.length > 0, this._context.model.getLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n\n    this._slider.setTop(layout.sliderTop);\n\n    this._slider.setHeight(layout.sliderHeight); // Compute horizontal slider coordinates\n\n\n    var scrollLeftChars = renderingCtx.scrollLeft / this._options.typicalHalfwidthCharacterWidth;\n    var horizontalSliderLeft = Math.min(this._options.minimapWidth, Math.round(scrollLeftChars * getMinimapCharWidth(this._options.renderMinimap) / this._options.pixelRatio));\n\n    this._sliderHorizontal.setLeft(horizontalSliderLeft);\n\n    this._sliderHorizontal.setWidth(this._options.minimapWidth - horizontalSliderLeft);\n\n    this._sliderHorizontal.setTop(0);\n\n    this._sliderHorizontal.setHeight(layout.sliderHeight);\n\n    this.renderDecorations(layout);\n    this._lastRenderData = this.renderLines(layout);\n  };\n\n  Minimap.prototype.renderDecorations = function (layout) {\n    if (this._renderDecorations) {\n      this._renderDecorations = false;\n\n      var decorations = this._context.model.getDecorationsInViewport(new Range(layout.startLineNumber, 1, layout.endLineNumber, this._context.model.getLineMaxColumn(layout.endLineNumber)));\n\n      var _a = this._options,\n          renderMinimap = _a.renderMinimap,\n          canvasInnerWidth = _a.canvasInnerWidth,\n          canvasInnerHeight = _a.canvasInnerHeight;\n      var lineHeight = getMinimapLineHeight(renderMinimap);\n      var characterWidth = getMinimapCharWidth(renderMinimap);\n\n      var tabSize = this._context.model.getOptions().tabSize;\n\n      var canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n\n      canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight); // Loop over decorations, ignoring those that don't have the minimap property set and rendering rectangles for each line the decoration spans\n\n      var lineOffsetMap = new Map();\n\n      for (var i = 0; i < decorations.length; i++) {\n        var decoration = decorations[i];\n\n        if (!decoration.options.minimap) {\n          continue;\n        }\n\n        for (var line = decoration.range.startLineNumber; line <= decoration.range.endLineNumber; line++) {\n          this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration, layout, line, lineHeight, lineHeight, tabSize, characterWidth);\n        }\n      }\n\n      this._lastDecorations = decorations;\n    }\n  };\n\n  Minimap.prototype.renderDecorationOnLine = function (canvasContext, lineOffsetMap, decoration, layout, lineNumber, height, lineHeight, tabSize, charWidth) {\n    var y = (lineNumber - layout.startLineNumber) * lineHeight; // Cache line offset data so that it is only read once per line\n\n    var lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n    var isFirstDecorationForLine = !lineIndexToXOffset;\n\n    if (!lineIndexToXOffset) {\n      var lineData = this._context.model.getLineContent(lineNumber);\n\n      lineIndexToXOffset = [0];\n\n      for (var i = 1; i < lineData.length + 1; i++) {\n        var charCode = lineData.charCodeAt(i - 1);\n        var dx = charCode === 9\n        /* Tab */\n        ? tabSize * charWidth : strings.isFullWidthCharacter(charCode) ? 2 * charWidth : charWidth;\n        lineIndexToXOffset[i] = lineIndexToXOffset[i - 1] + dx;\n      }\n\n      lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n    }\n\n    var _a = decoration.range,\n        startColumn = _a.startColumn,\n        endColumn = _a.endColumn,\n        startLineNumber = _a.startLineNumber,\n        endLineNumber = _a.endLineNumber;\n    var x = startLineNumber === lineNumber ? lineIndexToXOffset[startColumn - 1] : 0;\n    var endColumnForLine = endLineNumber > lineNumber ? lineIndexToXOffset.length - 1 : endColumn - 1;\n\n    if (endColumnForLine > 0) {\n      // If the decoration starts at the last character of the column and spans over it, ensure it has a width\n      var width = lineIndexToXOffset[endColumnForLine] - x || 2;\n      this.renderDecoration(canvasContext, decoration.options.minimap, x, y, width, height);\n    }\n\n    if (isFirstDecorationForLine) {\n      this.renderLineHighlight(canvasContext, decoration.options.minimap, y, height);\n    }\n  };\n\n  Minimap.prototype.renderLineHighlight = function (canvasContext, minimapOptions, y, height) {\n    var decorationColor = minimapOptions.getColor(this._context.theme);\n    canvasContext.fillStyle = decorationColor && decorationColor.transparent(0.5).toString() || '';\n    canvasContext.fillRect(0, y, canvasContext.canvas.width, height);\n  };\n\n  Minimap.prototype.renderDecoration = function (canvasContext, minimapOptions, x, y, width, height) {\n    var decorationColor = minimapOptions.getColor(this._context.theme);\n    canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n    canvasContext.fillRect(x, y, width, height);\n  };\n\n  Minimap.prototype.renderLines = function (layout) {\n    var renderMinimap = this._options.renderMinimap;\n    var startLineNumber = layout.startLineNumber;\n    var endLineNumber = layout.endLineNumber;\n    var minimapLineHeight = getMinimapLineHeight(renderMinimap); // Check if nothing changed w.r.t. lines from last frame\n\n    if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n      var _lastData = this._lastRenderData._get(); // Nice!! Nothing changed from last frame\n\n\n      return new RenderData(layout, _lastData.imageData, _lastData.lines);\n    } // Oh well!! We need to repaint some lines...\n\n\n    var imageData = this._getBuffer(); // Render untouched lines by using last rendered data.\n\n\n    var _a = Minimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData),\n        _dirtyY1 = _a[0],\n        _dirtyY2 = _a[1],\n        needed = _a[2]; // Fetch rendering info from view model for rest of lines that need rendering.\n\n\n    var lineInfo = this._context.model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n\n    var tabSize = lineInfo.tabSize;\n\n    var background = this._tokensColorTracker.getColor(2\n    /* DefaultBackground */\n    );\n\n    var useLighterFont = this._tokensColorTracker.backgroundIsLight(); // Render the rest of lines\n\n\n    var dy = 0;\n    var renderedLines = [];\n\n    for (var lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n      if (needed[lineIndex]) {\n        Minimap._renderLine(imageData, background, useLighterFont, renderMinimap, this._tokensColorTracker, getOrCreateMinimapCharRenderer(), dy, tabSize, lineInfo.data[lineIndex]);\n      }\n\n      renderedLines[lineIndex] = new MinimapLine(dy);\n      dy += minimapLineHeight;\n    }\n\n    var dirtyY1 = _dirtyY1 === -1 ? 0 : _dirtyY1;\n    var dirtyY2 = _dirtyY2 === -1 ? imageData.height : _dirtyY2;\n    var dirtyHeight = dirtyY2 - dirtyY1; // Finally, paint to the canvas\n\n    var ctx = this._canvas.domNode.getContext('2d');\n\n    ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight); // Save rendered data for reuse on next frame if possible\n\n    return new RenderData(layout, imageData, renderedLines);\n  };\n\n  Minimap._renderUntouchedLines = function (target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n    var needed = [];\n\n    if (!lastRenderData) {\n      for (var i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n        needed[i] = true;\n      }\n\n      return [-1, -1, needed];\n    }\n\n    var _lastData = lastRenderData._get();\n\n    var lastTargetData = _lastData.imageData.data;\n    var lastStartLineNumber = _lastData.rendLineNumberStart;\n    var lastLines = _lastData.lines;\n    var lastLinesLength = lastLines.length;\n    var WIDTH = target.width;\n    var targetData = target.data;\n    var maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n    var dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n\n    var dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n\n    var copySourceStart = -1;\n    var copySourceEnd = -1;\n    var copyDestStart = -1;\n    var copyDestEnd = -1;\n    var dest_dy = 0;\n\n    for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      var lineIndex = lineNumber - startLineNumber;\n      var lastLineIndex = lineNumber - lastStartLineNumber;\n      var source_dy = lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1;\n\n      if (source_dy === -1) {\n        needed[lineIndex] = true;\n        dest_dy += minimapLineHeight;\n        continue;\n      }\n\n      var sourceStart = source_dy * WIDTH * 4;\n      var sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n      var destStart = dest_dy * WIDTH * 4;\n      var destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n\n      if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n        // contiguous zone => extend copy request\n        copySourceEnd = sourceEnd;\n        copyDestEnd = destEnd;\n      } else {\n        if (copySourceStart !== -1) {\n          // flush existing copy request\n          targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n\n          if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n            dirtyPixel1 = copySourceEnd;\n          }\n\n          if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n            dirtyPixel2 = copySourceStart;\n          }\n        }\n\n        copySourceStart = sourceStart;\n        copySourceEnd = sourceEnd;\n        copyDestStart = destStart;\n        copyDestEnd = destEnd;\n      }\n\n      needed[lineIndex] = false;\n      dest_dy += minimapLineHeight;\n    }\n\n    if (copySourceStart !== -1) {\n      // flush existing copy request\n      targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n\n      if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n        dirtyPixel1 = copySourceEnd;\n      }\n\n      if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n        dirtyPixel2 = copySourceStart;\n      }\n    }\n\n    var dirtyY1 = dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4);\n    var dirtyY2 = dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4);\n    return [dirtyY1, dirtyY2, needed];\n  };\n\n  Minimap._renderLine = function (target, backgroundColor, useLighterFont, renderMinimap, colorTracker, minimapCharRenderer, dy, tabSize, lineData) {\n    var content = lineData.content;\n    var tokens = lineData.tokens;\n    var charWidth = getMinimapCharWidth(renderMinimap);\n    var maxDx = target.width - charWidth;\n    var dx = 0;\n    var charIndex = 0;\n    var tabsCharDelta = 0;\n\n    for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n      var tokenEndIndex = tokens.getEndOffset(tokenIndex);\n      var tokenColorId = tokens.getForeground(tokenIndex);\n      var tokenColor = colorTracker.getColor(tokenColorId);\n\n      for (; charIndex < tokenEndIndex; charIndex++) {\n        if (dx > maxDx) {\n          // hit edge of minimap\n          return;\n        }\n\n        var charCode = content.charCodeAt(charIndex);\n\n        if (charCode === 9\n        /* Tab */\n        ) {\n            var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n            tabsCharDelta += insertSpacesCount - 1; // No need to render anything since tab is invisible\n\n            dx += insertSpacesCount * charWidth;\n          } else if (charCode === 32\n        /* Space */\n        ) {\n            // No need to render anything since space is invisible\n            dx += charWidth;\n          } else {\n          // Render twice for a full width character\n          var count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n\n          for (var i = 0; i < count; i++) {\n            if (renderMinimap === 2\n            /* Large */\n            ) {\n                minimapCharRenderer.x2RenderChar(target, dx, dy, charCode, tokenColor, backgroundColor, useLighterFont);\n              } else if (renderMinimap === 1\n            /* Small */\n            ) {\n                minimapCharRenderer.x1RenderChar(target, dx, dy, charCode, tokenColor, backgroundColor, useLighterFont);\n              } else if (renderMinimap === 4\n            /* LargeBlocks */\n            ) {\n                minimapCharRenderer.x2BlockRenderChar(target, dx, dy, tokenColor, backgroundColor, useLighterFont);\n              } else {\n              // RenderMinimap.SmallBlocks\n              minimapCharRenderer.x1BlockRenderChar(target, dx, dy, tokenColor, backgroundColor, useLighterFont);\n            }\n\n            dx += charWidth;\n\n            if (dx > maxDx) {\n              // hit edge of minimap\n              return;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  return Minimap;\n}(ViewPart);\n\nexport { Minimap };\nregisterThemingParticipant(function (theme, collector) {\n  var sliderBackground = theme.getColor(scrollbarSliderBackground);\n\n  if (sliderBackground) {\n    var halfSliderBackground = sliderBackground.transparent(0.5);\n    collector.addRule(\".monaco-editor .minimap-slider, .monaco-editor .minimap-slider .minimap-slider-horizontal { background: \" + halfSliderBackground + \"; }\");\n  }\n\n  var sliderHoverBackground = theme.getColor(scrollbarSliderHoverBackground);\n\n  if (sliderHoverBackground) {\n    var halfSliderHoverBackground = sliderHoverBackground.transparent(0.5);\n    collector.addRule(\".monaco-editor .minimap-slider:hover, .monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: \" + halfSliderHoverBackground + \"; }\");\n  }\n\n  var sliderActiveBackground = theme.getColor(scrollbarSliderActiveBackground);\n\n  if (sliderActiveBackground) {\n    var halfSliderActiveBackground = sliderActiveBackground.transparent(0.5);\n    collector.addRule(\".monaco-editor .minimap-slider.active, .monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: \" + halfSliderActiveBackground + \"; }\");\n  }\n\n  var shadow = theme.getColor(scrollbarShadow);\n\n  if (shadow) {\n    collector.addRule(\".monaco-editor .minimap-shadow-visible { box-shadow: \" + shadow + \" -6px 0 6px -6px inset; }\");\n  }\n});","map":null,"metadata":{},"sourceType":"module"}