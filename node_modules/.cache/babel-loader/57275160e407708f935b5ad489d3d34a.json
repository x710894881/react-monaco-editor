{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from './arrays.js';\nimport * as strings from './strings.js';\nimport * as extpath from './extpath.js';\nimport * as paths from './path.js';\nimport { LRUCache } from './map.js';\nimport { isThenable } from './async.js';\nvar GLOBSTAR = '**';\nvar GLOB_SPLIT = '/';\nvar PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\n\nvar NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\n\nvar ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount) {\n  switch (starCount) {\n    case 0:\n      return '';\n\n    case 1:\n      return NO_PATH_REGEX + \"*?\";\n    // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\n    default:\n      // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n      // Group is non capturing because we don't need to capture at all (?:...)\n      // Overall we use non-greedy matching because it could be that we match too much\n      return \"(?:\" + PATH_REGEX + \"|\" + NO_PATH_REGEX + \"+\" + PATH_REGEX + \"|\" + PATH_REGEX + NO_PATH_REGEX + \"+)*?\";\n  }\n}\n\nexport function splitGlobAware(pattern, splitChar) {\n  if (!pattern) {\n    return [];\n  }\n\n  var segments = [];\n  var inBraces = false;\n  var inBrackets = false;\n  var curVal = '';\n\n  for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {\n    var char = pattern_1[_i];\n\n    switch (char) {\n      case splitChar:\n        if (!inBraces && !inBrackets) {\n          segments.push(curVal);\n          curVal = '';\n          continue;\n        }\n\n        break;\n\n      case '{':\n        inBraces = true;\n        break;\n\n      case '}':\n        inBraces = false;\n        break;\n\n      case '[':\n        inBrackets = true;\n        break;\n\n      case ']':\n        inBrackets = false;\n        break;\n    }\n\n    curVal += char;\n  } // Tail\n\n\n  if (curVal) {\n    segments.push(curVal);\n  }\n\n  return segments;\n}\n\nfunction parseRegExp(pattern) {\n  if (!pattern) {\n    return '';\n  }\n\n  var regEx = ''; // Split up into segments for each slash found\n\n  var segments = splitGlobAware(pattern, GLOB_SPLIT); // Special case where we only have globstars\n\n  if (segments.every(function (s) {\n    return s === GLOBSTAR;\n  })) {\n    regEx = '.*';\n  } // Build regex over segments\n  else {\n      var previousSegmentWasGlobStar_1 = false;\n      segments.forEach(function (segment, index) {\n        // Globstar is special\n        if (segment === GLOBSTAR) {\n          // if we have more than one globstar after another, just ignore it\n          if (!previousSegmentWasGlobStar_1) {\n            regEx += starsToRegExp(2);\n            previousSegmentWasGlobStar_1 = true;\n          }\n\n          return;\n        } // States\n\n\n        var inBraces = false;\n        var braceVal = '';\n        var inBrackets = false;\n        var bracketVal = '';\n\n        for (var _i = 0, segment_1 = segment; _i < segment_1.length; _i++) {\n          var char = segment_1[_i]; // Support brace expansion\n\n          if (char !== '}' && inBraces) {\n            braceVal += char;\n            continue;\n          } // Support brackets\n\n\n          if (inBrackets && (char !== ']' || !bracketVal)\n          /* ] is literally only allowed as first character in brackets to match it */\n          ) {\n              var res = void 0; // range operator\n\n              if (char === '-') {\n                res = char;\n              } // negation operator (only valid on first index in bracket)\n              else if ((char === '^' || char === '!') && !bracketVal) {\n                  res = '^';\n                } // glob split matching is not allowed within character ranges\n                // see http://man7.org/linux/man-pages/man7/glob.7.html\n                else if (char === GLOB_SPLIT) {\n                    res = '';\n                  } // anything else gets escaped\n                  else {\n                      res = strings.escapeRegExpCharacters(char);\n                    }\n\n              bracketVal += res;\n              continue;\n            }\n\n          switch (char) {\n            case '{':\n              inBraces = true;\n              continue;\n\n            case '[':\n              inBrackets = true;\n              continue;\n\n            case '}':\n              var choices = splitGlobAware(braceVal, ','); // Converts {foo,bar} => [foo|bar]\n\n              var braceRegExp = \"(?:\" + choices.map(function (c) {\n                return parseRegExp(c);\n              }).join('|') + \")\";\n              regEx += braceRegExp;\n              inBraces = false;\n              braceVal = '';\n              break;\n\n            case ']':\n              regEx += '[' + bracketVal + ']';\n              inBrackets = false;\n              bracketVal = '';\n              break;\n\n            case '?':\n              regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\n              continue;\n\n            case '*':\n              regEx += starsToRegExp(1);\n              continue;\n\n            default:\n              regEx += strings.escapeRegExpCharacters(char);\n          }\n        } // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n        // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n        // a folder called \"something\" to match as well.\n        // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n        // is to match 0-N segments.\n\n\n        if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n          regEx += PATH_REGEX;\n        } // reset state\n\n\n        previousSegmentWasGlobStar_1 = false;\n      });\n    }\n\n  return regEx;\n} // regexes to check for trival glob patterns that just check for String#endsWith\n\n\nvar T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\n\nvar T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\n\nvar T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\n\nvar T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\n\nvar T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\n\nvar T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\n\nvar CACHE = new LRUCache(10000); // bounded to 10000 elements\n\nvar FALSE = function () {\n  return false;\n};\n\nvar NULL = function () {\n  return null;\n};\n\nfunction parsePattern(arg1, options) {\n  if (!arg1) {\n    return NULL;\n  } // Handle IRelativePattern\n\n\n  var pattern;\n\n  if (typeof arg1 !== 'string') {\n    pattern = arg1.pattern;\n  } else {\n    pattern = arg1;\n  } // Whitespace trimming\n\n\n  pattern = pattern.trim(); // Check cache\n\n  var patternKey = pattern + \"_\" + !!options.trimForExclusions;\n  var parsedPattern = CACHE.get(patternKey);\n\n  if (parsedPattern) {\n    return wrapRelativePattern(parsedPattern, arg1);\n  } // Check for Trivias\n\n\n  var match;\n\n  if (T1.test(pattern)) {\n    // common pattern: **/*.txt just need endsWith check\n    var base_1 = pattern.substr(4); // '**/*'.length === 4\n\n    parsedPattern = function (path, basename) {\n      return typeof path === 'string' && strings.endsWith(path, base_1) ? pattern : null;\n    };\n  } else if (match = T2.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/some.txt just need basename check\n    parsedPattern = trivia2(match[1], pattern);\n  } else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {\n    // repetition of common patterns (see above) {**/*.txt,**/*.png}\n    parsedPattern = trivia3(pattern, options);\n  } else if (match = T4.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/something/else just need endsWith check\n    parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n  } else if (match = T5.exec(trimForExclusions(pattern, options))) {\n    // common pattern: something/else just need equals check\n    parsedPattern = trivia4and5(match[1], pattern, false);\n  } // Otherwise convert to pattern\n  else {\n      parsedPattern = toRegExp(pattern);\n    } // Cache\n\n\n  CACHE.set(patternKey, parsedPattern);\n  return wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern, arg2) {\n  if (typeof arg2 === 'string') {\n    return parsedPattern;\n  }\n\n  return function (path, basename) {\n    if (!extpath.isEqualOrParent(path, arg2.base)) {\n      return null;\n    }\n\n    return parsedPattern(paths.relative(arg2.base, path), basename);\n  };\n}\n\nfunction trimForExclusions(pattern, options) {\n  return options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n} // common pattern: **/some.txt just need basename check\n\n\nfunction trivia2(base, originalPattern) {\n  var slashBase = \"/\" + base;\n  var backslashBase = \"\\\\\" + base;\n\n  var parsedPattern = function (path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n\n    if (basename) {\n      return basename === base ? originalPattern : null;\n    }\n\n    return path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;\n  };\n\n  var basenames = [base];\n  parsedPattern.basenames = basenames;\n  parsedPattern.patterns = [originalPattern];\n  parsedPattern.allBasenames = basenames;\n  return parsedPattern;\n} // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\n\nfunction trivia3(pattern, options) {\n  var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',').map(function (pattern) {\n    return parsePattern(pattern, options);\n  }).filter(function (pattern) {\n    return pattern !== NULL;\n  }), pattern);\n  var n = parsedPatterns.length;\n\n  if (!n) {\n    return NULL;\n  }\n\n  if (n === 1) {\n    return parsedPatterns[0];\n  }\n\n  var parsedPattern = function (path, basename) {\n    for (var i = 0, n_1 = parsedPatterns.length; i < n_1; i++) {\n      if (parsedPatterns[i](path, basename)) {\n        return pattern;\n      }\n    }\n\n    return null;\n  };\n\n  var withBasenames = arrays.first(parsedPatterns, function (pattern) {\n    return !!pattern.allBasenames;\n  });\n\n  if (withBasenames) {\n    parsedPattern.allBasenames = withBasenames.allBasenames;\n  }\n\n  var allPaths = parsedPatterns.reduce(function (all, current) {\n    return current.allPaths ? all.concat(current.allPaths) : all;\n  }, []);\n\n  if (allPaths.length) {\n    parsedPattern.allPaths = allPaths;\n  }\n\n  return parsedPattern;\n} // common patterns: **/something/else just need endsWith check, something/else just needs and equals check\n\n\nfunction trivia4and5(path, pattern, matchPathEnds) {\n  var nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\n  var nativePathEnd = paths.sep + nativePath;\n  var parsedPattern = matchPathEnds ? function (path, basename) {\n    return typeof path === 'string' && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;\n  } : function (path, basename) {\n    return typeof path === 'string' && path === nativePath ? pattern : null;\n  };\n  parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\n  return parsedPattern;\n}\n\nfunction toRegExp(pattern) {\n  try {\n    var regExp_1 = new RegExp(\"^\" + parseRegExp(pattern) + \"$\");\n    return function (path, basename) {\n      regExp_1.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n      return typeof path === 'string' && regExp_1.test(path) ? pattern : null;\n    };\n  } catch (error) {\n    return NULL;\n  }\n}\n\nexport function match(arg1, path, hasSibling) {\n  if (!arg1 || typeof path !== 'string') {\n    return false;\n  }\n\n  return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (!arg1) {\n    return FALSE;\n  } // Glob with String\n\n\n  if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n    var parsedPattern_1 = parsePattern(arg1, options);\n\n    if (parsedPattern_1 === NULL) {\n      return FALSE;\n    }\n\n    var resultPattern = function (path, basename) {\n      return !!parsedPattern_1(path, basename);\n    };\n\n    if (parsedPattern_1.allBasenames) {\n      resultPattern.allBasenames = parsedPattern_1.allBasenames;\n    }\n\n    if (parsedPattern_1.allPaths) {\n      resultPattern.allPaths = parsedPattern_1.allPaths;\n    }\n\n    return resultPattern;\n  } // Glob with Expression\n\n\n  return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n  var rp = obj;\n  return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nfunction parsedExpression(expression, options) {\n  var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map(function (pattern) {\n    return parseExpressionPattern(pattern, expression[pattern], options);\n  }).filter(function (pattern) {\n    return pattern !== NULL;\n  }));\n  var n = parsedPatterns.length;\n\n  if (!n) {\n    return NULL;\n  }\n\n  if (!parsedPatterns.some(function (parsedPattern) {\n    return !!parsedPattern.requiresSiblings;\n  })) {\n    if (n === 1) {\n      return parsedPatterns[0];\n    }\n\n    var resultExpression_1 = function (path, basename) {\n      for (var i = 0, n_2 = parsedPatterns.length; i < n_2; i++) {\n        // Pattern matches path\n        var result = parsedPatterns[i](path, basename);\n\n        if (result) {\n          return result;\n        }\n      }\n\n      return null;\n    };\n\n    var withBasenames_1 = arrays.first(parsedPatterns, function (pattern) {\n      return !!pattern.allBasenames;\n    });\n\n    if (withBasenames_1) {\n      resultExpression_1.allBasenames = withBasenames_1.allBasenames;\n    }\n\n    var allPaths_1 = parsedPatterns.reduce(function (all, current) {\n      return current.allPaths ? all.concat(current.allPaths) : all;\n    }, []);\n\n    if (allPaths_1.length) {\n      resultExpression_1.allPaths = allPaths_1;\n    }\n\n    return resultExpression_1;\n  }\n\n  var resultExpression = function (path, basename, hasSibling) {\n    var name = undefined;\n\n    for (var i = 0, n_3 = parsedPatterns.length; i < n_3; i++) {\n      // Pattern matches path\n      var parsedPattern = parsedPatterns[i];\n\n      if (parsedPattern.requiresSiblings && hasSibling) {\n        if (!basename) {\n          basename = paths.basename(path);\n        }\n\n        if (!name) {\n          name = basename.substr(0, basename.length - paths.extname(path).length);\n        }\n      }\n\n      var result = parsedPattern(path, basename, name, hasSibling);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n\n  var withBasenames = arrays.first(parsedPatterns, function (pattern) {\n    return !!pattern.allBasenames;\n  });\n\n  if (withBasenames) {\n    resultExpression.allBasenames = withBasenames.allBasenames;\n  }\n\n  var allPaths = parsedPatterns.reduce(function (all, current) {\n    return current.allPaths ? all.concat(current.allPaths) : all;\n  }, []);\n\n  if (allPaths.length) {\n    resultExpression.allPaths = allPaths;\n  }\n\n  return resultExpression;\n}\n\nfunction parseExpressionPattern(pattern, value, options) {\n  if (value === false) {\n    return NULL; // pattern is disabled\n  }\n\n  var parsedPattern = parsePattern(pattern, options);\n\n  if (parsedPattern === NULL) {\n    return NULL;\n  } // Expression Pattern is <boolean>\n\n\n  if (typeof value === 'boolean') {\n    return parsedPattern;\n  } // Expression Pattern is <SiblingClause>\n\n\n  if (value) {\n    var when_1 = value.when;\n\n    if (typeof when_1 === 'string') {\n      var result = function (path, basename, name, hasSibling) {\n        if (!hasSibling || !parsedPattern(path, basename)) {\n          return null;\n        }\n\n        var clausePattern = when_1.replace('$(basename)', name);\n        var matched = hasSibling(clausePattern);\n        return isThenable(matched) ? matched.then(function (m) {\n          return m ? pattern : null;\n        }) : matched ? pattern : null;\n      };\n\n      result.requiresSiblings = true;\n      return result;\n    }\n  } // Expression is Anything\n\n\n  return parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n  var basenamePatterns = parsedPatterns.filter(function (parsedPattern) {\n    return !!parsedPattern.basenames;\n  });\n\n  if (basenamePatterns.length < 2) {\n    return parsedPatterns;\n  }\n\n  var basenames = basenamePatterns.reduce(function (all, current) {\n    var basenames = current.basenames;\n    return basenames ? all.concat(basenames) : all;\n  }, []);\n  var patterns;\n\n  if (result) {\n    patterns = [];\n\n    for (var i = 0, n = basenames.length; i < n; i++) {\n      patterns.push(result);\n    }\n  } else {\n    patterns = basenamePatterns.reduce(function (all, current) {\n      var patterns = current.patterns;\n      return patterns ? all.concat(patterns) : all;\n    }, []);\n  }\n\n  var aggregate = function (path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n\n    if (!basename) {\n      var i = void 0;\n\n      for (i = path.length; i > 0; i--) {\n        var ch = path.charCodeAt(i - 1);\n\n        if (ch === 47\n        /* Slash */\n        || ch === 92\n        /* Backslash */\n        ) {\n            break;\n          }\n      }\n\n      basename = path.substr(i);\n    }\n\n    var index = basenames.indexOf(basename);\n    return index !== -1 ? patterns[index] : null;\n  };\n\n  aggregate.basenames = basenames;\n  aggregate.patterns = patterns;\n  aggregate.allBasenames = basenames;\n  var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) {\n    return !parsedPattern.basenames;\n  });\n  aggregatedPatterns.push(aggregate);\n  return aggregatedPatterns;\n}","map":null,"metadata":{},"sourceType":"module"}