{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as nls from '../../../nls.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { MarkdownString, isEmptyMarkdownString, markedStringsEquals } from '../../../base/common/htmlContent.js';\nimport { toDisposable, DisposableStore, combinedDisposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { ModelDecorationOptions } from '../../common/model/textModel.js';\nimport { HoverProviderRegistry } from '../../common/modes.js';\nimport { getColorPresentations } from '../colorPicker/color.js';\nimport { ColorDetector } from '../colorPicker/colorDetector.js';\nimport { ColorPickerModel } from '../colorPicker/colorPickerModel.js';\nimport { ColorPickerWidget } from '../colorPicker/colorPickerWidget.js';\nimport { getHover } from './getHover.js';\nimport { HoverOperation } from './hoverOperation.js';\nimport { ContentHoverWidget } from './hoverWidgets.js';\nimport { MarkdownRenderer } from '../markdown/markdownRenderer.js';\nimport { coalesce, isNonEmptyArray, asArray } from '../../../base/common/arrays.js';\nimport { IMarkerData, MarkerSeverity } from '../../../platform/markers/common/markers.js';\nimport { basename } from '../../../base/common/resources.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { NullOpenerService } from '../../../platform/opener/common/opener.js';\nimport { MarkerController, NextMarkerAction } from '../gotoError/gotoError.js';\nimport { createCancelablePromise } from '../../../base/common/async.js';\nimport { getCodeActions } from '../codeAction/codeAction.js';\nimport { QuickFixAction, QuickFixController } from '../codeAction/codeActionCommands.js';\nimport { CodeActionKind } from '../codeAction/codeActionTrigger.js';\nvar $ = dom.$;\n\nvar ColorHover =\n/** @class */\nfunction () {\n  function ColorHover(range, color, provider) {\n    this.range = range;\n    this.color = color;\n    this.provider = provider;\n  }\n\n  return ColorHover;\n}();\n\nvar MarkerHover =\n/** @class */\nfunction () {\n  function MarkerHover(range, marker) {\n    this.range = range;\n    this.marker = marker;\n  }\n\n  return MarkerHover;\n}();\n\nvar ModesContentComputer =\n/** @class */\nfunction () {\n  function ModesContentComputer(editor, _markerDecorationsService) {\n    this._markerDecorationsService = _markerDecorationsService;\n    this._editor = editor;\n    this._result = [];\n  }\n\n  ModesContentComputer.prototype.setRange = function (range) {\n    this._range = range;\n    this._result = [];\n  };\n\n  ModesContentComputer.prototype.clearResult = function () {\n    this._result = [];\n  };\n\n  ModesContentComputer.prototype.computeAsync = function (token) {\n    if (!this._editor.hasModel() || !this._range) {\n      return Promise.resolve([]);\n    }\n\n    var model = this._editor.getModel();\n\n    if (!HoverProviderRegistry.has(model)) {\n      return Promise.resolve([]);\n    }\n\n    return getHover(model, new Position(this._range.startLineNumber, this._range.startColumn), token);\n  };\n\n  ModesContentComputer.prototype.computeSync = function () {\n    var _this = this;\n\n    if (!this._editor.hasModel() || !this._range) {\n      return [];\n    }\n\n    var model = this._editor.getModel();\n\n    var lineNumber = this._range.startLineNumber;\n\n    if (lineNumber > this._editor.getModel().getLineCount()) {\n      // Illegal line number => no results\n      return [];\n    }\n\n    var colorDetector = ColorDetector.get(this._editor);\n    var maxColumn = model.getLineMaxColumn(lineNumber);\n\n    var lineDecorations = this._editor.getLineDecorations(lineNumber);\n\n    var didFindColor = false;\n    var hoverRange = this._range;\n    var result = lineDecorations.map(function (d) {\n      var startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;\n      var endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;\n\n      if (startColumn > hoverRange.startColumn || hoverRange.endColumn > endColumn) {\n        return null;\n      }\n\n      var range = new Range(hoverRange.startLineNumber, startColumn, hoverRange.startLineNumber, endColumn);\n\n      var marker = _this._markerDecorationsService.getMarker(model, d);\n\n      if (marker) {\n        return new MarkerHover(range, marker);\n      }\n\n      var colorData = colorDetector.getColorData(d.range.getStartPosition());\n\n      if (!didFindColor && colorData) {\n        didFindColor = true;\n        var _a = colorData.colorInfo,\n            color = _a.color,\n            range_1 = _a.range;\n        return new ColorHover(range_1, color, colorData.provider);\n      } else {\n        if (isEmptyMarkdownString(d.options.hoverMessage)) {\n          return null;\n        }\n\n        var contents = d.options.hoverMessage ? asArray(d.options.hoverMessage) : [];\n        return {\n          contents: contents,\n          range: range\n        };\n      }\n    });\n    return coalesce(result);\n  };\n\n  ModesContentComputer.prototype.onResult = function (result, isFromSynchronousComputation) {\n    // Always put synchronous messages before asynchronous ones\n    if (isFromSynchronousComputation) {\n      this._result = result.concat(this._result.sort(function (a, b) {\n        if (a instanceof ColorHover) {\n          // sort picker messages at to the top\n          return -1;\n        } else if (b instanceof ColorHover) {\n          return 1;\n        }\n\n        return 0;\n      }));\n    } else {\n      this._result = this._result.concat(result);\n    }\n  };\n\n  ModesContentComputer.prototype.getResult = function () {\n    return this._result.slice(0);\n  };\n\n  ModesContentComputer.prototype.getResultWithLoadingMessage = function () {\n    return this._result.slice(0).concat([this._getLoadingMessage()]);\n  };\n\n  ModesContentComputer.prototype._getLoadingMessage = function () {\n    return {\n      range: this._range,\n      contents: [new MarkdownString().appendText(nls.localize('modesContentHover.loading', \"Loading...\"))]\n    };\n  };\n\n  return ModesContentComputer;\n}();\n\nvar ModesContentHoverWidget =\n/** @class */\nfunction (_super) {\n  __extends(ModesContentHoverWidget, _super);\n\n  function ModesContentHoverWidget(editor, markerDecorationsService, _themeService, _keybindingService, _modeService, _openerService) {\n    if (_openerService === void 0) {\n      _openerService = NullOpenerService;\n    }\n\n    var _this = _super.call(this, ModesContentHoverWidget.ID, editor) || this;\n\n    _this._themeService = _themeService;\n    _this._keybindingService = _keybindingService;\n    _this._modeService = _modeService;\n    _this._openerService = _openerService;\n    _this.renderDisposable = _this._register(new MutableDisposable());\n    _this._messages = [];\n    _this._lastRange = null;\n    _this._computer = new ModesContentComputer(_this._editor, markerDecorationsService);\n    _this._highlightDecorations = [];\n    _this._isChangingDecorations = false;\n    _this._shouldFocus = false;\n    _this._colorPicker = null;\n    _this._hoverOperation = new HoverOperation(_this._computer, function (result) {\n      return _this._withResult(result, true);\n    }, null, function (result) {\n      return _this._withResult(result, false);\n    }, _this._editor.getConfiguration().contribInfo.hover.delay);\n\n    _this._register(dom.addStandardDisposableListener(_this.getDomNode(), dom.EventType.FOCUS, function () {\n      if (_this._colorPicker) {\n        dom.addClass(_this.getDomNode(), 'colorpicker-hover');\n      }\n    }));\n\n    _this._register(dom.addStandardDisposableListener(_this.getDomNode(), dom.EventType.BLUR, function () {\n      dom.removeClass(_this.getDomNode(), 'colorpicker-hover');\n    }));\n\n    _this._register(editor.onDidChangeConfiguration(function (e) {\n      _this._hoverOperation.setHoverTime(_this._editor.getConfiguration().contribInfo.hover.delay);\n    }));\n\n    return _this;\n  }\n\n  ModesContentHoverWidget.prototype.dispose = function () {\n    this._hoverOperation.cancel();\n\n    _super.prototype.dispose.call(this);\n  };\n\n  ModesContentHoverWidget.prototype.onModelDecorationsChanged = function () {\n    if (this._isChangingDecorations) {\n      return;\n    }\n\n    if (this.isVisible) {\n      // The decorations have changed and the hover is visible,\n      // we need to recompute the displayed text\n      this._hoverOperation.cancel();\n\n      this._computer.clearResult();\n\n      if (!this._colorPicker) {\n        // TODO@Michel ensure that displayed text for other decorations is computed even if color picker is in place\n        this._hoverOperation.start(0\n        /* Delayed */\n        );\n      }\n    }\n  };\n\n  ModesContentHoverWidget.prototype.startShowingAt = function (range, mode, focus) {\n    if (this._lastRange && this._lastRange.equalsRange(range)) {\n      // We have to show the widget at the exact same range as before, so no work is needed\n      return;\n    }\n\n    this._hoverOperation.cancel();\n\n    if (this.isVisible) {\n      // The range might have changed, but the hover is visible\n      // Instead of hiding it completely, filter out messages that are still in the new range and\n      // kick off a new computation\n      if (!this._showAtPosition || this._showAtPosition.lineNumber !== range.startLineNumber) {\n        this.hide();\n      } else {\n        var filteredMessages = [];\n\n        for (var i = 0, len = this._messages.length; i < len; i++) {\n          var msg = this._messages[i];\n          var rng = msg.range;\n\n          if (rng && rng.startColumn <= range.startColumn && rng.endColumn >= range.endColumn) {\n            filteredMessages.push(msg);\n          }\n        }\n\n        if (filteredMessages.length > 0) {\n          if (hoverContentsEquals(filteredMessages, this._messages)) {\n            return;\n          }\n\n          this._renderMessages(range, filteredMessages);\n        } else {\n          this.hide();\n        }\n      }\n    }\n\n    this._lastRange = range;\n\n    this._computer.setRange(range);\n\n    this._shouldFocus = focus;\n\n    this._hoverOperation.start(mode);\n  };\n\n  ModesContentHoverWidget.prototype.hide = function () {\n    this._lastRange = null;\n\n    this._hoverOperation.cancel();\n\n    _super.prototype.hide.call(this);\n\n    this._isChangingDecorations = true;\n    this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, []);\n    this._isChangingDecorations = false;\n    this.renderDisposable.clear();\n    this._colorPicker = null;\n  };\n\n  ModesContentHoverWidget.prototype.isColorPickerVisible = function () {\n    if (this._colorPicker) {\n      return true;\n    }\n\n    return false;\n  };\n\n  ModesContentHoverWidget.prototype._withResult = function (result, complete) {\n    this._messages = result;\n\n    if (this._lastRange && this._messages.length > 0) {\n      this._renderMessages(this._lastRange, this._messages);\n    } else if (complete) {\n      this.hide();\n    }\n  };\n\n  ModesContentHoverWidget.prototype._renderMessages = function (renderRange, messages) {\n    var _this = this;\n\n    this.renderDisposable.dispose();\n    this._colorPicker = null; // update column from which to show\n\n    var renderColumn = Number.MAX_VALUE;\n    var highlightRange = messages[0].range ? Range.lift(messages[0].range) : null;\n    var fragment = document.createDocumentFragment();\n    var isEmptyHoverContent = true;\n    var containColorPicker = false;\n    var markdownDisposeables = new DisposableStore();\n    var markerMessages = [];\n    messages.forEach(function (msg) {\n      if (!msg.range) {\n        return;\n      }\n\n      renderColumn = Math.min(renderColumn, msg.range.startColumn);\n      highlightRange = highlightRange ? Range.plusRange(highlightRange, msg.range) : Range.lift(msg.range);\n\n      if (msg instanceof ColorHover) {\n        containColorPicker = true;\n        var _a = msg.color,\n            red = _a.red,\n            green = _a.green,\n            blue = _a.blue,\n            alpha = _a.alpha;\n        var rgba = new RGBA(red * 255, green * 255, blue * 255, alpha);\n        var color_1 = new Color(rgba);\n\n        if (!_this._editor.hasModel()) {\n          return;\n        }\n\n        var editorModel_1 = _this._editor.getModel();\n\n        var range_2 = new Range(msg.range.startLineNumber, msg.range.startColumn, msg.range.endLineNumber, msg.range.endColumn);\n        var colorInfo = {\n          range: msg.range,\n          color: msg.color\n        }; // create blank olor picker model and widget first to ensure it's positioned correctly.\n\n        var model_1 = new ColorPickerModel(color_1, [], 0);\n        var widget_1 = new ColorPickerWidget(fragment, model_1, _this._editor.getConfiguration().pixelRatio, _this._themeService);\n        getColorPresentations(editorModel_1, colorInfo, msg.provider, CancellationToken.None).then(function (colorPresentations) {\n          model_1.colorPresentations = colorPresentations || [];\n\n          if (!_this._editor.hasModel()) {\n            // gone...\n            return;\n          }\n\n          var originalText = _this._editor.getModel().getValueInRange(msg.range);\n\n          model_1.guessColorPresentation(color_1, originalText);\n\n          var updateEditorModel = function () {\n            var textEdits;\n            var newRange;\n\n            if (model_1.presentation.textEdit) {\n              textEdits = [model_1.presentation.textEdit];\n              newRange = new Range(model_1.presentation.textEdit.range.startLineNumber, model_1.presentation.textEdit.range.startColumn, model_1.presentation.textEdit.range.endLineNumber, model_1.presentation.textEdit.range.endColumn);\n              newRange = newRange.setEndPosition(newRange.endLineNumber, newRange.startColumn + model_1.presentation.textEdit.text.length);\n            } else {\n              textEdits = [{\n                identifier: null,\n                range: range_2,\n                text: model_1.presentation.label,\n                forceMoveMarkers: false\n              }];\n              newRange = range_2.setEndPosition(range_2.endLineNumber, range_2.startColumn + model_1.presentation.label.length);\n            }\n\n            _this._editor.pushUndoStop();\n\n            _this._editor.executeEdits('colorpicker', textEdits);\n\n            if (model_1.presentation.additionalTextEdits) {\n              textEdits = model_1.presentation.additionalTextEdits.slice();\n\n              _this._editor.executeEdits('colorpicker', textEdits);\n\n              _this.hide();\n            }\n\n            _this._editor.pushUndoStop();\n\n            range_2 = newRange;\n          };\n\n          var updateColorPresentations = function (color) {\n            return getColorPresentations(editorModel_1, {\n              range: range_2,\n              color: {\n                red: color.rgba.r / 255,\n                green: color.rgba.g / 255,\n                blue: color.rgba.b / 255,\n                alpha: color.rgba.a\n              }\n            }, msg.provider, CancellationToken.None).then(function (colorPresentations) {\n              model_1.colorPresentations = colorPresentations || [];\n            });\n          };\n\n          var colorListener = model_1.onColorFlushed(function (color) {\n            updateColorPresentations(color).then(updateEditorModel);\n          });\n          var colorChangeListener = model_1.onDidChangeColor(updateColorPresentations);\n          _this._colorPicker = widget_1;\n\n          _this.showAt(range_2.getStartPosition(), range_2, _this._shouldFocus);\n\n          _this.updateContents(fragment);\n\n          _this._colorPicker.layout();\n\n          _this.renderDisposable.value = combinedDisposable(colorListener, colorChangeListener, widget_1, markdownDisposeables);\n        });\n      } else {\n        if (msg instanceof MarkerHover) {\n          markerMessages.push(msg);\n          isEmptyHoverContent = false;\n        } else {\n          msg.contents.filter(function (contents) {\n            return !isEmptyMarkdownString(contents);\n          }).forEach(function (contents) {\n            var markdownHoverElement = $('div.hover-row.markdown-hover');\n            var hoverContentsElement = dom.append(markdownHoverElement, $('div.hover-contents'));\n            var renderer = markdownDisposeables.add(new MarkdownRenderer(_this._editor, _this._modeService, _this._openerService));\n            markdownDisposeables.add(renderer.onDidRenderCodeBlock(function () {\n              hoverContentsElement.className = 'hover-contents code-hover-contents';\n\n              _this.onContentsChange();\n            }));\n            var renderedContents = markdownDisposeables.add(renderer.render(contents));\n            hoverContentsElement.appendChild(renderedContents.element);\n            fragment.appendChild(markdownHoverElement);\n            isEmptyHoverContent = false;\n          });\n        }\n      }\n    });\n\n    if (markerMessages.length) {\n      markerMessages.forEach(function (msg) {\n        return fragment.appendChild(_this.renderMarkerHover(msg));\n      });\n      var markerHoverForStatusbar = markerMessages.length === 1 ? markerMessages[0] : markerMessages.sort(function (a, b) {\n        return MarkerSeverity.compare(a.marker.severity, b.marker.severity);\n      })[0];\n      fragment.appendChild(this.renderMarkerStatusbar(markerHoverForStatusbar));\n    } // show\n\n\n    if (!containColorPicker && !isEmptyHoverContent) {\n      this.showAt(new Position(renderRange.startLineNumber, renderColumn), highlightRange, this._shouldFocus);\n      this.updateContents(fragment);\n    }\n\n    this._isChangingDecorations = true;\n    this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, highlightRange ? [{\n      range: highlightRange,\n      options: ModesContentHoverWidget._DECORATION_OPTIONS\n    }] : []);\n    this._isChangingDecorations = false;\n  };\n\n  ModesContentHoverWidget.prototype.renderMarkerHover = function (markerHover) {\n    var _this = this;\n\n    var hoverElement = $('div.hover-row');\n    var markerElement = dom.append(hoverElement, $('div.marker.hover-contents'));\n    var _a = markerHover.marker,\n        source = _a.source,\n        message = _a.message,\n        code = _a.code,\n        relatedInformation = _a.relatedInformation;\n\n    this._editor.applyFontInfo(markerElement);\n\n    var messageElement = dom.append(markerElement, $('span'));\n    messageElement.style.whiteSpace = 'pre-wrap';\n    messageElement.innerText = message;\n\n    if (source || code) {\n      var detailsElement = dom.append(markerElement, $('span'));\n      detailsElement.style.opacity = '0.6';\n      detailsElement.style.paddingLeft = '6px';\n      detailsElement.innerText = source && code ? source + \"(\" + code + \")\" : source ? source : \"(\" + code + \")\";\n    }\n\n    if (isNonEmptyArray(relatedInformation)) {\n      var _loop_1 = function (message_1, resource, startLineNumber, startColumn) {\n        var relatedInfoContainer = dom.append(markerElement, $('div'));\n        relatedInfoContainer.style.marginTop = '8px';\n        var a = dom.append(relatedInfoContainer, $('a'));\n        a.innerText = basename(resource) + \"(\" + startLineNumber + \", \" + startColumn + \"): \";\n        a.style.cursor = 'pointer';\n\n        a.onclick = function (e) {\n          e.stopPropagation();\n          e.preventDefault();\n\n          if (_this._openerService) {\n            _this._openerService.open(resource.with({\n              fragment: startLineNumber + \",\" + startColumn\n            })).catch(onUnexpectedError);\n          }\n        };\n\n        var messageElement_1 = dom.append(relatedInfoContainer, $('span'));\n        messageElement_1.innerText = message_1;\n\n        this_1._editor.applyFontInfo(messageElement_1);\n      };\n\n      var this_1 = this;\n\n      for (var _i = 0, relatedInformation_1 = relatedInformation; _i < relatedInformation_1.length; _i++) {\n        var _b = relatedInformation_1[_i],\n            message_1 = _b.message,\n            resource = _b.resource,\n            startLineNumber = _b.startLineNumber,\n            startColumn = _b.startColumn;\n\n        _loop_1(message_1, resource, startLineNumber, startColumn);\n      }\n    }\n\n    return hoverElement;\n  };\n\n  ModesContentHoverWidget.prototype.renderMarkerStatusbar = function (markerHover) {\n    var _this = this;\n\n    var hoverElement = $('div.hover-row.status-bar');\n    var disposables = new DisposableStore();\n    var actionsElement = dom.append(hoverElement, $('div.actions'));\n\n    if (markerHover.marker.severity === MarkerSeverity.Error || markerHover.marker.severity === MarkerSeverity.Warning || markerHover.marker.severity === MarkerSeverity.Info) {\n      disposables.add(this.renderAction(actionsElement, {\n        label: nls.localize('peek problem', \"Peek Problem\"),\n        commandId: NextMarkerAction.ID,\n        run: function () {\n          _this.hide();\n\n          MarkerController.get(_this._editor).show(markerHover.marker);\n\n          _this._editor.focus();\n        }\n      }));\n    }\n\n    var quickfixPlaceholderElement = dom.append(actionsElement, $('div'));\n    quickfixPlaceholderElement.style.opacity = '0';\n    quickfixPlaceholderElement.style.transition = 'opacity 0.2s';\n    setTimeout(function () {\n      return quickfixPlaceholderElement.style.opacity = '1';\n    }, 200);\n    quickfixPlaceholderElement.textContent = nls.localize('checkingForQuickFixes', \"Checking for quick fixes...\");\n    disposables.add(toDisposable(function () {\n      return quickfixPlaceholderElement.remove();\n    }));\n    var codeActionsPromise = this.getCodeActions(markerHover.marker);\n    disposables.add(toDisposable(function () {\n      return codeActionsPromise.cancel();\n    }));\n    codeActionsPromise.then(function (actions) {\n      quickfixPlaceholderElement.style.transition = '';\n      quickfixPlaceholderElement.style.opacity = '1';\n\n      if (!actions.actions.length) {\n        actions.dispose();\n        quickfixPlaceholderElement.textContent = nls.localize('noQuickFixes', \"No quick fixes available\");\n        return;\n      }\n\n      quickfixPlaceholderElement.remove();\n      var showing = false;\n      disposables.add(toDisposable(function () {\n        if (!showing) {\n          actions.dispose();\n        }\n      }));\n      disposables.add(_this.renderAction(actionsElement, {\n        label: nls.localize('quick fixes', \"Quick Fix...\"),\n        commandId: QuickFixAction.Id,\n        run: function (target) {\n          showing = true;\n          var controller = QuickFixController.get(_this._editor);\n          var elementPosition = dom.getDomNodePagePosition(target);\n          controller.showCodeActions(actions, {\n            x: elementPosition.left + 6,\n            y: elementPosition.top + elementPosition.height + 6\n          });\n        }\n      }));\n    });\n    this.renderDisposable.value = disposables;\n    return hoverElement;\n  };\n\n  ModesContentHoverWidget.prototype.getCodeActions = function (marker) {\n    var _this = this;\n\n    return createCancelablePromise(function (cancellationToken) {\n      return getCodeActions(_this._editor.getModel(), new Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn), {\n        type: 'manual',\n        filter: {\n          kind: CodeActionKind.QuickFix\n        }\n      }, cancellationToken);\n    });\n  };\n\n  ModesContentHoverWidget.prototype.renderAction = function (parent, actionOptions) {\n    var actionContainer = dom.append(parent, $('div.action-container'));\n    var action = dom.append(actionContainer, $('a.action'));\n\n    if (actionOptions.iconClass) {\n      dom.append(action, $(\"span.icon.\" + actionOptions.iconClass));\n    }\n\n    var label = dom.append(action, $('span'));\n    label.textContent = actionOptions.label;\n\n    var keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);\n\n    if (keybinding) {\n      label.title = actionOptions.label + \" (\" + keybinding.getLabel() + \")\";\n    }\n\n    return dom.addDisposableListener(actionContainer, dom.EventType.CLICK, function (e) {\n      e.stopPropagation();\n      e.preventDefault();\n      actionOptions.run(actionContainer);\n    });\n  };\n\n  ModesContentHoverWidget.ID = 'editor.contrib.modesContentHoverWidget';\n  ModesContentHoverWidget._DECORATION_OPTIONS = ModelDecorationOptions.register({\n    className: 'hoverHighlight'\n  });\n  return ModesContentHoverWidget;\n}(ContentHoverWidget);\n\nexport { ModesContentHoverWidget };\n\nfunction hoverContentsEquals(first, second) {\n  if (!first && second || first && !second || first.length !== second.length) {\n    return false;\n  }\n\n  for (var i = 0; i < first.length; i++) {\n    var firstElement = first[i];\n    var secondElement = second[i];\n\n    if (firstElement instanceof MarkerHover && secondElement instanceof MarkerHover) {\n      return IMarkerData.makeKey(firstElement.marker) === IMarkerData.makeKey(secondElement.marker);\n    }\n\n    if (firstElement instanceof ColorHover || secondElement instanceof ColorHover) {\n      return false;\n    }\n\n    if (firstElement instanceof MarkerHover || secondElement instanceof MarkerHover) {\n      return false;\n    }\n\n    if (!markedStringsEquals(firstElement.contents, secondElement.contents)) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":null,"metadata":{},"sourceType":"module"}