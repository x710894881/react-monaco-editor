{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { createStringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\n\nvar LinePart =\n/** @class */\nfunction () {\n  function LinePart(endIndex, type) {\n    this.endIndex = endIndex;\n    this.type = type;\n  }\n\n  return LinePart;\n}();\n\nvar LineRange =\n/** @class */\nfunction () {\n  function LineRange(startIndex, endIndex) {\n    this.startOffset = startIndex;\n    this.endOffset = endIndex;\n  }\n\n  LineRange.prototype.equals = function (otherLineRange) {\n    return this.startOffset === otherLineRange.startOffset && this.endOffset === otherLineRange.endOffset;\n  };\n\n  return LineRange;\n}();\n\nexport { LineRange };\n\nvar RenderLineInput =\n/** @class */\nfunction () {\n  function RenderLineInput(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, spaceWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n    this.useMonospaceOptimizations = useMonospaceOptimizations;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.continuesWithWrappedLine = continuesWithWrappedLine;\n    this.isBasicASCII = isBasicASCII;\n    this.containsRTL = containsRTL;\n    this.fauxIndentLength = fauxIndentLength;\n    this.lineTokens = lineTokens;\n    this.lineDecorations = lineDecorations;\n    this.tabSize = tabSize;\n    this.spaceWidth = spaceWidth;\n    this.stopRenderingLineAfter = stopRenderingLineAfter;\n    this.renderWhitespace = renderWhitespace === 'all' ? 3\n    /* All */\n    : renderWhitespace === 'boundary' ? 1\n    /* Boundary */\n    : renderWhitespace === 'selection' ? 2\n    /* Selection */\n    : 0\n    /* None */\n    ;\n    this.renderControlCharacters = renderControlCharacters;\n    this.fontLigatures = fontLigatures;\n    this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort(function (a, b) {\n      return a.startOffset < b.startOffset ? -1 : 1;\n    });\n  }\n\n  RenderLineInput.prototype.sameSelection = function (otherSelections) {\n    if (this.selectionsOnLine === null) {\n      return otherSelections === null;\n    }\n\n    if (otherSelections === null) {\n      return false;\n    }\n\n    if (otherSelections.length !== this.selectionsOnLine.length) {\n      return false;\n    }\n\n    for (var i = 0; i < this.selectionsOnLine.length; i++) {\n      if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  RenderLineInput.prototype.equals = function (other) {\n    return this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineContent === other.lineContent && this.continuesWithWrappedLine === other.continuesWithWrappedLine && this.isBasicASCII === other.isBasicASCII && this.containsRTL === other.containsRTL && this.fauxIndentLength === other.fauxIndentLength && this.tabSize === other.tabSize && this.spaceWidth === other.spaceWidth && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.fontLigatures === other.fontLigatures && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations) && this.lineTokens.equals(other.lineTokens) && this.sameSelection(other.selectionsOnLine);\n  };\n\n  return RenderLineInput;\n}();\n\nexport { RenderLineInput };\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\n\nvar CharacterMapping =\n/** @class */\nfunction () {\n  function CharacterMapping(length, partCount) {\n    this.length = length;\n    this._data = new Uint32Array(this.length);\n    this._absoluteOffsets = new Uint32Array(this.length);\n  }\n\n  CharacterMapping.getPartIndex = function (partData) {\n    return (partData & 4294901760\n    /* PART_INDEX_MASK */\n    ) >>> 16\n    /* PART_INDEX_OFFSET */\n    ;\n  };\n\n  CharacterMapping.getCharIndex = function (partData) {\n    return (partData & 65535\n    /* CHAR_INDEX_MASK */\n    ) >>> 0\n    /* CHAR_INDEX_OFFSET */\n    ;\n  };\n\n  CharacterMapping.prototype.setPartData = function (charOffset, partIndex, charIndex, partAbsoluteOffset) {\n    var partData = (partIndex << 16\n    /* PART_INDEX_OFFSET */\n    | charIndex << 0\n    /* CHAR_INDEX_OFFSET */\n    ) >>> 0;\n    this._data[charOffset] = partData;\n    this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\n  };\n\n  CharacterMapping.prototype.getAbsoluteOffsets = function () {\n    return this._absoluteOffsets;\n  };\n\n  CharacterMapping.prototype.charOffsetToPartData = function (charOffset) {\n    if (this.length === 0) {\n      return 0;\n    }\n\n    if (charOffset < 0) {\n      return this._data[0];\n    }\n\n    if (charOffset >= this.length) {\n      return this._data[this.length - 1];\n    }\n\n    return this._data[charOffset];\n  };\n\n  CharacterMapping.prototype.partDataToCharOffset = function (partIndex, partLength, charIndex) {\n    if (this.length === 0) {\n      return 0;\n    }\n\n    var searchEntry = (partIndex << 16\n    /* PART_INDEX_OFFSET */\n    | charIndex << 0\n    /* CHAR_INDEX_OFFSET */\n    ) >>> 0;\n    var min = 0;\n    var max = this.length - 1;\n\n    while (min + 1 < max) {\n      var mid = min + max >>> 1;\n      var midEntry = this._data[mid];\n\n      if (midEntry === searchEntry) {\n        return mid;\n      } else if (midEntry > searchEntry) {\n        max = mid;\n      } else {\n        min = mid;\n      }\n    }\n\n    if (min === max) {\n      return min;\n    }\n\n    var minEntry = this._data[min];\n    var maxEntry = this._data[max];\n\n    if (minEntry === searchEntry) {\n      return min;\n    }\n\n    if (maxEntry === searchEntry) {\n      return max;\n    }\n\n    var minPartIndex = CharacterMapping.getPartIndex(minEntry);\n    var minCharIndex = CharacterMapping.getCharIndex(minEntry);\n    var maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n    var maxCharIndex;\n\n    if (minPartIndex !== maxPartIndex) {\n      // sitting between parts\n      maxCharIndex = partLength;\n    } else {\n      maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n    }\n\n    var minEntryDistance = charIndex - minCharIndex;\n    var maxEntryDistance = maxCharIndex - charIndex;\n\n    if (minEntryDistance <= maxEntryDistance) {\n      return min;\n    }\n\n    return max;\n  };\n\n  return CharacterMapping;\n}();\n\nexport { CharacterMapping };\n\nvar RenderLineOutput =\n/** @class */\nfunction () {\n  function RenderLineOutput(characterMapping, containsRTL, containsForeignElements) {\n    this.characterMapping = characterMapping;\n    this.containsRTL = containsRTL;\n    this.containsForeignElements = containsForeignElements;\n  }\n\n  return RenderLineOutput;\n}();\n\nexport { RenderLineOutput };\nexport function renderViewLine(input, sb) {\n  if (input.lineContent.length === 0) {\n    var containsForeignElements = 0\n    /* None */\n    ; // This is basically for IE's hit test to work\n\n    var content = '<span><span>\\u00a0</span></span>';\n\n    if (input.lineDecorations.length > 0) {\n      // This line is empty, but it contains inline decorations\n      var classNames = [];\n\n      for (var i = 0, len = input.lineDecorations.length; i < len; i++) {\n        var lineDecoration = input.lineDecorations[i];\n\n        if (lineDecoration.type === 1\n        /* Before */\n        ) {\n            classNames.push(input.lineDecorations[i].className);\n            containsForeignElements |= 1\n            /* Before */\n            ;\n          }\n\n        if (lineDecoration.type === 2\n        /* After */\n        ) {\n            classNames.push(input.lineDecorations[i].className);\n            containsForeignElements |= 2\n            /* After */\n            ;\n          }\n      }\n\n      if (containsForeignElements !== 0\n      /* None */\n      ) {\n          content = \"<span><span class=\\\"\" + classNames.join(' ') + \"\\\"></span></span>\";\n        }\n    }\n\n    sb.appendASCIIString(content);\n    return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);\n  }\n\n  return _renderLine(resolveRenderLineInput(input), sb);\n}\n\nvar RenderLineOutput2 =\n/** @class */\nfunction () {\n  function RenderLineOutput2(characterMapping, html, containsRTL, containsForeignElements) {\n    this.characterMapping = characterMapping;\n    this.html = html;\n    this.containsRTL = containsRTL;\n    this.containsForeignElements = containsForeignElements;\n  }\n\n  return RenderLineOutput2;\n}();\n\nexport { RenderLineOutput2 };\nexport function renderViewLine2(input) {\n  var sb = createStringBuilder(10000);\n  var out = renderViewLine(input, sb);\n  return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\n\nvar ResolvedRenderLineInput =\n/** @class */\nfunction () {\n  function ResolvedRenderLineInput(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, tabSize, containsRTL, spaceWidth, renderWhitespace, renderControlCharacters) {\n    this.fontIsMonospace = fontIsMonospace;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.len = len;\n    this.isOverflowing = isOverflowing;\n    this.parts = parts;\n    this.containsForeignElements = containsForeignElements;\n    this.tabSize = tabSize;\n    this.containsRTL = containsRTL;\n    this.spaceWidth = spaceWidth;\n    this.renderWhitespace = renderWhitespace;\n    this.renderControlCharacters = renderControlCharacters; //\n  }\n\n  return ResolvedRenderLineInput;\n}();\n\nfunction resolveRenderLineInput(input) {\n  var useMonospaceOptimizations = input.useMonospaceOptimizations;\n  var lineContent = input.lineContent;\n  var isOverflowing;\n  var len;\n\n  if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n    isOverflowing = true;\n    len = input.stopRenderingLineAfter;\n  } else {\n    isOverflowing = false;\n    len = lineContent.length;\n  }\n\n  var tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n\n  if (input.renderWhitespace === 3\n  /* All */\n  || input.renderWhitespace === 1\n  /* Boundary */\n  || input.renderWhitespace === 2\n  /* Selection */\n  && !!input.selectionsOnLine) {\n    tokens = _applyRenderWhitespace(lineContent, len, input.continuesWithWrappedLine, tokens, input.fauxIndentLength, input.tabSize, useMonospaceOptimizations, input.selectionsOnLine, input.renderWhitespace === 1\n    /* Boundary */\n    );\n  }\n\n  var containsForeignElements = 0\n  /* None */\n  ;\n\n  if (input.lineDecorations.length > 0) {\n    for (var i = 0, len_1 = input.lineDecorations.length; i < len_1; i++) {\n      var lineDecoration = input.lineDecorations[i];\n\n      if (lineDecoration.type === 3\n      /* RegularAffectingLetterSpacing */\n      ) {\n          // Pretend there are foreign elements... although not 100% accurate.\n          containsForeignElements |= 1\n          /* Before */\n          ;\n        } else if (lineDecoration.type === 1\n      /* Before */\n      ) {\n          containsForeignElements |= 1\n          /* Before */\n          ;\n        } else if (lineDecoration.type === 2\n      /* After */\n      ) {\n          containsForeignElements |= 2\n          /* After */\n          ;\n        }\n    }\n\n    tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n  }\n\n  if (!input.containsRTL) {\n    // We can never split RTL text, as it ruins the rendering\n    tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n  }\n\n  return new ResolvedRenderLineInput(useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.tabSize, input.containsRTL, input.spaceWidth, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\n\n\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\n  var result = [],\n      resultLen = 0; // The faux indent part of the line should have no token type\n\n  if (fauxIndentLength > 0) {\n    result[resultLen++] = new LinePart(fauxIndentLength, '');\n  }\n\n  for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n    var endIndex = tokens.getEndOffset(tokenIndex);\n\n    if (endIndex <= fauxIndentLength) {\n      // The faux indent part of the line should have no token type\n      continue;\n    }\n\n    var type = tokens.getClassName(tokenIndex);\n\n    if (endIndex >= len) {\n      result[resultLen++] = new LinePart(len, type);\n      break;\n    }\n\n    result[resultLen++] = new LinePart(endIndex, type);\n  }\n\n  return result;\n}\n/**\n * See https://github.com/Microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\n\n\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n  var lastTokenEndIndex = 0;\n  var result = [],\n      resultLen = 0;\n\n  if (onlyAtSpaces) {\n    // Split only at spaces => we need to walk each character\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      var token = tokens[i];\n      var tokenEndIndex = token.endIndex;\n\n      if (lastTokenEndIndex + 50\n      /* LongToken */\n      < tokenEndIndex) {\n        var tokenType = token.type;\n        var lastSpaceOffset = -1;\n        var currTokenStart = lastTokenEndIndex;\n\n        for (var j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n          if (lineContent.charCodeAt(j) === 32\n          /* Space */\n          ) {\n              lastSpaceOffset = j;\n            }\n\n          if (lastSpaceOffset !== -1 && j - currTokenStart >= 50\n          /* LongToken */\n          ) {\n              // Split at `lastSpaceOffset` + 1\n              result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType);\n              currTokenStart = lastSpaceOffset + 1;\n              lastSpaceOffset = -1;\n            }\n        }\n\n        if (currTokenStart !== tokenEndIndex) {\n          result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\n        }\n      } else {\n        result[resultLen++] = token;\n      }\n\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  } else {\n    // Split anywhere => we don't need to walk each character\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      var token = tokens[i];\n      var tokenEndIndex = token.endIndex;\n      var diff = tokenEndIndex - lastTokenEndIndex;\n\n      if (diff > 50\n      /* LongToken */\n      ) {\n          var tokenType = token.type;\n          var piecesCount = Math.ceil(diff / 50\n          /* LongToken */\n          );\n\n          for (var j = 1; j < piecesCount; j++) {\n            var pieceEndIndex = lastTokenEndIndex + j * 50\n            /* LongToken */\n            ;\n            result[resultLen++] = new LinePart(pieceEndIndex, tokenType);\n          }\n\n          result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\n        } else {\n        result[resultLen++] = token;\n      }\n\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  }\n\n  return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `vs-whitespace` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\n\n\nfunction _applyRenderWhitespace(lineContent, len, continuesWithWrappedLine, tokens, fauxIndentLength, tabSize, useMonospaceOptimizations, selections, onlyBoundary) {\n  var result = [],\n      resultLen = 0;\n  var tokenIndex = 0;\n  var tokenType = tokens[tokenIndex].type;\n  var tokenEndIndex = tokens[tokenIndex].endIndex;\n  var tokensLength = tokens.length;\n  var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n  var lastNonWhitespaceIndex;\n\n  if (firstNonWhitespaceIndex === -1) {\n    // The entire line is whitespace\n    firstNonWhitespaceIndex = len;\n    lastNonWhitespaceIndex = len;\n  } else {\n    lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n  }\n\n  var tmpIndent = 0;\n\n  for (var charIndex = 0; charIndex < fauxIndentLength; charIndex++) {\n    var chCode = lineContent.charCodeAt(charIndex);\n\n    if (chCode === 9\n    /* Tab */\n    ) {\n        tmpIndent = tabSize;\n      } else if (strings.isFullWidthCharacter(chCode)) {\n      tmpIndent += 2;\n    } else {\n      tmpIndent++;\n    }\n  }\n\n  tmpIndent = tmpIndent % tabSize;\n  var wasInWhitespace = false;\n  var currentSelectionIndex = 0;\n  var currentSelection = selections && selections[currentSelectionIndex];\n\n  for (var charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n    var chCode = lineContent.charCodeAt(charIndex);\n\n    if (currentSelection && charIndex >= currentSelection.endOffset) {\n      currentSelectionIndex++;\n      currentSelection = selections && selections[currentSelectionIndex];\n    }\n\n    var isInWhitespace = void 0;\n\n    if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n      // in leading or trailing whitespace\n      isInWhitespace = true;\n    } else if (chCode === 9\n    /* Tab */\n    ) {\n        // a tab character is rendered both in all and boundary cases\n        isInWhitespace = true;\n      } else if (chCode === 32\n    /* Space */\n    ) {\n        // hit a space character\n        if (onlyBoundary) {\n          // rendering only boundary whitespace\n          if (wasInWhitespace) {\n            isInWhitespace = true;\n          } else {\n            var nextChCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0\n            /* Null */\n            ;\n            isInWhitespace = nextChCode === 32\n            /* Space */\n            || nextChCode === 9\n            /* Tab */\n            ;\n          }\n        } else {\n          isInWhitespace = true;\n        }\n      } else {\n      isInWhitespace = false;\n    } // If rendering whitespace on selection, check that the charIndex falls within a selection\n\n\n    if (isInWhitespace && selections) {\n      isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n    }\n\n    if (wasInWhitespace) {\n      // was in whitespace token\n      if (!isInWhitespace || !useMonospaceOptimizations && tmpIndent >= tabSize) {\n        // leaving whitespace token or entering a new indent\n        result[resultLen++] = new LinePart(charIndex, 'vs-whitespace');\n        tmpIndent = tmpIndent % tabSize;\n      }\n    } else {\n      // was in regular token\n      if (charIndex === tokenEndIndex || isInWhitespace && charIndex > fauxIndentLength) {\n        result[resultLen++] = new LinePart(charIndex, tokenType);\n        tmpIndent = tmpIndent % tabSize;\n      }\n    }\n\n    if (chCode === 9\n    /* Tab */\n    ) {\n        tmpIndent = tabSize;\n      } else if (strings.isFullWidthCharacter(chCode)) {\n      tmpIndent += 2;\n    } else {\n      tmpIndent++;\n    }\n\n    wasInWhitespace = isInWhitespace;\n\n    if (charIndex === tokenEndIndex) {\n      tokenIndex++;\n\n      if (tokenIndex < tokensLength) {\n        tokenType = tokens[tokenIndex].type;\n        tokenEndIndex = tokens[tokenIndex].endIndex;\n      }\n    }\n  }\n\n  var generateWhitespace = false;\n\n  if (wasInWhitespace) {\n    // was in whitespace token\n    if (continuesWithWrappedLine && onlyBoundary) {\n      var lastCharCode = len > 0 ? lineContent.charCodeAt(len - 1) : 0\n      /* Null */\n      ;\n      var prevCharCode = len > 1 ? lineContent.charCodeAt(len - 2) : 0\n      /* Null */\n      ;\n      var isSingleTrailingSpace = lastCharCode === 32\n      /* Space */\n      && prevCharCode !== 32\n      /* Space */\n      && prevCharCode !== 9\n      /* Tab */\n      ;\n\n      if (!isSingleTrailingSpace) {\n        generateWhitespace = true;\n      }\n    } else {\n      generateWhitespace = true;\n    }\n  }\n\n  result[resultLen++] = new LinePart(len, generateWhitespace ? 'vs-whitespace' : tokenType);\n  return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\n\n\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n  _lineDecorations.sort(LineDecoration.compare);\n\n  var lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n  var lineDecorationsLen = lineDecorations.length;\n  var lineDecorationIndex = 0;\n  var result = [],\n      resultLen = 0,\n      lastResultEndIndex = 0;\n\n  for (var tokenIndex = 0, len_2 = tokens.length; tokenIndex < len_2; tokenIndex++) {\n    var token = tokens[tokenIndex];\n    var tokenEndIndex = token.endIndex;\n    var tokenType = token.type;\n\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n      var lineDecoration = lineDecorations[lineDecorationIndex];\n\n      if (lineDecoration.startOffset > lastResultEndIndex) {\n        lastResultEndIndex = lineDecoration.startOffset;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\n      }\n\n      if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n        // This line decoration ends before this token ends\n        lastResultEndIndex = lineDecoration.endOffset + 1;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\n        lineDecorationIndex++;\n      } else {\n        // This line decoration continues on to the next token\n        lastResultEndIndex = tokenEndIndex;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\n        break;\n      }\n    }\n\n    if (tokenEndIndex > lastResultEndIndex) {\n      lastResultEndIndex = tokenEndIndex;\n      result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\n    }\n  }\n\n  var lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n\n  if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n    var classNames = [];\n\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n      classNames.push(lineDecorations[lineDecorationIndex].className);\n      lineDecorationIndex++;\n    }\n\n    result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '));\n  }\n\n  return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\n\n\nfunction _renderLine(input, sb) {\n  var fontIsMonospace = input.fontIsMonospace;\n  var canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n  var containsForeignElements = input.containsForeignElements;\n  var lineContent = input.lineContent;\n  var len = input.len;\n  var isOverflowing = input.isOverflowing;\n  var parts = input.parts;\n  var tabSize = input.tabSize;\n  var containsRTL = input.containsRTL;\n  var spaceWidth = input.spaceWidth;\n  var renderWhitespace = input.renderWhitespace;\n  var renderControlCharacters = input.renderControlCharacters;\n  var characterMapping = new CharacterMapping(len + 1, parts.length);\n  var charIndex = 0;\n  var tabsCharDelta = 0;\n  var charOffsetInPart = 0;\n  var prevPartContentCnt = 0;\n  var partAbsoluteOffset = 0;\n  sb.appendASCIIString('<span>');\n\n  for (var partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n    partAbsoluteOffset += prevPartContentCnt;\n    var part = parts[partIndex];\n    var partEndIndex = part.endIndex;\n    var partType = part.type;\n    var partRendersWhitespace = renderWhitespace !== 0\n    /* None */\n    && partType.indexOf('vs-whitespace') >= 0;\n    charOffsetInPart = 0;\n    sb.appendASCIIString('<span class=\"');\n    sb.appendASCIIString(partType);\n    sb.appendASCII(34\n    /* DoubleQuote */\n    );\n\n    if (partRendersWhitespace) {\n      var partContentCnt = 0;\n      {\n        var _charIndex = charIndex;\n        var _tabsCharDelta = tabsCharDelta;\n\n        for (; _charIndex < partEndIndex; _charIndex++) {\n          var charCode = lineContent.charCodeAt(_charIndex);\n\n          if (charCode === 9\n          /* Tab */\n          ) {\n              var insertSpacesCount = tabSize - (_charIndex + _tabsCharDelta) % tabSize;\n              _tabsCharDelta += insertSpacesCount - 1;\n              partContentCnt += insertSpacesCount;\n            } else {\n            // must be CharCode.Space\n            partContentCnt++;\n          }\n        }\n      }\n\n      if (!fontIsMonospace) {\n        var partIsOnlyWhitespace = partType === 'vs-whitespace';\n\n        if (partIsOnlyWhitespace || !containsForeignElements) {\n          sb.appendASCIIString(' style=\"width:');\n          sb.appendASCIIString(String(spaceWidth * partContentCnt));\n          sb.appendASCIIString('px\"');\n        }\n      }\n\n      sb.appendASCII(62\n      /* GreaterThan */\n      );\n\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\n        var charCode = lineContent.charCodeAt(charIndex);\n\n        if (charCode === 9\n        /* Tab */\n        ) {\n            var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n            tabsCharDelta += insertSpacesCount - 1;\n            charOffsetInPart += insertSpacesCount - 1;\n\n            if (insertSpacesCount > 0) {\n              if (!canUseHalfwidthRightwardsArrow || insertSpacesCount > 1) {\n                sb.write1(0x2192); // RIGHTWARDS ARROW\n              } else {\n                sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n              }\n\n              insertSpacesCount--;\n            }\n\n            while (insertSpacesCount > 0) {\n              sb.write1(0xA0); // &nbsp;\n\n              insertSpacesCount--;\n            }\n          } else {\n          // must be CharCode.Space\n          sb.write1(0xB7); // &middot;\n        }\n\n        charOffsetInPart++;\n      }\n\n      prevPartContentCnt = partContentCnt;\n    } else {\n      var partContentCnt = 0;\n\n      if (containsRTL) {\n        sb.appendASCIIString(' dir=\"ltr\"');\n      }\n\n      sb.appendASCII(62\n      /* GreaterThan */\n      );\n\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\n        var charCode = lineContent.charCodeAt(charIndex);\n\n        switch (charCode) {\n          case 9\n          /* Tab */\n          :\n            var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n            tabsCharDelta += insertSpacesCount - 1;\n            charOffsetInPart += insertSpacesCount - 1;\n\n            while (insertSpacesCount > 0) {\n              sb.write1(0xA0); // &nbsp;\n\n              partContentCnt++;\n              insertSpacesCount--;\n            }\n\n            break;\n\n          case 32\n          /* Space */\n          :\n            sb.write1(0xA0); // &nbsp;\n\n            partContentCnt++;\n            break;\n\n          case 60\n          /* LessThan */\n          :\n            sb.appendASCIIString('&lt;');\n            partContentCnt++;\n            break;\n\n          case 62\n          /* GreaterThan */\n          :\n            sb.appendASCIIString('&gt;');\n            partContentCnt++;\n            break;\n\n          case 38\n          /* Ampersand */\n          :\n            sb.appendASCIIString('&amp;');\n            partContentCnt++;\n            break;\n\n          case 0\n          /* Null */\n          :\n            sb.appendASCIIString('&#00;');\n            partContentCnt++;\n            break;\n\n          case 65279\n          /* UTF8_BOM */\n          :\n          case 8232\n          /* LINE_SEPARATOR_2028 */\n          :\n            sb.write1(0xFFFD);\n            partContentCnt++;\n            break;\n\n          default:\n            if (strings.isFullWidthCharacter(charCode)) {\n              tabsCharDelta++;\n            }\n\n            if (renderControlCharacters && charCode < 32) {\n              sb.write1(9216 + charCode);\n              partContentCnt++;\n            } else {\n              sb.write1(charCode);\n              partContentCnt++;\n            }\n\n        }\n\n        charOffsetInPart++;\n      }\n\n      prevPartContentCnt = partContentCnt;\n    }\n\n    sb.appendASCIIString('</span>');\n  } // When getting client rects for the last character, we will position the\n  // text range at the end of the span, insteaf of at the beginning of next span\n\n\n  characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n\n  if (isOverflowing) {\n    sb.appendASCIIString('<span>&hellip;</span>');\n  }\n\n  sb.appendASCIIString('</span>');\n  return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}","map":null,"metadata":{},"sourceType":"module"}