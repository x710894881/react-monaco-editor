{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport * as arrays from '../common/arrays.js';\nimport { Disposable } from '../common/lifecycle.js';\nimport * as DomUtils from './dom.js';\nimport { memoize } from '../common/decorators.js';\nexport var EventType;\n\n(function (EventType) {\n  EventType.Tap = '-monaco-gesturetap';\n  EventType.Change = '-monaco-gesturechange';\n  EventType.Start = '-monaco-gesturestart';\n  EventType.End = '-monaco-gesturesend';\n  EventType.Contextmenu = '-monaco-gesturecontextmenu';\n})(EventType || (EventType = {}));\n\nvar Gesture =\n/** @class */\nfunction (_super) {\n  __extends(Gesture, _super);\n\n  function Gesture() {\n    var _this = _super.call(this) || this;\n\n    _this.dispatched = false;\n    _this.activeTouches = {};\n    _this.handle = null;\n    _this.targets = [];\n\n    _this._register(DomUtils.addDisposableListener(document, 'touchstart', function (e) {\n      return _this.onTouchStart(e);\n    }));\n\n    _this._register(DomUtils.addDisposableListener(document, 'touchend', function (e) {\n      return _this.onTouchEnd(e);\n    }));\n\n    _this._register(DomUtils.addDisposableListener(document, 'touchmove', function (e) {\n      return _this.onTouchMove(e);\n    }));\n\n    return _this;\n  }\n\n  Gesture.addTarget = function (element) {\n    if (!Gesture.isTouchDevice()) {\n      return;\n    }\n\n    if (!Gesture.INSTANCE) {\n      Gesture.INSTANCE = new Gesture();\n    }\n\n    Gesture.INSTANCE.targets.push(element);\n  };\n\n  Gesture.isTouchDevice = function () {\n    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0;\n  };\n\n  Gesture.prototype.dispose = function () {\n    if (this.handle) {\n      this.handle.dispose();\n      this.handle = null;\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n\n  Gesture.prototype.onTouchStart = function (e) {\n    var timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n    if (this.handle) {\n      this.handle.dispose();\n      this.handle = null;\n    }\n\n    for (var i = 0, len = e.targetTouches.length; i < len; i++) {\n      var touch = e.targetTouches.item(i);\n      this.activeTouches[touch.identifier] = {\n        id: touch.identifier,\n        initialTarget: touch.target,\n        initialTimeStamp: timestamp,\n        initialPageX: touch.pageX,\n        initialPageY: touch.pageY,\n        rollingTimestamps: [timestamp],\n        rollingPageX: [touch.pageX],\n        rollingPageY: [touch.pageY]\n      };\n      var evt = this.newGestureEvent(EventType.Start, touch.target);\n      evt.pageX = touch.pageX;\n      evt.pageY = touch.pageY;\n      this.dispatchEvent(evt);\n    }\n\n    if (this.dispatched) {\n      e.preventDefault();\n      e.stopPropagation();\n      this.dispatched = false;\n    }\n  };\n\n  Gesture.prototype.onTouchEnd = function (e) {\n    var timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n    var activeTouchCount = Object.keys(this.activeTouches).length;\n\n    var _loop_1 = function (i, len) {\n      var touch = e.changedTouches.item(i);\n\n      if (!this_1.activeTouches.hasOwnProperty(String(touch.identifier))) {\n        console.warn('move of an UNKNOWN touch', touch);\n        return \"continue\";\n      }\n\n      var data = this_1.activeTouches[touch.identifier],\n          holdTime = Date.now() - data.initialTimeStamp;\n\n      if (holdTime < Gesture.HOLD_DELAY && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {\n        var evt = this_1.newGestureEvent(EventType.Tap, data.initialTarget);\n        evt.pageX = arrays.tail(data.rollingPageX);\n        evt.pageY = arrays.tail(data.rollingPageY);\n        this_1.dispatchEvent(evt);\n      } else if (holdTime >= Gesture.HOLD_DELAY && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30 && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {\n        var evt = this_1.newGestureEvent(EventType.Contextmenu, data.initialTarget);\n        evt.pageX = arrays.tail(data.rollingPageX);\n        evt.pageY = arrays.tail(data.rollingPageY);\n        this_1.dispatchEvent(evt);\n      } else if (activeTouchCount === 1) {\n        var finalX = arrays.tail(data.rollingPageX);\n        var finalY = arrays.tail(data.rollingPageY);\n        var deltaT = arrays.tail(data.rollingTimestamps) - data.rollingTimestamps[0];\n        var deltaX = finalX - data.rollingPageX[0];\n        var deltaY = finalY - data.rollingPageY[0]; // We need to get all the dispatch targets on the start of the inertia event\n\n        var dispatchTo = this_1.targets.filter(function (t) {\n          return data.initialTarget instanceof Node && t.contains(data.initialTarget);\n        });\n        this_1.inertia(dispatchTo, timestamp, // time now\n        Math.abs(deltaX) / deltaT, // speed\n        deltaX > 0 ? 1 : -1, // x direction\n        finalX, // x now\n        Math.abs(deltaY) / deltaT, // y speed\n        deltaY > 0 ? 1 : -1, // y direction\n        finalY // y now\n        );\n      }\n\n      this_1.dispatchEvent(this_1.newGestureEvent(EventType.End, data.initialTarget)); // forget about this touch\n\n      delete this_1.activeTouches[touch.identifier];\n    };\n\n    var this_1 = this;\n\n    for (var i = 0, len = e.changedTouches.length; i < len; i++) {\n      _loop_1(i, len);\n    }\n\n    if (this.dispatched) {\n      e.preventDefault();\n      e.stopPropagation();\n      this.dispatched = false;\n    }\n  };\n\n  Gesture.prototype.newGestureEvent = function (type, initialTarget) {\n    var event = document.createEvent('CustomEvent');\n    event.initEvent(type, false, true);\n    event.initialTarget = initialTarget;\n    return event;\n  };\n\n  Gesture.prototype.dispatchEvent = function (event) {\n    var _this = this;\n\n    this.targets.forEach(function (target) {\n      if (event.initialTarget instanceof Node && target.contains(event.initialTarget)) {\n        target.dispatchEvent(event);\n        _this.dispatched = true;\n      }\n    });\n  };\n\n  Gesture.prototype.inertia = function (dispatchTo, t1, vX, dirX, x, vY, dirY, y) {\n    var _this = this;\n\n    this.handle = DomUtils.scheduleAtNextAnimationFrame(function () {\n      var now = Date.now(); // velocity: old speed + accel_over_time\n\n      var deltaT = now - t1,\n          delta_pos_x = 0,\n          delta_pos_y = 0,\n          stopped = true;\n      vX += Gesture.SCROLL_FRICTION * deltaT;\n      vY += Gesture.SCROLL_FRICTION * deltaT;\n\n      if (vX > 0) {\n        stopped = false;\n        delta_pos_x = dirX * vX * deltaT;\n      }\n\n      if (vY > 0) {\n        stopped = false;\n        delta_pos_y = dirY * vY * deltaT;\n      } // dispatch translation event\n\n\n      var evt = _this.newGestureEvent(EventType.Change);\n\n      evt.translationX = delta_pos_x;\n      evt.translationY = delta_pos_y;\n      dispatchTo.forEach(function (d) {\n        return d.dispatchEvent(evt);\n      });\n\n      if (!stopped) {\n        _this.inertia(dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);\n      }\n    });\n  };\n\n  Gesture.prototype.onTouchMove = function (e) {\n    var timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n    for (var i = 0, len = e.changedTouches.length; i < len; i++) {\n      var touch = e.changedTouches.item(i);\n\n      if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n        console.warn('end of an UNKNOWN touch', touch);\n        continue;\n      }\n\n      var data = this.activeTouches[touch.identifier];\n      var evt = this.newGestureEvent(EventType.Change, data.initialTarget);\n      evt.translationX = touch.pageX - arrays.tail(data.rollingPageX);\n      evt.translationY = touch.pageY - arrays.tail(data.rollingPageY);\n      evt.pageX = touch.pageX;\n      evt.pageY = touch.pageY;\n      this.dispatchEvent(evt); // only keep a few data points, to average the final speed\n\n      if (data.rollingPageX.length > 3) {\n        data.rollingPageX.shift();\n        data.rollingPageY.shift();\n        data.rollingTimestamps.shift();\n      }\n\n      data.rollingPageX.push(touch.pageX);\n      data.rollingPageY.push(touch.pageY);\n      data.rollingTimestamps.push(timestamp);\n    }\n\n    if (this.dispatched) {\n      e.preventDefault();\n      e.stopPropagation();\n      this.dispatched = false;\n    }\n  };\n\n  Gesture.SCROLL_FRICTION = -0.005;\n  Gesture.HOLD_DELAY = 700;\n\n  __decorate([memoize], Gesture, \"isTouchDevice\", null);\n\n  return Gesture;\n}(Disposable);\n\nexport { Gesture };","map":null,"metadata":{},"sourceType":"module"}