{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as browser from '../../../base/browser/browser.js';\nimport { PageCoordinates } from '../editorDom.js';\nimport { PartFingerprints } from '../view/viewPart.js';\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range as EditorRange } from '../../common/core/range.js';\nimport { CursorColumns } from '../../common/controller/cursorCommon.js';\n\nvar MouseTarget =\n/** @class */\nfunction () {\n  function MouseTarget(element, type, mouseColumn, position, range, detail) {\n    if (mouseColumn === void 0) {\n      mouseColumn = 0;\n    }\n\n    if (position === void 0) {\n      position = null;\n    }\n\n    if (range === void 0) {\n      range = null;\n    }\n\n    if (detail === void 0) {\n      detail = null;\n    }\n\n    this.element = element;\n    this.type = type;\n    this.mouseColumn = mouseColumn;\n    this.position = position;\n\n    if (!range && position) {\n      range = new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\n    }\n\n    this.range = range;\n    this.detail = detail;\n  }\n\n  MouseTarget._typeToString = function (type) {\n    if (type === 1\n    /* TEXTAREA */\n    ) {\n        return 'TEXTAREA';\n      }\n\n    if (type === 2\n    /* GUTTER_GLYPH_MARGIN */\n    ) {\n        return 'GUTTER_GLYPH_MARGIN';\n      }\n\n    if (type === 3\n    /* GUTTER_LINE_NUMBERS */\n    ) {\n        return 'GUTTER_LINE_NUMBERS';\n      }\n\n    if (type === 4\n    /* GUTTER_LINE_DECORATIONS */\n    ) {\n        return 'GUTTER_LINE_DECORATIONS';\n      }\n\n    if (type === 5\n    /* GUTTER_VIEW_ZONE */\n    ) {\n        return 'GUTTER_VIEW_ZONE';\n      }\n\n    if (type === 6\n    /* CONTENT_TEXT */\n    ) {\n        return 'CONTENT_TEXT';\n      }\n\n    if (type === 7\n    /* CONTENT_EMPTY */\n    ) {\n        return 'CONTENT_EMPTY';\n      }\n\n    if (type === 8\n    /* CONTENT_VIEW_ZONE */\n    ) {\n        return 'CONTENT_VIEW_ZONE';\n      }\n\n    if (type === 9\n    /* CONTENT_WIDGET */\n    ) {\n        return 'CONTENT_WIDGET';\n      }\n\n    if (type === 10\n    /* OVERVIEW_RULER */\n    ) {\n        return 'OVERVIEW_RULER';\n      }\n\n    if (type === 11\n    /* SCROLLBAR */\n    ) {\n        return 'SCROLLBAR';\n      }\n\n    if (type === 12\n    /* OVERLAY_WIDGET */\n    ) {\n        return 'OVERLAY_WIDGET';\n      }\n\n    return 'UNKNOWN';\n  };\n\n  MouseTarget.toString = function (target) {\n    return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + target.detail;\n  };\n\n  MouseTarget.prototype.toString = function () {\n    return MouseTarget.toString(this);\n  };\n\n  return MouseTarget;\n}();\n\nexport { MouseTarget };\n\nvar ElementPath =\n/** @class */\nfunction () {\n  function ElementPath() {}\n\n  ElementPath.isTextArea = function (path) {\n    return path.length === 2 && path[0] === 3\n    /* OverflowGuard */\n    && path[1] === 6\n    /* TextArea */\n    ;\n  };\n\n  ElementPath.isChildOfViewLines = function (path) {\n    return path.length >= 4 && path[0] === 3\n    /* OverflowGuard */\n    && path[3] === 7\n    /* ViewLines */\n    ;\n  };\n\n  ElementPath.isStrictChildOfViewLines = function (path) {\n    return path.length > 4 && path[0] === 3\n    /* OverflowGuard */\n    && path[3] === 7\n    /* ViewLines */\n    ;\n  };\n\n  ElementPath.isChildOfScrollableElement = function (path) {\n    return path.length >= 2 && path[0] === 3\n    /* OverflowGuard */\n    && path[1] === 5\n    /* ScrollableElement */\n    ;\n  };\n\n  ElementPath.isChildOfMinimap = function (path) {\n    return path.length >= 2 && path[0] === 3\n    /* OverflowGuard */\n    && path[1] === 8\n    /* Minimap */\n    ;\n  };\n\n  ElementPath.isChildOfContentWidgets = function (path) {\n    return path.length >= 4 && path[0] === 3\n    /* OverflowGuard */\n    && path[3] === 1\n    /* ContentWidgets */\n    ;\n  };\n\n  ElementPath.isChildOfOverflowingContentWidgets = function (path) {\n    return path.length >= 1 && path[0] === 2\n    /* OverflowingContentWidgets */\n    ;\n  };\n\n  ElementPath.isChildOfOverlayWidgets = function (path) {\n    return path.length >= 2 && path[0] === 3\n    /* OverflowGuard */\n    && path[1] === 4\n    /* OverlayWidgets */\n    ;\n  };\n\n  return ElementPath;\n}();\n\nvar HitTestContext =\n/** @class */\nfunction () {\n  function HitTestContext(context, viewHelper, lastViewCursorsRenderData) {\n    this.model = context.model;\n    this.layoutInfo = context.configuration.editor.layoutInfo;\n    this.viewDomNode = viewHelper.viewDomNode;\n    this.lineHeight = context.configuration.editor.lineHeight;\n    this.typicalHalfwidthCharacterWidth = context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;\n    this.lastViewCursorsRenderData = lastViewCursorsRenderData;\n    this._context = context;\n    this._viewHelper = viewHelper;\n  }\n\n  HitTestContext.prototype.getZoneAtCoord = function (mouseVerticalOffset) {\n    return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\n  };\n\n  HitTestContext.getZoneAtCoord = function (context, mouseVerticalOffset) {\n    // The target is either a view zone or the empty space after the last view-line\n    var viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\n\n    if (viewZoneWhitespace) {\n      var viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2,\n          lineCount = context.model.getLineCount(),\n          positionBefore = null,\n          position = void 0,\n          positionAfter = null;\n\n      if (viewZoneWhitespace.afterLineNumber !== lineCount) {\n        // There are more lines after this view zone\n        positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\n      }\n\n      if (viewZoneWhitespace.afterLineNumber > 0) {\n        // There are more lines above this view zone\n        positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\n      }\n\n      if (positionAfter === null) {\n        position = positionBefore;\n      } else if (positionBefore === null) {\n        position = positionAfter;\n      } else if (mouseVerticalOffset < viewZoneMiddle) {\n        position = positionBefore;\n      } else {\n        position = positionAfter;\n      }\n\n      return {\n        viewZoneId: viewZoneWhitespace.id,\n        afterLineNumber: viewZoneWhitespace.afterLineNumber,\n        positionBefore: positionBefore,\n        positionAfter: positionAfter,\n        position: position\n      };\n    }\n\n    return null;\n  };\n\n  HitTestContext.prototype.getFullLineRangeAtCoord = function (mouseVerticalOffset) {\n    if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\n      // Below the last line\n      var lineNumber_1 = this._context.model.getLineCount();\n\n      var maxLineColumn_1 = this._context.model.getLineMaxColumn(lineNumber_1);\n\n      return {\n        range: new EditorRange(lineNumber_1, maxLineColumn_1, lineNumber_1, maxLineColumn_1),\n        isAfterLines: true\n      };\n    }\n\n    var lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n\n    var maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\n\n    return {\n      range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\n      isAfterLines: false\n    };\n  };\n\n  HitTestContext.prototype.getLineNumberAtVerticalOffset = function (mouseVerticalOffset) {\n    return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n  };\n\n  HitTestContext.prototype.isAfterLines = function (mouseVerticalOffset) {\n    return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\n  };\n\n  HitTestContext.prototype.getVerticalOffsetForLineNumber = function (lineNumber) {\n    return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n  };\n\n  HitTestContext.prototype.findAttribute = function (element, attr) {\n    return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\n  };\n\n  HitTestContext._findAttribute = function (element, attr, stopAt) {\n    while (element && element !== document.body) {\n      if (element.hasAttribute && element.hasAttribute(attr)) {\n        return element.getAttribute(attr);\n      }\n\n      if (element === stopAt) {\n        return null;\n      }\n\n      element = element.parentNode;\n    }\n\n    return null;\n  };\n\n  HitTestContext.prototype.getLineWidth = function (lineNumber) {\n    return this._viewHelper.getLineWidth(lineNumber);\n  };\n\n  HitTestContext.prototype.visibleRangeForPosition2 = function (lineNumber, column) {\n    return this._viewHelper.visibleRangeForPosition2(lineNumber, column);\n  };\n\n  HitTestContext.prototype.getPositionFromDOMInfo = function (spanNode, offset) {\n    return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\n  };\n\n  HitTestContext.prototype.getCurrentScrollTop = function () {\n    return this._context.viewLayout.getCurrentScrollTop();\n  };\n\n  HitTestContext.prototype.getCurrentScrollLeft = function () {\n    return this._context.viewLayout.getCurrentScrollLeft();\n  };\n\n  return HitTestContext;\n}();\n\nexport { HitTestContext };\n\nvar BareHitTestRequest =\n/** @class */\nfunction () {\n  function BareHitTestRequest(ctx, editorPos, pos) {\n    this.editorPos = editorPos;\n    this.pos = pos;\n    this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + pos.y - editorPos.y);\n    this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + pos.x - editorPos.x - ctx.layoutInfo.contentLeft;\n    this.isInMarginArea = pos.x - editorPos.x < ctx.layoutInfo.contentLeft && pos.x - editorPos.x >= ctx.layoutInfo.glyphMarginLeft;\n    this.isInContentArea = !this.isInMarginArea;\n    this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\n  }\n\n  return BareHitTestRequest;\n}();\n\nvar HitTestRequest =\n/** @class */\nfunction (_super) {\n  __extends(HitTestRequest, _super);\n\n  function HitTestRequest(ctx, editorPos, pos, target) {\n    var _this = _super.call(this, ctx, editorPos, pos) || this;\n\n    _this._ctx = ctx;\n\n    if (target) {\n      _this.target = target;\n      _this.targetPath = PartFingerprints.collect(target, ctx.viewDomNode);\n    } else {\n      _this.target = null;\n      _this.targetPath = new Uint8Array(0);\n    }\n\n    return _this;\n  }\n\n  HitTestRequest.prototype.toString = function () {\n    return \"pos(\" + this.pos.x + \",\" + this.pos.y + \"), editorPos(\" + this.editorPos.x + \",\" + this.editorPos.y + \"), mouseVerticalOffset: \" + this.mouseVerticalOffset + \", mouseContentHorizontalOffset: \" + this.mouseContentHorizontalOffset + \"\\n\\ttarget: \" + (this.target ? this.target.outerHTML : null);\n  };\n\n  HitTestRequest.prototype.fulfill = function (type, position, range, detail) {\n    if (position === void 0) {\n      position = null;\n    }\n\n    if (range === void 0) {\n      range = null;\n    }\n\n    if (detail === void 0) {\n      detail = null;\n    }\n\n    var mouseColumn = this.mouseColumn;\n\n    if (position && position.column < this._ctx.model.getLineMaxColumn(position.lineNumber)) {\n      // Most likely, the line contains foreign decorations...\n      mouseColumn = CursorColumns.visibleColumnFromColumn(this._ctx.model.getLineContent(position.lineNumber), position.column, this._ctx.model.getOptions().tabSize) + 1;\n    }\n\n    return new MouseTarget(this.target, type, mouseColumn, position, range, detail);\n  };\n\n  HitTestRequest.prototype.withTarget = function (target) {\n    return new HitTestRequest(this._ctx, this.editorPos, this.pos, target);\n  };\n\n  return HitTestRequest;\n}(BareHitTestRequest);\n\nvar EMPTY_CONTENT_AFTER_LINES = {\n  isAfterLines: true\n};\n\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\n  return {\n    isAfterLines: false,\n    horizontalDistanceToText: horizontalDistanceToText\n  };\n}\n\nvar MouseTargetFactory =\n/** @class */\nfunction () {\n  function MouseTargetFactory(context, viewHelper) {\n    this._context = context;\n    this._viewHelper = viewHelper;\n  }\n\n  MouseTargetFactory.prototype.mouseTargetIsWidget = function (e) {\n    var t = e.target;\n    var path = PartFingerprints.collect(t, this._viewHelper.viewDomNode); // Is it a content widget?\n\n    if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\n      return true;\n    } // Is it an overlay widget?\n\n\n    if (ElementPath.isChildOfOverlayWidgets(path)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  MouseTargetFactory.prototype.createMouseTarget = function (lastViewCursorsRenderData, editorPos, pos, target) {\n    var ctx = new HitTestContext(this._context, this._viewHelper, lastViewCursorsRenderData);\n    var request = new HitTestRequest(ctx, editorPos, pos, target);\n\n    try {\n      var r = MouseTargetFactory._createMouseTarget(ctx, request, false); // console.log(r.toString());\n\n\n      return r;\n    } catch (err) {\n      // console.log(err);\n      return request.fulfill(0\n      /* UNKNOWN */\n      );\n    }\n  };\n\n  MouseTargetFactory._createMouseTarget = function (ctx, request, domHitTestExecuted) {\n    // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\n    // First ensure the request has a target\n    if (request.target === null) {\n      if (domHitTestExecuted) {\n        // Still no target... and we have already executed hit test...\n        return request.fulfill(0\n        /* UNKNOWN */\n        );\n      }\n\n      var hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n\n      if (hitTestResult.position) {\n        return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);\n      }\n\n      return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n    } // we know for a fact that request.target is not null\n\n\n    var resolvedRequest = request;\n    var result = null;\n    result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest, domHitTestExecuted);\n    result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\n    return result || request.fulfill(0\n    /* UNKNOWN */\n    );\n  };\n\n  MouseTargetFactory._hitTestContentWidget = function (ctx, request) {\n    // Is it a content widget?\n    if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\n      var widgetId = ctx.findAttribute(request.target, 'widgetId');\n\n      if (widgetId) {\n        return request.fulfill(9\n        /* CONTENT_WIDGET */\n        , null, null, widgetId);\n      } else {\n        return request.fulfill(0\n        /* UNKNOWN */\n        );\n      }\n    }\n\n    return null;\n  };\n\n  MouseTargetFactory._hitTestOverlayWidget = function (ctx, request) {\n    // Is it an overlay widget?\n    if (ElementPath.isChildOfOverlayWidgets(request.targetPath)) {\n      var widgetId = ctx.findAttribute(request.target, 'widgetId');\n\n      if (widgetId) {\n        return request.fulfill(12\n        /* OVERLAY_WIDGET */\n        , null, null, widgetId);\n      } else {\n        return request.fulfill(0\n        /* UNKNOWN */\n        );\n      }\n    }\n\n    return null;\n  };\n\n  MouseTargetFactory._hitTestViewCursor = function (ctx, request) {\n    if (request.target) {\n      // Check if we've hit a painted cursor\n      var lastViewCursorsRenderData = ctx.lastViewCursorsRenderData;\n\n      for (var _i = 0, lastViewCursorsRenderData_1 = lastViewCursorsRenderData; _i < lastViewCursorsRenderData_1.length; _i++) {\n        var d = lastViewCursorsRenderData_1[_i];\n\n        if (request.target === d.domNode) {\n          return request.fulfill(6\n          /* CONTENT_TEXT */\n          , d.position);\n        }\n      }\n    }\n\n    if (request.isInContentArea) {\n      // Edge has a bug when hit-testing the exact position of a cursor,\n      // instead of returning the correct dom node, it returns the\n      // first or last rendered view line dom node, therefore help it out\n      // and first check if we are on top of a cursor\n      var lastViewCursorsRenderData = ctx.lastViewCursorsRenderData;\n      var mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\n      var mouseVerticalOffset = request.mouseVerticalOffset;\n\n      for (var _a = 0, lastViewCursorsRenderData_2 = lastViewCursorsRenderData; _a < lastViewCursorsRenderData_2.length; _a++) {\n        var d = lastViewCursorsRenderData_2[_a];\n\n        if (mouseContentHorizontalOffset < d.contentLeft) {\n          // mouse position is to the left of the cursor\n          continue;\n        }\n\n        if (mouseContentHorizontalOffset > d.contentLeft + d.width) {\n          // mouse position is to the right of the cursor\n          continue;\n        }\n\n        var cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);\n\n        if (cursorVerticalOffset <= mouseVerticalOffset && mouseVerticalOffset <= cursorVerticalOffset + d.height) {\n          return request.fulfill(6\n          /* CONTENT_TEXT */\n          , d.position);\n        }\n      }\n    }\n\n    return null;\n  };\n\n  MouseTargetFactory._hitTestViewZone = function (ctx, request) {\n    var viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\n\n    if (viewZoneData) {\n      var mouseTargetType = request.isInContentArea ? 8\n      /* CONTENT_VIEW_ZONE */\n      : 5\n      /* GUTTER_VIEW_ZONE */\n      ;\n      return request.fulfill(mouseTargetType, viewZoneData.position, null, viewZoneData);\n    }\n\n    return null;\n  };\n\n  MouseTargetFactory._hitTestTextArea = function (ctx, request) {\n    // Is it the textarea?\n    if (ElementPath.isTextArea(request.targetPath)) {\n      return request.fulfill(1\n      /* TEXTAREA */\n      );\n    }\n\n    return null;\n  };\n\n  MouseTargetFactory._hitTestMargin = function (ctx, request) {\n    if (request.isInMarginArea) {\n      var res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\n      var pos = res.range.getStartPosition();\n      var offset = Math.abs(request.pos.x - request.editorPos.x);\n      var detail = {\n        isAfterLines: res.isAfterLines,\n        glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\n        glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\n        lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\n        offsetX: offset\n      };\n      offset -= ctx.layoutInfo.glyphMarginLeft;\n\n      if (offset <= ctx.layoutInfo.glyphMarginWidth) {\n        // On the glyph margin\n        return request.fulfill(2\n        /* GUTTER_GLYPH_MARGIN */\n        , pos, res.range, detail);\n      }\n\n      offset -= ctx.layoutInfo.glyphMarginWidth;\n\n      if (offset <= ctx.layoutInfo.lineNumbersWidth) {\n        // On the line numbers\n        return request.fulfill(3\n        /* GUTTER_LINE_NUMBERS */\n        , pos, res.range, detail);\n      }\n\n      offset -= ctx.layoutInfo.lineNumbersWidth; // On the line decorations\n\n      return request.fulfill(4\n      /* GUTTER_LINE_DECORATIONS */\n      , pos, res.range, detail);\n    }\n\n    return null;\n  };\n\n  MouseTargetFactory._hitTestViewLines = function (ctx, request, domHitTestExecuted) {\n    if (!ElementPath.isChildOfViewLines(request.targetPath)) {\n      return null;\n    } // Check if it is below any lines and any view zones\n\n\n    if (ctx.isAfterLines(request.mouseVerticalOffset)) {\n      // This most likely indicates it happened after the last view-line\n      var lineCount = ctx.model.getLineCount();\n      var maxLineColumn = ctx.model.getLineMaxColumn(lineCount);\n      return request.fulfill(7\n      /* CONTENT_EMPTY */\n      , new Position(lineCount, maxLineColumn), undefined, EMPTY_CONTENT_AFTER_LINES);\n    }\n\n    if (domHitTestExecuted) {\n      // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\n      // See https://github.com/Microsoft/vscode/issues/46942\n      if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\n        var lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n\n        if (ctx.model.getLineLength(lineNumber) === 0) {\n          var lineWidth = ctx.getLineWidth(lineNumber);\n          var detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n          return request.fulfill(7\n          /* CONTENT_EMPTY */\n          , new Position(lineNumber, 1), undefined, detail);\n        }\n      } // We have already executed hit test...\n\n\n      return request.fulfill(0\n      /* UNKNOWN */\n      );\n    }\n\n    var hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n\n    if (hitTestResult.position) {\n      return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);\n    }\n\n    return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n  };\n\n  MouseTargetFactory._hitTestMinimap = function (ctx, request) {\n    if (ElementPath.isChildOfMinimap(request.targetPath)) {\n      var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n      var maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n      return request.fulfill(11\n      /* SCROLLBAR */\n      , new Position(possibleLineNumber, maxColumn));\n    }\n\n    return null;\n  };\n\n  MouseTargetFactory._hitTestScrollbarSlider = function (ctx, request) {\n    if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n      if (request.target && request.target.nodeType === 1) {\n        var className = request.target.className;\n\n        if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\n          var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n          var maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n          return request.fulfill(11\n          /* SCROLLBAR */\n          , new Position(possibleLineNumber, maxColumn));\n        }\n      }\n    }\n\n    return null;\n  };\n\n  MouseTargetFactory._hitTestScrollbar = function (ctx, request) {\n    // Is it the overview ruler?\n    // Is it a child of the scrollable element?\n    if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n      var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n      var maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n      return request.fulfill(11\n      /* SCROLLBAR */\n      , new Position(possibleLineNumber, maxColumn));\n    }\n\n    return null;\n  };\n\n  MouseTargetFactory.prototype.getMouseColumn = function (editorPos, pos) {\n    var layoutInfo = this._context.configuration.editor.layoutInfo;\n    var mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + pos.x - editorPos.x - layoutInfo.contentLeft;\n    return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth);\n  };\n\n  MouseTargetFactory._getMouseColumn = function (mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\n    if (mouseContentHorizontalOffset < 0) {\n      return 1;\n    }\n\n    var chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\n    return chars + 1;\n  };\n\n  MouseTargetFactory.createMouseTargetFromHitTestPosition = function (ctx, request, lineNumber, column) {\n    var pos = new Position(lineNumber, column);\n    var lineWidth = ctx.getLineWidth(lineNumber);\n\n    if (request.mouseContentHorizontalOffset > lineWidth) {\n      if (browser.isEdge && pos.column === 1) {\n        // See https://github.com/Microsoft/vscode/issues/10875\n        var detail_1 = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n        return request.fulfill(7\n        /* CONTENT_EMPTY */\n        , new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber)), undefined, detail_1);\n      }\n\n      var detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n      return request.fulfill(7\n      /* CONTENT_EMPTY */\n      , pos, undefined, detail);\n    }\n\n    var visibleRange = ctx.visibleRangeForPosition2(lineNumber, column);\n\n    if (!visibleRange) {\n      return request.fulfill(0\n      /* UNKNOWN */\n      , pos);\n    }\n\n    var columnHorizontalOffset = visibleRange.left;\n\n    if (request.mouseContentHorizontalOffset === columnHorizontalOffset) {\n      return request.fulfill(6\n      /* CONTENT_TEXT */\n      , pos);\n    }\n\n    var points = [];\n    points.push({\n      offset: visibleRange.left,\n      column: column\n    });\n\n    if (column > 1) {\n      var visibleRange_1 = ctx.visibleRangeForPosition2(lineNumber, column - 1);\n\n      if (visibleRange_1) {\n        points.push({\n          offset: visibleRange_1.left,\n          column: column - 1\n        });\n      }\n    }\n\n    var lineMaxColumn = ctx.model.getLineMaxColumn(lineNumber);\n\n    if (column < lineMaxColumn) {\n      var visibleRange_2 = ctx.visibleRangeForPosition2(lineNumber, column + 1);\n\n      if (visibleRange_2) {\n        points.push({\n          offset: visibleRange_2.left,\n          column: column + 1\n        });\n      }\n    }\n\n    points.sort(function (a, b) {\n      return a.offset - b.offset;\n    });\n\n    for (var i = 1; i < points.length; i++) {\n      var prev = points[i - 1];\n      var curr = points[i];\n\n      if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\n        var rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\n        return request.fulfill(6\n        /* CONTENT_TEXT */\n        , pos, rng);\n      }\n    }\n\n    return request.fulfill(6\n    /* CONTENT_TEXT */\n    , pos);\n  };\n  /**\n   * Most probably WebKit browsers and Edge\n   */\n\n\n  MouseTargetFactory._doHitTestWithCaretRangeFromPoint = function (ctx, request) {\n    // In Chrome, especially on Linux it is possible to click between lines,\n    // so try to adjust the `hity` below so that it lands in the center of a line\n    var lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n    var lineVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\n    var lineCenteredVerticalOffset = lineVerticalOffset + Math.floor(ctx.lineHeight / 2);\n    var adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\n\n    if (adjustedPageY <= request.editorPos.y) {\n      adjustedPageY = request.editorPos.y + 1;\n    }\n\n    if (adjustedPageY >= request.editorPos.y + ctx.layoutInfo.height) {\n      adjustedPageY = request.editorPos.y + ctx.layoutInfo.height - 1;\n    }\n\n    var adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\n\n    var r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates());\n\n    if (r.position) {\n      return r;\n    } // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\n\n\n    return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates());\n  };\n\n  MouseTargetFactory._actualDoHitTestWithCaretRangeFromPoint = function (ctx, coords) {\n    var range = document.caretRangeFromPoint(coords.clientX, coords.clientY);\n\n    if (!range || !range.startContainer) {\n      return {\n        position: null,\n        hitTarget: null\n      };\n    } // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\n\n\n    var startContainer = range.startContainer;\n    var hitTarget = null;\n\n    if (startContainer.nodeType === startContainer.TEXT_NODE) {\n      // startContainer is expected to be the token text\n      var parent1 = startContainer.parentNode; // expected to be the token span\n\n      var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n\n      var parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n\n      var parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n\n      if (parent3ClassName === ViewLine.CLASS_NAME) {\n        var p = ctx.getPositionFromDOMInfo(parent1, range.startOffset);\n        return {\n          position: p,\n          hitTarget: null\n        };\n      } else {\n        hitTarget = startContainer.parentNode;\n      }\n    } else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\n      // startContainer is expected to be the token span\n      var parent1 = startContainer.parentNode; // expected to be the view line container span\n\n      var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div\n\n      var parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n\n      if (parent2ClassName === ViewLine.CLASS_NAME) {\n        var p = ctx.getPositionFromDOMInfo(startContainer, startContainer.textContent.length);\n        return {\n          position: p,\n          hitTarget: null\n        };\n      } else {\n        hitTarget = startContainer;\n      }\n    }\n\n    return {\n      position: null,\n      hitTarget: hitTarget\n    };\n  };\n  /**\n   * Most probably Gecko\n   */\n\n\n  MouseTargetFactory._doHitTestWithCaretPositionFromPoint = function (ctx, coords) {\n    var hitResult = document.caretPositionFromPoint(coords.clientX, coords.clientY);\n\n    if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\n      // offsetNode is expected to be the token text\n      var parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\n\n      var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n\n      var parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n\n      var parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n\n      if (parent3ClassName === ViewLine.CLASS_NAME) {\n        var p = ctx.getPositionFromDOMInfo(hitResult.offsetNode.parentNode, hitResult.offset);\n        return {\n          position: p,\n          hitTarget: null\n        };\n      } else {\n        return {\n          position: null,\n          hitTarget: hitResult.offsetNode.parentNode\n        };\n      }\n    }\n\n    return {\n      position: null,\n      hitTarget: hitResult.offsetNode\n    };\n  };\n  /**\n   * Most probably IE\n   */\n\n\n  MouseTargetFactory._doHitTestWithMoveToPoint = function (ctx, coords) {\n    var resultPosition = null;\n    var resultHitTarget = null;\n    var textRange = document.body.createTextRange();\n\n    try {\n      textRange.moveToPoint(coords.clientX, coords.clientY);\n    } catch (err) {\n      return {\n        position: null,\n        hitTarget: null\n      };\n    }\n\n    textRange.collapse(true); // Now, let's do our best to figure out what we hit :)\n\n    var parentElement = textRange ? textRange.parentElement() : null;\n    var parent1 = parentElement ? parentElement.parentNode : null;\n    var parent2 = parent1 ? parent1.parentNode : null;\n    var parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : '';\n\n    if (parent2ClassName === ViewLine.CLASS_NAME) {\n      var rangeToContainEntireSpan = textRange.duplicate();\n      rangeToContainEntireSpan.moveToElementText(parentElement);\n      rangeToContainEntireSpan.setEndPoint('EndToStart', textRange);\n      resultPosition = ctx.getPositionFromDOMInfo(parentElement, rangeToContainEntireSpan.text.length); // Move range out of the span node, IE doesn't like having many ranges in\n      // the same spot and will act badly for lines containing dashes ('-')\n\n      rangeToContainEntireSpan.moveToElementText(ctx.viewDomNode);\n    } else {\n      // Looks like we've hit the hover or something foreign\n      resultHitTarget = parentElement;\n    } // Move range out of the span node, IE doesn't like having many ranges in\n    // the same spot and will act badly for lines containing dashes ('-')\n\n\n    textRange.moveToElementText(ctx.viewDomNode);\n    return {\n      position: resultPosition,\n      hitTarget: resultHitTarget\n    };\n  };\n\n  MouseTargetFactory._doHitTest = function (ctx, request) {\n    // State of the art (18.10.2012):\n    // The spec says browsers should support document.caretPositionFromPoint, but nobody implemented it (http://dev.w3.org/csswg/cssom-view/)\n    // Gecko:\n    //    - they tried to implement it once, but failed: https://bugzilla.mozilla.org/show_bug.cgi?id=654352\n    //    - however, they do give out rangeParent/rangeOffset properties on mouse events\n    // Webkit:\n    //    - they have implemented a previous version of the spec which was using document.caretRangeFromPoint\n    // IE:\n    //    - they have a proprietary method on ranges, moveToPoint: https://msdn.microsoft.com/en-us/library/ie/ms536632(v=vs.85).aspx\n    // 24.08.2016: Edge has added WebKit's document.caretRangeFromPoint, but it is quite buggy\n    //    - when hit testing the cursor it returns the first or the last line in the viewport\n    //    - it inconsistently hits text nodes or span nodes, while WebKit only hits text nodes\n    //    - when toggling render whitespace on, and hit testing in the empty content after a line, it always hits offset 0 of the first span of the line\n    // Thank you browsers for making this so 'easy' :)\n    if (document.caretRangeFromPoint) {\n      return this._doHitTestWithCaretRangeFromPoint(ctx, request);\n    } else if (document.caretPositionFromPoint) {\n      return this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates());\n    } else if (document.body.createTextRange) {\n      return this._doHitTestWithMoveToPoint(ctx, request.pos.toClientCoordinates());\n    }\n\n    return {\n      position: null,\n      hitTarget: null\n    };\n  };\n\n  return MouseTargetFactory;\n}();\n\nexport { MouseTargetFactory };","map":null,"metadata":{},"sourceType":"module"}