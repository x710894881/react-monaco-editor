{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorColumns, CursorConfiguration, CursorContext, CursorState, EditOperationResult } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport * as editorCommon from '../editorCommon.js';\nimport * as viewEvents from '../view/viewEvents.js';\nimport { dispose } from '../../../base/common/lifecycle.js';\n\nfunction containsLineMappingChanged(events) {\n  for (var i = 0, len = events.length; i < len; i++) {\n    if (events[i].type === 6\n    /* ViewLineMappingChanged */\n    ) {\n        return true;\n      }\n  }\n\n  return false;\n}\n\nvar CursorStateChangedEvent =\n/** @class */\nfunction () {\n  function CursorStateChangedEvent(selections, source, reason) {\n    this.selections = selections;\n    this.source = source;\n    this.reason = reason;\n  }\n\n  return CursorStateChangedEvent;\n}();\n\nexport { CursorStateChangedEvent };\n/**\n * A snapshot of the cursor and the model state\n */\n\nvar CursorModelState =\n/** @class */\nfunction () {\n  function CursorModelState(model, cursor) {\n    this.modelVersionId = model.getVersionId();\n    this.cursorState = cursor.getAll();\n  }\n\n  CursorModelState.prototype.equals = function (other) {\n    if (!other) {\n      return false;\n    }\n\n    if (this.modelVersionId !== other.modelVersionId) {\n      return false;\n    }\n\n    if (this.cursorState.length !== other.cursorState.length) {\n      return false;\n    }\n\n    for (var i = 0, len = this.cursorState.length; i < len; i++) {\n      if (!this.cursorState[i].equals(other.cursorState[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return CursorModelState;\n}();\n\nexport { CursorModelState };\n\nvar AutoClosedAction =\n/** @class */\nfunction () {\n  function AutoClosedAction(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n    this._model = model;\n    this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n    this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n  }\n\n  AutoClosedAction.getAllAutoClosedCharacters = function (autoClosedActions) {\n    var autoClosedCharacters = [];\n\n    for (var _i = 0, autoClosedActions_1 = autoClosedActions; _i < autoClosedActions_1.length; _i++) {\n      var autoClosedAction = autoClosedActions_1[_i];\n      autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n    }\n\n    return autoClosedCharacters;\n  };\n\n  AutoClosedAction.prototype.dispose = function () {\n    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n    this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n  };\n\n  AutoClosedAction.prototype.getAutoClosedCharactersRanges = function () {\n    var result = [];\n\n    for (var i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n      var decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n\n      if (decorationRange) {\n        result.push(decorationRange);\n      }\n    }\n\n    return result;\n  };\n\n  AutoClosedAction.prototype.isValid = function (selections) {\n    var enclosingRanges = [];\n\n    for (var i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n      var decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n\n      if (decorationRange) {\n        enclosingRanges.push(decorationRange);\n\n        if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n          // Stop tracking if the range becomes multiline...\n          return false;\n        }\n      }\n    }\n\n    enclosingRanges.sort(Range.compareRangesUsingStarts);\n    selections.sort(Range.compareRangesUsingStarts);\n\n    for (var i = 0; i < selections.length; i++) {\n      if (i >= enclosingRanges.length) {\n        return false;\n      }\n\n      if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return AutoClosedAction;\n}();\n\nvar Cursor =\n/** @class */\nfunction (_super) {\n  __extends(Cursor, _super);\n\n  function Cursor(configuration, model, viewModel) {\n    var _this = _super.call(this) || this;\n\n    _this._onDidReachMaxCursorCount = _this._register(new Emitter());\n    _this.onDidReachMaxCursorCount = _this._onDidReachMaxCursorCount.event;\n    _this._onDidAttemptReadOnlyEdit = _this._register(new Emitter());\n    _this.onDidAttemptReadOnlyEdit = _this._onDidAttemptReadOnlyEdit.event;\n    _this._onDidChange = _this._register(new Emitter());\n    _this.onDidChange = _this._onDidChange.event;\n    _this._configuration = configuration;\n    _this._model = model;\n    _this._knownModelVersionId = _this._model.getVersionId();\n    _this._viewModel = viewModel;\n    _this.context = new CursorContext(_this._configuration, _this._model, _this._viewModel);\n    _this._cursors = new CursorCollection(_this.context);\n    _this._isHandling = false;\n    _this._isDoingComposition = false;\n    _this._columnSelectData = null;\n    _this._autoClosedActions = [];\n    _this._prevEditOperationType = 0\n    /* Other */\n    ;\n\n    _this._register(_this._model.onDidChangeRawContent(function (e) {\n      _this._knownModelVersionId = e.versionId;\n\n      if (_this._isHandling) {\n        return;\n      }\n\n      var hadFlushEvent = e.containsEvent(1\n      /* Flush */\n      );\n\n      _this._onModelContentChanged(hadFlushEvent);\n    }));\n\n    _this._register(viewModel.addEventListener(function (events) {\n      if (!containsLineMappingChanged(events)) {\n        return;\n      }\n\n      if (_this._knownModelVersionId !== _this._model.getVersionId()) {\n        // There are model change events that I didn't yet receive.\n        //\n        // This can happen when editing the model, and the view model receives the change events first,\n        // and the view model emits line mapping changed events, all before the cursor gets a chance to\n        // recover from markers.\n        //\n        // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n        return;\n      } // Ensure valid state\n\n\n      _this.setStates('viewModel', 0\n      /* NotSet */\n      , _this.getAll());\n    }));\n\n    var updateCursorContext = function () {\n      _this.context = new CursorContext(_this._configuration, _this._model, _this._viewModel);\n\n      _this._cursors.updateContext(_this.context);\n    };\n\n    _this._register(_this._model.onDidChangeLanguage(function (e) {\n      updateCursorContext();\n    }));\n\n    _this._register(_this._model.onDidChangeLanguageConfiguration(function () {\n      updateCursorContext();\n    }));\n\n    _this._register(_this._model.onDidChangeOptions(function () {\n      updateCursorContext();\n    }));\n\n    _this._register(_this._configuration.onDidChange(function (e) {\n      if (CursorConfiguration.shouldRecreate(e)) {\n        updateCursorContext();\n      }\n    }));\n\n    return _this;\n  }\n\n  Cursor.prototype.dispose = function () {\n    this._cursors.dispose();\n\n    this._autoClosedActions = dispose(this._autoClosedActions);\n\n    _super.prototype.dispose.call(this);\n  };\n\n  Cursor.prototype._validateAutoClosedActions = function () {\n    if (this._autoClosedActions.length > 0) {\n      var selections = this._cursors.getSelections();\n\n      for (var i = 0; i < this._autoClosedActions.length; i++) {\n        var autoClosedAction = this._autoClosedActions[i];\n\n        if (!autoClosedAction.isValid(selections)) {\n          autoClosedAction.dispose();\n\n          this._autoClosedActions.splice(i, 1);\n\n          i--;\n        }\n      }\n    }\n  }; // ------ some getters/setters\n\n\n  Cursor.prototype.getPrimaryCursor = function () {\n    return this._cursors.getPrimaryCursor();\n  };\n\n  Cursor.prototype.getLastAddedCursorIndex = function () {\n    return this._cursors.getLastAddedCursorIndex();\n  };\n\n  Cursor.prototype.getAll = function () {\n    return this._cursors.getAll();\n  };\n\n  Cursor.prototype.setStates = function (source, reason, states) {\n    if (states !== null && states.length > Cursor.MAX_CURSOR_COUNT) {\n      states = states.slice(0, Cursor.MAX_CURSOR_COUNT);\n\n      this._onDidReachMaxCursorCount.fire(undefined);\n    }\n\n    var oldState = new CursorModelState(this._model, this);\n\n    this._cursors.setStates(states);\n\n    this._cursors.normalize();\n\n    this._columnSelectData = null;\n\n    this._validateAutoClosedActions();\n\n    this._emitStateChangedIfNecessary(source, reason, oldState);\n  };\n\n  Cursor.prototype.setColumnSelectData = function (columnSelectData) {\n    this._columnSelectData = columnSelectData;\n  };\n\n  Cursor.prototype.reveal = function (horizontal, target, scrollType) {\n    this._revealRange(target, 0\n    /* Simple */\n    , horizontal, scrollType);\n  };\n\n  Cursor.prototype.revealRange = function (revealHorizontal, viewRange, verticalType, scrollType) {\n    this.emitCursorRevealRange(viewRange, verticalType, revealHorizontal, scrollType);\n  };\n\n  Cursor.prototype.scrollTo = function (desiredScrollTop) {\n    this._viewModel.viewLayout.setScrollPositionSmooth({\n      scrollTop: desiredScrollTop\n    });\n  };\n\n  Cursor.prototype.saveState = function () {\n    var result = [];\n\n    var selections = this._cursors.getSelections();\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n      result.push({\n        inSelectionMode: !selection.isEmpty(),\n        selectionStart: {\n          lineNumber: selection.selectionStartLineNumber,\n          column: selection.selectionStartColumn\n        },\n        position: {\n          lineNumber: selection.positionLineNumber,\n          column: selection.positionColumn\n        }\n      });\n    }\n\n    return result;\n  };\n\n  Cursor.prototype.restoreState = function (states) {\n    var desiredSelections = [];\n\n    for (var i = 0, len = states.length; i < len; i++) {\n      var state = states[i];\n      var positionLineNumber = 1;\n      var positionColumn = 1; // Avoid missing properties on the literal\n\n      if (state.position && state.position.lineNumber) {\n        positionLineNumber = state.position.lineNumber;\n      }\n\n      if (state.position && state.position.column) {\n        positionColumn = state.position.column;\n      }\n\n      var selectionStartLineNumber = positionLineNumber;\n      var selectionStartColumn = positionColumn; // Avoid missing properties on the literal\n\n      if (state.selectionStart && state.selectionStart.lineNumber) {\n        selectionStartLineNumber = state.selectionStart.lineNumber;\n      }\n\n      if (state.selectionStart && state.selectionStart.column) {\n        selectionStartColumn = state.selectionStart.column;\n      }\n\n      desiredSelections.push({\n        selectionStartLineNumber: selectionStartLineNumber,\n        selectionStartColumn: selectionStartColumn,\n        positionLineNumber: positionLineNumber,\n        positionColumn: positionColumn\n      });\n    }\n\n    this.setStates('restoreState', 0\n    /* NotSet */\n    , CursorState.fromModelSelections(desiredSelections));\n    this.reveal(true, 0\n    /* Primary */\n    , 1\n    /* Immediate */\n    );\n  };\n\n  Cursor.prototype._onModelContentChanged = function (hadFlushEvent) {\n    this._prevEditOperationType = 0\n    /* Other */\n    ;\n\n    if (hadFlushEvent) {\n      // a model.setValue() was called\n      this._cursors.dispose();\n\n      this._cursors = new CursorCollection(this.context);\n\n      this._validateAutoClosedActions();\n\n      this._emitStateChangedIfNecessary('model', 1\n      /* ContentFlush */\n      , null);\n    } else {\n      var selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n\n      this.setStates('modelChange', 2\n      /* RecoverFromMarkers */\n      , CursorState.fromModelSelections(selectionsFromMarkers));\n    }\n  };\n\n  Cursor.prototype.getSelection = function () {\n    return this._cursors.getPrimaryCursor().modelState.selection;\n  };\n\n  Cursor.prototype.getColumnSelectData = function () {\n    if (this._columnSelectData) {\n      return this._columnSelectData;\n    }\n\n    var primaryCursor = this._cursors.getPrimaryCursor();\n\n    var primaryPos = primaryCursor.viewState.position;\n    var viewLineNumber = primaryPos.lineNumber;\n    var viewVisualColumn = CursorColumns.visibleColumnFromColumn2(this.context.config, this.context.viewModel, primaryPos);\n    return {\n      isReal: false,\n      fromViewLineNumber: viewLineNumber,\n      fromViewVisualColumn: viewVisualColumn,\n      toViewLineNumber: viewLineNumber,\n      toViewVisualColumn: viewVisualColumn\n    };\n  };\n\n  Cursor.prototype.getSelections = function () {\n    return this._cursors.getSelections();\n  };\n\n  Cursor.prototype.getViewSelections = function () {\n    return this._cursors.getViewSelections();\n  };\n\n  Cursor.prototype.getPosition = function () {\n    return this._cursors.getPrimaryCursor().modelState.position;\n  };\n\n  Cursor.prototype.setSelections = function (source, selections) {\n    this.setStates(source, 0\n    /* NotSet */\n    , CursorState.fromModelSelections(selections));\n  };\n\n  Cursor.prototype.getPrevEditOperationType = function () {\n    return this._prevEditOperationType;\n  };\n\n  Cursor.prototype.setPrevEditOperationType = function (type) {\n    this._prevEditOperationType = type;\n  }; // ------ auxiliary handling logic\n\n\n  Cursor.prototype._pushAutoClosedAction = function (autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n    var autoClosedCharactersDeltaDecorations = [];\n    var autoClosedEnclosingDeltaDecorations = [];\n\n    for (var i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n      autoClosedCharactersDeltaDecorations.push({\n        range: autoClosedCharactersRanges[i],\n        options: {\n          inlineClassName: 'auto-closed-character',\n          stickiness: 1\n          /* NeverGrowsWhenTypingAtEdges */\n\n        }\n      });\n      autoClosedEnclosingDeltaDecorations.push({\n        range: autoClosedEnclosingRanges[i],\n        options: {\n          stickiness: 1\n          /* NeverGrowsWhenTypingAtEdges */\n\n        }\n      });\n    }\n\n    var autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n\n    var autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n\n    this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n  };\n\n  Cursor.prototype._executeEditOperation = function (opResult) {\n    if (!opResult) {\n      // Nothing to execute\n      return;\n    }\n\n    if (opResult.shouldPushStackElementBefore) {\n      this._model.pushStackElement();\n    }\n\n    var result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n\n    if (result) {\n      // The commands were applied correctly\n      this._interpretCommandResult(result); // Check for auto-closing closed characters\n\n\n      var autoClosedCharactersRanges = [];\n      var autoClosedEnclosingRanges = [];\n\n      for (var i = 0; i < opResult.commands.length; i++) {\n        var command = opResult.commands[i];\n\n        if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n          autoClosedCharactersRanges.push(command.closeCharacterRange);\n          autoClosedEnclosingRanges.push(command.enclosingRange);\n        }\n      }\n\n      if (autoClosedCharactersRanges.length > 0) {\n        this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n      }\n\n      this._prevEditOperationType = opResult.type;\n    }\n\n    if (opResult.shouldPushStackElementAfter) {\n      this._model.pushStackElement();\n    }\n  };\n\n  Cursor.prototype._interpretCommandResult = function (cursorState) {\n    if (!cursorState || cursorState.length === 0) {\n      cursorState = this._cursors.readSelectionFromMarkers();\n    }\n\n    this._columnSelectData = null;\n\n    this._cursors.setSelections(cursorState);\n\n    this._cursors.normalize();\n  }; // -----------------------------------------------------------------------------------------------------------\n  // ----- emitting events\n\n\n  Cursor.prototype._emitStateChangedIfNecessary = function (source, reason, oldState) {\n    var newState = new CursorModelState(this._model, this);\n\n    if (newState.equals(oldState)) {\n      return false;\n    }\n\n    var selections = this._cursors.getSelections();\n\n    var viewSelections = this._cursors.getViewSelections(); // Let the view get the event first.\n\n\n    try {\n      var eventsCollector = this._beginEmit();\n\n      eventsCollector.emit(new viewEvents.ViewCursorStateChangedEvent(viewSelections));\n    } finally {\n      this._endEmit();\n    } // Only after the view has been notified, let the rest of the world know...\n\n\n    if (!oldState || oldState.cursorState.length !== newState.cursorState.length || newState.cursorState.some(function (newCursorState, i) {\n      return !newCursorState.modelState.equals(oldState.cursorState[i].modelState);\n    })) {\n      this._onDidChange.fire(new CursorStateChangedEvent(selections, source || 'keyboard', reason));\n    }\n\n    return true;\n  };\n\n  Cursor.prototype._revealRange = function (revealTarget, verticalType, revealHorizontal, scrollType) {\n    var viewPositions = this._cursors.getViewPositions();\n\n    var viewPosition = viewPositions[0];\n\n    if (revealTarget === 1\n    /* TopMost */\n    ) {\n        for (var i = 1; i < viewPositions.length; i++) {\n          if (viewPositions[i].isBefore(viewPosition)) {\n            viewPosition = viewPositions[i];\n          }\n        }\n      } else if (revealTarget === 2\n    /* BottomMost */\n    ) {\n        for (var i = 1; i < viewPositions.length; i++) {\n          if (viewPosition.isBeforeOrEqual(viewPositions[i])) {\n            viewPosition = viewPositions[i];\n          }\n        }\n      } else {\n      if (viewPositions.length > 1) {\n        // no revealing!\n        return;\n      }\n    }\n\n    var viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n    this.emitCursorRevealRange(viewRange, verticalType, revealHorizontal, scrollType);\n  };\n\n  Cursor.prototype.emitCursorRevealRange = function (viewRange, verticalType, revealHorizontal, scrollType) {\n    try {\n      var eventsCollector = this._beginEmit();\n\n      eventsCollector.emit(new viewEvents.ViewRevealRangeRequestEvent(viewRange, verticalType, revealHorizontal, scrollType));\n    } finally {\n      this._endEmit();\n    }\n  }; // -----------------------------------------------------------------------------------------------------------\n  // ----- handlers beyond this point\n\n\n  Cursor.prototype._findAutoClosingPairs = function (edits) {\n    if (!edits.length) {\n      return null;\n    }\n\n    var indices = [];\n\n    for (var i = 0, len = edits.length; i < len; i++) {\n      var edit = edits[i];\n\n      if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n        return null;\n      }\n\n      var m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n\n      if (!m) {\n        return null;\n      }\n\n      var closeChar = m[1];\n      var autoClosingPairsCandidates = this.context.config.autoClosingPairsClose2.get(closeChar);\n\n      if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n        return null;\n      }\n\n      var openChar = autoClosingPairsCandidates[0].open;\n      var closeCharIndex = edit.text.length - m[2].length - 1;\n      var openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n\n      if (openCharIndex === -1) {\n        return null;\n      }\n\n      indices.push([openCharIndex, closeCharIndex]);\n    }\n\n    return indices;\n  };\n\n  Cursor.prototype.executeEdits = function (source, edits, cursorStateComputer) {\n    var _this = this;\n\n    var autoClosingIndices = null;\n\n    if (source === 'snippet') {\n      autoClosingIndices = this._findAutoClosingPairs(edits);\n    }\n\n    if (autoClosingIndices) {\n      edits[0]._isTracked = true;\n    }\n\n    var autoClosedCharactersRanges = [];\n    var autoClosedEnclosingRanges = [];\n\n    var selections = this._model.pushEditOperations(this.getSelections(), edits, function (undoEdits) {\n      if (autoClosingIndices) {\n        for (var i = 0, len = autoClosingIndices.length; i < len; i++) {\n          var _a = autoClosingIndices[i],\n              openCharInnerIndex = _a[0],\n              closeCharInnerIndex = _a[1];\n          var undoEdit = undoEdits[i];\n          var lineNumber = undoEdit.range.startLineNumber;\n          var openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n          var closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n          autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n          autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n        }\n      }\n\n      var selections = cursorStateComputer(undoEdits);\n\n      if (selections) {\n        // Don't recover the selection from markers because\n        // we know what it should be.\n        _this._isHandling = true;\n      }\n\n      return selections;\n    });\n\n    if (selections) {\n      this._isHandling = false;\n      this.setSelections(source, selections);\n    }\n\n    if (autoClosedCharactersRanges.length > 0) {\n      this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n    }\n  };\n\n  Cursor.prototype.trigger = function (source, handlerId, payload) {\n    var H = editorCommon.Handler;\n\n    if (handlerId === H.CompositionStart) {\n      this._isDoingComposition = true;\n      return;\n    }\n\n    if (handlerId === H.CompositionEnd) {\n      this._isDoingComposition = false;\n    }\n\n    if (this._configuration.editor.readOnly) {\n      // All the remaining handlers will try to edit the model,\n      // but we cannot edit when read only...\n      this._onDidAttemptReadOnlyEdit.fire(undefined);\n\n      return;\n    }\n\n    var oldState = new CursorModelState(this._model, this);\n    var cursorChangeReason = 0\n    /* NotSet */\n    ;\n\n    if (handlerId !== H.Undo && handlerId !== H.Redo) {\n      // TODO@Alex: if the undo/redo stack contains non-null selections\n      // it would also be OK to stop tracking selections here\n      this._cursors.stopTrackingSelections();\n    } // ensure valid state on all cursors\n\n\n    this._cursors.ensureValidState();\n\n    this._isHandling = true;\n\n    try {\n      switch (handlerId) {\n        case H.Type:\n          this._type(source, payload.text);\n\n          break;\n\n        case H.ReplacePreviousChar:\n          this._replacePreviousChar(payload.text, payload.replaceCharCnt);\n\n          break;\n\n        case H.Paste:\n          cursorChangeReason = 4\n          /* Paste */\n          ;\n\n          this._paste(payload.text, payload.pasteOnNewLine, payload.multicursorText);\n\n          break;\n\n        case H.Cut:\n          this._cut();\n\n          break;\n\n        case H.Undo:\n          cursorChangeReason = 5\n          /* Undo */\n          ;\n\n          this._interpretCommandResult(this._model.undo());\n\n          break;\n\n        case H.Redo:\n          cursorChangeReason = 6\n          /* Redo */\n          ;\n\n          this._interpretCommandResult(this._model.redo());\n\n          break;\n\n        case H.ExecuteCommand:\n          this._externalExecuteCommand(payload);\n\n          break;\n\n        case H.ExecuteCommands:\n          this._externalExecuteCommands(payload);\n\n          break;\n\n        case H.CompositionEnd:\n          this._interpretCompositionEnd(source);\n\n          break;\n      }\n    } catch (err) {\n      onUnexpectedError(err);\n    }\n\n    this._isHandling = false;\n\n    if (handlerId !== H.Undo && handlerId !== H.Redo) {\n      this._cursors.startTrackingSelections();\n    }\n\n    this._validateAutoClosedActions();\n\n    if (this._emitStateChangedIfNecessary(source, cursorChangeReason, oldState)) {\n      this._revealRange(0\n      /* Primary */\n      , 0\n      /* Simple */\n      , true, 0\n      /* Smooth */\n      );\n    }\n  };\n\n  Cursor.prototype._interpretCompositionEnd = function (source) {\n    if (!this._isDoingComposition && source === 'keyboard') {\n      // composition finishes, let's check if we need to auto complete if necessary.\n      var autoClosedCharacters = AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n\n      this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), autoClosedCharacters));\n    }\n  };\n\n  Cursor.prototype._type = function (source, text) {\n    if (!this._isDoingComposition && source === 'keyboard') {\n      // If this event is coming straight from the keyboard, look for electric characters and enter\n      for (var i = 0, len = text.length; i < len; i++) {\n        var charCode = text.charCodeAt(i);\n        var chr = void 0;\n\n        if (strings.isHighSurrogate(charCode) && i + 1 < len) {\n          chr = text.charAt(i) + text.charAt(i + 1);\n          i++;\n        } else {\n          chr = text.charAt(i);\n        } // Here we must interpret each typed character individually\n\n\n        var autoClosedCharacters = AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n\n        this._executeEditOperation(TypeOperations.typeWithInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), autoClosedCharacters, chr));\n      }\n    } else {\n      this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), text));\n    }\n  };\n\n  Cursor.prototype._replacePreviousChar = function (text, replaceCharCnt) {\n    this._executeEditOperation(TypeOperations.replacePreviousChar(this._prevEditOperationType, this.context.config, this.context.model, this.getSelections(), text, replaceCharCnt));\n  };\n\n  Cursor.prototype._paste = function (text, pasteOnNewLine, multicursorText) {\n    this._executeEditOperation(TypeOperations.paste(this.context.config, this.context.model, this.getSelections(), text, pasteOnNewLine, multicursorText));\n  };\n\n  Cursor.prototype._cut = function () {\n    this._executeEditOperation(DeleteOperations.cut(this.context.config, this.context.model, this.getSelections()));\n  };\n\n  Cursor.prototype._externalExecuteCommand = function (command) {\n    this._cursors.killSecondaryCursors();\n\n    this._executeEditOperation(new EditOperationResult(0\n    /* Other */\n    , [command], {\n      shouldPushStackElementBefore: false,\n      shouldPushStackElementAfter: false\n    }));\n  };\n\n  Cursor.prototype._externalExecuteCommands = function (commands) {\n    this._executeEditOperation(new EditOperationResult(0\n    /* Other */\n    , commands, {\n      shouldPushStackElementBefore: false,\n      shouldPushStackElementAfter: false\n    }));\n  };\n\n  Cursor.MAX_CURSOR_COUNT = 10000;\n  return Cursor;\n}(viewEvents.ViewEventEmitter);\n\nexport { Cursor };\n\nvar CommandExecutor =\n/** @class */\nfunction () {\n  function CommandExecutor() {}\n\n  CommandExecutor.executeCommands = function (model, selectionsBefore, commands) {\n    var ctx = {\n      model: model,\n      selectionsBefore: selectionsBefore,\n      trackedRanges: [],\n      trackedRangesDirection: []\n    };\n\n    var result = this._innerExecuteCommands(ctx, commands);\n\n    for (var i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n      ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0\n      /* AlwaysGrowsWhenTypingAtEdges */\n      );\n    }\n\n    return result;\n  };\n\n  CommandExecutor._innerExecuteCommands = function (ctx, commands) {\n    if (this._arrayIsEmpty(commands)) {\n      return null;\n    }\n\n    var commandsData = this._getEditOperations(ctx, commands);\n\n    if (commandsData.operations.length === 0) {\n      return null;\n    }\n\n    var rawOperations = commandsData.operations;\n\n    var loserCursorsMap = this._getLoserCursorMap(rawOperations);\n\n    if (loserCursorsMap.hasOwnProperty('0')) {\n      // These commands are very messed up\n      console.warn('Ignoring commands');\n      return null;\n    } // Remove operations belonging to losing cursors\n\n\n    var filteredOperations = [];\n\n    for (var i = 0, len = rawOperations.length; i < len; i++) {\n      if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n        filteredOperations.push(rawOperations[i]);\n      }\n    } // TODO@Alex: find a better way to do this.\n    // give the hint that edit operations are tracked to the model\n\n\n    if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n      filteredOperations[0]._isTracked = true;\n    }\n\n    var selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, function (inverseEditOperations) {\n      var groupedInverseEditOperations = [];\n\n      for (var i = 0; i < ctx.selectionsBefore.length; i++) {\n        groupedInverseEditOperations[i] = [];\n      }\n\n      for (var _i = 0, inverseEditOperations_1 = inverseEditOperations; _i < inverseEditOperations_1.length; _i++) {\n        var op = inverseEditOperations_1[_i];\n\n        if (!op.identifier) {\n          // perhaps auto whitespace trim edits\n          continue;\n        }\n\n        groupedInverseEditOperations[op.identifier.major].push(op);\n      }\n\n      var minorBasedSorter = function (a, b) {\n        return a.identifier.minor - b.identifier.minor;\n      };\n\n      var cursorSelections = [];\n\n      var _loop_1 = function (i) {\n        if (groupedInverseEditOperations[i].length > 0) {\n          groupedInverseEditOperations[i].sort(minorBasedSorter);\n          cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n            getInverseEditOperations: function () {\n              return groupedInverseEditOperations[i];\n            },\n            getTrackedSelection: function (id) {\n              var idx = parseInt(id, 10);\n\n              var range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n\n              if (ctx.trackedRangesDirection[idx] === 0\n              /* LTR */\n              ) {\n                  return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                }\n\n              return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n            }\n          });\n        } else {\n          cursorSelections[i] = ctx.selectionsBefore[i];\n        }\n      };\n\n      for (var i = 0; i < ctx.selectionsBefore.length; i++) {\n        _loop_1(i);\n      }\n\n      return cursorSelections;\n    });\n\n    if (!selectionsAfter) {\n      selectionsAfter = ctx.selectionsBefore;\n    } // Extract losing cursors\n\n\n    var losingCursors = [];\n\n    for (var losingCursorIndex in loserCursorsMap) {\n      if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n        losingCursors.push(parseInt(losingCursorIndex, 10));\n      }\n    } // Sort losing cursors descending\n\n\n    losingCursors.sort(function (a, b) {\n      return b - a;\n    }); // Remove losing cursors\n\n    for (var _i = 0, losingCursors_1 = losingCursors; _i < losingCursors_1.length; _i++) {\n      var losingCursor = losingCursors_1[_i];\n      selectionsAfter.splice(losingCursor, 1);\n    }\n\n    return selectionsAfter;\n  };\n\n  CommandExecutor._arrayIsEmpty = function (commands) {\n    for (var i = 0, len = commands.length; i < len; i++) {\n      if (commands[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  CommandExecutor._getEditOperations = function (ctx, commands) {\n    var operations = [];\n    var hadTrackedEditOperation = false;\n\n    for (var i = 0, len = commands.length; i < len; i++) {\n      var command = commands[i];\n\n      if (command) {\n        var r = this._getEditOperationsFromCommand(ctx, i, command);\n\n        operations = operations.concat(r.operations);\n        hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n      }\n    }\n\n    return {\n      operations: operations,\n      hadTrackedEditOperation: hadTrackedEditOperation\n    };\n  };\n\n  CommandExecutor._getEditOperationsFromCommand = function (ctx, majorIdentifier, command) {\n    // This method acts as a transaction, if the command fails\n    // everything it has done is ignored\n    var operations = [];\n    var operationMinor = 0;\n\n    var addEditOperation = function (selection, text) {\n      if (selection.isEmpty() && text === '') {\n        // This command wants to add a no-op => no thank you\n        return;\n      }\n\n      operations.push({\n        identifier: {\n          major: majorIdentifier,\n          minor: operationMinor++\n        },\n        range: selection,\n        text: text,\n        forceMoveMarkers: false,\n        isAutoWhitespaceEdit: command.insertsAutoWhitespace\n      });\n    };\n\n    var hadTrackedEditOperation = false;\n\n    var addTrackedEditOperation = function (selection, text) {\n      hadTrackedEditOperation = true;\n      addEditOperation(selection, text);\n    };\n\n    var trackSelection = function (selection, trackPreviousOnEmpty) {\n      var stickiness;\n\n      if (selection.isEmpty()) {\n        if (typeof trackPreviousOnEmpty === 'boolean') {\n          if (trackPreviousOnEmpty) {\n            stickiness = 2\n            /* GrowsOnlyWhenTypingBefore */\n            ;\n          } else {\n            stickiness = 3\n            /* GrowsOnlyWhenTypingAfter */\n            ;\n          }\n        } else {\n          // Try to lock it with surrounding text\n          var maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n\n          if (selection.startColumn === maxLineColumn) {\n            stickiness = 2\n            /* GrowsOnlyWhenTypingBefore */\n            ;\n          } else {\n            stickiness = 3\n            /* GrowsOnlyWhenTypingAfter */\n            ;\n          }\n        }\n      } else {\n        stickiness = 1\n        /* NeverGrowsWhenTypingAtEdges */\n        ;\n      }\n\n      var l = ctx.trackedRanges.length;\n\n      var id = ctx.model._setTrackedRange(null, selection, stickiness);\n\n      ctx.trackedRanges[l] = id;\n      ctx.trackedRangesDirection[l] = selection.getDirection();\n      return l.toString();\n    };\n\n    var editOperationBuilder = {\n      addEditOperation: addEditOperation,\n      addTrackedEditOperation: addTrackedEditOperation,\n      trackSelection: trackSelection\n    };\n\n    try {\n      command.getEditOperations(ctx.model, editOperationBuilder);\n    } catch (e) {\n      // TODO@Alex use notification service if this should be user facing\n      // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n      onUnexpectedError(e);\n      return {\n        operations: [],\n        hadTrackedEditOperation: false\n      };\n    }\n\n    return {\n      operations: operations,\n      hadTrackedEditOperation: hadTrackedEditOperation\n    };\n  };\n\n  CommandExecutor._getLoserCursorMap = function (operations) {\n    // This is destructive on the array\n    operations = operations.slice(0); // Sort operations with last one first\n\n    operations.sort(function (a, b) {\n      // Note the minus!\n      return -Range.compareRangesUsingEnds(a.range, b.range);\n    }); // Operations can not overlap!\n\n    var loserCursorsMap = {};\n\n    for (var i = 1; i < operations.length; i++) {\n      var previousOp = operations[i - 1];\n      var currentOp = operations[i];\n\n      if (previousOp.range.getStartPosition().isBefore(currentOp.range.getEndPosition())) {\n        var loserMajor = void 0;\n\n        if (previousOp.identifier.major > currentOp.identifier.major) {\n          // previousOp loses the battle\n          loserMajor = previousOp.identifier.major;\n        } else {\n          loserMajor = currentOp.identifier.major;\n        }\n\n        loserCursorsMap[loserMajor.toString()] = true;\n\n        for (var j = 0; j < operations.length; j++) {\n          if (operations[j].identifier.major === loserMajor) {\n            operations.splice(j, 1);\n\n            if (j < i) {\n              i--;\n            }\n\n            j--;\n          }\n        }\n\n        if (i > 0) {\n          i--;\n        }\n      }\n    }\n\n    return loserCursorsMap;\n  };\n\n  return CommandExecutor;\n}();","map":null,"metadata":{},"sourceType":"module"}