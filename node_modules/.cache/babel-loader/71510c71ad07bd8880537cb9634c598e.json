{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as Platform from '../../../common/platform.js';\nimport * as Browser from '../../../browser/browser.js';\nimport * as Lifecycle from '../../../common/lifecycle.js';\nimport * as DOM from '../../../browser/dom.js';\nimport * as Diff from '../../../common/diff/diff.js';\nimport * as Touch from '../../../browser/touch.js';\nimport * as strings from '../../../common/strings.js';\nimport * as Mouse from '../../../browser/mouseEvent.js';\nimport * as Keyboard from '../../../browser/keyboardEvent.js';\nimport * as dnd from './treeDnd.js';\nimport { ArrayIterator, MappedIterator } from '../../../common/iterator.js';\nimport { ScrollableElement } from '../../../browser/ui/scrollbar/scrollableElement.js';\nimport { HeightMap } from './treeViewModel.js';\nimport * as _ from './tree.js';\nimport { Emitter } from '../../../common/event.js';\nimport { DataTransfers, StaticDND } from '../../../browser/dnd.js';\nimport { DefaultTreestyler } from './treeDefaults.js';\nimport { Delayer, timeout } from '../../../common/async.js';\n\nfunction removeFromParent(element) {\n  try {\n    element.parentElement.removeChild(element);\n  } catch (e) {// this will throw if this happens due to a blur event, nasty business\n  }\n}\n\nvar RowCache =\n/** @class */\nfunction () {\n  function RowCache(context) {\n    this.context = context;\n    this._cache = {\n      '': []\n    };\n  }\n\n  RowCache.prototype.alloc = function (templateId) {\n    var result = this.cache(templateId).pop();\n\n    if (!result) {\n      var content = document.createElement('div');\n      content.className = 'content';\n      var row = document.createElement('div');\n      row.appendChild(content);\n      var templateData = null;\n\n      try {\n        templateData = this.context.renderer.renderTemplate(this.context.tree, templateId, content);\n      } catch (err) {\n        console.error('Tree usage error: exception while rendering template');\n        console.error(err);\n      }\n\n      result = {\n        element: row,\n        templateId: templateId,\n        templateData: templateData\n      };\n    }\n\n    return result;\n  };\n\n  RowCache.prototype.release = function (templateId, row) {\n    removeFromParent(row.element);\n    this.cache(templateId).push(row);\n  };\n\n  RowCache.prototype.cache = function (templateId) {\n    return this._cache[templateId] || (this._cache[templateId] = []);\n  };\n\n  RowCache.prototype.garbageCollect = function () {\n    var _this = this;\n\n    if (this._cache) {\n      Object.keys(this._cache).forEach(function (templateId) {\n        _this._cache[templateId].forEach(function (cachedRow) {\n          _this.context.renderer.disposeTemplate(_this.context.tree, templateId, cachedRow.templateData);\n\n          cachedRow.element = null;\n          cachedRow.templateData = null;\n        });\n\n        delete _this._cache[templateId];\n      });\n    }\n  };\n\n  RowCache.prototype.dispose = function () {\n    this.garbageCollect();\n    this._cache = null;\n  };\n\n  return RowCache;\n}();\n\nexport { RowCache };\n\nvar ViewItem =\n/** @class */\nfunction () {\n  function ViewItem(context, model) {\n    var _this = this;\n\n    this.width = 0;\n    this.needsRender = false;\n    this.uri = null;\n    this.unbindDragStart = Lifecycle.Disposable.None;\n    this._draggable = false;\n    this.context = context;\n    this.model = model;\n    this.id = this.model.id;\n    this.row = null;\n    this.top = 0;\n    this.height = model.getHeight();\n    this._styles = {};\n    model.getAllTraits().forEach(function (t) {\n      return _this._styles[t] = true;\n    });\n\n    if (model.isExpanded()) {\n      this.addClass('expanded');\n    }\n  }\n\n  Object.defineProperty(ViewItem.prototype, \"expanded\", {\n    set: function (value) {\n      value ? this.addClass('expanded') : this.removeClass('expanded');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ViewItem.prototype, \"loading\", {\n    set: function (value) {\n      value ? this.addClass('loading') : this.removeClass('loading');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ViewItem.prototype, \"draggable\", {\n    get: function () {\n      return this._draggable;\n    },\n    set: function (value) {\n      this._draggable = value;\n      this.render(true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ViewItem.prototype, \"dropTarget\", {\n    set: function (value) {\n      value ? this.addClass('drop-target') : this.removeClass('drop-target');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ViewItem.prototype, \"element\", {\n    get: function () {\n      return this.row && this.row.element;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ViewItem.prototype, \"templateId\", {\n    get: function () {\n      return this._templateId || (this._templateId = this.context.renderer.getTemplateId && this.context.renderer.getTemplateId(this.context.tree, this.model.getElement()));\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ViewItem.prototype.addClass = function (name) {\n    this._styles[name] = true;\n    this.render(true);\n  };\n\n  ViewItem.prototype.removeClass = function (name) {\n    delete this._styles[name]; // is this slow?\n\n    this.render(true);\n  };\n\n  ViewItem.prototype.render = function (skipUserRender) {\n    var _this = this;\n\n    if (skipUserRender === void 0) {\n      skipUserRender = false;\n    }\n\n    if (!this.model || !this.element) {\n      return;\n    }\n\n    var classes = ['monaco-tree-row'];\n    classes.push.apply(classes, Object.keys(this._styles));\n\n    if (this.model.hasChildren()) {\n      classes.push('has-children');\n    }\n\n    this.element.className = classes.join(' ');\n    this.element.draggable = this.draggable;\n    this.element.style.height = this.height + 'px'; // ARIA\n\n    this.element.setAttribute('role', 'treeitem');\n    var accessibility = this.context.accessibilityProvider;\n    var ariaLabel = accessibility.getAriaLabel(this.context.tree, this.model.getElement());\n\n    if (ariaLabel) {\n      this.element.setAttribute('aria-label', ariaLabel);\n    }\n\n    if (accessibility.getPosInSet && accessibility.getSetSize) {\n      this.element.setAttribute('aria-setsize', accessibility.getSetSize());\n      this.element.setAttribute('aria-posinset', accessibility.getPosInSet(this.context.tree, this.model.getElement()));\n    }\n\n    if (this.model.hasTrait('focused')) {\n      var base64Id = strings.safeBtoa(this.model.id);\n      this.element.setAttribute('aria-selected', 'true');\n      this.element.setAttribute('id', base64Id);\n    } else {\n      this.element.setAttribute('aria-selected', 'false');\n      this.element.removeAttribute('id');\n    }\n\n    if (this.model.hasChildren()) {\n      this.element.setAttribute('aria-expanded', String(!!this._styles['expanded']));\n    } else {\n      this.element.removeAttribute('aria-expanded');\n    }\n\n    this.element.setAttribute('aria-level', String(this.model.getDepth()));\n\n    if (this.context.options.paddingOnRow) {\n      this.element.style.paddingLeft = this.context.options.twistiePixels + (this.model.getDepth() - 1) * this.context.options.indentPixels + 'px';\n    } else {\n      this.element.style.paddingLeft = (this.model.getDepth() - 1) * this.context.options.indentPixels + 'px';\n      this.row.element.firstElementChild.style.paddingLeft = this.context.options.twistiePixels + 'px';\n    }\n\n    var uri = this.context.dnd.getDragURI(this.context.tree, this.model.getElement());\n\n    if (uri !== this.uri) {\n      if (this.unbindDragStart) {\n        this.unbindDragStart.dispose();\n      }\n\n      if (uri) {\n        this.uri = uri;\n        this.draggable = true;\n        this.unbindDragStart = DOM.addDisposableListener(this.element, 'dragstart', function (e) {\n          _this.onDragStart(e);\n        });\n      } else {\n        this.uri = null;\n      }\n    }\n\n    if (!skipUserRender && this.element) {\n      var paddingLeft = 0;\n\n      if (this.context.horizontalScrolling) {\n        var style = window.getComputedStyle(this.element);\n        paddingLeft = parseFloat(style.paddingLeft);\n      }\n\n      if (this.context.horizontalScrolling) {\n        this.element.style.width = 'fit-content';\n      }\n\n      try {\n        this.context.renderer.renderElement(this.context.tree, this.model.getElement(), this.templateId, this.row.templateData);\n      } catch (err) {\n        console.error('Tree usage error: exception while rendering element');\n        console.error(err);\n      }\n\n      if (this.context.horizontalScrolling) {\n        this.width = DOM.getContentWidth(this.element) + paddingLeft;\n        this.element.style.width = '';\n      }\n    }\n  };\n\n  ViewItem.prototype.insertInDOM = function (container, afterElement) {\n    if (!this.row) {\n      this.row = this.context.cache.alloc(this.templateId); // used in reverse lookup from HTMLElement to Item\n\n      this.element[TreeView.BINDING] = this;\n    }\n\n    if (this.element.parentElement) {\n      return;\n    }\n\n    if (afterElement === null) {\n      container.appendChild(this.element);\n    } else {\n      try {\n        container.insertBefore(this.element, afterElement);\n      } catch (e) {\n        console.warn('Failed to locate previous tree element');\n        container.appendChild(this.element);\n      }\n    }\n\n    this.render();\n  };\n\n  ViewItem.prototype.removeFromDOM = function () {\n    if (!this.row) {\n      return;\n    }\n\n    this.unbindDragStart.dispose();\n    this.uri = null;\n    this.element[TreeView.BINDING] = null;\n    this.context.cache.release(this.templateId, this.row);\n    this.row = null;\n  };\n\n  ViewItem.prototype.dispose = function () {\n    this.row = null;\n  };\n\n  return ViewItem;\n}();\n\nexport { ViewItem };\n\nvar RootViewItem =\n/** @class */\nfunction (_super) {\n  __extends(RootViewItem, _super);\n\n  function RootViewItem(context, model, wrapper) {\n    var _this = _super.call(this, context, model) || this;\n\n    _this.row = {\n      element: wrapper,\n      templateData: null,\n      templateId: null\n    };\n    return _this;\n  }\n\n  RootViewItem.prototype.render = function () {\n    if (!this.model || !this.element) {\n      return;\n    }\n\n    var classes = ['monaco-tree-wrapper'];\n    classes.push.apply(classes, Object.keys(this._styles));\n\n    if (this.model.hasChildren()) {\n      classes.push('has-children');\n    }\n\n    this.element.className = classes.join(' ');\n  };\n\n  RootViewItem.prototype.insertInDOM = function (container, afterElement) {// noop\n  };\n\n  RootViewItem.prototype.removeFromDOM = function () {// noop\n  };\n\n  return RootViewItem;\n}(ViewItem);\n\nfunction reactionEquals(one, other) {\n  if (!one && !other) {\n    return true;\n  } else if (!one || !other) {\n    return false;\n  } else if (one.accept !== other.accept) {\n    return false;\n  } else if (one.bubble !== other.bubble) {\n    return false;\n  } else if (one.effect !== other.effect) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nvar TreeView =\n/** @class */\nfunction (_super) {\n  __extends(TreeView, _super);\n\n  function TreeView(context, container) {\n    var _this = _super.call(this) || this;\n\n    _this.model = null;\n    _this.lastPointerType = '';\n    _this.lastClickTimeStamp = 0;\n    _this.contentWidthUpdateDelayer = new Delayer(50);\n    _this.isRefreshing = false;\n    _this.refreshingPreviousChildrenIds = {};\n    _this.currentDragAndDropData = null;\n    _this.currentDropTarget = null;\n    _this.currentDropTargets = null;\n    _this.currentDropDisposable = Lifecycle.Disposable.None;\n    _this.dragAndDropScrollInterval = null;\n    _this.dragAndDropScrollTimeout = null;\n    _this.dragAndDropMouseY = null;\n    _this.highlightedItemWasDraggable = false;\n    _this.onHiddenScrollTop = null;\n    _this._onDOMFocus = new Emitter();\n    _this.onDOMFocus = _this._onDOMFocus.event;\n    _this._onDOMBlur = new Emitter();\n    _this._onDidScroll = new Emitter();\n    TreeView.counter++;\n    _this.instance = TreeView.counter;\n    var horizontalScrollMode = typeof context.options.horizontalScrollMode === 'undefined' ? 2\n    /* Hidden */\n    : context.options.horizontalScrollMode;\n    _this.horizontalScrolling = horizontalScrollMode !== 2\n    /* Hidden */\n    ;\n    _this.context = {\n      dataSource: context.dataSource,\n      renderer: context.renderer,\n      controller: context.controller,\n      dnd: context.dnd,\n      filter: context.filter,\n      sorter: context.sorter,\n      tree: context.tree,\n      accessibilityProvider: context.accessibilityProvider,\n      options: context.options,\n      cache: new RowCache(context),\n      horizontalScrolling: _this.horizontalScrolling\n    };\n    _this.modelListeners = [];\n    _this.viewListeners = [];\n    _this.items = {};\n    _this.domNode = document.createElement('div');\n    _this.domNode.className = \"monaco-tree no-focused-item monaco-tree-instance-\" + _this.instance; // to allow direct tabbing into the tree instead of first focusing the tree\n\n    _this.domNode.tabIndex = context.options.preventRootFocus ? -1 : 0;\n    _this.styleElement = DOM.createStyleSheet(_this.domNode);\n    _this.treeStyler = context.styler || new DefaultTreestyler(_this.styleElement, \"monaco-tree-instance-\" + _this.instance); // ARIA\n\n    _this.domNode.setAttribute('role', 'tree');\n\n    if (_this.context.options.ariaLabel) {\n      _this.domNode.setAttribute('aria-label', _this.context.options.ariaLabel);\n    }\n\n    if (_this.context.options.alwaysFocused) {\n      DOM.addClass(_this.domNode, 'focused');\n    }\n\n    if (!_this.context.options.paddingOnRow) {\n      DOM.addClass(_this.domNode, 'no-row-padding');\n    }\n\n    _this.wrapper = document.createElement('div');\n    _this.wrapper.className = 'monaco-tree-wrapper';\n    _this.scrollableElement = new ScrollableElement(_this.wrapper, {\n      alwaysConsumeMouseWheel: true,\n      horizontal: horizontalScrollMode,\n      vertical: typeof context.options.verticalScrollMode !== 'undefined' ? context.options.verticalScrollMode : 1\n      /* Auto */\n      ,\n      useShadows: context.options.useShadows\n    });\n\n    _this.scrollableElement.onScroll(function (e) {\n      _this.render(e.scrollTop, e.height, e.scrollLeft, e.width, e.scrollWidth);\n\n      _this._onDidScroll.fire();\n    });\n\n    if (Browser.isIE) {\n      _this.wrapper.style.msTouchAction = 'none';\n      _this.wrapper.style.msContentZooming = 'none';\n    } else {\n      Touch.Gesture.addTarget(_this.wrapper);\n    }\n\n    _this.rowsContainer = document.createElement('div');\n    _this.rowsContainer.className = 'monaco-tree-rows';\n\n    if (context.options.showTwistie) {\n      _this.rowsContainer.className += ' show-twisties';\n    }\n\n    var focusTracker = DOM.trackFocus(_this.domNode);\n\n    _this.viewListeners.push(focusTracker.onDidFocus(function () {\n      return _this.onFocus();\n    }));\n\n    _this.viewListeners.push(focusTracker.onDidBlur(function () {\n      return _this.onBlur();\n    }));\n\n    _this.viewListeners.push(focusTracker);\n\n    _this.viewListeners.push(DOM.addDisposableListener(_this.domNode, 'keydown', function (e) {\n      return _this.onKeyDown(e);\n    }));\n\n    _this.viewListeners.push(DOM.addDisposableListener(_this.domNode, 'keyup', function (e) {\n      return _this.onKeyUp(e);\n    }));\n\n    _this.viewListeners.push(DOM.addDisposableListener(_this.domNode, 'mousedown', function (e) {\n      return _this.onMouseDown(e);\n    }));\n\n    _this.viewListeners.push(DOM.addDisposableListener(_this.domNode, 'mouseup', function (e) {\n      return _this.onMouseUp(e);\n    }));\n\n    _this.viewListeners.push(DOM.addDisposableListener(_this.wrapper, 'auxclick', function (e) {\n      if (e && e.button === 1) {\n        _this.onMouseMiddleClick(e);\n      }\n    }));\n\n    _this.viewListeners.push(DOM.addDisposableListener(_this.wrapper, 'click', function (e) {\n      return _this.onClick(e);\n    }));\n\n    _this.viewListeners.push(DOM.addDisposableListener(_this.domNode, 'contextmenu', function (e) {\n      return _this.onContextMenu(e);\n    }));\n\n    _this.viewListeners.push(DOM.addDisposableListener(_this.wrapper, Touch.EventType.Tap, function (e) {\n      return _this.onTap(e);\n    }));\n\n    _this.viewListeners.push(DOM.addDisposableListener(_this.wrapper, Touch.EventType.Change, function (e) {\n      return _this.onTouchChange(e);\n    }));\n\n    if (Browser.isIE) {\n      _this.viewListeners.push(DOM.addDisposableListener(_this.wrapper, 'MSPointerDown', function (e) {\n        return _this.onMsPointerDown(e);\n      }));\n\n      _this.viewListeners.push(DOM.addDisposableListener(_this.wrapper, 'MSGestureTap', function (e) {\n        return _this.onMsGestureTap(e);\n      })); // these events come too fast, we throttle them\n\n\n      _this.viewListeners.push(DOM.addDisposableThrottledListener(_this.wrapper, 'MSGestureChange', function (e) {\n        return _this.onThrottledMsGestureChange(e);\n      }, function (lastEvent, event) {\n        event.stopPropagation();\n        event.preventDefault();\n        var result = {\n          translationY: event.translationY,\n          translationX: event.translationX\n        };\n\n        if (lastEvent) {\n          result.translationY += lastEvent.translationY;\n          result.translationX += lastEvent.translationX;\n        }\n\n        return result;\n      }));\n    }\n\n    _this.viewListeners.push(DOM.addDisposableListener(window, 'dragover', function (e) {\n      return _this.onDragOver(e);\n    }));\n\n    _this.viewListeners.push(DOM.addDisposableListener(_this.wrapper, 'drop', function (e) {\n      return _this.onDrop(e);\n    }));\n\n    _this.viewListeners.push(DOM.addDisposableListener(window, 'dragend', function (e) {\n      return _this.onDragEnd(e);\n    }));\n\n    _this.viewListeners.push(DOM.addDisposableListener(window, 'dragleave', function (e) {\n      return _this.onDragOver(e);\n    }));\n\n    _this.wrapper.appendChild(_this.rowsContainer);\n\n    _this.domNode.appendChild(_this.scrollableElement.getDomNode());\n\n    container.appendChild(_this.domNode);\n    _this.lastRenderTop = 0;\n    _this.lastRenderHeight = 0;\n    _this.didJustPressContextMenuKey = false;\n    _this.currentDropTarget = null;\n    _this.currentDropTargets = [];\n    _this.shouldInvalidateDropReaction = false;\n    _this.dragAndDropScrollInterval = null;\n    _this.dragAndDropScrollTimeout = null;\n\n    _this.onRowsChanged();\n\n    _this.layout();\n\n    _this.setupMSGesture();\n\n    _this.applyStyles(context.options);\n\n    return _this;\n  }\n\n  TreeView.prototype.applyStyles = function (styles) {\n    this.treeStyler.style(styles);\n  };\n\n  TreeView.prototype.createViewItem = function (item) {\n    return new ViewItem(this.context, item);\n  };\n\n  TreeView.prototype.getHTMLElement = function () {\n    return this.domNode;\n  };\n\n  TreeView.prototype.focus = function () {\n    this.domNode.focus();\n  };\n\n  TreeView.prototype.isFocused = function () {\n    return document.activeElement === this.domNode;\n  };\n\n  TreeView.prototype.blur = function () {\n    this.domNode.blur();\n  };\n\n  TreeView.prototype.setupMSGesture = function () {\n    var _this = this;\n\n    if (window.MSGesture) {\n      this.msGesture = new MSGesture();\n      setTimeout(function () {\n        return _this.msGesture.target = _this.wrapper;\n      }, 100); // TODO@joh, TODO@IETeam\n    }\n  };\n\n  TreeView.prototype.isTreeVisible = function () {\n    return this.onHiddenScrollTop === null;\n  };\n\n  TreeView.prototype.layout = function (height, width) {\n    if (!this.isTreeVisible()) {\n      return;\n    }\n\n    this.viewHeight = height || DOM.getContentHeight(this.wrapper); // render\n\n    this.scrollHeight = this.getContentHeight();\n\n    if (this.horizontalScrolling) {\n      this.viewWidth = width || DOM.getContentWidth(this.wrapper);\n    }\n  };\n\n  TreeView.prototype.render = function (scrollTop, viewHeight, scrollLeft, viewWidth, scrollWidth) {\n    var i;\n    var stop;\n    var renderTop = scrollTop;\n    var renderBottom = scrollTop + viewHeight;\n    var thisRenderBottom = this.lastRenderTop + this.lastRenderHeight; // when view scrolls down, start rendering from the renderBottom\n\n    for (i = this.indexAfter(renderBottom) - 1, stop = this.indexAt(Math.max(thisRenderBottom, renderTop)); i >= stop; i--) {\n      this.insertItemInDOM(this.itemAtIndex(i));\n    } // when view scrolls up, start rendering from either this.renderTop or renderBottom\n\n\n    for (i = Math.min(this.indexAt(this.lastRenderTop), this.indexAfter(renderBottom)) - 1, stop = this.indexAt(renderTop); i >= stop; i--) {\n      this.insertItemInDOM(this.itemAtIndex(i));\n    } // when view scrolls down, start unrendering from renderTop\n\n\n    for (i = this.indexAt(this.lastRenderTop), stop = Math.min(this.indexAt(renderTop), this.indexAfter(thisRenderBottom)); i < stop; i++) {\n      this.removeItemFromDOM(this.itemAtIndex(i));\n    } // when view scrolls up, start unrendering from either renderBottom this.renderTop\n\n\n    for (i = Math.max(this.indexAfter(renderBottom), this.indexAt(this.lastRenderTop)), stop = this.indexAfter(thisRenderBottom); i < stop; i++) {\n      this.removeItemFromDOM(this.itemAtIndex(i));\n    }\n\n    var topItem = this.itemAtIndex(this.indexAt(renderTop));\n\n    if (topItem) {\n      this.rowsContainer.style.top = topItem.top - renderTop + 'px';\n    }\n\n    if (this.horizontalScrolling) {\n      this.rowsContainer.style.left = -scrollLeft + 'px';\n      this.rowsContainer.style.width = Math.max(scrollWidth, viewWidth) + \"px\";\n    }\n\n    this.lastRenderTop = renderTop;\n    this.lastRenderHeight = renderBottom - renderTop;\n  };\n\n  TreeView.prototype.setModel = function (newModel) {\n    this.releaseModel();\n    this.model = newModel;\n    this.model.onRefresh(this.onRefreshing, this, this.modelListeners);\n    this.model.onDidRefresh(this.onRefreshed, this, this.modelListeners);\n    this.model.onSetInput(this.onClearingInput, this, this.modelListeners);\n    this.model.onDidSetInput(this.onSetInput, this, this.modelListeners);\n    this.model.onDidFocus(this.onModelFocusChange, this, this.modelListeners);\n    this.model.onRefreshItemChildren(this.onItemChildrenRefreshing, this, this.modelListeners);\n    this.model.onDidRefreshItemChildren(this.onItemChildrenRefreshed, this, this.modelListeners);\n    this.model.onDidRefreshItem(this.onItemRefresh, this, this.modelListeners);\n    this.model.onExpandItem(this.onItemExpanding, this, this.modelListeners);\n    this.model.onDidExpandItem(this.onItemExpanded, this, this.modelListeners);\n    this.model.onCollapseItem(this.onItemCollapsing, this, this.modelListeners);\n    this.model.onDidRevealItem(this.onItemReveal, this, this.modelListeners);\n    this.model.onDidAddTraitItem(this.onItemAddTrait, this, this.modelListeners);\n    this.model.onDidRemoveTraitItem(this.onItemRemoveTrait, this, this.modelListeners);\n  };\n\n  TreeView.prototype.onRefreshing = function () {\n    this.isRefreshing = true;\n  };\n\n  TreeView.prototype.onRefreshed = function () {\n    this.isRefreshing = false;\n    this.onRowsChanged();\n  };\n\n  TreeView.prototype.onRowsChanged = function (scrollTop) {\n    if (scrollTop === void 0) {\n      scrollTop = this.scrollTop;\n    }\n\n    if (this.isRefreshing) {\n      return;\n    }\n\n    this.scrollTop = scrollTop;\n    this.updateScrollWidth();\n  };\n\n  TreeView.prototype.updateScrollWidth = function () {\n    var _this = this;\n\n    if (!this.horizontalScrolling) {\n      return;\n    }\n\n    this.contentWidthUpdateDelayer.trigger(function () {\n      var keys = Object.keys(_this.items);\n      var scrollWidth = 0;\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n        scrollWidth = Math.max(scrollWidth, _this.items[key].width);\n      }\n\n      _this.scrollWidth = scrollWidth + 10\n      /* scrollbar */\n      ;\n    });\n  };\n\n  TreeView.prototype.focusNextPage = function (eventPayload) {\n    var _this = this;\n\n    var lastPageIndex = this.indexAt(this.scrollTop + this.viewHeight);\n    lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;\n    var lastPageElement = this.itemAtIndex(lastPageIndex).model.getElement();\n    var currentlyFocusedElement = this.model.getFocus();\n\n    if (currentlyFocusedElement !== lastPageElement) {\n      this.model.setFocus(lastPageElement, eventPayload);\n    } else {\n      var previousScrollTop = this.scrollTop;\n      this.scrollTop += this.viewHeight;\n\n      if (this.scrollTop !== previousScrollTop) {\n        // Let the scroll event listener run\n        setTimeout(function () {\n          _this.focusNextPage(eventPayload);\n        }, 0);\n      }\n    }\n  };\n\n  TreeView.prototype.focusPreviousPage = function (eventPayload) {\n    var _this = this;\n\n    var firstPageIndex;\n\n    if (this.scrollTop === 0) {\n      firstPageIndex = this.indexAt(this.scrollTop);\n    } else {\n      firstPageIndex = this.indexAfter(this.scrollTop - 1);\n    }\n\n    var firstPageElement = this.itemAtIndex(firstPageIndex).model.getElement();\n    var currentlyFocusedElement = this.model.getFocus();\n\n    if (currentlyFocusedElement !== firstPageElement) {\n      this.model.setFocus(firstPageElement, eventPayload);\n    } else {\n      var previousScrollTop = this.scrollTop;\n      this.scrollTop -= this.viewHeight;\n\n      if (this.scrollTop !== previousScrollTop) {\n        // Let the scroll event listener run\n        setTimeout(function () {\n          _this.focusPreviousPage(eventPayload);\n        }, 0);\n      }\n    }\n  };\n\n  Object.defineProperty(TreeView.prototype, \"viewHeight\", {\n    get: function () {\n      var scrollDimensions = this.scrollableElement.getScrollDimensions();\n      return scrollDimensions.height;\n    },\n    set: function (height) {\n      this.scrollableElement.setScrollDimensions({\n        height: height\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeView.prototype, \"scrollHeight\", {\n    set: function (scrollHeight) {\n      scrollHeight = scrollHeight + (this.horizontalScrolling ? 10 : 0);\n      this.scrollableElement.setScrollDimensions({\n        scrollHeight: scrollHeight\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeView.prototype, \"viewWidth\", {\n    get: function () {\n      var scrollDimensions = this.scrollableElement.getScrollDimensions();\n      return scrollDimensions.width;\n    },\n    set: function (viewWidth) {\n      this.scrollableElement.setScrollDimensions({\n        width: viewWidth\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeView.prototype, \"scrollWidth\", {\n    set: function (scrollWidth) {\n      this.scrollableElement.setScrollDimensions({\n        scrollWidth: scrollWidth\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeView.prototype, \"scrollTop\", {\n    get: function () {\n      var scrollPosition = this.scrollableElement.getScrollPosition();\n      return scrollPosition.scrollTop;\n    },\n    set: function (scrollTop) {\n      var scrollHeight = this.getContentHeight() + (this.horizontalScrolling ? 10 : 0);\n      this.scrollableElement.setScrollDimensions({\n        scrollHeight: scrollHeight\n      });\n      this.scrollableElement.setScrollPosition({\n        scrollTop: scrollTop\n      });\n    },\n    enumerable: true,\n    configurable: true\n  }); // Events\n\n  TreeView.prototype.onClearingInput = function (e) {\n    var item = e.item;\n\n    if (item) {\n      this.onRemoveItems(new MappedIterator(item.getNavigator(), function (item) {\n        return item && item.id;\n      }));\n      this.onRowsChanged();\n    }\n  };\n\n  TreeView.prototype.onSetInput = function (e) {\n    this.context.cache.garbageCollect();\n    this.inputItem = new RootViewItem(this.context, e.item, this.wrapper);\n  };\n\n  TreeView.prototype.onItemChildrenRefreshing = function (e) {\n    var item = e.item;\n    var viewItem = this.items[item.id];\n\n    if (viewItem && this.context.options.showLoading) {\n      viewItem.loadingTimer = setTimeout(function () {\n        viewItem.loadingTimer = 0;\n        viewItem.loading = true;\n      }, TreeView.LOADING_DECORATION_DELAY);\n    }\n\n    if (!e.isNested) {\n      var childrenIds = [];\n      var navigator_1 = item.getNavigator();\n      var childItem = void 0;\n\n      while (childItem = navigator_1.next()) {\n        childrenIds.push(childItem.id);\n      }\n\n      this.refreshingPreviousChildrenIds[item.id] = childrenIds;\n    }\n  };\n\n  TreeView.prototype.onItemChildrenRefreshed = function (e) {\n    var _this = this;\n\n    var item = e.item;\n    var viewItem = this.items[item.id];\n\n    if (viewItem) {\n      if (viewItem.loadingTimer) {\n        clearTimeout(viewItem.loadingTimer);\n        viewItem.loadingTimer = 0;\n      }\n\n      viewItem.loading = false;\n    }\n\n    if (!e.isNested) {\n      var previousChildrenIds_1 = this.refreshingPreviousChildrenIds[item.id];\n      var afterModelItems_1 = [];\n      var navigator_2 = item.getNavigator();\n      var childItem = void 0;\n\n      while (childItem = navigator_2.next()) {\n        afterModelItems_1.push(childItem);\n      }\n\n      var skipDiff = Math.abs(previousChildrenIds_1.length - afterModelItems_1.length) > 1000;\n      var diff = [];\n      var doToInsertItemsAlreadyExist = false;\n\n      if (!skipDiff) {\n        var lcs = new Diff.LcsDiff({\n          getLength: function () {\n            return previousChildrenIds_1.length;\n          },\n          getElementAtIndex: function (i) {\n            return previousChildrenIds_1[i];\n          }\n        }, {\n          getLength: function () {\n            return afterModelItems_1.length;\n          },\n          getElementAtIndex: function (i) {\n            return afterModelItems_1[i].id;\n          }\n        }, null);\n        diff = lcs.ComputeDiff(false); // this means that the result of the diff algorithm would result\n        // in inserting items that were already registered. this can only\n        // happen if the data provider returns bad ids OR if the sorting\n        // of the elements has changed\n\n        doToInsertItemsAlreadyExist = diff.some(function (d) {\n          if (d.modifiedLength > 0) {\n            for (var i = d.modifiedStart, len = d.modifiedStart + d.modifiedLength; i < len; i++) {\n              if (_this.items.hasOwnProperty(afterModelItems_1[i].id)) {\n                return true;\n              }\n            }\n          }\n\n          return false;\n        });\n      } // 50 is an optimization number, at some point we're better off\n      // just replacing everything\n\n\n      if (!skipDiff && !doToInsertItemsAlreadyExist && diff.length < 50) {\n        for (var _i = 0, diff_1 = diff; _i < diff_1.length; _i++) {\n          var diffChange = diff_1[_i];\n\n          if (diffChange.originalLength > 0) {\n            this.onRemoveItems(new ArrayIterator(previousChildrenIds_1, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength));\n          }\n\n          if (diffChange.modifiedLength > 0) {\n            var beforeItem = afterModelItems_1[diffChange.modifiedStart - 1] || item;\n            beforeItem = beforeItem.getDepth() > 0 ? beforeItem : null;\n            this.onInsertItems(new ArrayIterator(afterModelItems_1, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength), beforeItem ? beforeItem.id : null);\n          }\n        }\n      } else if (skipDiff || diff.length) {\n        this.onRemoveItems(new ArrayIterator(previousChildrenIds_1));\n        this.onInsertItems(new ArrayIterator(afterModelItems_1), item.getDepth() > 0 ? item.id : null);\n      }\n\n      if (skipDiff || diff.length) {\n        this.onRowsChanged();\n      }\n    }\n  };\n\n  TreeView.prototype.onItemRefresh = function (item) {\n    this.onItemsRefresh([item]);\n  };\n\n  TreeView.prototype.onItemsRefresh = function (items) {\n    var _this = this;\n\n    this.onRefreshItemSet(items.filter(function (item) {\n      return _this.items.hasOwnProperty(item.id);\n    }));\n    this.onRowsChanged();\n  };\n\n  TreeView.prototype.onItemExpanding = function (e) {\n    var viewItem = this.items[e.item.id];\n\n    if (viewItem) {\n      viewItem.expanded = true;\n    }\n  };\n\n  TreeView.prototype.onItemExpanded = function (e) {\n    var item = e.item;\n    var viewItem = this.items[item.id];\n\n    if (viewItem) {\n      viewItem.expanded = true;\n      var height = this.onInsertItems(item.getNavigator(), item.id) || 0;\n      var scrollTop = this.scrollTop;\n\n      if (viewItem.top + viewItem.height <= this.scrollTop) {\n        scrollTop += height;\n      }\n\n      this.onRowsChanged(scrollTop);\n    }\n  };\n\n  TreeView.prototype.onItemCollapsing = function (e) {\n    var item = e.item;\n    var viewItem = this.items[item.id];\n\n    if (viewItem) {\n      viewItem.expanded = false;\n      this.onRemoveItems(new MappedIterator(item.getNavigator(), function (item) {\n        return item && item.id;\n      }));\n      this.onRowsChanged();\n    }\n  };\n\n  TreeView.prototype.onItemReveal = function (e) {\n    var item = e.item;\n    var relativeTop = e.relativeTop;\n    var viewItem = this.items[item.id];\n\n    if (viewItem) {\n      if (relativeTop !== null) {\n        relativeTop = relativeTop < 0 ? 0 : relativeTop;\n        relativeTop = relativeTop > 1 ? 1 : relativeTop; // y = mx + b\n\n        var m = viewItem.height - this.viewHeight;\n        this.scrollTop = m * relativeTop + viewItem.top;\n      } else {\n        var viewItemBottom = viewItem.top + viewItem.height;\n        var wrapperBottom = this.scrollTop + this.viewHeight;\n\n        if (viewItem.top < this.scrollTop) {\n          this.scrollTop = viewItem.top;\n        } else if (viewItemBottom >= wrapperBottom) {\n          this.scrollTop = viewItemBottom - this.viewHeight;\n        }\n      }\n    }\n  };\n\n  TreeView.prototype.onItemAddTrait = function (e) {\n    var item = e.item;\n    var trait = e.trait;\n    var viewItem = this.items[item.id];\n\n    if (viewItem) {\n      viewItem.addClass(trait);\n    }\n\n    if (trait === 'highlighted') {\n      DOM.addClass(this.domNode, trait); // Ugly Firefox fix: input fields can't be selected if parent nodes are draggable\n\n      if (viewItem) {\n        this.highlightedItemWasDraggable = !!viewItem.draggable;\n\n        if (viewItem.draggable) {\n          viewItem.draggable = false;\n        }\n      }\n    }\n  };\n\n  TreeView.prototype.onItemRemoveTrait = function (e) {\n    var item = e.item;\n    var trait = e.trait;\n    var viewItem = this.items[item.id];\n\n    if (viewItem) {\n      viewItem.removeClass(trait);\n    }\n\n    if (trait === 'highlighted') {\n      DOM.removeClass(this.domNode, trait); // Ugly Firefox fix: input fields can't be selected if parent nodes are draggable\n\n      if (this.highlightedItemWasDraggable) {\n        viewItem.draggable = true;\n      }\n\n      this.highlightedItemWasDraggable = false;\n    }\n  };\n\n  TreeView.prototype.onModelFocusChange = function () {\n    var focus = this.model && this.model.getFocus();\n    DOM.toggleClass(this.domNode, 'no-focused-item', !focus); // ARIA\n\n    if (focus) {\n      this.domNode.setAttribute('aria-activedescendant', strings.safeBtoa(this.context.dataSource.getId(this.context.tree, focus)));\n    } else {\n      this.domNode.removeAttribute('aria-activedescendant');\n    }\n  }; // HeightMap \"events\"\n\n\n  TreeView.prototype.onInsertItem = function (item) {\n    var _this = this;\n\n    item.onDragStart = function (e) {\n      _this.onDragStart(item, e);\n    };\n\n    item.needsRender = true;\n    this.refreshViewItem(item);\n    this.items[item.id] = item;\n  };\n\n  TreeView.prototype.onRefreshItem = function (item, needsRender) {\n    if (needsRender === void 0) {\n      needsRender = false;\n    }\n\n    item.needsRender = item.needsRender || needsRender;\n    this.refreshViewItem(item);\n  };\n\n  TreeView.prototype.onRemoveItem = function (item) {\n    this.removeItemFromDOM(item);\n    item.dispose();\n    delete this.items[item.id];\n  }; // ViewItem refresh\n\n\n  TreeView.prototype.refreshViewItem = function (item) {\n    item.render();\n\n    if (this.shouldBeRendered(item)) {\n      this.insertItemInDOM(item);\n    } else {\n      this.removeItemFromDOM(item);\n    }\n  }; // DOM Events\n\n\n  TreeView.prototype.onClick = function (e) {\n    if (this.lastPointerType && this.lastPointerType !== 'mouse') {\n      return;\n    }\n\n    var event = new Mouse.StandardMouseEvent(e);\n    var item = this.getItemAround(event.target);\n\n    if (!item) {\n      return;\n    }\n\n    if (Browser.isIE && Date.now() - this.lastClickTimeStamp < 300) {\n      // IE10+ doesn't set the detail property correctly. While IE10 simply\n      // counts the number of clicks, IE11 reports always 1. To align with\n      // other browser, we set the value to 2 if clicks events come in a 300ms\n      // sequence.\n      event.detail = 2;\n    }\n\n    this.lastClickTimeStamp = Date.now();\n    this.context.controller.onClick(this.context.tree, item.model.getElement(), event);\n  };\n\n  TreeView.prototype.onMouseMiddleClick = function (e) {\n    if (!this.context.controller.onMouseMiddleClick) {\n      return;\n    }\n\n    var event = new Mouse.StandardMouseEvent(e);\n    var item = this.getItemAround(event.target);\n\n    if (!item) {\n      return;\n    }\n\n    this.context.controller.onMouseMiddleClick(this.context.tree, item.model.getElement(), event);\n  };\n\n  TreeView.prototype.onMouseDown = function (e) {\n    this.didJustPressContextMenuKey = false;\n\n    if (!this.context.controller.onMouseDown) {\n      return;\n    }\n\n    if (this.lastPointerType && this.lastPointerType !== 'mouse') {\n      return;\n    }\n\n    var event = new Mouse.StandardMouseEvent(e);\n\n    if (event.ctrlKey && Platform.isNative && Platform.isMacintosh) {\n      return;\n    }\n\n    var item = this.getItemAround(event.target);\n\n    if (!item) {\n      return;\n    }\n\n    this.context.controller.onMouseDown(this.context.tree, item.model.getElement(), event);\n  };\n\n  TreeView.prototype.onMouseUp = function (e) {\n    if (!this.context.controller.onMouseUp) {\n      return;\n    }\n\n    if (this.lastPointerType && this.lastPointerType !== 'mouse') {\n      return;\n    }\n\n    var event = new Mouse.StandardMouseEvent(e);\n\n    if (event.ctrlKey && Platform.isNative && Platform.isMacintosh) {\n      return;\n    }\n\n    var item = this.getItemAround(event.target);\n\n    if (!item) {\n      return;\n    }\n\n    this.context.controller.onMouseUp(this.context.tree, item.model.getElement(), event);\n  };\n\n  TreeView.prototype.onTap = function (e) {\n    var item = this.getItemAround(e.initialTarget);\n\n    if (!item) {\n      return;\n    }\n\n    this.context.controller.onTap(this.context.tree, item.model.getElement(), e);\n  };\n\n  TreeView.prototype.onTouchChange = function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    this.scrollTop -= event.translationY;\n  };\n\n  TreeView.prototype.onContextMenu = function (event) {\n    var resultEvent;\n    var element;\n\n    if (event instanceof KeyboardEvent || this.didJustPressContextMenuKey) {\n      this.didJustPressContextMenuKey = false;\n      var keyboardEvent = new Keyboard.StandardKeyboardEvent(event);\n      element = this.model.getFocus();\n      var position = void 0;\n\n      if (!element) {\n        element = this.model.getInput();\n        position = DOM.getDomNodePagePosition(this.inputItem.element);\n      } else {\n        var id = this.context.dataSource.getId(this.context.tree, element);\n        var viewItem = this.items[id];\n        position = DOM.getDomNodePagePosition(viewItem.element);\n      }\n\n      resultEvent = new _.KeyboardContextMenuEvent(position.left + position.width, position.top, keyboardEvent);\n    } else {\n      var mouseEvent = new Mouse.StandardMouseEvent(event);\n      var item = this.getItemAround(mouseEvent.target);\n\n      if (!item) {\n        return;\n      }\n\n      element = item.model.getElement();\n      resultEvent = new _.MouseContextMenuEvent(mouseEvent);\n    }\n\n    this.context.controller.onContextMenu(this.context.tree, element, resultEvent);\n  };\n\n  TreeView.prototype.onKeyDown = function (e) {\n    var event = new Keyboard.StandardKeyboardEvent(e);\n    this.didJustPressContextMenuKey = event.keyCode === 58\n    /* ContextMenu */\n    || event.shiftKey && event.keyCode === 68\n    /* F10 */\n    ;\n\n    if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {\n      return; // Ignore event if target is a form input field (avoids browser specific issues)\n    }\n\n    if (this.didJustPressContextMenuKey) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    this.context.controller.onKeyDown(this.context.tree, event);\n  };\n\n  TreeView.prototype.onKeyUp = function (e) {\n    if (this.didJustPressContextMenuKey) {\n      this.onContextMenu(e);\n    }\n\n    this.didJustPressContextMenuKey = false;\n    this.context.controller.onKeyUp(this.context.tree, new Keyboard.StandardKeyboardEvent(e));\n  };\n\n  TreeView.prototype.onDragStart = function (item, e) {\n    if (this.model.getHighlight()) {\n      return;\n    }\n\n    var element = item.model.getElement();\n    var selection = this.model.getSelection();\n    var elements;\n\n    if (selection.indexOf(element) > -1) {\n      elements = selection;\n    } else {\n      elements = [element];\n    }\n\n    e.dataTransfer.effectAllowed = 'copyMove';\n    e.dataTransfer.setData(DataTransfers.RESOURCES, JSON.stringify([item.uri]));\n\n    if (e.dataTransfer.setDragImage) {\n      var label = void 0;\n\n      if (this.context.dnd.getDragLabel) {\n        label = this.context.dnd.getDragLabel(this.context.tree, elements);\n      } else {\n        label = String(elements.length);\n      }\n\n      var dragImage_1 = document.createElement('div');\n      dragImage_1.className = 'monaco-tree-drag-image';\n      dragImage_1.textContent = label;\n      document.body.appendChild(dragImage_1);\n      e.dataTransfer.setDragImage(dragImage_1, -10, -10);\n      setTimeout(function () {\n        return document.body.removeChild(dragImage_1);\n      }, 0);\n    }\n\n    this.currentDragAndDropData = new dnd.ElementsDragAndDropData(elements);\n    StaticDND.CurrentDragAndDropData = new dnd.ExternalElementsDragAndDropData(elements);\n    this.context.dnd.onDragStart(this.context.tree, this.currentDragAndDropData, new Mouse.DragMouseEvent(e));\n  };\n\n  TreeView.prototype.setupDragAndDropScrollInterval = function () {\n    var _this = this;\n\n    var viewTop = DOM.getTopLeftOffset(this.wrapper).top;\n\n    if (!this.dragAndDropScrollInterval) {\n      this.dragAndDropScrollInterval = window.setInterval(function () {\n        if (_this.dragAndDropMouseY === null) {\n          return;\n        }\n\n        var diff = _this.dragAndDropMouseY - viewTop;\n        var scrollDiff = 0;\n        var upperLimit = _this.viewHeight - 35;\n\n        if (diff < 35) {\n          scrollDiff = Math.max(-14, 0.2 * (diff - 35));\n        } else if (diff > upperLimit) {\n          scrollDiff = Math.min(14, 0.2 * (diff - upperLimit));\n        }\n\n        _this.scrollTop += scrollDiff;\n      }, 10);\n      this.cancelDragAndDropScrollTimeout();\n      this.dragAndDropScrollTimeout = window.setTimeout(function () {\n        _this.cancelDragAndDropScrollInterval();\n\n        _this.dragAndDropScrollTimeout = null;\n      }, 1000);\n    }\n  };\n\n  TreeView.prototype.cancelDragAndDropScrollInterval = function () {\n    if (this.dragAndDropScrollInterval) {\n      window.clearInterval(this.dragAndDropScrollInterval);\n      this.dragAndDropScrollInterval = null;\n    }\n\n    this.cancelDragAndDropScrollTimeout();\n  };\n\n  TreeView.prototype.cancelDragAndDropScrollTimeout = function () {\n    if (this.dragAndDropScrollTimeout) {\n      window.clearTimeout(this.dragAndDropScrollTimeout);\n      this.dragAndDropScrollTimeout = null;\n    }\n  };\n\n  TreeView.prototype.onDragOver = function (e) {\n    var _this = this;\n\n    e.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)\n\n    var event = new Mouse.DragMouseEvent(e);\n    var viewItem = this.getItemAround(event.target);\n\n    if (!viewItem || event.posx === 0 && event.posy === 0 && event.browserEvent.type === DOM.EventType.DRAG_LEAVE) {\n      // dragging outside of tree\n      if (this.currentDropTarget) {\n        // clear previously hovered element feedback\n        this.currentDropTargets.forEach(function (i) {\n          return i.dropTarget = false;\n        });\n        this.currentDropTargets = [];\n        this.currentDropDisposable.dispose();\n      }\n\n      this.cancelDragAndDropScrollInterval();\n      this.currentDropTarget = null;\n      this.currentDropElement = null;\n      this.dragAndDropMouseY = null;\n      return false;\n    } // dragging inside the tree\n\n\n    this.setupDragAndDropScrollInterval();\n    this.dragAndDropMouseY = event.posy;\n\n    if (!this.currentDragAndDropData) {\n      // just started dragging\n      if (StaticDND.CurrentDragAndDropData) {\n        this.currentDragAndDropData = StaticDND.CurrentDragAndDropData;\n      } else {\n        if (!event.dataTransfer.types) {\n          return false;\n        }\n\n        this.currentDragAndDropData = new dnd.DesktopDragAndDropData();\n      }\n    }\n\n    this.currentDragAndDropData.update(event.browserEvent.dataTransfer);\n    var element;\n    var item = viewItem.model;\n    var reaction; // check the bubble up behavior\n\n    do {\n      element = item ? item.getElement() : this.model.getInput();\n      reaction = this.context.dnd.onDragOver(this.context.tree, this.currentDragAndDropData, element, event);\n\n      if (!reaction || reaction.bubble !== 1\n      /* BUBBLE_UP */\n      ) {\n          break;\n        }\n\n      item = item && item.parent;\n    } while (item);\n\n    if (!item) {\n      this.currentDropElement = null;\n      return false;\n    }\n\n    var canDrop = reaction && reaction.accept;\n\n    if (canDrop) {\n      this.currentDropElement = item.getElement();\n      event.preventDefault();\n      event.dataTransfer.dropEffect = reaction.effect === 0\n      /* COPY */\n      ? 'copy' : 'move';\n    } else {\n      this.currentDropElement = null;\n    } // item is the model item where drop() should be called\n    // can be null\n\n\n    var currentDropTarget = item.id === this.inputItem.id ? this.inputItem : this.items[item.id];\n\n    if (this.shouldInvalidateDropReaction || this.currentDropTarget !== currentDropTarget || !reactionEquals(this.currentDropElementReaction, reaction)) {\n      this.shouldInvalidateDropReaction = false;\n\n      if (this.currentDropTarget) {\n        this.currentDropTargets.forEach(function (i) {\n          return i.dropTarget = false;\n        });\n        this.currentDropTargets = [];\n        this.currentDropDisposable.dispose();\n      }\n\n      this.currentDropTarget = currentDropTarget;\n      this.currentDropElementReaction = reaction;\n\n      if (canDrop) {\n        // setup hover feedback for drop target\n        if (this.currentDropTarget) {\n          this.currentDropTarget.dropTarget = true;\n          this.currentDropTargets.push(this.currentDropTarget);\n        }\n\n        if (reaction.bubble === 0\n        /* BUBBLE_DOWN */\n        ) {\n            var nav = item.getNavigator();\n            var child = void 0;\n\n            while (child = nav.next()) {\n              viewItem = this.items[child.id];\n\n              if (viewItem) {\n                viewItem.dropTarget = true;\n                this.currentDropTargets.push(viewItem);\n              }\n            }\n          }\n\n        if (reaction.autoExpand) {\n          var timeoutPromise_1 = timeout(500);\n          this.currentDropDisposable = Lifecycle.toDisposable(function () {\n            return timeoutPromise_1.cancel();\n          });\n          timeoutPromise_1.then(function () {\n            return _this.context.tree.expand(_this.currentDropElement);\n          }).then(function () {\n            return _this.shouldInvalidateDropReaction = true;\n          });\n        }\n      }\n    }\n\n    return true;\n  };\n\n  TreeView.prototype.onDrop = function (e) {\n    if (this.currentDropElement) {\n      var event_1 = new Mouse.DragMouseEvent(e);\n      event_1.preventDefault();\n      this.currentDragAndDropData.update(event_1.browserEvent.dataTransfer);\n      this.context.dnd.drop(this.context.tree, this.currentDragAndDropData, this.currentDropElement, event_1);\n      this.onDragEnd(e);\n    }\n\n    this.cancelDragAndDropScrollInterval();\n  };\n\n  TreeView.prototype.onDragEnd = function (e) {\n    if (this.currentDropTarget) {\n      this.currentDropTargets.forEach(function (i) {\n        return i.dropTarget = false;\n      });\n      this.currentDropTargets = [];\n    }\n\n    this.currentDropDisposable.dispose();\n    this.cancelDragAndDropScrollInterval();\n    this.currentDragAndDropData = null;\n    StaticDND.CurrentDragAndDropData = undefined;\n    this.currentDropElement = null;\n    this.currentDropTarget = null;\n    this.dragAndDropMouseY = null;\n  };\n\n  TreeView.prototype.onFocus = function () {\n    if (!this.context.options.alwaysFocused) {\n      DOM.addClass(this.domNode, 'focused');\n    }\n\n    this._onDOMFocus.fire();\n  };\n\n  TreeView.prototype.onBlur = function () {\n    if (!this.context.options.alwaysFocused) {\n      DOM.removeClass(this.domNode, 'focused');\n    }\n\n    this.domNode.removeAttribute('aria-activedescendant'); // ARIA\n\n    this._onDOMBlur.fire();\n  }; // MS specific DOM Events\n\n\n  TreeView.prototype.onMsPointerDown = function (event) {\n    if (!this.msGesture) {\n      return;\n    } // Circumvent IE11 breaking change in e.pointerType & TypeScript's stale definitions\n\n\n    var pointerType = event.pointerType;\n\n    if (pointerType === (event.MSPOINTER_TYPE_MOUSE || 'mouse')) {\n      this.lastPointerType = 'mouse';\n      return;\n    } else if (pointerType === (event.MSPOINTER_TYPE_TOUCH || 'touch')) {\n      this.lastPointerType = 'touch';\n    } else {\n      return;\n    }\n\n    event.stopPropagation();\n    event.preventDefault();\n    this.msGesture.addPointer(event.pointerId);\n  };\n\n  TreeView.prototype.onThrottledMsGestureChange = function (event) {\n    this.scrollTop -= event.translationY;\n  };\n\n  TreeView.prototype.onMsGestureTap = function (event) {\n    event.initialTarget = document.elementFromPoint(event.clientX, event.clientY);\n    this.onTap(event);\n  }; // DOM changes\n\n\n  TreeView.prototype.insertItemInDOM = function (item) {\n    var elementAfter = null;\n    var itemAfter = this.itemAfter(item);\n\n    if (itemAfter && itemAfter.element) {\n      elementAfter = itemAfter.element;\n    }\n\n    item.insertInDOM(this.rowsContainer, elementAfter);\n  };\n\n  TreeView.prototype.removeItemFromDOM = function (item) {\n    if (!item) {\n      return;\n    }\n\n    item.removeFromDOM();\n  }; // Helpers\n\n\n  TreeView.prototype.shouldBeRendered = function (item) {\n    return item.top < this.lastRenderTop + this.lastRenderHeight && item.top + item.height > this.lastRenderTop;\n  };\n\n  TreeView.prototype.getItemAround = function (element) {\n    var candidate = this.inputItem;\n    var el = element;\n\n    do {\n      if (el[TreeView.BINDING]) {\n        candidate = el[TreeView.BINDING];\n      }\n\n      if (el === this.wrapper || el === this.domNode) {\n        return candidate;\n      }\n\n      if (el === this.scrollableElement.getDomNode() || el === document.body) {\n        return undefined;\n      }\n    } while (el = el.parentElement);\n\n    return undefined;\n  }; // Cleanup\n\n\n  TreeView.prototype.releaseModel = function () {\n    if (this.model) {\n      this.modelListeners = Lifecycle.dispose(this.modelListeners);\n      this.model = null;\n    }\n  };\n\n  TreeView.prototype.dispose = function () {\n    var _this = this; // TODO@joao: improve\n\n\n    this.scrollableElement.dispose();\n    this.releaseModel();\n    this.viewListeners = Lifecycle.dispose(this.viewListeners);\n\n    this._onDOMFocus.dispose();\n\n    this._onDOMBlur.dispose();\n\n    if (this.domNode.parentNode) {\n      this.domNode.parentNode.removeChild(this.domNode);\n    }\n\n    if (this.items) {\n      Object.keys(this.items).forEach(function (key) {\n        return _this.items[key].removeFromDOM();\n      });\n    }\n\n    if (this.context.cache) {\n      this.context.cache.dispose();\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n\n  TreeView.BINDING = 'monaco-tree-row';\n  TreeView.LOADING_DECORATION_DELAY = 800;\n  TreeView.counter = 0;\n  return TreeView;\n}(HeightMap);\n\nexport { TreeView };","map":null,"metadata":{},"sourceType":"module"}