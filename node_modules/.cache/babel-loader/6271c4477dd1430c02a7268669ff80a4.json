{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createScanner } from './htmlScanner.js';\nimport { findFirst } from '../utils/arrays.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\n\nvar Node =\n/** @class */\nfunction () {\n  function Node(start, end, children, parent) {\n    this.start = start;\n    this.end = end;\n    this.children = children;\n    this.parent = parent;\n    this.closed = false;\n  }\n\n  Object.defineProperty(Node.prototype, \"attributeNames\", {\n    get: function () {\n      return this.attributes ? Object.keys(this.attributes) : [];\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Node.prototype.isSameTag = function (tagInLowerCase) {\n    return this.tag && tagInLowerCase && this.tag.length === tagInLowerCase.length && this.tag.toLowerCase() === tagInLowerCase;\n  };\n\n  Object.defineProperty(Node.prototype, \"firstChild\", {\n    get: function () {\n      return this.children[0];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"lastChild\", {\n    get: function () {\n      return this.children.length ? this.children[this.children.length - 1] : void 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Node.prototype.findNodeBefore = function (offset) {\n    var idx = findFirst(this.children, function (c) {\n      return offset <= c.start;\n    }) - 1;\n\n    if (idx >= 0) {\n      var child = this.children[idx];\n\n      if (offset > child.start) {\n        if (offset < child.end) {\n          return child.findNodeBefore(offset);\n        }\n\n        var lastChild = child.lastChild;\n\n        if (lastChild && lastChild.end === child.end) {\n          return child.findNodeBefore(offset);\n        }\n\n        return child;\n      }\n    }\n\n    return this;\n  };\n\n  Node.prototype.findNodeAt = function (offset) {\n    var idx = findFirst(this.children, function (c) {\n      return offset <= c.start;\n    }) - 1;\n\n    if (idx >= 0) {\n      var child = this.children[idx];\n\n      if (offset > child.start && offset <= child.end) {\n        return child.findNodeAt(offset);\n      }\n    }\n\n    return this;\n  };\n\n  return Node;\n}();\n\nexport { Node };\nexport function parse(text) {\n  var scanner = createScanner(text);\n  var htmlDocument = new Node(0, text.length, [], void 0);\n  var curr = htmlDocument;\n  var endTagStart = -1;\n  var endTagName = null;\n  var pendingAttribute = null;\n  var token = scanner.scan();\n\n  while (token !== TokenType.EOS) {\n    switch (token) {\n      case TokenType.StartTagOpen:\n        var child = new Node(scanner.getTokenOffset(), text.length, [], curr);\n        curr.children.push(child);\n        curr = child;\n        break;\n\n      case TokenType.StartTag:\n        curr.tag = scanner.getTokenText();\n        break;\n\n      case TokenType.StartTagClose:\n        curr.end = scanner.getTokenEnd(); // might be later set to end tag position\n\n        curr.startTagEnd = scanner.getTokenEnd();\n\n        if (curr.tag && isVoidElement(curr.tag) && curr.parent) {\n          curr.closed = true;\n          curr = curr.parent;\n        }\n\n        break;\n\n      case TokenType.StartTagSelfClose:\n        if (curr.parent) {\n          curr.closed = true;\n          curr.end = scanner.getTokenEnd();\n          curr.startTagEnd = scanner.getTokenEnd();\n          curr = curr.parent;\n        }\n\n        break;\n\n      case TokenType.EndTagOpen:\n        endTagStart = scanner.getTokenOffset();\n        endTagName = null;\n        break;\n\n      case TokenType.EndTag:\n        endTagName = scanner.getTokenText().toLowerCase();\n        break;\n\n      case TokenType.EndTagClose:\n        if (endTagName) {\n          var node = curr; // see if we can find a matching tag\n\n          while (!node.isSameTag(endTagName) && node.parent) {\n            node = node.parent;\n          }\n\n          if (node.parent) {\n            while (curr !== node) {\n              curr.end = endTagStart;\n              curr.closed = false;\n              curr = curr.parent;\n            }\n\n            curr.closed = true;\n            curr.endTagStart = endTagStart;\n            curr.end = scanner.getTokenEnd();\n            curr = curr.parent;\n          }\n        }\n\n        break;\n\n      case TokenType.AttributeName:\n        {\n          pendingAttribute = scanner.getTokenText();\n          var attributes = curr.attributes;\n\n          if (!attributes) {\n            curr.attributes = attributes = {};\n          }\n\n          attributes[pendingAttribute] = null; // Support valueless attributes such as 'checked'\n\n          break;\n        }\n\n      case TokenType.AttributeValue:\n        {\n          var value = scanner.getTokenText();\n          var attributes = curr.attributes;\n\n          if (attributes && pendingAttribute) {\n            attributes[pendingAttribute] = value;\n            pendingAttribute = null;\n          }\n\n          break;\n        }\n    }\n\n    token = scanner.scan();\n  }\n\n  while (curr.parent) {\n    curr.end = text.length;\n    curr.closed = false;\n    curr = curr.parent;\n  }\n\n  return {\n    roots: htmlDocument.children,\n    findNodeBefore: htmlDocument.findNodeBefore.bind(htmlDocument),\n    findNodeAt: htmlDocument.findNodeAt.bind(htmlDocument)\n  };\n}","map":null,"metadata":{},"sourceType":"module"}