{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { TokenMetadata } from '../modes.js';\nexport function countEOL(text) {\n  var eolCount = 0;\n  var firstLineLength = 0;\n\n  for (var i = 0, len = text.length; i < len; i++) {\n    var chr = text.charCodeAt(i);\n\n    if (chr === 13\n    /* CarriageReturn */\n    ) {\n        if (eolCount === 0) {\n          firstLineLength = i;\n        }\n\n        eolCount++;\n\n        if (i + 1 < len && text.charCodeAt(i + 1) === 10\n        /* LineFeed */\n        ) {\n            // \\r\\n... case\n            i++; // skip \\n\n          } else {// \\r... case\n          }\n      } else if (chr === 10\n    /* LineFeed */\n    ) {\n        if (eolCount === 0) {\n          firstLineLength = i;\n        }\n\n        eolCount++;\n      }\n  }\n\n  if (eolCount === 0) {\n    firstLineLength = text.length;\n  }\n\n  return [eolCount, firstLineLength];\n}\n\nfunction getDefaultMetadata(topLevelLanguageId) {\n  return (topLevelLanguageId << 0\n  /* LANGUAGEID_OFFSET */\n  | 0\n  /* Other */\n  << 8\n  /* TOKEN_TYPE_OFFSET */\n  | 0\n  /* None */\n  << 11\n  /* FONT_STYLE_OFFSET */\n  | 1\n  /* DefaultForeground */\n  << 14\n  /* FOREGROUND_OFFSET */\n  | 2\n  /* DefaultBackground */\n  << 23\n  /* BACKGROUND_OFFSET */\n  ) >>> 0;\n}\n\nvar EMPTY_LINE_TOKENS = new Uint32Array(0).buffer;\n\nvar MultilineTokensBuilder =\n/** @class */\nfunction () {\n  function MultilineTokensBuilder() {\n    this.tokens = [];\n  }\n\n  MultilineTokensBuilder.prototype.add = function (lineNumber, lineTokens) {\n    if (this.tokens.length > 0) {\n      var last = this.tokens[this.tokens.length - 1];\n      var lastLineNumber = last.startLineNumber + last.tokens.length - 1;\n\n      if (lastLineNumber + 1 === lineNumber) {\n        // append\n        last.tokens.push(lineTokens);\n        return;\n      }\n    }\n\n    this.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));\n  };\n\n  return MultilineTokensBuilder;\n}();\n\nexport { MultilineTokensBuilder };\n\nvar MultilineTokens =\n/** @class */\nfunction () {\n  function MultilineTokens(startLineNumber, tokens) {\n    this.startLineNumber = startLineNumber;\n    this.tokens = tokens;\n  }\n\n  return MultilineTokens;\n}();\n\nexport { MultilineTokens };\n\nfunction toUint32Array(arr) {\n  if (arr instanceof Uint32Array) {\n    return arr;\n  } else {\n    return new Uint32Array(arr);\n  }\n}\n\nvar TokensStore =\n/** @class */\nfunction () {\n  function TokensStore() {\n    this._lineTokens = [];\n    this._len = 0;\n  }\n\n  TokensStore.prototype.flush = function () {\n    this._lineTokens = [];\n    this._len = 0;\n  };\n\n  TokensStore.prototype.getTokens = function (topLevelLanguageId, lineIndex, lineText) {\n    var rawLineTokens = null;\n\n    if (lineIndex < this._len) {\n      rawLineTokens = this._lineTokens[lineIndex];\n    }\n\n    if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n      return new LineTokens(toUint32Array(rawLineTokens), lineText);\n    }\n\n    var lineTokens = new Uint32Array(2);\n    lineTokens[0] = lineText.length;\n    lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\n    return new LineTokens(lineTokens, lineText);\n  };\n\n  TokensStore._massageTokens = function (topLevelLanguageId, lineTextLength, _tokens) {\n    var tokens = _tokens ? toUint32Array(_tokens) : null;\n\n    if (lineTextLength === 0) {\n      var hasDifferentLanguageId = false;\n\n      if (tokens && tokens.length > 1) {\n        hasDifferentLanguageId = TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId;\n      }\n\n      if (!hasDifferentLanguageId) {\n        return EMPTY_LINE_TOKENS;\n      }\n    }\n\n    if (!tokens || tokens.length === 0) {\n      var tokens_1 = new Uint32Array(2);\n      tokens_1[0] = lineTextLength;\n      tokens_1[1] = getDefaultMetadata(topLevelLanguageId);\n      return tokens_1.buffer;\n    } // Ensure the last token covers the end of the text\n\n\n    tokens[tokens.length - 2] = lineTextLength;\n\n    if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n      // Store directly the ArrayBuffer pointer to save an object\n      return tokens.buffer;\n    }\n\n    return tokens;\n  };\n\n  TokensStore.prototype._ensureLine = function (lineIndex) {\n    while (lineIndex >= this._len) {\n      this._lineTokens[this._len] = null;\n      this._len++;\n    }\n  };\n\n  TokensStore.prototype._deleteLines = function (start, deleteCount) {\n    if (deleteCount === 0) {\n      return;\n    }\n\n    if (start + deleteCount > this._len) {\n      deleteCount = this._len - start;\n    }\n\n    this._lineTokens.splice(start, deleteCount);\n\n    this._len -= deleteCount;\n  };\n\n  TokensStore.prototype._insertLines = function (insertIndex, insertCount) {\n    if (insertCount === 0) {\n      return;\n    }\n\n    var lineTokens = [];\n\n    for (var i = 0; i < insertCount; i++) {\n      lineTokens[i] = null;\n    }\n\n    this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n    this._len += insertCount;\n  };\n\n  TokensStore.prototype.setTokens = function (topLevelLanguageId, lineIndex, lineTextLength, _tokens) {\n    var tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);\n\n    this._ensureLine(lineIndex);\n\n    this._lineTokens[lineIndex] = tokens;\n  }; //#region Editing\n\n\n  TokensStore.prototype.acceptEdit = function (range, eolCount, firstLineLength) {\n    this._acceptDeleteRange(range);\n\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n  };\n\n  TokensStore.prototype._acceptDeleteRange = function (range) {\n    var firstLineIndex = range.startLineNumber - 1;\n\n    if (firstLineIndex >= this._len) {\n      return;\n    }\n\n    if (range.startLineNumber === range.endLineNumber) {\n      if (range.startColumn === range.endColumn) {\n        // Nothing to delete\n        return;\n      }\n\n      this._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n      return;\n    }\n\n    this._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n    var lastLineIndex = range.endLineNumber - 1;\n    var lastLineTokens = null;\n\n    if (lastLineIndex < this._len) {\n      lastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n    } // Take remaining text on last line and append it to remaining text on first line\n\n\n    this._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens); // Delete middle lines\n\n    this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n  };\n\n  TokensStore.prototype._acceptInsertText = function (position, eolCount, firstLineLength) {\n    if (eolCount === 0 && firstLineLength === 0) {\n      // Nothing to insert\n      return;\n    }\n\n    var lineIndex = position.lineNumber - 1;\n\n    if (lineIndex >= this._len) {\n      return;\n    }\n\n    if (eolCount === 0) {\n      // Inserting text on one line\n      this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n      return;\n    }\n\n    this._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n    this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n\n    this._insertLines(position.lineNumber, eolCount);\n  };\n\n  TokensStore._deleteBeginning = function (lineTokens, toChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n\n    return TokensStore._delete(lineTokens, 0, toChIndex);\n  };\n\n  TokensStore._deleteEnding = function (lineTokens, fromChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n\n    var tokens = toUint32Array(lineTokens);\n    var lineTextLength = tokens[tokens.length - 2];\n    return TokensStore._delete(lineTokens, fromChIndex, lineTextLength);\n  };\n\n  TokensStore._delete = function (lineTokens, fromChIndex, toChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n      return lineTokens;\n    }\n\n    var tokens = toUint32Array(lineTokens);\n    var tokensCount = tokens.length >>> 1; // special case: deleting everything\n\n    if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n      return EMPTY_LINE_TOKENS;\n    }\n\n    var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n    var fromTokenStartOffset = fromTokenIndex > 0 ? tokens[fromTokenIndex - 1 << 1] : 0;\n    var fromTokenEndOffset = tokens[fromTokenIndex << 1];\n\n    if (toChIndex < fromTokenEndOffset) {\n      // the delete range is inside a single token\n      var delta_1 = toChIndex - fromChIndex;\n\n      for (var i = fromTokenIndex; i < tokensCount; i++) {\n        tokens[i << 1] -= delta_1;\n      }\n\n      return lineTokens;\n    }\n\n    var dest;\n    var lastEnd;\n\n    if (fromTokenStartOffset !== fromChIndex) {\n      tokens[fromTokenIndex << 1] = fromChIndex;\n      dest = fromTokenIndex + 1 << 1;\n      lastEnd = fromChIndex;\n    } else {\n      dest = fromTokenIndex << 1;\n      lastEnd = fromTokenStartOffset;\n    }\n\n    var delta = toChIndex - fromChIndex;\n\n    for (var tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n      var tokenEndOffset = tokens[tokenIndex << 1] - delta;\n\n      if (tokenEndOffset > lastEnd) {\n        tokens[dest++] = tokenEndOffset;\n        tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n        lastEnd = tokenEndOffset;\n      }\n    }\n\n    if (dest === tokens.length) {\n      // nothing to trim\n      return lineTokens;\n    }\n\n    var tmp = new Uint32Array(dest);\n    tmp.set(tokens.subarray(0, dest), 0);\n    return tmp.buffer;\n  };\n\n  TokensStore._append = function (lineTokens, _otherTokens) {\n    if (_otherTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n\n    if (lineTokens === EMPTY_LINE_TOKENS) {\n      return _otherTokens;\n    }\n\n    if (lineTokens === null) {\n      return lineTokens;\n    }\n\n    if (_otherTokens === null) {\n      // cannot determine combined line length...\n      return null;\n    }\n\n    var myTokens = toUint32Array(lineTokens);\n    var otherTokens = toUint32Array(_otherTokens);\n    var otherTokensCount = otherTokens.length >>> 1;\n    var result = new Uint32Array(myTokens.length + otherTokens.length);\n    result.set(myTokens, 0);\n    var dest = myTokens.length;\n    var delta = myTokens[myTokens.length - 2];\n\n    for (var i = 0; i < otherTokensCount; i++) {\n      result[dest++] = otherTokens[i << 1] + delta;\n      result[dest++] = otherTokens[(i << 1) + 1];\n    }\n\n    return result.buffer;\n  };\n\n  TokensStore._insert = function (lineTokens, chIndex, textLength) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      // nothing to do\n      return lineTokens;\n    }\n\n    var tokens = toUint32Array(lineTokens);\n    var tokensCount = tokens.length >>> 1;\n    var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n\n    if (fromTokenIndex > 0) {\n      var fromTokenStartOffset = tokens[fromTokenIndex - 1 << 1];\n\n      if (fromTokenStartOffset === chIndex) {\n        fromTokenIndex--;\n      }\n    }\n\n    for (var tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n      tokens[tokenIndex << 1] += textLength;\n    }\n\n    return lineTokens;\n  };\n\n  return TokensStore;\n}();\n\nexport { TokensStore };","map":null,"metadata":{},"sourceType":"module"}