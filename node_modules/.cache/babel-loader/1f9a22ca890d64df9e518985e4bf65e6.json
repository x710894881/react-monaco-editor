{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { alert } from '../../../base/browser/ui/aria/aria.js';\nimport { isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { dispose, DisposableStore, toDisposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { EditorAction, EditorCommand, registerEditorAction, registerEditorCommand, registerEditorContribution } from '../../browser/editorExtensions.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Range } from '../../common/core/range.js';\nimport { EditorContextKeys } from '../../common/editorContextKeys.js';\nimport { SnippetController2 } from '../snippet/snippetController2.js';\nimport { SnippetParser } from '../snippet/snippetParser.js';\nimport { ISuggestMemoryService } from './suggestMemory.js';\nimport * as nls from '../../../nls.js';\nimport { ICommandService } from '../../../platform/commands/common/commands.js';\nimport { ContextKeyExpr, IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { Context as SuggestContext } from './suggest.js';\nimport { SuggestAlternatives } from './suggestAlternatives.js';\nimport { SuggestModel } from './suggestModel.js';\nimport { SuggestWidget } from './suggestWidget.js';\nimport { WordContextKey } from './wordContextKey.js';\nimport { Event } from '../../../base/common/event.js';\nimport { IEditorWorkerService } from '../../common/services/editorWorkerService.js';\nimport { IdleValue } from '../../../base/common/async.js';\nimport { isObject } from '../../../base/common/types.js';\nimport { CommitCharacterController } from './suggestCommitCharacters.js';\nvar _sticky = false; // for development purposes only\n\nvar LineSuffix =\n/** @class */\nfunction () {\n  function LineSuffix(_model, _position) {\n    this._model = _model;\n    this._position = _position; // spy on what's happening right of the cursor. two cases:\n    // 1. end of line -> check that it's still end of line\n    // 2. mid of line -> add a marker and compute the delta\n\n    var maxColumn = _model.getLineMaxColumn(_position.lineNumber);\n\n    if (maxColumn !== _position.column) {\n      var offset = _model.getOffsetAt(_position);\n\n      var end = _model.getPositionAt(offset + 1);\n\n      this._marker = _model.deltaDecorations([], [{\n        range: Range.fromPositions(_position, end),\n        options: {\n          stickiness: 1\n          /* NeverGrowsWhenTypingAtEdges */\n\n        }\n      }]);\n    }\n  }\n\n  LineSuffix.prototype.dispose = function () {\n    if (this._marker && !this._model.isDisposed()) {\n      this._model.deltaDecorations(this._marker, []);\n    }\n  };\n\n  LineSuffix.prototype.delta = function (position) {\n    if (this._model.isDisposed() || this._position.lineNumber !== position.lineNumber) {\n      // bail out early if things seems fishy\n      return 0;\n    } // read the marker (in case suggest was triggered at line end) or compare\n    // the cursor to the line end.\n\n\n    if (this._marker) {\n      var range = this._model.getDecorationRange(this._marker[0]);\n\n      var end = this._model.getOffsetAt(range.getStartPosition());\n\n      return end - this._model.getOffsetAt(position);\n    } else {\n      return this._model.getLineMaxColumn(position.lineNumber) - position.column;\n    }\n  };\n\n  return LineSuffix;\n}();\n\nvar SuggestController =\n/** @class */\nfunction () {\n  function SuggestController(_editor, editorWorker, _memoryService, _commandService, _contextKeyService, _instantiationService) {\n    var _this = this;\n\n    this._editor = _editor;\n    this._memoryService = _memoryService;\n    this._commandService = _commandService;\n    this._contextKeyService = _contextKeyService;\n    this._instantiationService = _instantiationService;\n    this._lineSuffix = new MutableDisposable();\n    this._toDispose = new DisposableStore();\n    this._model = new SuggestModel(this._editor, editorWorker);\n    this._widget = new IdleValue(function () {\n      var widget = _this._instantiationService.createInstance(SuggestWidget, _this._editor);\n\n      _this._toDispose.add(widget);\n\n      _this._toDispose.add(widget.onDidSelect(function (item) {\n        return _this._insertSuggestion(item, false, true);\n      }, _this)); // Wire up logic to accept a suggestion on certain characters\n\n\n      var commitCharacterController = new CommitCharacterController(_this._editor, widget, function (item) {\n        return _this._insertSuggestion(item, false, true);\n      });\n\n      _this._toDispose.add(commitCharacterController);\n\n      _this._toDispose.add(_this._model.onDidSuggest(function (e) {\n        if (e.completionModel.items.length === 0) {\n          commitCharacterController.reset();\n        }\n      })); // Wire up makes text edit context key\n\n\n      var makesTextEdit = SuggestContext.MakesTextEdit.bindTo(_this._contextKeyService);\n\n      _this._toDispose.add(widget.onDidFocus(function (_a) {\n        var item = _a.item;\n\n        var position = _this._editor.getPosition();\n\n        var startColumn = item.completion.range.startColumn;\n        var endColumn = position.column;\n        var value = true;\n\n        if (_this._editor.getConfiguration().contribInfo.acceptSuggestionOnEnter === 'smart' && _this._model.state === 2\n        /* Auto */\n        && !item.completion.command && !item.completion.additionalTextEdits && !(item.completion.insertTextRules & 4\n        /* InsertAsSnippet */\n        ) && endColumn - startColumn === item.completion.insertText.length) {\n          var oldText = _this._editor.getModel().getValueInRange({\n            startLineNumber: position.lineNumber,\n            startColumn: startColumn,\n            endLineNumber: position.lineNumber,\n            endColumn: endColumn\n          });\n\n          value = oldText !== item.completion.insertText;\n        }\n\n        makesTextEdit.set(value);\n      }));\n\n      _this._toDispose.add(toDisposable(function () {\n        return makesTextEdit.reset();\n      }));\n\n      return widget;\n    });\n    this._alternatives = new IdleValue(function () {\n      return _this._toDispose.add(new SuggestAlternatives(_this._editor, _this._contextKeyService));\n    });\n\n    this._toDispose.add(_instantiationService.createInstance(WordContextKey, _editor));\n\n    this._toDispose.add(this._model.onDidTrigger(function (e) {\n      _this._widget.getValue().showTriggered(e.auto, e.shy ? 250 : 50);\n\n      _this._lineSuffix.value = new LineSuffix(_this._editor.getModel(), e.position);\n    }));\n\n    this._toDispose.add(this._model.onDidSuggest(function (e) {\n      if (!e.shy) {\n        var index = _this._memoryService.select(_this._editor.getModel(), _this._editor.getPosition(), e.completionModel.items);\n\n        _this._widget.getValue().showSuggestions(e.completionModel, index, e.isFrozen, e.auto);\n      }\n    }));\n\n    this._toDispose.add(this._model.onDidCancel(function (e) {\n      if (!e.retrigger) {\n        _this._widget.getValue().hideWidget();\n      }\n    }));\n\n    this._toDispose.add(this._editor.onDidBlurEditorWidget(function () {\n      if (!_sticky) {\n        _this._model.cancel();\n\n        _this._model.clear();\n      }\n    })); // Manage the acceptSuggestionsOnEnter context key\n\n\n    var acceptSuggestionsOnEnter = SuggestContext.AcceptSuggestionsOnEnter.bindTo(_contextKeyService);\n\n    var updateFromConfig = function () {\n      var acceptSuggestionOnEnter = _this._editor.getConfiguration().contribInfo.acceptSuggestionOnEnter;\n\n      acceptSuggestionsOnEnter.set(acceptSuggestionOnEnter === 'on' || acceptSuggestionOnEnter === 'smart');\n    };\n\n    this._toDispose.add(this._editor.onDidChangeConfiguration(function () {\n      return updateFromConfig();\n    }));\n\n    updateFromConfig();\n  }\n\n  SuggestController.get = function (editor) {\n    return editor.getContribution(SuggestController.ID);\n  };\n\n  SuggestController.prototype.getId = function () {\n    return SuggestController.ID;\n  };\n\n  SuggestController.prototype.dispose = function () {\n    this._alternatives.dispose();\n\n    this._toDispose.dispose();\n\n    this._widget.dispose();\n\n    this._model.dispose();\n\n    this._lineSuffix.dispose();\n  };\n\n  SuggestController.prototype._insertSuggestion = function (event, keepAlternativeSuggestions, undoStops) {\n    var _a;\n\n    var _this = this;\n\n    if (!event || !event.item) {\n      this._alternatives.getValue().reset();\n\n      this._model.cancel();\n\n      this._model.clear();\n\n      return;\n    }\n\n    if (!this._editor.hasModel()) {\n      return;\n    }\n\n    var model = this._editor.getModel();\n\n    var modelVersionNow = model.getAlternativeVersionId();\n    var _b = event.item,\n        suggestion = _b.completion,\n        position = _b.position;\n\n    var editorColumn = this._editor.getPosition().column;\n\n    var columnDelta = editorColumn - position.column; // pushing undo stops *before* additional text edits and\n    // *after* the main edit\n\n    if (undoStops) {\n      this._editor.pushUndoStop();\n    }\n\n    if (Array.isArray(suggestion.additionalTextEdits)) {\n      this._editor.executeEdits('suggestController.additionalTextEdits', suggestion.additionalTextEdits.map(function (edit) {\n        return EditOperation.replace(Range.lift(edit.range), edit.text);\n      }));\n    } // keep item in memory\n\n\n    this._memoryService.memorize(model, this._editor.getPosition(), event.item);\n\n    var insertText = suggestion.insertText;\n\n    if (!(suggestion.insertTextRules & 4\n    /* InsertAsSnippet */\n    )) {\n      insertText = SnippetParser.escape(insertText);\n    }\n\n    var overwriteBefore = position.column - suggestion.range.startColumn;\n    var overwriteAfter = suggestion.range.endColumn - position.column;\n    var suffixDelta = this._lineSuffix.value ? this._lineSuffix.value.delta(this._editor.getPosition()) : 0;\n    SnippetController2.get(this._editor).insert(insertText, {\n      overwriteBefore: overwriteBefore + columnDelta,\n      overwriteAfter: overwriteAfter + suffixDelta,\n      undoStopBefore: false,\n      undoStopAfter: false,\n      adjustWhitespace: !(suggestion.insertTextRules & 1\n      /* KeepWhitespace */\n      )\n    });\n\n    if (undoStops) {\n      this._editor.pushUndoStop();\n    }\n\n    if (!suggestion.command) {\n      // done\n      this._model.cancel();\n\n      this._model.clear();\n    } else if (suggestion.command.id === TriggerSuggestAction.id) {\n      // retigger\n      this._model.trigger({\n        auto: true,\n        shy: false\n      }, true);\n    } else {\n      // exec command, done\n      (_a = this._commandService).executeCommand.apply(_a, [suggestion.command.id].concat(suggestion.command.arguments ? suggestion.command.arguments.slice() : [])).catch(onUnexpectedError).finally(function () {\n        return _this._model.clear();\n      }); // <- clear only now, keep commands alive\n\n\n      this._model.cancel();\n    }\n\n    if (keepAlternativeSuggestions) {\n      this._alternatives.getValue().set(event, function (next) {\n        // this is not so pretty. when inserting the 'next'\n        // suggestion we undo until we are at the state at\n        // which we were before inserting the previous suggestion...\n        while (model.canUndo()) {\n          if (modelVersionNow !== model.getAlternativeVersionId()) {\n            model.undo();\n          }\n\n          _this._insertSuggestion(next, false, false);\n\n          break;\n        }\n      });\n    }\n\n    this._alertCompletionItem(event.item);\n  };\n\n  SuggestController.prototype._alertCompletionItem = function (_a) {\n    var suggestion = _a.completion;\n\n    if (isNonEmptyArray(suggestion.additionalTextEdits)) {\n      var msg = nls.localize('arai.alert.snippet', \"Accepting '{0}' made {1} additional edits\", suggestion.label, suggestion.additionalTextEdits.length);\n      alert(msg);\n    }\n  };\n\n  SuggestController.prototype.triggerSuggest = function (onlyFrom) {\n    if (this._editor.hasModel()) {\n      this._model.trigger({\n        auto: false,\n        shy: false\n      }, false, onlyFrom);\n\n      this._editor.revealLine(this._editor.getPosition().lineNumber, 0\n      /* Smooth */\n      );\n\n      this._editor.focus();\n    }\n  };\n\n  SuggestController.prototype.triggerSuggestAndAcceptBest = function (arg) {\n    var _this = this;\n\n    if (!this._editor.hasModel()) {\n      return;\n    }\n\n    var positionNow = this._editor.getPosition();\n\n    var fallback = function () {\n      if (positionNow.equals(_this._editor.getPosition())) {\n        _this._commandService.executeCommand(arg.fallback);\n      }\n    };\n\n    var makesTextEdit = function (item) {\n      if (item.completion.insertTextRules & 4\n      /* InsertAsSnippet */\n      || item.completion.additionalTextEdits) {\n        // snippet, other editor -> makes edit\n        return true;\n      }\n\n      var position = _this._editor.getPosition();\n\n      var startColumn = item.completion.range.startColumn;\n      var endColumn = position.column;\n\n      if (endColumn - startColumn !== item.completion.insertText.length) {\n        // unequal lengths -> makes edit\n        return true;\n      }\n\n      var textNow = _this._editor.getModel().getValueInRange({\n        startLineNumber: position.lineNumber,\n        startColumn: startColumn,\n        endLineNumber: position.lineNumber,\n        endColumn: endColumn\n      }); // unequal text -> makes edit\n\n\n      return textNow !== item.completion.insertText;\n    };\n\n    Event.once(this._model.onDidTrigger)(function (_) {\n      // wait for trigger because only then the cancel-event is trustworthy\n      var listener = [];\n      Event.any(_this._model.onDidTrigger, _this._model.onDidCancel)(function () {\n        // retrigger or cancel -> try to type default text\n        dispose(listener);\n        fallback();\n      }, undefined, listener);\n\n      _this._model.onDidSuggest(function (_a) {\n        var completionModel = _a.completionModel;\n        dispose(listener);\n\n        if (completionModel.items.length === 0) {\n          fallback();\n          return;\n        }\n\n        var index = _this._memoryService.select(_this._editor.getModel(), _this._editor.getPosition(), completionModel.items);\n\n        var item = completionModel.items[index];\n\n        if (!makesTextEdit(item)) {\n          fallback();\n          return;\n        }\n\n        _this._editor.pushUndoStop();\n\n        _this._insertSuggestion({\n          index: index,\n          item: item,\n          model: completionModel\n        }, true, false);\n      }, undefined, listener);\n    });\n\n    this._model.trigger({\n      auto: false,\n      shy: true\n    });\n\n    this._editor.revealLine(positionNow.lineNumber, 0\n    /* Smooth */\n    );\n\n    this._editor.focus();\n  };\n\n  SuggestController.prototype.acceptSelectedSuggestion = function (keepAlternativeSuggestions) {\n    var item = this._widget.getValue().getFocusedItem();\n\n    this._insertSuggestion(item, !!keepAlternativeSuggestions, true);\n  };\n\n  SuggestController.prototype.acceptNextSuggestion = function () {\n    this._alternatives.getValue().next();\n  };\n\n  SuggestController.prototype.acceptPrevSuggestion = function () {\n    this._alternatives.getValue().prev();\n  };\n\n  SuggestController.prototype.cancelSuggestWidget = function () {\n    this._model.cancel();\n\n    this._model.clear();\n\n    this._widget.getValue().hideWidget();\n  };\n\n  SuggestController.prototype.selectNextSuggestion = function () {\n    this._widget.getValue().selectNext();\n  };\n\n  SuggestController.prototype.selectNextPageSuggestion = function () {\n    this._widget.getValue().selectNextPage();\n  };\n\n  SuggestController.prototype.selectLastSuggestion = function () {\n    this._widget.getValue().selectLast();\n  };\n\n  SuggestController.prototype.selectPrevSuggestion = function () {\n    this._widget.getValue().selectPrevious();\n  };\n\n  SuggestController.prototype.selectPrevPageSuggestion = function () {\n    this._widget.getValue().selectPreviousPage();\n  };\n\n  SuggestController.prototype.selectFirstSuggestion = function () {\n    this._widget.getValue().selectFirst();\n  };\n\n  SuggestController.prototype.toggleSuggestionDetails = function () {\n    this._widget.getValue().toggleDetails();\n  };\n\n  SuggestController.prototype.toggleExplainMode = function () {\n    this._widget.getValue().toggleExplainMode();\n  };\n\n  SuggestController.prototype.toggleSuggestionFocus = function () {\n    this._widget.getValue().toggleDetailsFocus();\n  };\n\n  SuggestController.ID = 'editor.contrib.suggestController';\n  SuggestController = __decorate([__param(1, IEditorWorkerService), __param(2, ISuggestMemoryService), __param(3, ICommandService), __param(4, IContextKeyService), __param(5, IInstantiationService)], SuggestController);\n  return SuggestController;\n}();\n\nexport { SuggestController };\n\nvar TriggerSuggestAction =\n/** @class */\nfunction (_super) {\n  __extends(TriggerSuggestAction, _super);\n\n  function TriggerSuggestAction() {\n    return _super.call(this, {\n      id: TriggerSuggestAction.id,\n      label: nls.localize('suggest.trigger.label', \"Trigger Suggest\"),\n      alias: 'Trigger Suggest',\n      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCompletionItemProvider),\n      kbOpts: {\n        kbExpr: EditorContextKeys.textInputFocus,\n        primary: 2048\n        /* CtrlCmd */\n        | 10\n        /* Space */\n        ,\n        mac: {\n          primary: 256\n          /* WinCtrl */\n          | 10\n          /* Space */\n\n        },\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  TriggerSuggestAction.prototype.run = function (accessor, editor) {\n    var controller = SuggestController.get(editor);\n\n    if (!controller) {\n      return;\n    }\n\n    controller.triggerSuggest();\n  };\n\n  TriggerSuggestAction.id = 'editor.action.triggerSuggest';\n  return TriggerSuggestAction;\n}(EditorAction);\n\nexport { TriggerSuggestAction };\nregisterEditorContribution(SuggestController);\nregisterEditorAction(TriggerSuggestAction);\nvar weight = 100\n/* EditorContrib */\n+ 90;\nvar SuggestCommand = EditorCommand.bindToContribution(SuggestController.get);\nregisterEditorCommand(new SuggestCommand({\n  id: 'acceptSelectedSuggestion',\n  precondition: SuggestContext.Visible,\n  handler: function (x) {\n    return x.acceptSelectedSuggestion(true);\n  },\n  kbOpts: {\n    weight: weight,\n    kbExpr: EditorContextKeys.textInputFocus,\n    primary: 2\n    /* Tab */\n\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'acceptSelectedSuggestionOnEnter',\n  precondition: SuggestContext.Visible,\n  handler: function (x) {\n    return x.acceptSelectedSuggestion(false);\n  },\n  kbOpts: {\n    weight: weight,\n    kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, SuggestContext.AcceptSuggestionsOnEnter, SuggestContext.MakesTextEdit),\n    primary: 3\n    /* Enter */\n\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'hideSuggestWidget',\n  precondition: SuggestContext.Visible,\n  handler: function (x) {\n    return x.cancelSuggestWidget();\n  },\n  kbOpts: {\n    weight: weight,\n    kbExpr: EditorContextKeys.textInputFocus,\n    primary: 9\n    /* Escape */\n    ,\n    secondary: [1024\n    /* Shift */\n    | 9\n    /* Escape */\n    ]\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'selectNextSuggestion',\n  precondition: ContextKeyExpr.and(SuggestContext.Visible, SuggestContext.MultipleSuggestions),\n  handler: function (c) {\n    return c.selectNextSuggestion();\n  },\n  kbOpts: {\n    weight: weight,\n    kbExpr: EditorContextKeys.textInputFocus,\n    primary: 18\n    /* DownArrow */\n    ,\n    secondary: [2048\n    /* CtrlCmd */\n    | 18\n    /* DownArrow */\n    ],\n    mac: {\n      primary: 18\n      /* DownArrow */\n      ,\n      secondary: [2048\n      /* CtrlCmd */\n      | 18\n      /* DownArrow */\n      , 256\n      /* WinCtrl */\n      | 44\n      /* KEY_N */\n      ]\n    }\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'selectNextPageSuggestion',\n  precondition: ContextKeyExpr.and(SuggestContext.Visible, SuggestContext.MultipleSuggestions),\n  handler: function (c) {\n    return c.selectNextPageSuggestion();\n  },\n  kbOpts: {\n    weight: weight,\n    kbExpr: EditorContextKeys.textInputFocus,\n    primary: 12\n    /* PageDown */\n    ,\n    secondary: [2048\n    /* CtrlCmd */\n    | 12\n    /* PageDown */\n    ]\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'selectLastSuggestion',\n  precondition: ContextKeyExpr.and(SuggestContext.Visible, SuggestContext.MultipleSuggestions),\n  handler: function (c) {\n    return c.selectLastSuggestion();\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'selectPrevSuggestion',\n  precondition: ContextKeyExpr.and(SuggestContext.Visible, SuggestContext.MultipleSuggestions),\n  handler: function (c) {\n    return c.selectPrevSuggestion();\n  },\n  kbOpts: {\n    weight: weight,\n    kbExpr: EditorContextKeys.textInputFocus,\n    primary: 16\n    /* UpArrow */\n    ,\n    secondary: [2048\n    /* CtrlCmd */\n    | 16\n    /* UpArrow */\n    ],\n    mac: {\n      primary: 16\n      /* UpArrow */\n      ,\n      secondary: [2048\n      /* CtrlCmd */\n      | 16\n      /* UpArrow */\n      , 256\n      /* WinCtrl */\n      | 46\n      /* KEY_P */\n      ]\n    }\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'selectPrevPageSuggestion',\n  precondition: ContextKeyExpr.and(SuggestContext.Visible, SuggestContext.MultipleSuggestions),\n  handler: function (c) {\n    return c.selectPrevPageSuggestion();\n  },\n  kbOpts: {\n    weight: weight,\n    kbExpr: EditorContextKeys.textInputFocus,\n    primary: 11\n    /* PageUp */\n    ,\n    secondary: [2048\n    /* CtrlCmd */\n    | 11\n    /* PageUp */\n    ]\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'selectFirstSuggestion',\n  precondition: ContextKeyExpr.and(SuggestContext.Visible, SuggestContext.MultipleSuggestions),\n  handler: function (c) {\n    return c.selectFirstSuggestion();\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'toggleSuggestionDetails',\n  precondition: SuggestContext.Visible,\n  handler: function (x) {\n    return x.toggleSuggestionDetails();\n  },\n  kbOpts: {\n    weight: weight,\n    kbExpr: EditorContextKeys.textInputFocus,\n    primary: 2048\n    /* CtrlCmd */\n    | 10\n    /* Space */\n    ,\n    mac: {\n      primary: 256\n      /* WinCtrl */\n      | 10\n      /* Space */\n\n    }\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'toggleExplainMode',\n  precondition: SuggestContext.Visible,\n  handler: function (x) {\n    return x.toggleExplainMode();\n  },\n  kbOpts: {\n    weight: 100\n    /* EditorContrib */\n    ,\n    primary: 2048\n    /* CtrlCmd */\n    | 85\n    /* US_SLASH */\n\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'toggleSuggestionFocus',\n  precondition: SuggestContext.Visible,\n  handler: function (x) {\n    return x.toggleSuggestionFocus();\n  },\n  kbOpts: {\n    weight: weight,\n    kbExpr: EditorContextKeys.textInputFocus,\n    primary: 2048\n    /* CtrlCmd */\n    | 512\n    /* Alt */\n    | 10\n    /* Space */\n    ,\n    mac: {\n      primary: 256\n      /* WinCtrl */\n      | 512\n      /* Alt */\n      | 10\n      /* Space */\n\n    }\n  }\n})); //#region tab completions\n\nregisterEditorCommand(new SuggestCommand({\n  id: 'insertBestCompletion',\n  precondition: ContextKeyExpr.and(ContextKeyExpr.equals('config.editor.tabCompletion', 'on'), WordContextKey.AtEnd, SuggestContext.Visible.toNegated(), SuggestAlternatives.OtherSuggestions.toNegated(), SnippetController2.InSnippetMode.toNegated()),\n  handler: function (x, arg) {\n    x.triggerSuggestAndAcceptBest(isObject(arg) ? __assign({\n      fallback: 'tab'\n    }, arg) : {\n      fallback: 'tab'\n    });\n  },\n  kbOpts: {\n    weight: weight,\n    primary: 2\n    /* Tab */\n\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'insertNextSuggestion',\n  precondition: ContextKeyExpr.and(ContextKeyExpr.equals('config.editor.tabCompletion', 'on'), SuggestAlternatives.OtherSuggestions, SuggestContext.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),\n  handler: function (x) {\n    return x.acceptNextSuggestion();\n  },\n  kbOpts: {\n    weight: weight,\n    kbExpr: EditorContextKeys.textInputFocus,\n    primary: 2\n    /* Tab */\n\n  }\n}));\nregisterEditorCommand(new SuggestCommand({\n  id: 'insertPrevSuggestion',\n  precondition: ContextKeyExpr.and(ContextKeyExpr.equals('config.editor.tabCompletion', 'on'), SuggestAlternatives.OtherSuggestions, SuggestContext.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),\n  handler: function (x) {\n    return x.acceptPrevSuggestion();\n  },\n  kbOpts: {\n    weight: weight,\n    kbExpr: EditorContextKeys.textInputFocus,\n    primary: 1024\n    /* Shift */\n    | 2\n    /* Tab */\n\n  }\n}));","map":null,"metadata":{},"sourceType":"module"}