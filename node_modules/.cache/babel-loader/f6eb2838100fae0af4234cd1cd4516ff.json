{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { TimeoutTimer } from '../../../base/common/async.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { dispose, DisposableStore, isDisposable } from '../../../base/common/lifecycle.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { CompletionProviderRegistry, completionKindFromString } from '../../common/modes.js';\nimport { CompletionModel } from './completionModel.js';\nimport { getSuggestionComparator, provideSuggestionItems, getSnippetSuggestSupport, CompletionOptions } from './suggest.js';\nimport { SnippetController2 } from '../snippet/snippetController2.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { WordDistance } from './wordDistance.js';\n\nvar LineContext =\n/** @class */\nfunction () {\n  function LineContext(model, position, auto, shy) {\n    this.leadingLineContent = model.getLineContent(position.lineNumber).substr(0, position.column - 1);\n    this.leadingWord = model.getWordUntilPosition(position);\n    this.lineNumber = position.lineNumber;\n    this.column = position.column;\n    this.auto = auto;\n    this.shy = shy;\n  }\n\n  LineContext.shouldAutoTrigger = function (editor) {\n    if (!editor.hasModel()) {\n      return false;\n    }\n\n    var model = editor.getModel();\n    var pos = editor.getPosition();\n    model.tokenizeIfCheap(pos.lineNumber);\n    var word = model.getWordAtPosition(pos);\n\n    if (!word) {\n      return false;\n    }\n\n    if (word.endColumn !== pos.column) {\n      return false;\n    }\n\n    if (!isNaN(Number(word.word))) {\n      return false;\n    }\n\n    return true;\n  };\n\n  return LineContext;\n}();\n\nexport { LineContext };\n\nvar SuggestModel =\n/** @class */\nfunction () {\n  function SuggestModel(_editor, _editorWorker) {\n    var _this = this;\n\n    this._editor = _editor;\n    this._editorWorker = _editorWorker;\n    this._toDispose = new DisposableStore();\n    this._quickSuggestDelay = 10;\n    this._triggerQuickSuggest = new TimeoutTimer();\n    this._state = 0\n    /* Idle */\n    ;\n    this._completionDisposables = new DisposableStore();\n    this._onDidCancel = new Emitter();\n    this._onDidTrigger = new Emitter();\n    this._onDidSuggest = new Emitter();\n    this.onDidCancel = this._onDidCancel.event;\n    this.onDidTrigger = this._onDidTrigger.event;\n    this.onDidSuggest = this._onDidSuggest.event;\n    this._currentSelection = this._editor.getSelection() || new Selection(1, 1, 1, 1); // wire up various listeners\n\n    this._toDispose.add(this._editor.onDidChangeModel(function () {\n      _this._updateTriggerCharacters();\n\n      _this.cancel();\n    }));\n\n    this._toDispose.add(this._editor.onDidChangeModelLanguage(function () {\n      _this._updateTriggerCharacters();\n\n      _this.cancel();\n    }));\n\n    this._toDispose.add(this._editor.onDidChangeConfiguration(function () {\n      _this._updateTriggerCharacters();\n\n      _this._updateQuickSuggest();\n    }));\n\n    this._toDispose.add(CompletionProviderRegistry.onDidChange(function () {\n      _this._updateTriggerCharacters();\n\n      _this._updateActiveSuggestSession();\n    }));\n\n    this._toDispose.add(this._editor.onDidChangeCursorSelection(function (e) {\n      _this._onCursorChange(e);\n    }));\n\n    var editorIsComposing = false;\n\n    this._toDispose.add(this._editor.onCompositionStart(function () {\n      editorIsComposing = true;\n    }));\n\n    this._toDispose.add(this._editor.onCompositionEnd(function () {\n      // refilter when composition ends\n      editorIsComposing = false;\n\n      _this._refilterCompletionItems();\n    }));\n\n    this._toDispose.add(this._editor.onDidChangeModelContent(function () {\n      // only filter completions when the editor isn't\n      // composing a character, e.g. ¨ + u makes ü but just\n      // ¨ cannot be used for filtering\n      if (!editorIsComposing) {\n        _this._refilterCompletionItems();\n      }\n    }));\n\n    this._updateTriggerCharacters();\n\n    this._updateQuickSuggest();\n  }\n\n  SuggestModel.prototype.dispose = function () {\n    dispose(this._triggerCharacterListener);\n    dispose([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerQuickSuggest]);\n\n    this._toDispose.dispose();\n\n    this._completionDisposables.dispose();\n\n    this.cancel();\n  }; // --- handle configuration & precondition changes\n\n\n  SuggestModel.prototype._updateQuickSuggest = function () {\n    this._quickSuggestDelay = this._editor.getConfiguration().contribInfo.quickSuggestionsDelay;\n\n    if (isNaN(this._quickSuggestDelay) || !this._quickSuggestDelay && this._quickSuggestDelay !== 0 || this._quickSuggestDelay < 0) {\n      this._quickSuggestDelay = 10;\n    }\n  };\n\n  SuggestModel.prototype._updateTriggerCharacters = function () {\n    var _this = this;\n\n    dispose(this._triggerCharacterListener);\n\n    if (this._editor.getConfiguration().readOnly || !this._editor.hasModel() || !this._editor.getConfiguration().contribInfo.suggestOnTriggerCharacters) {\n      return;\n    }\n\n    var supportsByTriggerCharacter = Object.create(null);\n\n    for (var _i = 0, _a = CompletionProviderRegistry.all(this._editor.getModel()); _i < _a.length; _i++) {\n      var support = _a[_i];\n\n      for (var _b = 0, _c = support.triggerCharacters || []; _b < _c.length; _b++) {\n        var ch = _c[_b];\n        var set = supportsByTriggerCharacter[ch];\n\n        if (!set) {\n          set = supportsByTriggerCharacter[ch] = new Set();\n          set.add(getSnippetSuggestSupport());\n        }\n\n        set.add(support);\n      }\n    }\n\n    this._triggerCharacterListener = this._editor.onDidType(function (text) {\n      var lastChar = text.charAt(text.length - 1);\n      var supports = supportsByTriggerCharacter[lastChar];\n\n      if (supports) {\n        // keep existing items that where not computed by the\n        // supports/providers that want to trigger now\n        var items = _this._completionModel ? _this._completionModel.adopt(supports) : undefined;\n\n        _this.trigger({\n          auto: true,\n          shy: false,\n          triggerCharacter: lastChar\n        }, Boolean(_this._completionModel), supports, items);\n      }\n    });\n  };\n\n  Object.defineProperty(SuggestModel.prototype, \"state\", {\n    // --- trigger/retrigger/cancel suggest\n    get: function () {\n      return this._state;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SuggestModel.prototype.cancel = function (retrigger) {\n    if (retrigger === void 0) {\n      retrigger = false;\n    }\n\n    if (this._state !== 0\n    /* Idle */\n    ) {\n        this._triggerQuickSuggest.cancel();\n\n        if (this._requestToken) {\n          this._requestToken.cancel();\n\n          this._requestToken = undefined;\n        }\n\n        this._state = 0\n        /* Idle */\n        ;\n        this._completionModel = undefined;\n        this._context = undefined;\n\n        this._onDidCancel.fire({\n          retrigger: retrigger\n        });\n      }\n  };\n\n  SuggestModel.prototype.clear = function () {\n    this._completionDisposables.clear();\n  };\n\n  SuggestModel.prototype._updateActiveSuggestSession = function () {\n    if (this._state !== 0\n    /* Idle */\n    ) {\n        if (!this._editor.hasModel() || !CompletionProviderRegistry.has(this._editor.getModel())) {\n          this.cancel();\n        } else {\n          this.trigger({\n            auto: this._state === 2\n            /* Auto */\n            ,\n            shy: false\n          }, true);\n        }\n      }\n  };\n\n  SuggestModel.prototype._onCursorChange = function (e) {\n    var _this = this;\n\n    if (!this._editor.hasModel()) {\n      return;\n    }\n\n    var model = this._editor.getModel();\n\n    var prevSelection = this._currentSelection;\n    this._currentSelection = this._editor.getSelection();\n\n    if (!e.selection.isEmpty() || e.reason !== 0\n    /* NotSet */\n    || e.source !== 'keyboard' && e.source !== 'deleteLeft') {\n      // Early exit if nothing needs to be done!\n      // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\n      if (this._state !== 0\n      /* Idle */\n      ) {\n          this.cancel();\n        }\n\n      return;\n    }\n\n    if (!CompletionProviderRegistry.has(model)) {\n      return;\n    }\n\n    if (this._state === 0\n    /* Idle */\n    ) {\n        if (this._editor.getConfiguration().contribInfo.quickSuggestions === false) {\n          // not enabled\n          return;\n        }\n\n        if (!prevSelection.containsRange(this._currentSelection) && !prevSelection.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) {\n          // cursor didn't move RIGHT\n          return;\n        }\n\n        if (this._editor.getConfiguration().contribInfo.suggest.snippetsPreventQuickSuggestions && SnippetController2.get(this._editor).isInSnippet()) {\n          // no quick suggestion when in snippet mode\n          return;\n        }\n\n        this.cancel();\n\n        this._triggerQuickSuggest.cancelAndSet(function () {\n          if (_this._state !== 0\n          /* Idle */\n          ) {\n              return;\n            }\n\n          if (!LineContext.shouldAutoTrigger(_this._editor)) {\n            return;\n          }\n\n          if (!_this._editor.hasModel()) {\n            return;\n          }\n\n          var model = _this._editor.getModel();\n\n          var pos = _this._editor.getPosition(); // validate enabled now\n\n\n          var quickSuggestions = _this._editor.getConfiguration().contribInfo.quickSuggestions;\n\n          if (quickSuggestions === false) {\n            return;\n          } else if (quickSuggestions === true) {// all good\n          } else {\n            // Check the type of the token that triggered this\n            model.tokenizeIfCheap(pos.lineNumber);\n            var lineTokens = model.getLineTokens(pos.lineNumber);\n            var tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(pos.column - 1 - 1, 0)));\n            var inValidScope = quickSuggestions.other && tokenType === 0\n            /* Other */\n            || quickSuggestions.comments && tokenType === 1\n            /* Comment */\n            || quickSuggestions.strings && tokenType === 2\n            /* String */\n            ;\n\n            if (!inValidScope) {\n              return;\n            }\n          } // we made it till here -> trigger now\n\n\n          _this.trigger({\n            auto: true,\n            shy: false\n          });\n        }, this._quickSuggestDelay);\n      }\n  };\n\n  SuggestModel.prototype._refilterCompletionItems = function () {\n    var _this = this; // Re-filter suggestions. This MUST run async because filtering/scoring\n    // uses the model content AND the cursor position. The latter is NOT\n    // updated when the document has changed (the event which drives this method)\n    // and therefore a little pause (next mirco task) is needed. See:\n    // https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context#25933985\n\n\n    Promise.resolve().then(function () {\n      if (_this._state === 0\n      /* Idle */\n      ) {\n          return;\n        }\n\n      if (!_this._editor.hasModel()) {\n        return;\n      }\n\n      var model = _this._editor.getModel();\n\n      var position = _this._editor.getPosition();\n\n      var ctx = new LineContext(model, position, _this._state === 2\n      /* Auto */\n      , false);\n\n      _this._onNewContext(ctx);\n    });\n  };\n\n  SuggestModel.prototype.trigger = function (context, retrigger, onlyFrom, existingItems) {\n    var _this = this;\n\n    if (retrigger === void 0) {\n      retrigger = false;\n    }\n\n    if (!this._editor.hasModel()) {\n      return;\n    }\n\n    var model = this._editor.getModel();\n\n    var auto = context.auto;\n    var ctx = new LineContext(model, this._editor.getPosition(), auto, context.shy); // Cancel previous requests, change state & update UI\n\n    this.cancel(retrigger);\n    this._state = auto ? 2\n    /* Auto */\n    : 1\n    /* Manual */\n    ;\n\n    this._onDidTrigger.fire({\n      auto: auto,\n      shy: context.shy,\n      position: this._editor.getPosition()\n    }); // Capture context when request was sent\n\n\n    this._context = ctx; // Build context for request\n\n    var suggestCtx;\n\n    if (context.triggerCharacter) {\n      suggestCtx = {\n        triggerKind: 1\n        /* TriggerCharacter */\n        ,\n        triggerCharacter: context.triggerCharacter\n      };\n    } else if (onlyFrom && onlyFrom.size > 0) {\n      suggestCtx = {\n        triggerKind: 2\n        /* TriggerForIncompleteCompletions */\n\n      };\n    } else {\n      suggestCtx = {\n        triggerKind: 0\n        /* Invoke */\n\n      };\n    }\n\n    this._requestToken = new CancellationTokenSource(); // kind filter and snippet sort rules\n\n    var contribInfo = this._editor.getConfiguration().contribInfo;\n\n    var itemKindFilter = new Set();\n    var snippetSortOrder = 1\n    /* Inline */\n    ;\n\n    switch (contribInfo.suggest.snippets) {\n      case 'top':\n        snippetSortOrder = 0\n        /* Top */\n        ;\n        break;\n      // \t↓ that's the default anyways...\n      // case 'inline':\n      // \tsnippetSortOrder = SnippetSortOrder.Inline;\n      // \tbreak;\n\n      case 'bottom':\n        snippetSortOrder = 2\n        /* Bottom */\n        ;\n        break;\n\n      case 'none':\n        itemKindFilter.add(25\n        /* Snippet */\n        );\n        break;\n    } // kind filter\n\n\n    for (var key in contribInfo.suggest.filteredTypes) {\n      var kind = completionKindFromString(key, true);\n\n      if (typeof kind !== 'undefined' && contribInfo.suggest.filteredTypes[key] === false) {\n        itemKindFilter.add(kind);\n      }\n    }\n\n    var wordDistance = WordDistance.create(this._editorWorker, this._editor);\n    var items = provideSuggestionItems(model, this._editor.getPosition(), new CompletionOptions(snippetSortOrder, itemKindFilter, onlyFrom), suggestCtx, this._requestToken.token);\n    Promise.all([items, wordDistance]).then(function (_a) {\n      var items = _a[0],\n          wordDistance = _a[1];\n      dispose(_this._requestToken);\n\n      if (_this._state === 0\n      /* Idle */\n      ) {\n          return;\n        }\n\n      if (!_this._editor.hasModel()) {\n        return;\n      }\n\n      var model = _this._editor.getModel();\n\n      if (isNonEmptyArray(existingItems)) {\n        var cmpFn = getSuggestionComparator(snippetSortOrder);\n        items = items.concat(existingItems).sort(cmpFn);\n      }\n\n      var ctx = new LineContext(model, _this._editor.getPosition(), auto, context.shy);\n      _this._completionModel = new CompletionModel(items, _this._context.column, {\n        leadingLineContent: ctx.leadingLineContent,\n        characterCountDelta: ctx.column - _this._context.column\n      }, wordDistance, _this._editor.getConfiguration().contribInfo.suggest); // store containers so that they can be disposed later\n\n      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n        var item = items_1[_i];\n\n        if (isDisposable(item.container)) {\n          _this._completionDisposables.add(item.container);\n        }\n      }\n\n      _this._onNewContext(ctx);\n    }).catch(onUnexpectedError);\n  };\n\n  SuggestModel.prototype._onNewContext = function (ctx) {\n    if (!this._context) {\n      // happens when 24x7 IntelliSense is enabled and still in its delay\n      return;\n    }\n\n    if (ctx.lineNumber !== this._context.lineNumber) {\n      // e.g. happens when pressing Enter while IntelliSense is computed\n      this.cancel();\n      return;\n    }\n\n    if (ctx.leadingWord.startColumn < this._context.leadingWord.startColumn) {\n      // happens when the current word gets outdented\n      this.cancel();\n      return;\n    }\n\n    if (ctx.column < this._context.column) {\n      // typed -> moved cursor LEFT -> retrigger if still on a word\n      if (ctx.leadingWord.word) {\n        this.trigger({\n          auto: this._context.auto,\n          shy: false\n        }, true);\n      } else {\n        this.cancel();\n      }\n\n      return;\n    }\n\n    if (!this._completionModel) {\n      // happens when IntelliSense is not yet computed\n      return;\n    }\n\n    if (ctx.column > this._context.column && this._completionModel.incomplete.size > 0 && ctx.leadingWord.word.length !== 0) {\n      // typed -> moved cursor RIGHT & incomple model & still on a word -> retrigger\n      var incomplete = this._completionModel.incomplete;\n\n      var adopted = this._completionModel.adopt(incomplete);\n\n      this.trigger({\n        auto: this._state === 2\n        /* Auto */\n        ,\n        shy: false\n      }, true, incomplete, adopted);\n    } else {\n      // typed -> moved cursor RIGHT -> update UI\n      var oldLineContext = this._completionModel.lineContext;\n      var isFrozen = false;\n      this._completionModel.lineContext = {\n        leadingLineContent: ctx.leadingLineContent,\n        characterCountDelta: ctx.column - this._context.column\n      };\n\n      if (this._completionModel.items.length === 0) {\n        if (LineContext.shouldAutoTrigger(this._editor) && this._context.leadingWord.endColumn < ctx.leadingWord.startColumn) {\n          // retrigger when heading into a new word\n          this.trigger({\n            auto: this._context.auto,\n            shy: false\n          }, true);\n          return;\n        }\n\n        if (!this._context.auto) {\n          // freeze when IntelliSense was manually requested\n          this._completionModel.lineContext = oldLineContext;\n          isFrozen = this._completionModel.items.length > 0;\n\n          if (isFrozen && ctx.leadingWord.word.length === 0) {\n            // there were results before but now there aren't\n            // and also we are not on a word anymore -> cancel\n            this.cancel();\n            return;\n          }\n        } else {\n          // nothing left\n          this.cancel();\n          return;\n        }\n      }\n\n      this._onDidSuggest.fire({\n        completionModel: this._completionModel,\n        auto: this._context.auto,\n        shy: this._context.shy,\n        isFrozen: isFrozen\n      });\n    }\n  };\n\n  return SuggestModel;\n}();\n\nexport { SuggestModel };","map":null,"metadata":{},"sourceType":"module"}