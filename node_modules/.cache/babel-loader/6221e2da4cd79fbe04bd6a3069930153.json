{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport './folding.css';\nimport * as nls from '../../../nls.js';\nimport * as types from '../../../base/common/types.js';\nimport { escapeRegExpCharacters } from '../../../base/common/strings.js';\nimport { RunOnceScheduler, Delayer, createCancelablePromise } from '../../../base/common/async.js';\nimport { KeyChord } from '../../../base/common/keyCodes.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { registerEditorAction, registerEditorContribution, EditorAction, registerInstantiatedEditorAction } from '../../browser/editorExtensions.js';\nimport { FoldingModel, setCollapseStateAtLevel, setCollapseStateLevelsDown, setCollapseStateLevelsUp, setCollapseStateForMatchingLines, setCollapseStateForType } from './foldingModel.js';\nimport { FoldingDecorationProvider } from './foldingDecorations.js';\nimport { EditorContextKeys } from '../../common/editorContextKeys.js';\nimport { HiddenRangeModel } from './hiddenRangeModel.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport { IndentRangeProvider } from './indentRangeProvider.js';\nimport { FoldingRangeProviderRegistry, FoldingRangeKind } from '../../common/modes.js';\nimport { SyntaxRangeProvider, ID_SYNTAX_PROVIDER } from './syntaxRangeProvider.js';\nimport { InitializingRangeProvider, ID_INIT_PROVIDER } from './intializingRangeProvider.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { RawContextKey, IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nvar CONTEXT_FOLDING_ENABLED = new RawContextKey('foldingEnabled', false);\nexport var ID = 'editor.contrib.folding';\n\nvar FoldingController =\n/** @class */\nfunction (_super) {\n  __extends(FoldingController, _super);\n\n  function FoldingController(editor, contextKeyService) {\n    var _this = _super.call(this) || this;\n\n    _this.contextKeyService = contextKeyService;\n    _this.localToDispose = _this._register(new DisposableStore());\n    _this.editor = editor;\n    _this._isEnabled = _this.editor.getConfiguration().contribInfo.folding;\n    _this._autoHideFoldingControls = _this.editor.getConfiguration().contribInfo.showFoldingControls === 'mouseover';\n    _this._useFoldingProviders = _this.editor.getConfiguration().contribInfo.foldingStrategy !== 'indentation';\n    _this.foldingModel = null;\n    _this.hiddenRangeModel = null;\n    _this.rangeProvider = null;\n    _this.foldingRegionPromise = null;\n    _this.foldingStateMemento = null;\n    _this.foldingModelPromise = null;\n    _this.updateScheduler = null;\n    _this.cursorChangedScheduler = null;\n    _this.mouseDownInfo = null;\n    _this.foldingDecorationProvider = new FoldingDecorationProvider(editor);\n    _this.foldingDecorationProvider.autoHideFoldingControls = _this._autoHideFoldingControls;\n    _this.foldingEnabled = CONTEXT_FOLDING_ENABLED.bindTo(_this.contextKeyService);\n\n    _this.foldingEnabled.set(_this._isEnabled);\n\n    _this._register(_this.editor.onDidChangeModel(function () {\n      return _this.onModelChanged();\n    }));\n\n    _this._register(_this.editor.onDidChangeConfiguration(function (e) {\n      if (e.contribInfo) {\n        var oldIsEnabled = _this._isEnabled;\n        _this._isEnabled = _this.editor.getConfiguration().contribInfo.folding;\n\n        _this.foldingEnabled.set(_this._isEnabled);\n\n        if (oldIsEnabled !== _this._isEnabled) {\n          _this.onModelChanged();\n        }\n\n        var oldShowFoldingControls = _this._autoHideFoldingControls;\n        _this._autoHideFoldingControls = _this.editor.getConfiguration().contribInfo.showFoldingControls === 'mouseover';\n\n        if (oldShowFoldingControls !== _this._autoHideFoldingControls) {\n          _this.foldingDecorationProvider.autoHideFoldingControls = _this._autoHideFoldingControls;\n\n          _this.onModelContentChanged();\n        }\n\n        var oldUseFoldingProviders = _this._useFoldingProviders;\n        _this._useFoldingProviders = _this.editor.getConfiguration().contribInfo.foldingStrategy !== 'indentation';\n\n        if (oldUseFoldingProviders !== _this._useFoldingProviders) {\n          _this.onFoldingStrategyChanged();\n        }\n      }\n    }));\n\n    _this.onModelChanged();\n\n    return _this;\n  }\n\n  FoldingController.get = function (editor) {\n    return editor.getContribution(ID);\n  };\n\n  FoldingController.prototype.getId = function () {\n    return ID;\n  };\n  /**\n   * Store view state.\n   */\n\n\n  FoldingController.prototype.saveViewState = function () {\n    var model = this.editor.getModel();\n\n    if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {\n      return {};\n    }\n\n    if (this.foldingModel) {\n      // disposed ?\n      var collapsedRegions = this.foldingModel.isInitialized ? this.foldingModel.getMemento() : this.hiddenRangeModel.getMemento();\n      var provider = this.rangeProvider ? this.rangeProvider.id : undefined;\n      return {\n        collapsedRegions: collapsedRegions,\n        lineCount: model.getLineCount(),\n        provider: provider\n      };\n    }\n\n    return undefined;\n  };\n  /**\n   * Restore view state.\n   */\n\n\n  FoldingController.prototype.restoreViewState = function (state) {\n    var model = this.editor.getModel();\n\n    if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) {\n      return;\n    }\n\n    if (!state || !state.collapsedRegions || state.lineCount !== model.getLineCount()) {\n      return;\n    }\n\n    if (state.provider === ID_SYNTAX_PROVIDER || state.provider === ID_INIT_PROVIDER) {\n      this.foldingStateMemento = state;\n    }\n\n    var collapsedRegions = state.collapsedRegions; // set the hidden ranges right away, before waiting for the folding model.\n\n    if (this.hiddenRangeModel.applyMemento(collapsedRegions)) {\n      var foldingModel = this.getFoldingModel();\n\n      if (foldingModel) {\n        foldingModel.then(function (foldingModel) {\n          if (foldingModel) {\n            foldingModel.applyMemento(collapsedRegions);\n          }\n        }).then(undefined, onUnexpectedError);\n      }\n    }\n  };\n\n  FoldingController.prototype.onModelChanged = function () {\n    var _this = this;\n\n    this.localToDispose.clear();\n    var model = this.editor.getModel();\n\n    if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {\n      // huge files get no view model, so they cannot support hidden areas\n      return;\n    }\n\n    this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);\n    this.localToDispose.add(this.foldingModel);\n    this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);\n    this.localToDispose.add(this.hiddenRangeModel);\n    this.localToDispose.add(this.hiddenRangeModel.onDidChange(function (hr) {\n      return _this.onHiddenRangesChanges(hr);\n    }));\n    this.updateScheduler = new Delayer(200);\n    this.cursorChangedScheduler = new RunOnceScheduler(function () {\n      return _this.revealCursor();\n    }, 200);\n    this.localToDispose.add(this.cursorChangedScheduler);\n    this.localToDispose.add(FoldingRangeProviderRegistry.onDidChange(function () {\n      return _this.onFoldingStrategyChanged();\n    }));\n    this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(function () {\n      return _this.onFoldingStrategyChanged();\n    })); // covers model language changes as well\n\n    this.localToDispose.add(this.editor.onDidChangeModelContent(function () {\n      return _this.onModelContentChanged();\n    }));\n    this.localToDispose.add(this.editor.onDidChangeCursorPosition(function () {\n      return _this.onCursorPositionChanged();\n    }));\n    this.localToDispose.add(this.editor.onMouseDown(function (e) {\n      return _this.onEditorMouseDown(e);\n    }));\n    this.localToDispose.add(this.editor.onMouseUp(function (e) {\n      return _this.onEditorMouseUp(e);\n    }));\n    this.localToDispose.add({\n      dispose: function () {\n        if (_this.foldingRegionPromise) {\n          _this.foldingRegionPromise.cancel();\n\n          _this.foldingRegionPromise = null;\n        }\n\n        if (_this.updateScheduler) {\n          _this.updateScheduler.cancel();\n        }\n\n        _this.updateScheduler = null;\n        _this.foldingModel = null;\n        _this.foldingModelPromise = null;\n        _this.hiddenRangeModel = null;\n        _this.cursorChangedScheduler = null;\n        _this.foldingStateMemento = null;\n\n        if (_this.rangeProvider) {\n          _this.rangeProvider.dispose();\n        }\n\n        _this.rangeProvider = null;\n      }\n    });\n    this.onModelContentChanged();\n  };\n\n  FoldingController.prototype.onFoldingStrategyChanged = function () {\n    if (this.rangeProvider) {\n      this.rangeProvider.dispose();\n    }\n\n    this.rangeProvider = null;\n    this.onModelContentChanged();\n  };\n\n  FoldingController.prototype.getRangeProvider = function (editorModel) {\n    var _this = this;\n\n    if (this.rangeProvider) {\n      return this.rangeProvider;\n    }\n\n    this.rangeProvider = new IndentRangeProvider(editorModel); // fallback\n\n    if (this._useFoldingProviders && this.foldingModel) {\n      var foldingProviders = FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel);\n\n      if (foldingProviders.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions) {\n        var rangeProvider = this.rangeProvider = new InitializingRangeProvider(editorModel, this.foldingStateMemento.collapsedRegions, function () {\n          // if after 30 the InitializingRangeProvider is still not replaced, force a refresh\n          _this.foldingStateMemento = null;\n\n          _this.onFoldingStrategyChanged();\n        }, 30000);\n        return rangeProvider; // keep memento in case there are still no foldingProviders on the next request.\n      } else if (foldingProviders.length > 0) {\n        this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders);\n      }\n    }\n\n    this.foldingStateMemento = null;\n    return this.rangeProvider;\n  };\n\n  FoldingController.prototype.getFoldingModel = function () {\n    return this.foldingModelPromise;\n  };\n\n  FoldingController.prototype.onModelContentChanged = function () {\n    var _this = this;\n\n    if (this.updateScheduler) {\n      if (this.foldingRegionPromise) {\n        this.foldingRegionPromise.cancel();\n        this.foldingRegionPromise = null;\n      }\n\n      this.foldingModelPromise = this.updateScheduler.trigger(function () {\n        var foldingModel = _this.foldingModel;\n\n        if (!foldingModel) {\n          // null if editor has been disposed, or folding turned off\n          return null;\n        }\n\n        var foldingRegionPromise = _this.foldingRegionPromise = createCancelablePromise(function (token) {\n          return _this.getRangeProvider(foldingModel.textModel).compute(token);\n        });\n        return foldingRegionPromise.then(function (foldingRanges) {\n          if (foldingRanges && foldingRegionPromise === _this.foldingRegionPromise) {\n            // new request or cancelled in the meantime?\n            // some cursors might have moved into hidden regions, make sure they are in expanded regions\n            var selections = _this.editor.getSelections();\n\n            var selectionLineNumbers = selections ? selections.map(function (s) {\n              return s.startLineNumber;\n            }) : [];\n            foldingModel.update(foldingRanges, selectionLineNumbers);\n          }\n\n          return foldingModel;\n        });\n      }).then(undefined, function (err) {\n        onUnexpectedError(err);\n        return null;\n      });\n    }\n  };\n\n  FoldingController.prototype.onHiddenRangesChanges = function (hiddenRanges) {\n    if (this.hiddenRangeModel && hiddenRanges.length) {\n      var selections = this.editor.getSelections();\n\n      if (selections) {\n        if (this.hiddenRangeModel.adjustSelections(selections)) {\n          this.editor.setSelections(selections);\n        }\n      }\n    }\n\n    this.editor.setHiddenAreas(hiddenRanges);\n  };\n\n  FoldingController.prototype.onCursorPositionChanged = function () {\n    if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) {\n      this.cursorChangedScheduler.schedule();\n    }\n  };\n\n  FoldingController.prototype.revealCursor = function () {\n    var _this = this;\n\n    var foldingModel = this.getFoldingModel();\n\n    if (!foldingModel) {\n      return;\n    }\n\n    foldingModel.then(function (foldingModel) {\n      if (foldingModel) {\n        var selections = _this.editor.getSelections();\n\n        if (selections && selections.length > 0) {\n          var toToggle = [];\n\n          var _loop_1 = function (selection) {\n            var lineNumber = selection.selectionStartLineNumber;\n\n            if (_this.hiddenRangeModel && _this.hiddenRangeModel.isHidden(lineNumber)) {\n              toToggle.push.apply(toToggle, foldingModel.getAllRegionsAtLine(lineNumber, function (r) {\n                return r.isCollapsed && lineNumber > r.startLineNumber;\n              }));\n            }\n          };\n\n          for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {\n            var selection = selections_1[_i];\n\n            _loop_1(selection);\n          }\n\n          if (toToggle.length) {\n            foldingModel.toggleCollapseState(toToggle);\n\n            _this.reveal(selections[0].getPosition());\n          }\n        }\n      }\n    }).then(undefined, onUnexpectedError);\n  };\n\n  FoldingController.prototype.onEditorMouseDown = function (e) {\n    this.mouseDownInfo = null;\n\n    if (!this.hiddenRangeModel || !e.target || !e.target.range) {\n      return;\n    }\n\n    if (!e.event.leftButton && !e.event.middleButton) {\n      return;\n    }\n\n    var range = e.target.range;\n    var iconClicked = false;\n\n    switch (e.target.type) {\n      case 4\n      /* GUTTER_LINE_DECORATIONS */\n      :\n        var data = e.target.detail;\n        var offsetLeftInGutter = e.target.element.offsetLeft;\n        var gutterOffsetX = data.offsetX - offsetLeftInGutter; // const gutterOffsetX = data.offsetX - data.glyphMarginWidth - data.lineNumbersWidth - data.glyphMarginLeft;\n        // TODO@joao TODO@alex TODO@martin this is such that we don't collide with dirty diff\n\n        if (gutterOffsetX < 5) {\n          // the whitespace between the border and the real folding icon border is 5px\n          return;\n        }\n\n        iconClicked = true;\n        break;\n\n      case 7\n      /* CONTENT_EMPTY */\n      :\n        {\n          if (this.hiddenRangeModel.hasRanges()) {\n            var data_1 = e.target.detail;\n\n            if (!data_1.isAfterLines) {\n              break;\n            }\n          }\n\n          return;\n        }\n\n      case 6\n      /* CONTENT_TEXT */\n      :\n        {\n          if (this.hiddenRangeModel.hasRanges()) {\n            var model = this.editor.getModel();\n\n            if (model && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {\n              break;\n            }\n          }\n\n          return;\n        }\n\n      default:\n        return;\n    }\n\n    this.mouseDownInfo = {\n      lineNumber: range.startLineNumber,\n      iconClicked: iconClicked\n    };\n  };\n\n  FoldingController.prototype.onEditorMouseUp = function (e) {\n    var _this = this;\n\n    var foldingModel = this.getFoldingModel();\n\n    if (!foldingModel || !this.mouseDownInfo || !e.target) {\n      return;\n    }\n\n    var lineNumber = this.mouseDownInfo.lineNumber;\n    var iconClicked = this.mouseDownInfo.iconClicked;\n    var range = e.target.range;\n\n    if (!range || range.startLineNumber !== lineNumber) {\n      return;\n    }\n\n    if (iconClicked) {\n      if (e.target.type !== 4\n      /* GUTTER_LINE_DECORATIONS */\n      ) {\n          return;\n        }\n    } else {\n      var model = this.editor.getModel();\n\n      if (!model || range.startColumn !== model.getLineMaxColumn(lineNumber)) {\n        return;\n      }\n    }\n\n    foldingModel.then(function (foldingModel) {\n      if (foldingModel) {\n        var region = foldingModel.getRegionAtLine(lineNumber);\n\n        if (region && region.startLineNumber === lineNumber) {\n          var isCollapsed_1 = region.isCollapsed;\n\n          if (iconClicked || isCollapsed_1) {\n            var toToggle = [region];\n\n            if (e.event.middleButton || e.event.shiftKey) {\n              toToggle.push.apply(toToggle, foldingModel.getRegionsInside(region, function (r) {\n                return r.isCollapsed === isCollapsed_1;\n              }));\n            }\n\n            foldingModel.toggleCollapseState(toToggle);\n\n            _this.reveal({\n              lineNumber: lineNumber,\n              column: 1\n            });\n          }\n        }\n      }\n    }).then(undefined, onUnexpectedError);\n  };\n\n  FoldingController.prototype.reveal = function (position) {\n    this.editor.revealPositionInCenterIfOutsideViewport(position, 0\n    /* Smooth */\n    );\n  };\n\n  FoldingController = __decorate([__param(1, IContextKeyService)], FoldingController);\n  return FoldingController;\n}(Disposable);\n\nexport { FoldingController };\n\nvar FoldingAction =\n/** @class */\nfunction (_super) {\n  __extends(FoldingAction, _super);\n\n  function FoldingAction() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FoldingAction.prototype.runEditorCommand = function (accessor, editor, args) {\n    var _this = this;\n\n    var foldingController = FoldingController.get(editor);\n\n    if (!foldingController) {\n      return;\n    }\n\n    var foldingModelPromise = foldingController.getFoldingModel();\n\n    if (foldingModelPromise) {\n      this.reportTelemetry(accessor, editor);\n      return foldingModelPromise.then(function (foldingModel) {\n        if (foldingModel) {\n          _this.invoke(foldingController, foldingModel, editor, args);\n\n          var selection = editor.getSelection();\n\n          if (selection) {\n            foldingController.reveal(selection.getStartPosition());\n          }\n        }\n      });\n    }\n  };\n\n  FoldingAction.prototype.getSelectedLines = function (editor) {\n    var selections = editor.getSelections();\n    return selections ? selections.map(function (s) {\n      return s.startLineNumber;\n    }) : [];\n  };\n\n  FoldingAction.prototype.getLineNumbers = function (args, editor) {\n    if (args && args.selectionLines) {\n      return args.selectionLines.map(function (l) {\n        return l + 1;\n      }); // to 0-bases line numbers\n    }\n\n    return this.getSelectedLines(editor);\n  };\n\n  FoldingAction.prototype.run = function (_accessor, _editor) {};\n\n  return FoldingAction;\n}(EditorAction);\n\nfunction foldingArgumentsConstraint(args) {\n  if (!types.isUndefined(args)) {\n    if (!types.isObject(args)) {\n      return false;\n    }\n\n    var foldingArgs = args;\n\n    if (!types.isUndefined(foldingArgs.levels) && !types.isNumber(foldingArgs.levels)) {\n      return false;\n    }\n\n    if (!types.isUndefined(foldingArgs.direction) && !types.isString(foldingArgs.direction)) {\n      return false;\n    }\n\n    if (!types.isUndefined(foldingArgs.selectionLines) && (!types.isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(types.isNumber))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar UnfoldAction =\n/** @class */\nfunction (_super) {\n  __extends(UnfoldAction, _super);\n\n  function UnfoldAction() {\n    return _super.call(this, {\n      id: 'editor.unfold',\n      label: nls.localize('unfoldAction.label', \"Unfold\"),\n      alias: 'Unfold',\n      precondition: CONTEXT_FOLDING_ENABLED,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 2048\n        /* CtrlCmd */\n        | 1024\n        /* Shift */\n        | 89\n        /* US_CLOSE_SQUARE_BRACKET */\n        ,\n        mac: {\n          primary: 2048\n          /* CtrlCmd */\n          | 512\n          /* Alt */\n          | 89\n          /* US_CLOSE_SQUARE_BRACKET */\n\n        },\n        weight: 100\n        /* EditorContrib */\n\n      },\n      description: {\n        description: 'Unfold the content in the editor',\n        args: [{\n          name: 'Unfold editor argument',\n          description: \"Property-value pairs that can be passed through this argument:\\n\\t\\t\\t\\t\\t\\t* 'levels': Number of levels to unfold. If not set, defaults to 1.\\n\\t\\t\\t\\t\\t\\t* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.\\n\\t\\t\\t\\t\\t\\t* 'selectionLines': The start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.\\n\\t\\t\\t\\t\\t\\t\",\n          constraint: foldingArgumentsConstraint,\n          schema: {\n            'type': 'object',\n            'properties': {\n              'levels': {\n                'type': 'number',\n                'default': 1\n              },\n              'direction': {\n                'type': 'string',\n                'enum': ['up', 'down'],\n                'default': 'down'\n              },\n              'selectionLines': {\n                'type': 'array',\n                'items': {\n                  'type': 'number'\n                }\n              }\n            }\n          }\n        }]\n      }\n    }) || this;\n  }\n\n  UnfoldAction.prototype.invoke = function (_foldingController, foldingModel, editor, args) {\n    var levels = args && args.levels || 1;\n    var lineNumbers = this.getLineNumbers(args, editor);\n\n    if (args && args.direction === 'up') {\n      setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);\n    } else {\n      setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);\n    }\n  };\n\n  return UnfoldAction;\n}(FoldingAction);\n\nvar UnFoldRecursivelyAction =\n/** @class */\nfunction (_super) {\n  __extends(UnFoldRecursivelyAction, _super);\n\n  function UnFoldRecursivelyAction() {\n    return _super.call(this, {\n      id: 'editor.unfoldRecursively',\n      label: nls.localize('unFoldRecursivelyAction.label', \"Unfold Recursively\"),\n      alias: 'Unfold Recursively',\n      precondition: CONTEXT_FOLDING_ENABLED,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: KeyChord(2048\n        /* CtrlCmd */\n        | 41\n        /* KEY_K */\n        , 2048\n        /* CtrlCmd */\n        | 89\n        /* US_CLOSE_SQUARE_BRACKET */\n        ),\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  UnFoldRecursivelyAction.prototype.invoke = function (_foldingController, foldingModel, editor, _args) {\n    setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor));\n  };\n\n  return UnFoldRecursivelyAction;\n}(FoldingAction);\n\nvar FoldAction =\n/** @class */\nfunction (_super) {\n  __extends(FoldAction, _super);\n\n  function FoldAction() {\n    return _super.call(this, {\n      id: 'editor.fold',\n      label: nls.localize('foldAction.label', \"Fold\"),\n      alias: 'Fold',\n      precondition: CONTEXT_FOLDING_ENABLED,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 2048\n        /* CtrlCmd */\n        | 1024\n        /* Shift */\n        | 87\n        /* US_OPEN_SQUARE_BRACKET */\n        ,\n        mac: {\n          primary: 2048\n          /* CtrlCmd */\n          | 512\n          /* Alt */\n          | 87\n          /* US_OPEN_SQUARE_BRACKET */\n\n        },\n        weight: 100\n        /* EditorContrib */\n\n      },\n      description: {\n        description: 'Fold the content in the editor',\n        args: [{\n          name: 'Fold editor argument',\n          description: \"Property-value pairs that can be passed through this argument:\\n\\t\\t\\t\\t\\t\\t\\t* 'levels': Number of levels to fold. Defaults to 1.\\n\\t\\t\\t\\t\\t\\t\\t* 'direction': If 'up', folds given number of levels up otherwise folds down.\\n\\t\\t\\t\\t\\t\\t\\t* 'selectionLines': The start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.\\n\\t\\t\\t\\t\\t\\t\",\n          constraint: foldingArgumentsConstraint,\n          schema: {\n            'type': 'object',\n            'properties': {\n              'levels': {\n                'type': 'number',\n                'default': 1\n              },\n              'direction': {\n                'type': 'string',\n                'enum': ['up', 'down'],\n                'default': 'down'\n              },\n              'selectionLines': {\n                'type': 'array',\n                'items': {\n                  'type': 'number'\n                }\n              }\n            }\n          }\n        }]\n      }\n    }) || this;\n  }\n\n  FoldAction.prototype.invoke = function (_foldingController, foldingModel, editor, args) {\n    var levels = args && args.levels || 1;\n    var lineNumbers = this.getLineNumbers(args, editor);\n\n    if (args && args.direction === 'up') {\n      setCollapseStateLevelsUp(foldingModel, true, levels, lineNumbers);\n    } else {\n      setCollapseStateLevelsDown(foldingModel, true, levels, lineNumbers);\n    }\n  };\n\n  return FoldAction;\n}(FoldingAction);\n\nvar FoldRecursivelyAction =\n/** @class */\nfunction (_super) {\n  __extends(FoldRecursivelyAction, _super);\n\n  function FoldRecursivelyAction() {\n    return _super.call(this, {\n      id: 'editor.foldRecursively',\n      label: nls.localize('foldRecursivelyAction.label', \"Fold Recursively\"),\n      alias: 'Fold Recursively',\n      precondition: CONTEXT_FOLDING_ENABLED,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: KeyChord(2048\n        /* CtrlCmd */\n        | 41\n        /* KEY_K */\n        , 2048\n        /* CtrlCmd */\n        | 87\n        /* US_OPEN_SQUARE_BRACKET */\n        ),\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  FoldRecursivelyAction.prototype.invoke = function (_foldingController, foldingModel, editor) {\n    var selectedLines = this.getSelectedLines(editor);\n    setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);\n  };\n\n  return FoldRecursivelyAction;\n}(FoldingAction);\n\nvar FoldAllBlockCommentsAction =\n/** @class */\nfunction (_super) {\n  __extends(FoldAllBlockCommentsAction, _super);\n\n  function FoldAllBlockCommentsAction() {\n    return _super.call(this, {\n      id: 'editor.foldAllBlockComments',\n      label: nls.localize('foldAllBlockComments.label', \"Fold All Block Comments\"),\n      alias: 'Fold All Block Comments',\n      precondition: CONTEXT_FOLDING_ENABLED,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: KeyChord(2048\n        /* CtrlCmd */\n        | 41\n        /* KEY_K */\n        , 2048\n        /* CtrlCmd */\n        | 85\n        /* US_SLASH */\n        ),\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  FoldAllBlockCommentsAction.prototype.invoke = function (_foldingController, foldingModel, editor) {\n    if (foldingModel.regions.hasTypes()) {\n      setCollapseStateForType(foldingModel, FoldingRangeKind.Comment.value, true);\n    } else {\n      var editorModel = editor.getModel();\n\n      if (!editorModel) {\n        return;\n      }\n\n      var comments = LanguageConfigurationRegistry.getComments(editorModel.getLanguageIdentifier().id);\n\n      if (comments && comments.blockCommentStartToken) {\n        var regExp = new RegExp('^\\\\s*' + escapeRegExpCharacters(comments.blockCommentStartToken));\n        setCollapseStateForMatchingLines(foldingModel, regExp, true);\n      }\n    }\n  };\n\n  return FoldAllBlockCommentsAction;\n}(FoldingAction);\n\nvar FoldAllRegionsAction =\n/** @class */\nfunction (_super) {\n  __extends(FoldAllRegionsAction, _super);\n\n  function FoldAllRegionsAction() {\n    return _super.call(this, {\n      id: 'editor.foldAllMarkerRegions',\n      label: nls.localize('foldAllMarkerRegions.label', \"Fold All Regions\"),\n      alias: 'Fold All Regions',\n      precondition: CONTEXT_FOLDING_ENABLED,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: KeyChord(2048\n        /* CtrlCmd */\n        | 41\n        /* KEY_K */\n        , 2048\n        /* CtrlCmd */\n        | 29\n        /* KEY_8 */\n        ),\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  FoldAllRegionsAction.prototype.invoke = function (_foldingController, foldingModel, editor) {\n    if (foldingModel.regions.hasTypes()) {\n      setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, true);\n    } else {\n      var editorModel = editor.getModel();\n\n      if (!editorModel) {\n        return;\n      }\n\n      var foldingRules = LanguageConfigurationRegistry.getFoldingRules(editorModel.getLanguageIdentifier().id);\n\n      if (foldingRules && foldingRules.markers && foldingRules.markers.start) {\n        var regExp = new RegExp(foldingRules.markers.start);\n        setCollapseStateForMatchingLines(foldingModel, regExp, true);\n      }\n    }\n  };\n\n  return FoldAllRegionsAction;\n}(FoldingAction);\n\nvar UnfoldAllRegionsAction =\n/** @class */\nfunction (_super) {\n  __extends(UnfoldAllRegionsAction, _super);\n\n  function UnfoldAllRegionsAction() {\n    return _super.call(this, {\n      id: 'editor.unfoldAllMarkerRegions',\n      label: nls.localize('unfoldAllMarkerRegions.label', \"Unfold All Regions\"),\n      alias: 'Unfold All Regions',\n      precondition: CONTEXT_FOLDING_ENABLED,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: KeyChord(2048\n        /* CtrlCmd */\n        | 41\n        /* KEY_K */\n        , 2048\n        /* CtrlCmd */\n        | 30\n        /* KEY_9 */\n        ),\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  UnfoldAllRegionsAction.prototype.invoke = function (_foldingController, foldingModel, editor) {\n    if (foldingModel.regions.hasTypes()) {\n      setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, false);\n    } else {\n      var editorModel = editor.getModel();\n\n      if (!editorModel) {\n        return;\n      }\n\n      var foldingRules = LanguageConfigurationRegistry.getFoldingRules(editorModel.getLanguageIdentifier().id);\n\n      if (foldingRules && foldingRules.markers && foldingRules.markers.start) {\n        var regExp = new RegExp(foldingRules.markers.start);\n        setCollapseStateForMatchingLines(foldingModel, regExp, false);\n      }\n    }\n  };\n\n  return UnfoldAllRegionsAction;\n}(FoldingAction);\n\nvar FoldAllAction =\n/** @class */\nfunction (_super) {\n  __extends(FoldAllAction, _super);\n\n  function FoldAllAction() {\n    return _super.call(this, {\n      id: 'editor.foldAll',\n      label: nls.localize('foldAllAction.label', \"Fold All\"),\n      alias: 'Fold All',\n      precondition: CONTEXT_FOLDING_ENABLED,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: KeyChord(2048\n        /* CtrlCmd */\n        | 41\n        /* KEY_K */\n        , 2048\n        /* CtrlCmd */\n        | 21\n        /* KEY_0 */\n        ),\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  FoldAllAction.prototype.invoke = function (_foldingController, foldingModel, _editor) {\n    setCollapseStateLevelsDown(foldingModel, true);\n  };\n\n  return FoldAllAction;\n}(FoldingAction);\n\nvar UnfoldAllAction =\n/** @class */\nfunction (_super) {\n  __extends(UnfoldAllAction, _super);\n\n  function UnfoldAllAction() {\n    return _super.call(this, {\n      id: 'editor.unfoldAll',\n      label: nls.localize('unfoldAllAction.label', \"Unfold All\"),\n      alias: 'Unfold All',\n      precondition: CONTEXT_FOLDING_ENABLED,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: KeyChord(2048\n        /* CtrlCmd */\n        | 41\n        /* KEY_K */\n        , 2048\n        /* CtrlCmd */\n        | 40\n        /* KEY_J */\n        ),\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  UnfoldAllAction.prototype.invoke = function (_foldingController, foldingModel, _editor) {\n    setCollapseStateLevelsDown(foldingModel, false);\n  };\n\n  return UnfoldAllAction;\n}(FoldingAction);\n\nvar FoldLevelAction =\n/** @class */\nfunction (_super) {\n  __extends(FoldLevelAction, _super);\n\n  function FoldLevelAction() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FoldLevelAction.prototype.getFoldingLevel = function () {\n    return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));\n  };\n\n  FoldLevelAction.prototype.invoke = function (_foldingController, foldingModel, editor) {\n    setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor));\n  };\n\n  FoldLevelAction.ID_PREFIX = 'editor.foldLevel';\n\n  FoldLevelAction.ID = function (level) {\n    return FoldLevelAction.ID_PREFIX + level;\n  };\n\n  return FoldLevelAction;\n}(FoldingAction);\n\nregisterEditorContribution(FoldingController);\nregisterEditorAction(UnfoldAction);\nregisterEditorAction(UnFoldRecursivelyAction);\nregisterEditorAction(FoldAction);\nregisterEditorAction(FoldRecursivelyAction);\nregisterEditorAction(FoldAllAction);\nregisterEditorAction(UnfoldAllAction);\nregisterEditorAction(FoldAllBlockCommentsAction);\nregisterEditorAction(FoldAllRegionsAction);\nregisterEditorAction(UnfoldAllRegionsAction);\n\nfor (var i = 1; i <= 7; i++) {\n  registerInstantiatedEditorAction(new FoldLevelAction({\n    id: FoldLevelAction.ID(i),\n    label: nls.localize('foldLevelAction.label', \"Fold Level {0}\", i),\n    alias: \"Fold Level \" + i,\n    precondition: CONTEXT_FOLDING_ENABLED,\n    kbOpts: {\n      kbExpr: EditorContextKeys.editorTextFocus,\n      primary: KeyChord(2048\n      /* CtrlCmd */\n      | 41\n      /* KEY_K */\n      , 2048\n      /* CtrlCmd */\n      | 21\n      /* KEY_0 */\n      + i),\n      weight: 100\n      /* EditorContrib */\n\n    }\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}