{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as formatter from './impl/format.js';\nimport * as edit from './impl/edit.js';\nimport * as scanner from './impl/scanner.js';\nimport * as parser from './impl/parser.js';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\n\nexport var createScanner = scanner.createScanner;\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\n\nexport var getLocation = parser.getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\n\nexport var parse = parser.parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\n\nexport var parseTree = parser.parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\n\nexport var findNodeAtLocation = parser.findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\n\nexport var findNodeAtOffset = parser.findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\n\nexport var getNodePath = parser.getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\n\nexport var getNodeValue = parser.getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\n\nexport var visit = parser.visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\n\nexport var stripComments = parser.stripComments;\nexport function printParseErrorCode(code) {\n  switch (code) {\n    case 1\n    /* InvalidSymbol */\n    :\n      return 'InvalidSymbol';\n\n    case 2\n    /* InvalidNumberFormat */\n    :\n      return 'InvalidNumberFormat';\n\n    case 3\n    /* PropertyNameExpected */\n    :\n      return 'PropertyNameExpected';\n\n    case 4\n    /* ValueExpected */\n    :\n      return 'ValueExpected';\n\n    case 5\n    /* ColonExpected */\n    :\n      return 'ColonExpected';\n\n    case 6\n    /* CommaExpected */\n    :\n      return 'CommaExpected';\n\n    case 7\n    /* CloseBraceExpected */\n    :\n      return 'CloseBraceExpected';\n\n    case 8\n    /* CloseBracketExpected */\n    :\n      return 'CloseBracketExpected';\n\n    case 9\n    /* EndOfFileExpected */\n    :\n      return 'EndOfFileExpected';\n\n    case 10\n    /* InvalidCommentToken */\n    :\n      return 'InvalidCommentToken';\n\n    case 11\n    /* UnexpectedEndOfComment */\n    :\n      return 'UnexpectedEndOfComment';\n\n    case 12\n    /* UnexpectedEndOfString */\n    :\n      return 'UnexpectedEndOfString';\n\n    case 13\n    /* UnexpectedEndOfNumber */\n    :\n      return 'UnexpectedEndOfNumber';\n\n    case 14\n    /* InvalidUnicode */\n    :\n      return 'InvalidUnicode';\n\n    case 15\n    /* InvalidEscapeCharacter */\n    :\n      return 'InvalidEscapeCharacter';\n\n    case 16\n    /* InvalidCharacter */\n    :\n      return 'InvalidCharacter';\n  }\n\n  return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edits needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\n\nexport function format(documentText, range, options) {\n  return formatter.format(documentText, range, options);\n}\n/**\n * Computes the edits needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\n\nexport function modify(text, path, value, options) {\n  return edit.setProperty(text, path, value, options.formattingOptions, options.getInsertionIndex);\n}\n/**\n * Applies edits to a input string.\n */\n\nexport function applyEdits(text, edits) {\n  for (var i = edits.length - 1; i >= 0; i--) {\n    text = edit.applyEdit(text, edits[i]);\n  }\n\n  return text;\n}","map":null,"metadata":{},"sourceType":"module"}