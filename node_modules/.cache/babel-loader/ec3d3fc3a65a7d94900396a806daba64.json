{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar _a;\n\nvar Scanner =\n/** @class */\nfunction () {\n  function Scanner() {\n    this.value = '';\n    this.pos = 0;\n  }\n\n  Scanner.isDigitCharacter = function (ch) {\n    return ch >= 48\n    /* Digit0 */\n    && ch <= 57\n    /* Digit9 */\n    ;\n  };\n\n  Scanner.isVariableCharacter = function (ch) {\n    return ch === 95\n    /* Underline */\n    || ch >= 97\n    /* a */\n    && ch <= 122\n    /* z */\n    || ch >= 65\n    /* A */\n    && ch <= 90\n    /* Z */\n    ;\n  };\n\n  Scanner.prototype.text = function (value) {\n    this.value = value;\n    this.pos = 0;\n  };\n\n  Scanner.prototype.tokenText = function (token) {\n    return this.value.substr(token.pos, token.len);\n  };\n\n  Scanner.prototype.next = function () {\n    if (this.pos >= this.value.length) {\n      return {\n        type: 14\n        /* EOF */\n        ,\n        pos: this.pos,\n        len: 0\n      };\n    }\n\n    var pos = this.pos;\n    var len = 0;\n    var ch = this.value.charCodeAt(pos);\n    var type; // static types\n\n    type = Scanner._table[ch];\n\n    if (typeof type === 'number') {\n      this.pos += 1;\n      return {\n        type: type,\n        pos: pos,\n        len: 1\n      };\n    } // number\n\n\n    if (Scanner.isDigitCharacter(ch)) {\n      type = 8\n      /* Int */\n      ;\n\n      do {\n        len += 1;\n        ch = this.value.charCodeAt(pos + len);\n      } while (Scanner.isDigitCharacter(ch));\n\n      this.pos += len;\n      return {\n        type: type,\n        pos: pos,\n        len: len\n      };\n    } // variable name\n\n\n    if (Scanner.isVariableCharacter(ch)) {\n      type = 9\n      /* VariableName */\n      ;\n\n      do {\n        ch = this.value.charCodeAt(pos + ++len);\n      } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));\n\n      this.pos += len;\n      return {\n        type: type,\n        pos: pos,\n        len: len\n      };\n    } // format\n\n\n    type = 10\n    /* Format */\n    ;\n\n    do {\n      len += 1;\n      ch = this.value.charCodeAt(pos + len);\n    } while (!isNaN(ch) && typeof Scanner._table[ch] === 'undefined' // not static token\n    && !Scanner.isDigitCharacter(ch) // not number\n    && !Scanner.isVariableCharacter(ch) // not variable\n    );\n\n    this.pos += len;\n    return {\n      type: type,\n      pos: pos,\n      len: len\n    };\n  };\n\n  Scanner._table = (_a = {}, _a[36\n  /* DollarSign */\n  ] = 0\n  /* Dollar */\n  , _a[58\n  /* Colon */\n  ] = 1\n  /* Colon */\n  , _a[44\n  /* Comma */\n  ] = 2\n  /* Comma */\n  , _a[123\n  /* OpenCurlyBrace */\n  ] = 3\n  /* CurlyOpen */\n  , _a[125\n  /* CloseCurlyBrace */\n  ] = 4\n  /* CurlyClose */\n  , _a[92\n  /* Backslash */\n  ] = 5\n  /* Backslash */\n  , _a[47\n  /* Slash */\n  ] = 6\n  /* Forwardslash */\n  , _a[124\n  /* Pipe */\n  ] = 7\n  /* Pipe */\n  , _a[43\n  /* Plus */\n  ] = 11\n  /* Plus */\n  , _a[45\n  /* Dash */\n  ] = 12\n  /* Dash */\n  , _a[63\n  /* QuestionMark */\n  ] = 13\n  /* QuestionMark */\n  , _a);\n  return Scanner;\n}();\n\nexport { Scanner };\n\nvar Marker =\n/** @class */\nfunction () {\n  function Marker() {\n    this._children = [];\n  }\n\n  Marker.prototype.appendChild = function (child) {\n    if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {\n      // this and previous child are text -> merge them\n      this._children[this._children.length - 1].value += child.value;\n    } else {\n      // normal adoption of child\n      child.parent = this;\n\n      this._children.push(child);\n    }\n\n    return this;\n  };\n\n  Marker.prototype.replace = function (child, others) {\n    var parent = child.parent;\n    var idx = parent.children.indexOf(child);\n    var newChildren = parent.children.slice(0);\n    newChildren.splice.apply(newChildren, [idx, 1].concat(others));\n    parent._children = newChildren;\n\n    (function _fixParent(children, parent) {\n      for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n        var child_1 = children_1[_i];\n        child_1.parent = parent;\n\n        _fixParent(child_1.children, child_1);\n      }\n    })(others, parent);\n  };\n\n  Object.defineProperty(Marker.prototype, \"children\", {\n    get: function () {\n      return this._children;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Marker.prototype, \"snippet\", {\n    get: function () {\n      var candidate = this;\n\n      while (true) {\n        if (!candidate) {\n          return undefined;\n        }\n\n        if (candidate instanceof TextmateSnippet) {\n          return candidate;\n        }\n\n        candidate = candidate.parent;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Marker.prototype.toString = function () {\n    return this.children.reduce(function (prev, cur) {\n      return prev + cur.toString();\n    }, '');\n  };\n\n  Marker.prototype.len = function () {\n    return 0;\n  };\n\n  return Marker;\n}();\n\nexport { Marker };\n\nvar Text =\n/** @class */\nfunction (_super) {\n  __extends(Text, _super);\n\n  function Text(value) {\n    var _this_1 = _super.call(this) || this;\n\n    _this_1.value = value;\n    return _this_1;\n  }\n\n  Text.prototype.toString = function () {\n    return this.value;\n  };\n\n  Text.prototype.len = function () {\n    return this.value.length;\n  };\n\n  Text.prototype.clone = function () {\n    return new Text(this.value);\n  };\n\n  return Text;\n}(Marker);\n\nexport { Text };\n\nvar TransformableMarker =\n/** @class */\nfunction (_super) {\n  __extends(TransformableMarker, _super);\n\n  function TransformableMarker() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return TransformableMarker;\n}(Marker);\n\nexport { TransformableMarker };\n\nvar Placeholder =\n/** @class */\nfunction (_super) {\n  __extends(Placeholder, _super);\n\n  function Placeholder(index) {\n    var _this_1 = _super.call(this) || this;\n\n    _this_1.index = index;\n    return _this_1;\n  }\n\n  Placeholder.compareByIndex = function (a, b) {\n    if (a.index === b.index) {\n      return 0;\n    } else if (a.isFinalTabstop) {\n      return 1;\n    } else if (b.isFinalTabstop) {\n      return -1;\n    } else if (a.index < b.index) {\n      return -1;\n    } else if (a.index > b.index) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  Object.defineProperty(Placeholder.prototype, \"isFinalTabstop\", {\n    get: function () {\n      return this.index === 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Placeholder.prototype, \"choice\", {\n    get: function () {\n      return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Placeholder.prototype.clone = function () {\n    var ret = new Placeholder(this.index);\n\n    if (this.transform) {\n      ret.transform = this.transform.clone();\n    }\n\n    ret._children = this.children.map(function (child) {\n      return child.clone();\n    });\n    return ret;\n  };\n\n  return Placeholder;\n}(TransformableMarker);\n\nexport { Placeholder };\n\nvar Choice =\n/** @class */\nfunction (_super) {\n  __extends(Choice, _super);\n\n  function Choice() {\n    var _this_1 = _super !== null && _super.apply(this, arguments) || this;\n\n    _this_1.options = [];\n    return _this_1;\n  }\n\n  Choice.prototype.appendChild = function (marker) {\n    if (marker instanceof Text) {\n      marker.parent = this;\n      this.options.push(marker);\n    }\n\n    return this;\n  };\n\n  Choice.prototype.toString = function () {\n    return this.options[0].value;\n  };\n\n  Choice.prototype.len = function () {\n    return this.options[0].len();\n  };\n\n  Choice.prototype.clone = function () {\n    var ret = new Choice();\n    this.options.forEach(ret.appendChild, ret);\n    return ret;\n  };\n\n  return Choice;\n}(Marker);\n\nexport { Choice };\n\nvar Transform =\n/** @class */\nfunction (_super) {\n  __extends(Transform, _super);\n\n  function Transform() {\n    var _this_1 = _super !== null && _super.apply(this, arguments) || this;\n\n    _this_1.regexp = new RegExp('');\n    return _this_1;\n  }\n\n  Transform.prototype.resolve = function (value) {\n    var _this = this;\n\n    var didMatch = false;\n    var ret = value.replace(this.regexp, function () {\n      didMatch = true;\n      return _this._replace(Array.prototype.slice.call(arguments, 0, -2));\n    }); // when the regex didn't match and when the transform has\n    // else branches, then run those\n\n    if (!didMatch && this._children.some(function (child) {\n      return child instanceof FormatString && Boolean(child.elseValue);\n    })) {\n      ret = this._replace([]);\n    }\n\n    return ret;\n  };\n\n  Transform.prototype._replace = function (groups) {\n    var ret = '';\n\n    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {\n      var marker = _a[_i];\n\n      if (marker instanceof FormatString) {\n        var value = groups[marker.index] || '';\n        value = marker.resolve(value);\n        ret += value;\n      } else {\n        ret += marker.toString();\n      }\n    }\n\n    return ret;\n  };\n\n  Transform.prototype.toString = function () {\n    return '';\n  };\n\n  Transform.prototype.clone = function () {\n    var ret = new Transform();\n    ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));\n    ret._children = this.children.map(function (child) {\n      return child.clone();\n    });\n    return ret;\n  };\n\n  return Transform;\n}(Marker);\n\nexport { Transform };\n\nvar FormatString =\n/** @class */\nfunction (_super) {\n  __extends(FormatString, _super);\n\n  function FormatString(index, shorthandName, ifValue, elseValue) {\n    var _this_1 = _super.call(this) || this;\n\n    _this_1.index = index;\n    _this_1.shorthandName = shorthandName;\n    _this_1.ifValue = ifValue;\n    _this_1.elseValue = elseValue;\n    return _this_1;\n  }\n\n  FormatString.prototype.resolve = function (value) {\n    if (this.shorthandName === 'upcase') {\n      return !value ? '' : value.toLocaleUpperCase();\n    } else if (this.shorthandName === 'downcase') {\n      return !value ? '' : value.toLocaleLowerCase();\n    } else if (this.shorthandName === 'capitalize') {\n      return !value ? '' : value[0].toLocaleUpperCase() + value.substr(1);\n    } else if (this.shorthandName === 'pascalcase') {\n      return !value ? '' : this._toPascalCase(value);\n    } else if (Boolean(value) && typeof this.ifValue === 'string') {\n      return this.ifValue;\n    } else if (!Boolean(value) && typeof this.elseValue === 'string') {\n      return this.elseValue;\n    } else {\n      return value || '';\n    }\n  };\n\n  FormatString.prototype._toPascalCase = function (value) {\n    var match = value.match(/[a-z]+/gi);\n\n    if (!match) {\n      return value;\n    }\n\n    return match.map(function (word) {\n      return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();\n    }).join('');\n  };\n\n  FormatString.prototype.clone = function () {\n    var ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);\n    return ret;\n  };\n\n  return FormatString;\n}(Marker);\n\nexport { FormatString };\n\nvar Variable =\n/** @class */\nfunction (_super) {\n  __extends(Variable, _super);\n\n  function Variable(name) {\n    var _this_1 = _super.call(this) || this;\n\n    _this_1.name = name;\n    return _this_1;\n  }\n\n  Variable.prototype.resolve = function (resolver) {\n    var value = resolver.resolve(this);\n\n    if (this.transform) {\n      value = this.transform.resolve(value || '');\n    }\n\n    if (value !== undefined) {\n      this._children = [new Text(value)];\n      return true;\n    }\n\n    return false;\n  };\n\n  Variable.prototype.clone = function () {\n    var ret = new Variable(this.name);\n\n    if (this.transform) {\n      ret.transform = this.transform.clone();\n    }\n\n    ret._children = this.children.map(function (child) {\n      return child.clone();\n    });\n    return ret;\n  };\n\n  return Variable;\n}(TransformableMarker);\n\nexport { Variable };\n\nfunction walk(marker, visitor) {\n  var stack = marker.slice();\n\n  while (stack.length > 0) {\n    var marker_1 = stack.shift();\n    var recurse = visitor(marker_1);\n\n    if (!recurse) {\n      break;\n    }\n\n    stack.unshift.apply(stack, marker_1.children);\n  }\n}\n\nvar TextmateSnippet =\n/** @class */\nfunction (_super) {\n  __extends(TextmateSnippet, _super);\n\n  function TextmateSnippet() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(TextmateSnippet.prototype, \"placeholderInfo\", {\n    get: function () {\n      if (!this._placeholders) {\n        // fill in placeholders\n        var all_1 = [];\n        var last_1;\n        this.walk(function (candidate) {\n          if (candidate instanceof Placeholder) {\n            all_1.push(candidate);\n            last_1 = !last_1 || last_1.index < candidate.index ? candidate : last_1;\n          }\n\n          return true;\n        });\n        this._placeholders = {\n          all: all_1,\n          last: last_1\n        };\n      }\n\n      return this._placeholders;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TextmateSnippet.prototype, \"placeholders\", {\n    get: function () {\n      var all = this.placeholderInfo.all;\n      return all;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TextmateSnippet.prototype.offset = function (marker) {\n    var pos = 0;\n    var found = false;\n    this.walk(function (candidate) {\n      if (candidate === marker) {\n        found = true;\n        return false;\n      }\n\n      pos += candidate.len();\n      return true;\n    });\n\n    if (!found) {\n      return -1;\n    }\n\n    return pos;\n  };\n\n  TextmateSnippet.prototype.fullLen = function (marker) {\n    var ret = 0;\n    walk([marker], function (marker) {\n      ret += marker.len();\n      return true;\n    });\n    return ret;\n  };\n\n  TextmateSnippet.prototype.enclosingPlaceholders = function (placeholder) {\n    var ret = [];\n    var parent = placeholder.parent;\n\n    while (parent) {\n      if (parent instanceof Placeholder) {\n        ret.push(parent);\n      }\n\n      parent = parent.parent;\n    }\n\n    return ret;\n  };\n\n  TextmateSnippet.prototype.resolveVariables = function (resolver) {\n    var _this_1 = this;\n\n    this.walk(function (candidate) {\n      if (candidate instanceof Variable) {\n        if (candidate.resolve(resolver)) {\n          _this_1._placeholders = undefined;\n        }\n      }\n\n      return true;\n    });\n    return this;\n  };\n\n  TextmateSnippet.prototype.appendChild = function (child) {\n    this._placeholders = undefined;\n    return _super.prototype.appendChild.call(this, child);\n  };\n\n  TextmateSnippet.prototype.replace = function (child, others) {\n    this._placeholders = undefined;\n    return _super.prototype.replace.call(this, child, others);\n  };\n\n  TextmateSnippet.prototype.clone = function () {\n    var ret = new TextmateSnippet();\n    this._children = this.children.map(function (child) {\n      return child.clone();\n    });\n    return ret;\n  };\n\n  TextmateSnippet.prototype.walk = function (visitor) {\n    walk(this.children, visitor);\n  };\n\n  return TextmateSnippet;\n}(Marker);\n\nexport { TextmateSnippet };\n\nvar SnippetParser =\n/** @class */\nfunction () {\n  function SnippetParser() {\n    this._scanner = new Scanner();\n    this._token = {\n      type: 14\n      /* EOF */\n      ,\n      pos: 0,\n      len: 0\n    };\n  }\n\n  SnippetParser.escape = function (value) {\n    return value.replace(/\\$|}|\\\\/g, '\\\\$&');\n  };\n\n  SnippetParser.prototype.parse = function (value, insertFinalTabstop, enforceFinalTabstop) {\n    this._scanner.text(value);\n\n    this._token = this._scanner.next();\n    var snippet = new TextmateSnippet();\n\n    while (this._parse(snippet)) {} // nothing\n    // fill in values for placeholders. the first placeholder of an index\n    // that has a value defines the value for all placeholders with that index\n\n\n    var placeholderDefaultValues = new Map();\n    var incompletePlaceholders = [];\n    var placeholderCount = 0;\n    snippet.walk(function (marker) {\n      if (marker instanceof Placeholder) {\n        placeholderCount += 1;\n\n        if (marker.isFinalTabstop) {\n          placeholderDefaultValues.set(0, undefined);\n        } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {\n          placeholderDefaultValues.set(marker.index, marker.children);\n        } else {\n          incompletePlaceholders.push(marker);\n        }\n      }\n\n      return true;\n    });\n\n    for (var _i = 0, incompletePlaceholders_1 = incompletePlaceholders; _i < incompletePlaceholders_1.length; _i++) {\n      var placeholder = incompletePlaceholders_1[_i];\n      var defaultValues = placeholderDefaultValues.get(placeholder.index);\n\n      if (defaultValues) {\n        var clone = new Placeholder(placeholder.index);\n        clone.transform = placeholder.transform;\n\n        for (var _a = 0, defaultValues_1 = defaultValues; _a < defaultValues_1.length; _a++) {\n          var child = defaultValues_1[_a];\n          clone.appendChild(child.clone());\n        }\n\n        snippet.replace(placeholder, [clone]);\n      }\n    }\n\n    if (!enforceFinalTabstop) {\n      enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;\n    }\n\n    if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {\n      // the snippet uses placeholders but has no\n      // final tabstop defined -> insert at the end\n      snippet.appendChild(new Placeholder(0));\n    }\n\n    return snippet;\n  };\n\n  SnippetParser.prototype._accept = function (type, value) {\n    if (type === undefined || this._token.type === type) {\n      var ret = !value ? true : this._scanner.tokenText(this._token);\n      this._token = this._scanner.next();\n      return ret;\n    }\n\n    return false;\n  };\n\n  SnippetParser.prototype._backTo = function (token) {\n    this._scanner.pos = token.pos + token.len;\n    this._token = token;\n    return false;\n  };\n\n  SnippetParser.prototype._until = function (type) {\n    if (this._token.type === 14\n    /* EOF */\n    ) {\n        return false;\n      }\n\n    var res = '';\n    var pos = this._token.pos;\n    var prevToken = {\n      type: 14\n      /* EOF */\n      ,\n      pos: 0,\n      len: 0\n    };\n\n    while (this._token.type !== type || prevToken.type === 5\n    /* Backslash */\n    ) {\n      if (this._token.type === type) {\n        res += this._scanner.value.substring(pos, prevToken.pos);\n        pos = this._token.pos;\n      }\n\n      prevToken = this._token;\n      this._token = this._scanner.next();\n\n      if (this._token.type === 14\n      /* EOF */\n      ) {\n          return false;\n        }\n    }\n\n    res += this._scanner.value.substring(pos, this._token.pos);\n    this._token = this._scanner.next();\n    return res;\n  };\n\n  SnippetParser.prototype._parse = function (marker) {\n    return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);\n  }; // \\$, \\\\, \\} -> just text\n\n\n  SnippetParser.prototype._parseEscaped = function (marker) {\n    var value;\n\n    if (value = this._accept(5\n    /* Backslash */\n    , true)) {\n      // saw a backslash, append escaped token or that backslash\n      value = this._accept(0\n      /* Dollar */\n      , true) || this._accept(4\n      /* CurlyClose */\n      , true) || this._accept(5\n      /* Backslash */\n      , true) || value;\n      marker.appendChild(new Text(value));\n      return true;\n    }\n\n    return false;\n  }; // $foo -> variable, $1 -> tabstop\n\n\n  SnippetParser.prototype._parseTabstopOrVariableName = function (parent) {\n    var value;\n    var token = this._token;\n\n    var match = this._accept(0\n    /* Dollar */\n    ) && (value = this._accept(9\n    /* VariableName */\n    , true) || this._accept(8\n    /* Int */\n    , true));\n\n    if (!match) {\n      return this._backTo(token);\n    }\n\n    parent.appendChild(/^\\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));\n    return true;\n  }; // ${1:<children>}, ${1} -> placeholder\n\n\n  SnippetParser.prototype._parseComplexPlaceholder = function (parent) {\n    var index;\n    var token = this._token;\n\n    var match = this._accept(0\n    /* Dollar */\n    ) && this._accept(3\n    /* CurlyOpen */\n    ) && (index = this._accept(8\n    /* Int */\n    , true));\n\n    if (!match) {\n      return this._backTo(token);\n    }\n\n    var placeholder = new Placeholder(Number(index));\n\n    if (this._accept(1\n    /* Colon */\n    )) {\n      // ${1:<children>}\n      while (true) {\n        // ...} -> done\n        if (this._accept(4\n        /* CurlyClose */\n        )) {\n          parent.appendChild(placeholder);\n          return true;\n        }\n\n        if (this._parse(placeholder)) {\n          continue;\n        } // fallback\n\n\n        parent.appendChild(new Text('${' + index + ':'));\n        placeholder.children.forEach(parent.appendChild, parent);\n        return true;\n      }\n    } else if (placeholder.index > 0 && this._accept(7\n    /* Pipe */\n    )) {\n      // ${1|one,two,three|}\n      var choice = new Choice();\n\n      while (true) {\n        if (this._parseChoiceElement(choice)) {\n          if (this._accept(2\n          /* Comma */\n          )) {\n            // opt, -> more\n            continue;\n          }\n\n          if (this._accept(7\n          /* Pipe */\n          )) {\n            placeholder.appendChild(choice);\n\n            if (this._accept(4\n            /* CurlyClose */\n            )) {\n              // ..|} -> done\n              parent.appendChild(placeholder);\n              return true;\n            }\n          }\n        }\n\n        this._backTo(token);\n\n        return false;\n      }\n    } else if (this._accept(6\n    /* Forwardslash */\n    )) {\n      // ${1/<regex>/<format>/<options>}\n      if (this._parseTransform(placeholder)) {\n        parent.appendChild(placeholder);\n        return true;\n      }\n\n      this._backTo(token);\n\n      return false;\n    } else if (this._accept(4\n    /* CurlyClose */\n    )) {\n      // ${1}\n      parent.appendChild(placeholder);\n      return true;\n    } else {\n      // ${1 <- missing curly or colon\n      return this._backTo(token);\n    }\n  };\n\n  SnippetParser.prototype._parseChoiceElement = function (parent) {\n    var token = this._token;\n    var values = [];\n\n    while (true) {\n      if (this._token.type === 2\n      /* Comma */\n      || this._token.type === 7\n      /* Pipe */\n      ) {\n          break;\n        }\n\n      var value = void 0;\n\n      if (value = this._accept(5\n      /* Backslash */\n      , true)) {\n        // \\, \\|, or \\\\\n        value = this._accept(2\n        /* Comma */\n        , true) || this._accept(7\n        /* Pipe */\n        , true) || this._accept(5\n        /* Backslash */\n        , true) || value;\n      } else {\n        value = this._accept(undefined, true);\n      }\n\n      if (!value) {\n        // EOF\n        this._backTo(token);\n\n        return false;\n      }\n\n      values.push(value);\n    }\n\n    if (values.length === 0) {\n      this._backTo(token);\n\n      return false;\n    }\n\n    parent.appendChild(new Text(values.join('')));\n    return true;\n  }; // ${foo:<children>}, ${foo} -> variable\n\n\n  SnippetParser.prototype._parseComplexVariable = function (parent) {\n    var name;\n    var token = this._token;\n\n    var match = this._accept(0\n    /* Dollar */\n    ) && this._accept(3\n    /* CurlyOpen */\n    ) && (name = this._accept(9\n    /* VariableName */\n    , true));\n\n    if (!match) {\n      return this._backTo(token);\n    }\n\n    var variable = new Variable(name);\n\n    if (this._accept(1\n    /* Colon */\n    )) {\n      // ${foo:<children>}\n      while (true) {\n        // ...} -> done\n        if (this._accept(4\n        /* CurlyClose */\n        )) {\n          parent.appendChild(variable);\n          return true;\n        }\n\n        if (this._parse(variable)) {\n          continue;\n        } // fallback\n\n\n        parent.appendChild(new Text('${' + name + ':'));\n        variable.children.forEach(parent.appendChild, parent);\n        return true;\n      }\n    } else if (this._accept(6\n    /* Forwardslash */\n    )) {\n      // ${foo/<regex>/<format>/<options>}\n      if (this._parseTransform(variable)) {\n        parent.appendChild(variable);\n        return true;\n      }\n\n      this._backTo(token);\n\n      return false;\n    } else if (this._accept(4\n    /* CurlyClose */\n    )) {\n      // ${foo}\n      parent.appendChild(variable);\n      return true;\n    } else {\n      // ${foo <- missing curly or colon\n      return this._backTo(token);\n    }\n  };\n\n  SnippetParser.prototype._parseTransform = function (parent) {\n    // ...<regex>/<format>/<options>}\n    var transform = new Transform();\n    var regexValue = '';\n    var regexOptions = ''; // (1) /regex\n\n    while (true) {\n      if (this._accept(6\n      /* Forwardslash */\n      )) {\n        break;\n      }\n\n      var escaped = void 0;\n\n      if (escaped = this._accept(5\n      /* Backslash */\n      , true)) {\n        escaped = this._accept(6\n        /* Forwardslash */\n        , true) || escaped;\n        regexValue += escaped;\n        continue;\n      }\n\n      if (this._token.type !== 14\n      /* EOF */\n      ) {\n          regexValue += this._accept(undefined, true);\n          continue;\n        }\n\n      return false;\n    } // (2) /format\n\n\n    while (true) {\n      if (this._accept(6\n      /* Forwardslash */\n      )) {\n        break;\n      }\n\n      var escaped = void 0;\n\n      if (escaped = this._accept(5\n      /* Backslash */\n      , true)) {\n        escaped = this._accept(5\n        /* Backslash */\n        , true) || this._accept(6\n        /* Forwardslash */\n        , true) || escaped;\n        transform.appendChild(new Text(escaped));\n        continue;\n      }\n\n      if (this._parseFormatString(transform) || this._parseAnything(transform)) {\n        continue;\n      }\n\n      return false;\n    } // (3) /option\n\n\n    while (true) {\n      if (this._accept(4\n      /* CurlyClose */\n      )) {\n        break;\n      }\n\n      if (this._token.type !== 14\n      /* EOF */\n      ) {\n          regexOptions += this._accept(undefined, true);\n          continue;\n        }\n\n      return false;\n    }\n\n    try {\n      transform.regexp = new RegExp(regexValue, regexOptions);\n    } catch (e) {\n      // invalid regexp\n      return false;\n    }\n\n    parent.transform = transform;\n    return true;\n  };\n\n  SnippetParser.prototype._parseFormatString = function (parent) {\n    var token = this._token;\n\n    if (!this._accept(0\n    /* Dollar */\n    )) {\n      return false;\n    }\n\n    var complex = false;\n\n    if (this._accept(3\n    /* CurlyOpen */\n    )) {\n      complex = true;\n    }\n\n    var index = this._accept(8\n    /* Int */\n    , true);\n\n    if (!index) {\n      this._backTo(token);\n\n      return false;\n    } else if (!complex) {\n      // $1\n      parent.appendChild(new FormatString(Number(index)));\n      return true;\n    } else if (this._accept(4\n    /* CurlyClose */\n    )) {\n      // ${1}\n      parent.appendChild(new FormatString(Number(index)));\n      return true;\n    } else if (!this._accept(1\n    /* Colon */\n    )) {\n      this._backTo(token);\n\n      return false;\n    }\n\n    if (this._accept(6\n    /* Forwardslash */\n    )) {\n      // ${1:/upcase}\n      var shorthand = this._accept(9\n      /* VariableName */\n      , true);\n\n      if (!shorthand || !this._accept(4\n      /* CurlyClose */\n      )) {\n        this._backTo(token);\n\n        return false;\n      } else {\n        parent.appendChild(new FormatString(Number(index), shorthand));\n        return true;\n      }\n    } else if (this._accept(11\n    /* Plus */\n    )) {\n      // ${1:+<if>}\n      var ifValue = this._until(4\n      /* CurlyClose */\n      );\n\n      if (ifValue) {\n        parent.appendChild(new FormatString(Number(index), undefined, ifValue, undefined));\n        return true;\n      }\n    } else if (this._accept(12\n    /* Dash */\n    )) {\n      // ${2:-<else>}\n      var elseValue = this._until(4\n      /* CurlyClose */\n      );\n\n      if (elseValue) {\n        parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n        return true;\n      }\n    } else if (this._accept(13\n    /* QuestionMark */\n    )) {\n      // ${2:?<if>:<else>}\n      var ifValue = this._until(1\n      /* Colon */\n      );\n\n      if (ifValue) {\n        var elseValue = this._until(4\n        /* CurlyClose */\n        );\n\n        if (elseValue) {\n          parent.appendChild(new FormatString(Number(index), undefined, ifValue, elseValue));\n          return true;\n        }\n      }\n    } else {\n      // ${1:<else>}\n      var elseValue = this._until(4\n      /* CurlyClose */\n      );\n\n      if (elseValue) {\n        parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n        return true;\n      }\n    }\n\n    this._backTo(token);\n\n    return false;\n  };\n\n  SnippetParser.prototype._parseAnything = function (marker) {\n    if (this._token.type !== 14\n    /* EOF */\n    ) {\n        marker.appendChild(new Text(this._scanner.tokenText(this._token)));\n\n        this._accept(undefined);\n\n        return true;\n      }\n\n    return false;\n  };\n\n  return SnippetParser;\n}();\n\nexport { SnippetParser };","map":null,"metadata":{},"sourceType":"module"}