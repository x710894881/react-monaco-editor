{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\n\nvar RenderedLinesCollection =\n/** @class */\nfunction () {\n  function RenderedLinesCollection(createLine) {\n    this._createLine = createLine;\n\n    this._set(1, []);\n  }\n\n  RenderedLinesCollection.prototype.flush = function () {\n    this._set(1, []);\n  };\n\n  RenderedLinesCollection.prototype._set = function (rendLineNumberStart, lines) {\n    this._lines = lines;\n    this._rendLineNumberStart = rendLineNumberStart;\n  };\n\n  RenderedLinesCollection.prototype._get = function () {\n    return {\n      rendLineNumberStart: this._rendLineNumberStart,\n      lines: this._lines\n    };\n  };\n  /**\n   * @returns Inclusive line number that is inside this collection\n   */\n\n\n  RenderedLinesCollection.prototype.getStartLineNumber = function () {\n    return this._rendLineNumberStart;\n  };\n  /**\n   * @returns Inclusive line number that is inside this collection\n   */\n\n\n  RenderedLinesCollection.prototype.getEndLineNumber = function () {\n    return this._rendLineNumberStart + this._lines.length - 1;\n  };\n\n  RenderedLinesCollection.prototype.getCount = function () {\n    return this._lines.length;\n  };\n\n  RenderedLinesCollection.prototype.getLine = function (lineNumber) {\n    var lineIndex = lineNumber - this._rendLineNumberStart;\n\n    if (lineIndex < 0 || lineIndex >= this._lines.length) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._lines[lineIndex];\n  };\n  /**\n   * @returns Lines that were removed from this collection\n   */\n\n\n  RenderedLinesCollection.prototype.onLinesDeleted = function (deleteFromLineNumber, deleteToLineNumber) {\n    if (this.getCount() === 0) {\n      // no lines\n      return null;\n    }\n\n    var startLineNumber = this.getStartLineNumber();\n    var endLineNumber = this.getEndLineNumber();\n\n    if (deleteToLineNumber < startLineNumber) {\n      // deleting above the viewport\n      var deleteCnt = deleteToLineNumber - deleteFromLineNumber + 1;\n      this._rendLineNumberStart -= deleteCnt;\n      return null;\n    }\n\n    if (deleteFromLineNumber > endLineNumber) {\n      // deleted below the viewport\n      return null;\n    } // Record what needs to be deleted\n\n\n    var deleteStartIndex = 0;\n    var deleteCount = 0;\n\n    for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      var lineIndex = lineNumber - this._rendLineNumberStart;\n\n      if (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {\n        // this is a line to be deleted\n        if (deleteCount === 0) {\n          // this is the first line to be deleted\n          deleteStartIndex = lineIndex;\n          deleteCount = 1;\n        } else {\n          deleteCount++;\n        }\n      }\n    } // Adjust this._rendLineNumberStart for lines deleted above\n\n\n    if (deleteFromLineNumber < startLineNumber) {\n      // Something was deleted above\n      var deleteAboveCount = 0;\n\n      if (deleteToLineNumber < startLineNumber) {\n        // the entire deleted lines are above\n        deleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;\n      } else {\n        deleteAboveCount = startLineNumber - deleteFromLineNumber;\n      }\n\n      this._rendLineNumberStart -= deleteAboveCount;\n    }\n\n    var deleted = this._lines.splice(deleteStartIndex, deleteCount);\n\n    return deleted;\n  };\n\n  RenderedLinesCollection.prototype.onLinesChanged = function (changeFromLineNumber, changeToLineNumber) {\n    if (this.getCount() === 0) {\n      // no lines\n      return false;\n    }\n\n    var startLineNumber = this.getStartLineNumber();\n    var endLineNumber = this.getEndLineNumber();\n    var someoneNotified = false;\n\n    for (var changedLineNumber = changeFromLineNumber; changedLineNumber <= changeToLineNumber; changedLineNumber++) {\n      if (changedLineNumber >= startLineNumber && changedLineNumber <= endLineNumber) {\n        // Notify the line\n        this._lines[changedLineNumber - this._rendLineNumberStart].onContentChanged();\n\n        someoneNotified = true;\n      }\n    }\n\n    return someoneNotified;\n  };\n\n  RenderedLinesCollection.prototype.onLinesInserted = function (insertFromLineNumber, insertToLineNumber) {\n    if (this.getCount() === 0) {\n      // no lines\n      return null;\n    }\n\n    var insertCnt = insertToLineNumber - insertFromLineNumber + 1;\n    var startLineNumber = this.getStartLineNumber();\n    var endLineNumber = this.getEndLineNumber();\n\n    if (insertFromLineNumber <= startLineNumber) {\n      // inserting above the viewport\n      this._rendLineNumberStart += insertCnt;\n      return null;\n    }\n\n    if (insertFromLineNumber > endLineNumber) {\n      // inserting below the viewport\n      return null;\n    }\n\n    if (insertCnt + insertFromLineNumber > endLineNumber) {\n      // insert inside the viewport in such a way that all remaining lines are pushed outside\n      var deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);\n\n      return deleted;\n    } // insert inside the viewport, push out some lines, but not all remaining lines\n\n\n    var newLines = [];\n\n    for (var i = 0; i < insertCnt; i++) {\n      newLines[i] = this._createLine();\n    }\n\n    var insertIndex = insertFromLineNumber - this._rendLineNumberStart;\n\n    var beforeLines = this._lines.slice(0, insertIndex);\n\n    var afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);\n\n    var deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);\n\n    this._lines = beforeLines.concat(newLines).concat(afterLines);\n    return deletedLines;\n  };\n\n  RenderedLinesCollection.prototype.onTokensChanged = function (ranges) {\n    if (this.getCount() === 0) {\n      // no lines\n      return false;\n    }\n\n    var startLineNumber = this.getStartLineNumber();\n    var endLineNumber = this.getEndLineNumber();\n    var notifiedSomeone = false;\n\n    for (var i = 0, len = ranges.length; i < len; i++) {\n      var rng = ranges[i];\n\n      if (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {\n        // range outside viewport\n        continue;\n      }\n\n      var from = Math.max(startLineNumber, rng.fromLineNumber);\n      var to = Math.min(endLineNumber, rng.toLineNumber);\n\n      for (var lineNumber = from; lineNumber <= to; lineNumber++) {\n        var lineIndex = lineNumber - this._rendLineNumberStart;\n\n        this._lines[lineIndex].onTokensChanged();\n\n        notifiedSomeone = true;\n      }\n    }\n\n    return notifiedSomeone;\n  };\n\n  return RenderedLinesCollection;\n}();\n\nexport { RenderedLinesCollection };\n\nvar VisibleLinesCollection =\n/** @class */\nfunction () {\n  function VisibleLinesCollection(host) {\n    var _this = this;\n\n    this._host = host;\n    this.domNode = this._createDomNode();\n    this._linesCollection = new RenderedLinesCollection(function () {\n      return _this._host.createVisibleLine();\n    });\n  }\n\n  VisibleLinesCollection.prototype._createDomNode = function () {\n    var domNode = createFastDomNode(document.createElement('div'));\n    domNode.setClassName('view-layer');\n    domNode.setPosition('absolute');\n    domNode.domNode.setAttribute('role', 'presentation');\n    domNode.domNode.setAttribute('aria-hidden', 'true');\n    return domNode;\n  }; // ---- begin view event handlers\n\n\n  VisibleLinesCollection.prototype.onConfigurationChanged = function (e) {\n    return e.layoutInfo;\n  };\n\n  VisibleLinesCollection.prototype.onFlushed = function (e) {\n    this._linesCollection.flush(); // No need to clear the dom node because a full .innerHTML will occur in ViewLayerRenderer._render\n\n\n    return true;\n  };\n\n  VisibleLinesCollection.prototype.onLinesChanged = function (e) {\n    return this._linesCollection.onLinesChanged(e.fromLineNumber, e.toLineNumber);\n  };\n\n  VisibleLinesCollection.prototype.onLinesDeleted = function (e) {\n    var deleted = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n\n    if (deleted) {\n      // Remove from DOM\n      for (var i = 0, len = deleted.length; i < len; i++) {\n        var lineDomNode = deleted[i].getDomNode();\n\n        if (lineDomNode) {\n          this.domNode.domNode.removeChild(lineDomNode);\n        }\n      }\n    }\n\n    return true;\n  };\n\n  VisibleLinesCollection.prototype.onLinesInserted = function (e) {\n    var deleted = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n\n    if (deleted) {\n      // Remove from DOM\n      for (var i = 0, len = deleted.length; i < len; i++) {\n        var lineDomNode = deleted[i].getDomNode();\n\n        if (lineDomNode) {\n          this.domNode.domNode.removeChild(lineDomNode);\n        }\n      }\n    }\n\n    return true;\n  };\n\n  VisibleLinesCollection.prototype.onScrollChanged = function (e) {\n    return e.scrollTopChanged;\n  };\n\n  VisibleLinesCollection.prototype.onTokensChanged = function (e) {\n    return this._linesCollection.onTokensChanged(e.ranges);\n  };\n\n  VisibleLinesCollection.prototype.onZonesChanged = function (e) {\n    return true;\n  }; // ---- end view event handlers\n\n\n  VisibleLinesCollection.prototype.getStartLineNumber = function () {\n    return this._linesCollection.getStartLineNumber();\n  };\n\n  VisibleLinesCollection.prototype.getEndLineNumber = function () {\n    return this._linesCollection.getEndLineNumber();\n  };\n\n  VisibleLinesCollection.prototype.getVisibleLine = function (lineNumber) {\n    return this._linesCollection.getLine(lineNumber);\n  };\n\n  VisibleLinesCollection.prototype.renderLines = function (viewportData) {\n    var inp = this._linesCollection._get();\n\n    var renderer = new ViewLayerRenderer(this.domNode.domNode, this._host, viewportData);\n    var ctx = {\n      rendLineNumberStart: inp.rendLineNumberStart,\n      lines: inp.lines,\n      linesLength: inp.lines.length\n    }; // Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)\n\n    var resCtx = renderer.render(ctx, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);\n\n    this._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);\n  };\n\n  return VisibleLinesCollection;\n}();\n\nexport { VisibleLinesCollection };\n\nvar ViewLayerRenderer =\n/** @class */\nfunction () {\n  function ViewLayerRenderer(domNode, host, viewportData) {\n    this.domNode = domNode;\n    this.host = host;\n    this.viewportData = viewportData;\n  }\n\n  ViewLayerRenderer.prototype.render = function (inContext, startLineNumber, stopLineNumber, deltaTop) {\n    var ctx = {\n      rendLineNumberStart: inContext.rendLineNumberStart,\n      lines: inContext.lines.slice(0),\n      linesLength: inContext.linesLength\n    };\n\n    if (ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber || stopLineNumber < ctx.rendLineNumberStart) {\n      // There is no overlap whatsoever\n      ctx.rendLineNumberStart = startLineNumber;\n      ctx.linesLength = stopLineNumber - startLineNumber + 1;\n      ctx.lines = [];\n\n      for (var x = startLineNumber; x <= stopLineNumber; x++) {\n        ctx.lines[x - startLineNumber] = this.host.createVisibleLine();\n      }\n\n      this._finishRendering(ctx, true, deltaTop);\n\n      return ctx;\n    } // Update lines which will remain untouched\n\n\n    this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);\n\n    if (ctx.rendLineNumberStart > startLineNumber) {\n      // Insert lines before\n      var fromLineNumber = startLineNumber;\n      var toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);\n\n      if (fromLineNumber <= toLineNumber) {\n        this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n\n        ctx.linesLength += toLineNumber - fromLineNumber + 1;\n      }\n    } else if (ctx.rendLineNumberStart < startLineNumber) {\n      // Remove lines before\n      var removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);\n\n      if (removeCnt > 0) {\n        this._removeLinesBefore(ctx, removeCnt);\n\n        ctx.linesLength -= removeCnt;\n      }\n    }\n\n    ctx.rendLineNumberStart = startLineNumber;\n\n    if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {\n      // Insert lines after\n      var fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;\n      var toLineNumber = stopLineNumber;\n\n      if (fromLineNumber <= toLineNumber) {\n        this._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n\n        ctx.linesLength += toLineNumber - fromLineNumber + 1;\n      }\n    } else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {\n      // Remove lines after\n      var fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);\n      var toLineNumber = ctx.linesLength - 1;\n      var removeCnt = toLineNumber - fromLineNumber + 1;\n\n      if (removeCnt > 0) {\n        this._removeLinesAfter(ctx, removeCnt);\n\n        ctx.linesLength -= removeCnt;\n      }\n    }\n\n    this._finishRendering(ctx, false, deltaTop);\n\n    return ctx;\n  };\n\n  ViewLayerRenderer.prototype._renderUntouchedLines = function (ctx, startIndex, endIndex, deltaTop, deltaLN) {\n    var rendLineNumberStart = ctx.rendLineNumberStart;\n    var lines = ctx.lines;\n\n    for (var i = startIndex; i <= endIndex; i++) {\n      var lineNumber = rendLineNumberStart + i;\n      lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN]);\n    }\n  };\n\n  ViewLayerRenderer.prototype._insertLinesBefore = function (ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n    var newLines = [];\n    var newLinesLen = 0;\n\n    for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n      newLines[newLinesLen++] = this.host.createVisibleLine();\n    }\n\n    ctx.lines = newLines.concat(ctx.lines);\n  };\n\n  ViewLayerRenderer.prototype._removeLinesBefore = function (ctx, removeCount) {\n    for (var i = 0; i < removeCount; i++) {\n      var lineDomNode = ctx.lines[i].getDomNode();\n\n      if (lineDomNode) {\n        this.domNode.removeChild(lineDomNode);\n      }\n    }\n\n    ctx.lines.splice(0, removeCount);\n  };\n\n  ViewLayerRenderer.prototype._insertLinesAfter = function (ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n    var newLines = [];\n    var newLinesLen = 0;\n\n    for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n      newLines[newLinesLen++] = this.host.createVisibleLine();\n    }\n\n    ctx.lines = ctx.lines.concat(newLines);\n  };\n\n  ViewLayerRenderer.prototype._removeLinesAfter = function (ctx, removeCount) {\n    var removeIndex = ctx.linesLength - removeCount;\n\n    for (var i = 0; i < removeCount; i++) {\n      var lineDomNode = ctx.lines[removeIndex + i].getDomNode();\n\n      if (lineDomNode) {\n        this.domNode.removeChild(lineDomNode);\n      }\n    }\n\n    ctx.lines.splice(removeIndex, removeCount);\n  };\n\n  ViewLayerRenderer.prototype._finishRenderingNewLines = function (ctx, domNodeIsEmpty, newLinesHTML, wasNew) {\n    var lastChild = this.domNode.lastChild;\n\n    if (domNodeIsEmpty || !lastChild) {\n      this.domNode.innerHTML = newLinesHTML;\n    } else {\n      lastChild.insertAdjacentHTML('afterend', newLinesHTML);\n    }\n\n    var currChild = this.domNode.lastChild;\n\n    for (var i = ctx.linesLength - 1; i >= 0; i--) {\n      var line = ctx.lines[i];\n\n      if (wasNew[i]) {\n        line.setDomNode(currChild);\n        currChild = currChild.previousSibling;\n      }\n    }\n  };\n\n  ViewLayerRenderer.prototype._finishRenderingInvalidLines = function (ctx, invalidLinesHTML, wasInvalid) {\n    var hugeDomNode = document.createElement('div');\n    hugeDomNode.innerHTML = invalidLinesHTML;\n\n    for (var i = 0; i < ctx.linesLength; i++) {\n      var line = ctx.lines[i];\n\n      if (wasInvalid[i]) {\n        var source = hugeDomNode.firstChild;\n        var lineDomNode = line.getDomNode();\n        lineDomNode.parentNode.replaceChild(source, lineDomNode);\n        line.setDomNode(source);\n      }\n    }\n  };\n\n  ViewLayerRenderer.prototype._finishRendering = function (ctx, domNodeIsEmpty, deltaTop) {\n    var sb = ViewLayerRenderer._sb;\n    var linesLength = ctx.linesLength;\n    var lines = ctx.lines;\n    var rendLineNumberStart = ctx.rendLineNumberStart;\n    var wasNew = [];\n    {\n      sb.reset();\n      var hadNewLine = false;\n\n      for (var i = 0; i < linesLength; i++) {\n        var line = lines[i];\n        wasNew[i] = false;\n        var lineDomNode = line.getDomNode();\n\n        if (lineDomNode) {\n          // line is not new\n          continue;\n        }\n\n        var renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);\n\n        if (!renderResult) {\n          // line does not need rendering\n          continue;\n        }\n\n        wasNew[i] = true;\n        hadNewLine = true;\n      }\n\n      if (hadNewLine) {\n        this._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);\n      }\n    }\n    {\n      sb.reset();\n      var hadInvalidLine = false;\n      var wasInvalid = [];\n\n      for (var i = 0; i < linesLength; i++) {\n        var line = lines[i];\n        wasInvalid[i] = false;\n\n        if (wasNew[i]) {\n          // line was new\n          continue;\n        }\n\n        var renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData, sb);\n\n        if (!renderResult) {\n          // line does not need rendering\n          continue;\n        }\n\n        wasInvalid[i] = true;\n        hadInvalidLine = true;\n      }\n\n      if (hadInvalidLine) {\n        this._finishRenderingInvalidLines(ctx, sb.build(), wasInvalid);\n      }\n    }\n  };\n\n  ViewLayerRenderer._sb = createStringBuilder(100000);\n  return ViewLayerRenderer;\n}();","map":null,"metadata":{},"sourceType":"module"}