{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { format, isEOL } from './format.js';\nimport { parseTree, findNodeAtLocation } from './parser.js';\nexport function removeProperty(text, path, formattingOptions) {\n  return setProperty(text, path, void 0, formattingOptions);\n}\nexport function setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {\n  var _a;\n\n  var path = originalPath.slice();\n  var errors = [];\n  var root = parseTree(text, errors);\n  var parent = void 0;\n  var lastSegment = void 0;\n\n  while (path.length > 0) {\n    lastSegment = path.pop();\n    parent = findNodeAtLocation(root, path);\n\n    if (parent === void 0 && value !== void 0) {\n      if (typeof lastSegment === 'string') {\n        value = (_a = {}, _a[lastSegment] = value, _a);\n      } else {\n        value = [value];\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (!parent) {\n    // empty document\n    if (value === void 0) {\n      // delete\n      throw new Error('Can not delete in empty document');\n    }\n\n    return withFormatting(text, {\n      offset: root ? root.offset : 0,\n      length: root ? root.length : 0,\n      content: JSON.stringify(value)\n    }, formattingOptions);\n  } else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n    var existing = findNodeAtLocation(parent, [lastSegment]);\n\n    if (existing !== void 0) {\n      if (value === void 0) {\n        // delete\n        if (!existing.parent) {\n          throw new Error('Malformed AST');\n        }\n\n        var propertyIndex = parent.children.indexOf(existing.parent);\n        var removeBegin = void 0;\n        var removeEnd = existing.parent.offset + existing.parent.length;\n\n        if (propertyIndex > 0) {\n          // remove the comma of the previous node\n          var previous = parent.children[propertyIndex - 1];\n          removeBegin = previous.offset + previous.length;\n        } else {\n          removeBegin = parent.offset + 1;\n\n          if (parent.children.length > 1) {\n            // remove the comma of the next node\n            var next = parent.children[1];\n            removeEnd = next.offset;\n          }\n        }\n\n        return withFormatting(text, {\n          offset: removeBegin,\n          length: removeEnd - removeBegin,\n          content: ''\n        }, formattingOptions);\n      } else {\n        // set value of existing property\n        return withFormatting(text, {\n          offset: existing.offset,\n          length: existing.length,\n          content: JSON.stringify(value)\n        }, formattingOptions);\n      }\n    } else {\n      if (value === void 0) {\n        // delete\n        return []; // property does not exist, nothing to do\n      }\n\n      var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n      var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) {\n        return p.children[0].value;\n      })) : parent.children.length;\n      var edit = void 0;\n\n      if (index > 0) {\n        var previous = parent.children[index - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      } else if (parent.children.length === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty\n        };\n      } else {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty + ','\n        };\n      }\n\n      return withFormatting(text, edit, formattingOptions);\n    }\n  } else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n    var insertIndex = lastSegment;\n\n    if (insertIndex === -1) {\n      // Insert\n      var newProperty = \"\" + JSON.stringify(value);\n      var edit = void 0;\n\n      if (parent.children.length === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty\n        };\n      } else {\n        var previous = parent.children[parent.children.length - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      }\n\n      return withFormatting(text, edit, formattingOptions);\n    } else {\n      if (value === void 0 && parent.children.length >= 0) {\n        //Removal\n        var removalIndex = lastSegment;\n        var toRemove = parent.children[removalIndex];\n        var edit = void 0;\n\n        if (parent.children.length === 1) {\n          // only item\n          edit = {\n            offset: parent.offset + 1,\n            length: parent.length - 2,\n            content: ''\n          };\n        } else if (parent.children.length - 1 === removalIndex) {\n          // last item\n          var previous = parent.children[removalIndex - 1];\n          var offset = previous.offset + previous.length;\n          var parentEndOffset = parent.offset + parent.length;\n          edit = {\n            offset: offset,\n            length: parentEndOffset - 2 - offset,\n            content: ''\n          };\n        } else {\n          edit = {\n            offset: toRemove.offset,\n            length: parent.children[removalIndex + 1].offset - toRemove.offset,\n            content: ''\n          };\n        }\n\n        return withFormatting(text, edit, formattingOptions);\n      } else {\n        throw new Error('Array modification not supported yet');\n      }\n    }\n  } else {\n    throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n  }\n}\n\nfunction withFormatting(text, edit, formattingOptions) {\n  // apply the edit\n  var newText = applyEdit(text, edit); // format the new text\n\n  var begin = edit.offset;\n  var end = edit.offset + edit.content.length;\n\n  if (edit.length === 0 || edit.content.length === 0) {\n    // insert or remove\n    while (begin > 0 && !isEOL(newText, begin - 1)) {\n      begin--;\n    }\n\n    while (end < newText.length && !isEOL(newText, end)) {\n      end++;\n    }\n  }\n\n  var edits = format(newText, {\n    offset: begin,\n    length: end - begin\n  }, formattingOptions); // apply the formatting edits and track the begin and end offsets of the changes\n\n  for (var i = edits.length - 1; i >= 0; i--) {\n    var edit_1 = edits[i];\n    newText = applyEdit(newText, edit_1);\n    begin = Math.min(begin, edit_1.offset);\n    end = Math.max(end, edit_1.offset + edit_1.length);\n    end += edit_1.content.length - edit_1.length;\n  } // create a single edit with all changes\n\n\n  var editLength = text.length - (newText.length - end) - begin;\n  return [{\n    offset: begin,\n    length: editLength,\n    content: newText.substring(begin, end)\n  }];\n}\n\nexport function applyEdit(text, edit) {\n  return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n  return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}","map":null,"metadata":{},"sourceType":"module"}