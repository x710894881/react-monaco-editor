{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as languageFacts from '../languageFacts/facts.js';\nimport { Rules, Settings } from './lintRules.js';\nimport * as nodes from '../parser/cssNodes.js';\nimport calculateBoxModel, { Element } from './lintUtil.js';\nimport { union } from '../utils/arrays.js';\nimport * as nls from '../../../fillers/vscode-nls.js';\nvar localize = nls.loadMessageBundle();\n\nvar NodesByRootMap =\n/** @class */\nfunction () {\n  function NodesByRootMap() {\n    this.data = {};\n  }\n\n  NodesByRootMap.prototype.add = function (root, name, node) {\n    var entry = this.data[root];\n\n    if (!entry) {\n      entry = {\n        nodes: [],\n        names: []\n      };\n      this.data[root] = entry;\n    }\n\n    entry.names.push(name);\n\n    if (node) {\n      entry.nodes.push(node);\n    }\n  };\n\n  return NodesByRootMap;\n}();\n\nvar LintVisitor =\n/** @class */\nfunction () {\n  function LintVisitor(document, settings) {\n    var _this = this;\n\n    this.warnings = [];\n    this.settings = settings;\n    this.documentText = document.getText();\n    this.keyframes = new NodesByRootMap();\n    this.validProperties = {};\n    var properties = settings.getSetting(Settings.ValidProperties);\n\n    if (Array.isArray(properties)) {\n      properties.forEach(function (p) {\n        if (typeof p === 'string') {\n          var name = p.trim().toLowerCase();\n\n          if (name.length) {\n            _this.validProperties[name] = true;\n          }\n        }\n      });\n    }\n  }\n\n  LintVisitor.entries = function (node, document, settings, entryFilter) {\n    var visitor = new LintVisitor(document, settings);\n    node.acceptVisitor(visitor);\n    visitor.completeValidations();\n    return visitor.getEntries(entryFilter);\n  };\n\n  LintVisitor.prototype.isValidPropertyDeclaration = function (decl) {\n    var propertyName = decl.getFullPropertyName().toLowerCase();\n    return this.validProperties[propertyName];\n  };\n\n  LintVisitor.prototype.fetch = function (input, s) {\n    var elements = [];\n\n    for (var _i = 0, input_1 = input; _i < input_1.length; _i++) {\n      var curr = input_1[_i];\n\n      if (curr.name === s) {\n        elements.push(curr);\n      }\n    }\n\n    return elements;\n  };\n\n  LintVisitor.prototype.fetchWithValue = function (input, s, v) {\n    var elements = [];\n\n    for (var _i = 0, input_2 = input; _i < input_2.length; _i++) {\n      var inputElement = input_2[_i];\n\n      if (inputElement.name === s) {\n        var expression = inputElement.node.getValue();\n\n        if (expression && this.findValueInExpression(expression, v)) {\n          elements.push(inputElement);\n        }\n      }\n    }\n\n    return elements;\n  };\n\n  LintVisitor.prototype.findValueInExpression = function (expression, v) {\n    var found = false;\n    expression.accept(function (node) {\n      if (node.type === nodes.NodeType.Identifier && node.getText() === v) {\n        found = true;\n      }\n\n      return !found;\n    });\n    return found;\n  };\n\n  LintVisitor.prototype.getEntries = function (filter) {\n    if (filter === void 0) {\n      filter = nodes.Level.Warning | nodes.Level.Error;\n    }\n\n    return this.warnings.filter(function (entry) {\n      return (entry.getLevel() & filter) !== 0;\n    });\n  };\n\n  LintVisitor.prototype.addEntry = function (node, rule, details) {\n    var entry = new nodes.Marker(node, rule, this.settings.getRule(rule), details);\n    this.warnings.push(entry);\n  };\n\n  LintVisitor.prototype.getMissingNames = function (expected, actual) {\n    expected = expected.slice(0); // clone\n\n    for (var i = 0; i < actual.length; i++) {\n      var k = expected.indexOf(actual[i]);\n\n      if (k !== -1) {\n        expected[k] = null;\n      }\n    }\n\n    var result = null;\n\n    for (var i = 0; i < expected.length; i++) {\n      var curr = expected[i];\n\n      if (curr) {\n        if (result === null) {\n          result = localize('namelist.single', \"'{0}'\", curr);\n        } else {\n          result = localize('namelist.concatenated', \"{0}, '{1}'\", result, curr);\n        }\n      }\n    }\n\n    return result;\n  };\n\n  LintVisitor.prototype.visitNode = function (node) {\n    switch (node.type) {\n      case nodes.NodeType.UnknownAtRule:\n        return this.visitUnknownAtRule(node);\n\n      case nodes.NodeType.Keyframe:\n        return this.visitKeyframe(node);\n\n      case nodes.NodeType.FontFace:\n        return this.visitFontFace(node);\n\n      case nodes.NodeType.Ruleset:\n        return this.visitRuleSet(node);\n\n      case nodes.NodeType.SimpleSelector:\n        return this.visitSimpleSelector(node);\n\n      case nodes.NodeType.Function:\n        return this.visitFunction(node);\n\n      case nodes.NodeType.NumericValue:\n        return this.visitNumericValue(node);\n\n      case nodes.NodeType.Import:\n        return this.visitImport(node);\n\n      case nodes.NodeType.HexColorValue:\n        return this.visitHexColorValue(node);\n\n      case nodes.NodeType.Prio:\n        return this.visitPrio(node);\n    }\n\n    return true;\n  };\n\n  LintVisitor.prototype.completeValidations = function () {\n    this.validateKeyframes();\n  };\n\n  LintVisitor.prototype.visitUnknownAtRule = function (node) {\n    var atRuleName = node.getChild(0);\n\n    if (!atRuleName) {\n      return false;\n    }\n\n    this.addEntry(atRuleName, Rules.UnknownAtRules, \"Unknown at rule \" + atRuleName.getText());\n    return true;\n  };\n\n  LintVisitor.prototype.visitKeyframe = function (node) {\n    var keyword = node.getKeyword();\n    var text = keyword.getText();\n    this.keyframes.add(node.getName(), text, text !== '@keyframes' ? keyword : null);\n    return true;\n  };\n\n  LintVisitor.prototype.validateKeyframes = function () {\n    // @keyframe and it's vendor specific alternatives\n    // @keyframe should be included\n    var expected = ['@-webkit-keyframes', '@-moz-keyframes', '@-o-keyframes'];\n\n    for (var name in this.keyframes.data) {\n      var actual = this.keyframes.data[name].names;\n      var needsStandard = actual.indexOf('@keyframes') === -1;\n\n      if (!needsStandard && actual.length === 1) {\n        continue; // only the non-vendor specific keyword is used, that's fine, no warning\n      }\n\n      var missingVendorSpecific = this.getMissingNames(expected, actual);\n\n      if (missingVendorSpecific || needsStandard) {\n        for (var _i = 0, _a = this.keyframes.data[name].nodes; _i < _a.length; _i++) {\n          var node = _a[_i];\n\n          if (needsStandard) {\n            var message = localize('keyframes.standardrule.missing', \"Always define standard rule '@keyframes' when defining keyframes.\");\n            this.addEntry(node, Rules.IncludeStandardPropertyWhenUsingVendorPrefix, message);\n          }\n\n          if (missingVendorSpecific) {\n            var message = localize('keyframes.vendorspecific.missing', \"Always include all vendor specific rules: Missing: {0}\", missingVendorSpecific);\n            this.addEntry(node, Rules.AllVendorPrefixes, message);\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  LintVisitor.prototype.visitSimpleSelector = function (node) {\n    var firstChar = this.documentText.charAt(node.offset); /////////////////////////////////////////////////////////////\n    //\tLint - The universal selector (*) is known to be slow.\n    /////////////////////////////////////////////////////////////\n\n    if (node.length === 1 && firstChar === '*') {\n      this.addEntry(node, Rules.UniversalSelector);\n    } /////////////////////////////////////////////////////////////\n    //\tLint - Avoid id selectors\n    /////////////////////////////////////////////////////////////\n\n\n    if (firstChar === '#') {\n      this.addEntry(node, Rules.AvoidIdSelector);\n    }\n\n    return true;\n  };\n\n  LintVisitor.prototype.visitImport = function (node) {\n    /////////////////////////////////////////////////////////////\n    //\tLint - Import statements shouldn't be used, because they aren't offering parallel downloads.\n    /////////////////////////////////////////////////////////////\n    this.addEntry(node, Rules.ImportStatemement);\n    return true;\n  };\n\n  LintVisitor.prototype.visitRuleSet = function (node) {\n    /////////////////////////////////////////////////////////////\n    //\tLint - Don't use empty rulesets.\n    /////////////////////////////////////////////////////////////\n    var declarations = node.getDeclarations();\n\n    if (!declarations) {\n      // syntax error\n      return false;\n    }\n\n    if (!declarations.hasChildren()) {\n      this.addEntry(node.getSelectors(), Rules.EmptyRuleSet);\n    }\n\n    var propertyTable = [];\n\n    for (var _i = 0, _a = declarations.getChildren(); _i < _a.length; _i++) {\n      var element = _a[_i];\n\n      if (element instanceof nodes.Declaration) {\n        var decl = element;\n        propertyTable.push(new Element(decl.getFullPropertyName().toLowerCase(), decl));\n      }\n    } /////////////////////////////////////////////////////////////\n    // the rule warns when it finds:\n    // width being used with border, border-left, border-right, padding, padding-left, or padding-right\n    // height being used with border, border-top, border-bottom, padding, padding-top, or padding-bottom\n    // No error when box-sizing property is specified, as it assumes the user knows what he's doing.\n    // see https://github.com/CSSLint/csslint/wiki/Beware-of-box-model-size\n    /////////////////////////////////////////////////////////////\n\n\n    var boxModel = calculateBoxModel(propertyTable);\n\n    if (boxModel.width) {\n      var properties = [];\n\n      if (boxModel.right.value) {\n        properties = union(properties, boxModel.right.properties);\n      }\n\n      if (boxModel.left.value) {\n        properties = union(properties, boxModel.left.properties);\n      }\n\n      if (properties.length !== 0) {\n        for (var _b = 0, properties_1 = properties; _b < properties_1.length; _b++) {\n          var item = properties_1[_b];\n          this.addEntry(item.node, Rules.BewareOfBoxModelSize);\n        }\n\n        this.addEntry(boxModel.width.node, Rules.BewareOfBoxModelSize);\n      }\n    }\n\n    if (boxModel.height) {\n      var properties = [];\n\n      if (boxModel.top.value) {\n        properties = union(properties, boxModel.top.properties);\n      }\n\n      if (boxModel.bottom.value) {\n        properties = union(properties, boxModel.bottom.properties);\n      }\n\n      if (properties.length !== 0) {\n        for (var _c = 0, properties_2 = properties; _c < properties_2.length; _c++) {\n          var item = properties_2[_c];\n          this.addEntry(item.node, Rules.BewareOfBoxModelSize);\n        }\n\n        this.addEntry(boxModel.height.node, Rules.BewareOfBoxModelSize);\n      }\n    } /////////////////////////////////////////////////////////////\n    //\tProperties ignored due to display\n    /////////////////////////////////////////////////////////////\n    // With 'display: inline', the width, height, margin-top, margin-bottom, and float properties have no effect\n\n\n    var displayElems = this.fetchWithValue(propertyTable, 'display', 'inline');\n\n    if (displayElems.length > 0) {\n      for (var _d = 0, _e = ['width', 'height', 'margin-top', 'margin-bottom', 'float']; _d < _e.length; _d++) {\n        var prop = _e[_d];\n        var elem = this.fetch(propertyTable, prop);\n\n        for (var index = 0; index < elem.length; index++) {\n          var node_1 = elem[index].node;\n          var value = node_1.getValue();\n\n          if (prop === 'float' && (!value || value.matches('none'))) {\n            continue;\n          }\n\n          this.addEntry(node_1, Rules.PropertyIgnoredDueToDisplay, localize('rule.propertyIgnoredDueToDisplayInline', \"Property is ignored due to the display. With 'display: inline', the width, height, margin-top, margin-bottom, and float properties have no effect.\"));\n        }\n      }\n    } // With 'display: inline-block', 'float' has no effect\n\n\n    displayElems = this.fetchWithValue(propertyTable, 'display', 'inline-block');\n\n    if (displayElems.length > 0) {\n      var elem = this.fetch(propertyTable, 'float');\n\n      for (var index = 0; index < elem.length; index++) {\n        var node_2 = elem[index].node;\n        var value = node_2.getValue();\n\n        if (value && !value.matches('none')) {\n          this.addEntry(node_2, Rules.PropertyIgnoredDueToDisplay, localize('rule.propertyIgnoredDueToDisplayInlineBlock', \"inline-block is ignored due to the float. If 'float' has a value other than 'none', the box is floated and 'display' is treated as 'block'\"));\n        }\n      }\n    } // With 'display: block', 'vertical-align' has no effect\n\n\n    displayElems = this.fetchWithValue(propertyTable, 'display', 'block');\n\n    if (displayElems.length > 0) {\n      var elem = this.fetch(propertyTable, 'vertical-align');\n\n      for (var index = 0; index < elem.length; index++) {\n        this.addEntry(elem[index].node, Rules.PropertyIgnoredDueToDisplay, localize('rule.propertyIgnoredDueToDisplayBlock', \"Property is ignored due to the display. With 'display: block', vertical-align should not be used.\"));\n      }\n    } /////////////////////////////////////////////////////////////\n    //\tAvoid 'float'\n    /////////////////////////////////////////////////////////////\n\n\n    var elements = this.fetch(propertyTable, 'float');\n\n    for (var index = 0; index < elements.length; index++) {\n      var decl = elements[index].node;\n\n      if (!this.isValidPropertyDeclaration(decl)) {\n        this.addEntry(decl, Rules.AvoidFloat);\n      }\n    } /////////////////////////////////////////////////////////////\n    //\tDon't use duplicate declarations.\n    /////////////////////////////////////////////////////////////\n\n\n    for (var i = 0; i < propertyTable.length; i++) {\n      var element = propertyTable[i];\n\n      if (element.name !== 'background' && !this.validProperties[element.name]) {\n        var value = element.node.getValue();\n\n        if (value && this.documentText.charAt(value.offset) !== '-') {\n          var elements_1 = this.fetch(propertyTable, element.name);\n\n          if (elements_1.length > 1) {\n            for (var k = 0; k < elements_1.length; k++) {\n              var value_1 = elements_1[k].node.getValue();\n\n              if (value_1 && this.documentText.charAt(value_1.offset) !== '-' && elements_1[k] !== element) {\n                this.addEntry(element.node, Rules.DuplicateDeclarations);\n              }\n            }\n          }\n        }\n      }\n    } /////////////////////////////////////////////////////////////\n    //\tUnknown propery & When using a vendor-prefixed gradient, make sure to use them all.\n    /////////////////////////////////////////////////////////////\n\n\n    var isExportBlock = node.getSelectors().getText() === \":export\";\n\n    if (!isExportBlock) {\n      var propertiesBySuffix = new NodesByRootMap();\n      var containsUnknowns = false;\n\n      for (var _f = 0, _g = declarations.getChildren(); _f < _g.length; _f++) {\n        var node_3 = _g[_f];\n\n        if (this.isCSSDeclaration(node_3)) {\n          var decl = node_3;\n          var name = decl.getFullPropertyName().toLowerCase();\n          var firstChar = name.charAt(0);\n\n          if (firstChar === '-') {\n            if (name.charAt(1) !== '-') {\n              // avoid css variables\n              if (!languageFacts.cssDataManager.isKnownProperty(name) && !this.validProperties[name]) {\n                this.addEntry(decl.getProperty(), Rules.UnknownVendorSpecificProperty);\n              }\n\n              var nonPrefixedName = decl.getNonPrefixedPropertyName();\n              propertiesBySuffix.add(nonPrefixedName, name, decl.getProperty());\n            }\n          } else {\n            var fullName = name;\n\n            if (firstChar === '*' || firstChar === '_') {\n              this.addEntry(decl.getProperty(), Rules.IEStarHack);\n              name = name.substr(1);\n            } // _property and *property might be contributed via custom data\n\n\n            if (!languageFacts.cssDataManager.isKnownProperty(fullName) && !languageFacts.cssDataManager.isKnownProperty(name)) {\n              if (!this.validProperties[name]) {\n                this.addEntry(decl.getProperty(), Rules.UnknownProperty, localize('property.unknownproperty.detailed', \"Unknown property: '{0}'\", name));\n              }\n            }\n\n            propertiesBySuffix.add(name, name, null); // don't pass the node as we don't show errors on the standard\n          }\n        } else {\n          containsUnknowns = true;\n        }\n      }\n\n      if (!containsUnknowns) {\n        // don't perform this test if there are\n        for (var suffix in propertiesBySuffix.data) {\n          var entry = propertiesBySuffix.data[suffix];\n          var actual = entry.names;\n          var needsStandard = languageFacts.cssDataManager.isStandardProperty(suffix) && actual.indexOf(suffix) === -1;\n\n          if (!needsStandard && actual.length === 1) {\n            continue; // only the non-vendor specific rule is used, that's fine, no warning\n          }\n\n          var expected = [];\n\n          for (var i = 0, len = LintVisitor.prefixes.length; i < len; i++) {\n            var prefix = LintVisitor.prefixes[i];\n\n            if (languageFacts.cssDataManager.isStandardProperty(prefix + suffix)) {\n              expected.push(prefix + suffix);\n            }\n          }\n\n          var missingVendorSpecific = this.getMissingNames(expected, actual);\n\n          if (missingVendorSpecific || needsStandard) {\n            for (var _h = 0, _j = entry.nodes; _h < _j.length; _h++) {\n              var node_4 = _j[_h];\n\n              if (needsStandard) {\n                var message = localize('property.standard.missing', \"Also define the standard property '{0}' for compatibility\", suffix);\n                this.addEntry(node_4, Rules.IncludeStandardPropertyWhenUsingVendorPrefix, message);\n              }\n\n              if (missingVendorSpecific) {\n                var message = localize('property.vendorspecific.missing', \"Always include all vendor specific properties: Missing: {0}\", missingVendorSpecific);\n                this.addEntry(node_4, Rules.AllVendorPrefixes, message);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  LintVisitor.prototype.visitPrio = function (node) {\n    /////////////////////////////////////////////////////////////\n    //\tDon't use !important\n    /////////////////////////////////////////////////////////////\n    this.addEntry(node, Rules.AvoidImportant);\n    return true;\n  };\n\n  LintVisitor.prototype.visitNumericValue = function (node) {\n    /////////////////////////////////////////////////////////////\n    //\t0 has no following unit\n    /////////////////////////////////////////////////////////////\n    var funcDecl = node.findParent(nodes.NodeType.Function);\n\n    if (funcDecl && funcDecl.getName() === 'calc') {\n      return true;\n    }\n\n    var decl = node.findParent(nodes.NodeType.Declaration);\n\n    if (decl) {\n      var declValue = decl.getValue();\n\n      if (declValue) {\n        var value = node.getValue();\n\n        if (!value.unit || languageFacts.units.length.indexOf(value.unit.toLowerCase()) === -1) {\n          return true;\n        }\n\n        if (parseFloat(value.value) === 0.0 && !!value.unit && !this.validProperties[decl.getFullPropertyName()]) {\n          this.addEntry(node, Rules.ZeroWithUnit);\n        }\n      }\n    }\n\n    return true;\n  };\n\n  LintVisitor.prototype.visitFontFace = function (node) {\n    var declarations = node.getDeclarations();\n\n    if (!declarations) {\n      // syntax error\n      return;\n    }\n\n    var definesSrc = false,\n        definesFontFamily = false;\n    var containsUnknowns = false;\n\n    for (var _i = 0, _a = declarations.getChildren(); _i < _a.length; _i++) {\n      var node_5 = _a[_i];\n\n      if (this.isCSSDeclaration(node_5)) {\n        var name = node_5.getProperty().getName().toLowerCase();\n\n        if (name === 'src') {\n          definesSrc = true;\n        }\n\n        if (name === 'font-family') {\n          definesFontFamily = true;\n        }\n      } else {\n        containsUnknowns = true;\n      }\n    }\n\n    if (!containsUnknowns && (!definesSrc || !definesFontFamily)) {\n      this.addEntry(node, Rules.RequiredPropertiesForFontFace);\n    }\n\n    return true;\n  };\n\n  LintVisitor.prototype.isCSSDeclaration = function (node) {\n    if (node instanceof nodes.Declaration) {\n      if (!node.getValue()) {\n        return false;\n      }\n\n      var property = node.getProperty();\n\n      if (!property || property.getIdentifier().containsInterpolation()) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  LintVisitor.prototype.visitHexColorValue = function (node) {\n    // Rule: #eeff0011 or #eeff00 or #ef01 or #ef0\n    var length = node.length;\n\n    if (length !== 9 && length !== 7 && length !== 5 && length !== 4) {\n      this.addEntry(node, Rules.HexColorLength);\n    }\n\n    return false;\n  };\n\n  LintVisitor.prototype.visitFunction = function (node) {\n    var fnName = node.getName().toLowerCase();\n    var expectedAttrCount = -1;\n    var actualAttrCount = 0;\n\n    switch (fnName) {\n      case 'rgb(':\n      case 'hsl(':\n        expectedAttrCount = 3;\n        break;\n\n      case 'rgba(':\n      case 'hsla(':\n        expectedAttrCount = 4;\n        break;\n    }\n\n    if (expectedAttrCount !== -1) {\n      node.getArguments().accept(function (n) {\n        if (n instanceof nodes.BinaryExpression) {\n          actualAttrCount += 1;\n          return false;\n        }\n\n        return true;\n      });\n\n      if (actualAttrCount !== expectedAttrCount) {\n        this.addEntry(node, Rules.ArgsInColorFunction);\n      }\n    }\n\n    return true;\n  };\n\n  LintVisitor.prefixes = ['-ms-', '-moz-', '-o-', '-webkit-'];\n  return LintVisitor;\n}();\n\nexport { LintVisitor };","map":null,"metadata":{},"sourceType":"module"}