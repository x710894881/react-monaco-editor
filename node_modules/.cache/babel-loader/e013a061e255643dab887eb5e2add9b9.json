{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { TokenType, Scanner } from '../parser/cssScanner.js';\nimport { SCSSScanner, InterpolationFunction } from '../parser/scssScanner.js';\nimport { LESSScanner } from '../parser/lessScanner.js';\nexport function getFoldingRanges(document, context) {\n  var ranges = computeFoldingRanges(document);\n  return limitFoldingRanges(ranges, context);\n}\n\nfunction computeFoldingRanges(document) {\n  function getStartLine(t) {\n    return document.positionAt(t.offset).line;\n  }\n\n  function getEndLine(t) {\n    return document.positionAt(t.offset + t.len).line;\n  }\n\n  function getScanner() {\n    switch (document.languageId) {\n      case 'scss':\n        return new SCSSScanner();\n\n      case 'less':\n        return new LESSScanner();\n\n      default:\n        return new Scanner();\n    }\n  }\n\n  function tokenToRange(t, kind) {\n    var startLine = getStartLine(t);\n    var endLine = getEndLine(t);\n\n    if (startLine !== endLine) {\n      return {\n        startLine: startLine,\n        endLine: endLine,\n        kind: kind\n      };\n    } else {\n      return null;\n    }\n  }\n\n  var ranges = [];\n  var delimiterStack = [];\n  var scanner = getScanner();\n  scanner.ignoreComment = false;\n  scanner.setSource(document.getText());\n  var token = scanner.scan();\n  var prevToken;\n\n  var _loop_1 = function () {\n    switch (token.type) {\n      case TokenType.CurlyL:\n      case InterpolationFunction:\n        {\n          delimiterStack.push({\n            line: getStartLine(token),\n            type: 'brace',\n            isStart: true\n          });\n          break;\n        }\n\n      case TokenType.CurlyR:\n        {\n          if (delimiterStack.length !== 0) {\n            var prevDelimiter = popPrevStartDelimiterOfType(delimiterStack, 'brace');\n\n            if (!prevDelimiter) {\n              break;\n            }\n\n            var endLine = getEndLine(token);\n\n            if (prevDelimiter.type === 'brace') {\n              /**\n               * Other than the case when curly brace is not on a new line by itself, for example\n               * .foo {\n               *   color: red; }\n               * Use endLine minus one to show ending curly brace\n               */\n              if (getEndLine(prevToken) !== endLine) {\n                endLine--;\n              }\n\n              if (prevDelimiter.line !== endLine) {\n                ranges.push({\n                  startLine: prevDelimiter.line,\n                  endLine: endLine,\n                  kind: undefined\n                });\n              }\n            }\n          }\n\n          break;\n        }\n\n      /**\n       * In CSS, there is no single line comment prefixed with //\n       * All comments are marked as `Comment`\n       */\n\n      case TokenType.Comment:\n        {\n          var commentRegionMarkerToDelimiter_1 = function (marker) {\n            if (marker === '#region') {\n              return {\n                line: getStartLine(token),\n                type: 'comment',\n                isStart: true\n              };\n            } else {\n              return {\n                line: getEndLine(token),\n                type: 'comment',\n                isStart: false\n              };\n            }\n          };\n\n          var getCurrDelimiter = function (token) {\n            var matches = token.text.match(/^\\s*\\/\\*\\s*(#region|#endregion)\\b\\s*(.*?)\\s*\\*\\//);\n\n            if (matches) {\n              return commentRegionMarkerToDelimiter_1(matches[1]);\n            } else if (document.languageId === 'scss' || document.languageId === 'less') {\n              var matches_1 = token.text.match(/^\\s*\\/\\/\\s*(#region|#endregion)\\b\\s*(.*?)\\s*/);\n\n              if (matches_1) {\n                return commentRegionMarkerToDelimiter_1(matches_1[1]);\n              }\n            }\n\n            return null;\n          };\n\n          var currDelimiter = getCurrDelimiter(token); // /* */ comment region folding\n          // All #region and #endregion cases\n\n          if (currDelimiter) {\n            if (currDelimiter.isStart) {\n              delimiterStack.push(currDelimiter);\n            } else {\n              var prevDelimiter = popPrevStartDelimiterOfType(delimiterStack, 'comment');\n\n              if (!prevDelimiter) {\n                break;\n              }\n\n              if (prevDelimiter.type === 'comment') {\n                if (prevDelimiter.line !== currDelimiter.line) {\n                  ranges.push({\n                    startLine: prevDelimiter.line,\n                    endLine: currDelimiter.line,\n                    kind: 'region'\n                  });\n                }\n              }\n            }\n          } // Multiline comment case\n          else {\n              var range = tokenToRange(token, 'comment');\n\n              if (range) {\n                ranges.push(range);\n              }\n            }\n\n          break;\n        }\n    }\n\n    prevToken = token;\n    token = scanner.scan();\n  };\n\n  while (token.type !== TokenType.EOF) {\n    _loop_1();\n  }\n\n  return ranges;\n}\n\nfunction popPrevStartDelimiterOfType(stack, type) {\n  if (stack.length === 0) {\n    return null;\n  }\n\n  for (var i = stack.length - 1; i >= 0; i--) {\n    if (stack[i].type === type && stack[i].isStart) {\n      return stack.splice(i, 1)[0];\n    }\n  }\n\n  return null;\n}\n/**\n * - Sort regions\n * - Remove invalid regions (intersections)\n * - If limit exceeds, only return `rangeLimit` amount of ranges\n */\n\n\nfunction limitFoldingRanges(ranges, context) {\n  var maxRanges = context && context.rangeLimit || Number.MAX_VALUE;\n  var sortedRanges = ranges.sort(function (r1, r2) {\n    var diff = r1.startLine - r2.startLine;\n\n    if (diff === 0) {\n      diff = r1.endLine - r2.endLine;\n    }\n\n    return diff;\n  });\n  var validRanges = [];\n  var prevEndLine = -1;\n  sortedRanges.forEach(function (r) {\n    if (!(r.startLine < prevEndLine && prevEndLine < r.endLine)) {\n      validRanges.push(r);\n      prevEndLine = r.endLine;\n    }\n  });\n\n  if (validRanges.length < maxRanges) {\n    return validRanges;\n  } else {\n    return validRanges.slice(0, maxRanges);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}