{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport './viewLines.css';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Configuration } from '../../config/configuration.js';\nimport { VisibleLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { DomReadingContext, ViewLine, ViewLineOptions } from './viewLine.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LineVisibleRanges } from '../../../common/view/renderingContext.js';\n\nvar LastRenderedData =\n/** @class */\nfunction () {\n  function LastRenderedData() {\n    this._currentVisibleRange = new Range(1, 1, 1, 1);\n  }\n\n  LastRenderedData.prototype.getCurrentVisibleRange = function () {\n    return this._currentVisibleRange;\n  };\n\n  LastRenderedData.prototype.setCurrentVisibleRange = function (currentVisibleRange) {\n    this._currentVisibleRange = currentVisibleRange;\n  };\n\n  return LastRenderedData;\n}();\n\nvar HorizontalRevealRequest =\n/** @class */\nfunction () {\n  function HorizontalRevealRequest(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\n    this.lineNumber = lineNumber;\n    this.startColumn = startColumn;\n    this.endColumn = endColumn;\n    this.startScrollTop = startScrollTop;\n    this.stopScrollTop = stopScrollTop;\n    this.scrollType = scrollType;\n  }\n\n  return HorizontalRevealRequest;\n}();\n\nvar ViewLines =\n/** @class */\nfunction (_super) {\n  __extends(ViewLines, _super);\n\n  function ViewLines(context, linesContent) {\n    var _this = _super.call(this, context) || this;\n\n    _this._linesContent = linesContent;\n    _this._textRangeRestingSpot = document.createElement('div');\n    _this._visibleLines = new VisibleLinesCollection(_this);\n    _this.domNode = _this._visibleLines.domNode;\n    var conf = _this._context.configuration;\n    _this._lineHeight = conf.editor.lineHeight;\n    _this._typicalHalfwidthCharacterWidth = conf.editor.fontInfo.typicalHalfwidthCharacterWidth;\n    _this._isViewportWrapping = conf.editor.wrappingInfo.isViewportWrapping;\n    _this._revealHorizontalRightPadding = conf.editor.viewInfo.revealHorizontalRightPadding;\n    _this._scrollOff = conf.editor.viewInfo.cursorSurroundingLines;\n    _this._canUseLayerHinting = conf.editor.canUseLayerHinting;\n    _this._viewLineOptions = new ViewLineOptions(conf, _this._context.theme.type);\n    PartFingerprints.write(_this.domNode, 7\n    /* ViewLines */\n    );\n\n    _this.domNode.setClassName('view-lines');\n\n    Configuration.applyFontInfo(_this.domNode, conf.editor.fontInfo); // --- width & height\n\n    _this._maxLineWidth = 0;\n    _this._asyncUpdateLineWidths = new RunOnceScheduler(function () {\n      _this._updateLineWidthsSlow();\n    }, 200);\n    _this._lastRenderedData = new LastRenderedData();\n    _this._horizontalRevealRequest = null;\n    return _this;\n  }\n\n  ViewLines.prototype.dispose = function () {\n    this._asyncUpdateLineWidths.dispose();\n\n    _super.prototype.dispose.call(this);\n  };\n\n  ViewLines.prototype.getDomNode = function () {\n    return this.domNode;\n  }; // ---- begin IVisibleLinesHost\n\n\n  ViewLines.prototype.createVisibleLine = function () {\n    return new ViewLine(this._viewLineOptions);\n  }; // ---- end IVisibleLinesHost\n  // ---- begin view event handlers\n\n\n  ViewLines.prototype.onConfigurationChanged = function (e) {\n    this._visibleLines.onConfigurationChanged(e);\n\n    if (e.wrappingInfo) {\n      this._maxLineWidth = 0;\n    }\n\n    var conf = this._context.configuration;\n\n    if (e.lineHeight) {\n      this._lineHeight = conf.editor.lineHeight;\n    }\n\n    if (e.fontInfo) {\n      this._typicalHalfwidthCharacterWidth = conf.editor.fontInfo.typicalHalfwidthCharacterWidth;\n    }\n\n    if (e.wrappingInfo) {\n      this._isViewportWrapping = conf.editor.wrappingInfo.isViewportWrapping;\n    }\n\n    if (e.viewInfo) {\n      this._revealHorizontalRightPadding = conf.editor.viewInfo.revealHorizontalRightPadding;\n      this._scrollOff = conf.editor.viewInfo.cursorSurroundingLines;\n    }\n\n    if (e.canUseLayerHinting) {\n      this._canUseLayerHinting = conf.editor.canUseLayerHinting;\n    }\n\n    if (e.fontInfo) {\n      Configuration.applyFontInfo(this.domNode, conf.editor.fontInfo);\n    }\n\n    this._onOptionsMaybeChanged();\n\n    if (e.layoutInfo) {\n      this._maxLineWidth = 0;\n    }\n\n    return true;\n  };\n\n  ViewLines.prototype._onOptionsMaybeChanged = function () {\n    var conf = this._context.configuration;\n    var newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n\n    if (!this._viewLineOptions.equals(newViewLineOptions)) {\n      this._viewLineOptions = newViewLineOptions;\n\n      var startLineNumber = this._visibleLines.getStartLineNumber();\n\n      var endLineNumber = this._visibleLines.getEndLineNumber();\n\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        var line = this._visibleLines.getVisibleLine(lineNumber);\n\n        line.onOptionsChanged(this._viewLineOptions);\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  ViewLines.prototype.onCursorStateChanged = function (e) {\n    var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n    var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n    var r = false;\n\n    for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n      r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\n    }\n\n    return r;\n  };\n\n  ViewLines.prototype.onDecorationsChanged = function (e) {\n    if (true\n    /*e.inlineDecorationsChanged*/\n    ) {\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n        for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n          this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\n        }\n      }\n\n    return true;\n  };\n\n  ViewLines.prototype.onFlushed = function (e) {\n    var shouldRender = this._visibleLines.onFlushed(e);\n\n    this._maxLineWidth = 0;\n    return shouldRender;\n  };\n\n  ViewLines.prototype.onLinesChanged = function (e) {\n    return this._visibleLines.onLinesChanged(e);\n  };\n\n  ViewLines.prototype.onLinesDeleted = function (e) {\n    return this._visibleLines.onLinesDeleted(e);\n  };\n\n  ViewLines.prototype.onLinesInserted = function (e) {\n    return this._visibleLines.onLinesInserted(e);\n  };\n\n  ViewLines.prototype.onRevealRangeRequest = function (e) {\n    // Using the future viewport here in order to handle multiple\n    // incoming reveal range requests that might all desire to be animated\n    var desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.range, e.verticalType); // validate the new desired scroll top\n\n\n    var newScrollPosition = this._context.viewLayout.validateScrollPosition({\n      scrollTop: desiredScrollTop\n    });\n\n    if (e.revealHorizontal) {\n      if (e.range.startLineNumber !== e.range.endLineNumber) {\n        // Two or more lines? => scroll to base (That's how you see most of the two lines)\n        newScrollPosition = {\n          scrollTop: newScrollPosition.scrollTop,\n          scrollLeft: 0\n        };\n      } else {\n        // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\n        this._horizontalRevealRequest = new HorizontalRevealRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n      }\n    } else {\n      this._horizontalRevealRequest = null;\n    }\n\n    var scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\n\n    if (e.scrollType === 0\n    /* Smooth */\n    && scrollTopDelta > this._lineHeight) {\n      this._context.viewLayout.setScrollPositionSmooth(newScrollPosition);\n    } else {\n      this._context.viewLayout.setScrollPositionNow(newScrollPosition);\n    }\n\n    return true;\n  };\n\n  ViewLines.prototype.onScrollChanged = function (e) {\n    if (this._horizontalRevealRequest && e.scrollLeftChanged) {\n      // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\n      this._horizontalRevealRequest = null;\n    }\n\n    if (this._horizontalRevealRequest && e.scrollTopChanged) {\n      var min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n      var max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n\n      if (e.scrollTop < min || e.scrollTop > max) {\n        // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\n        this._horizontalRevealRequest = null;\n      }\n    }\n\n    this.domNode.setWidth(e.scrollWidth);\n    return this._visibleLines.onScrollChanged(e) || true;\n  };\n\n  ViewLines.prototype.onTokensChanged = function (e) {\n    return this._visibleLines.onTokensChanged(e);\n  };\n\n  ViewLines.prototype.onZonesChanged = function (e) {\n    this._context.viewLayout.onMaxLineWidthChanged(this._maxLineWidth);\n\n    return this._visibleLines.onZonesChanged(e);\n  };\n\n  ViewLines.prototype.onThemeChanged = function (e) {\n    return this._onOptionsMaybeChanged();\n  }; // ---- end view event handlers\n  // ----------- HELPERS FOR OTHERS\n\n\n  ViewLines.prototype.getPositionFromDOMInfo = function (spanNode, offset) {\n    var viewLineDomNode = this._getViewLineDomNode(spanNode);\n\n    if (viewLineDomNode === null) {\n      // Couldn't find view line node\n      return null;\n    }\n\n    var lineNumber = this._getLineNumberFor(viewLineDomNode);\n\n    if (lineNumber === -1) {\n      // Couldn't find view line node\n      return null;\n    }\n\n    if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {\n      // lineNumber is outside range\n      return null;\n    }\n\n    if (this._context.model.getLineMaxColumn(lineNumber) === 1) {\n      // Line is empty\n      return new Position(lineNumber, 1);\n    }\n\n    var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n    var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n    if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n      // Couldn't find line\n      return null;\n    }\n\n    var column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);\n\n    var minColumn = this._context.model.getLineMinColumn(lineNumber);\n\n    if (column < minColumn) {\n      column = minColumn;\n    }\n\n    return new Position(lineNumber, column);\n  };\n\n  ViewLines.prototype._getViewLineDomNode = function (node) {\n    while (node && node.nodeType === 1) {\n      if (node.className === ViewLine.CLASS_NAME) {\n        return node;\n      }\n\n      node = node.parentElement;\n    }\n\n    return null;\n  };\n  /**\n   * @returns the line number of this view line dom node.\n   */\n\n\n  ViewLines.prototype._getLineNumberFor = function (domNode) {\n    var startLineNumber = this._visibleLines.getStartLineNumber();\n\n    var endLineNumber = this._visibleLines.getEndLineNumber();\n\n    for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      var line = this._visibleLines.getVisibleLine(lineNumber);\n\n      if (domNode === line.getDomNode()) {\n        return lineNumber;\n      }\n    }\n\n    return -1;\n  };\n\n  ViewLines.prototype.getLineWidth = function (lineNumber) {\n    var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n    var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n    if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n      // Couldn't find line\n      return -1;\n    }\n\n    return this._visibleLines.getVisibleLine(lineNumber).getWidth();\n  };\n\n  ViewLines.prototype.linesVisibleRangesForRange = function (_range, includeNewLines) {\n    if (this.shouldRender()) {\n      // Cannot read from the DOM because it is dirty\n      // i.e. the model & the dom are out of sync, so I'd be reading something stale\n      return null;\n    }\n\n    var originalEndLineNumber = _range.endLineNumber;\n    var range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n\n    if (!range) {\n      return null;\n    }\n\n    var visibleRanges = [],\n        visibleRangesLen = 0;\n    var domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n    var nextLineModelLineNumber = 0;\n\n    if (includeNewLines) {\n      nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\n    }\n\n    var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n    var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n    for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n      if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n        continue;\n      }\n\n      var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n      var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\n\n      var visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\n\n      if (!visibleRangesForLine || visibleRangesForLine.length === 0) {\n        continue;\n      }\n\n      if (includeNewLines && lineNumber < originalEndLineNumber) {\n        var currentLineModelLineNumber = nextLineModelLineNumber;\n        nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\n\n        if (currentLineModelLineNumber !== nextLineModelLineNumber) {\n          visibleRangesForLine[visibleRangesForLine.length - 1].width += this._typicalHalfwidthCharacterWidth;\n        }\n      }\n\n      visibleRanges[visibleRangesLen++] = new LineVisibleRanges(lineNumber, visibleRangesForLine);\n    }\n\n    if (visibleRangesLen === 0) {\n      return null;\n    }\n\n    return visibleRanges;\n  };\n\n  ViewLines.prototype.visibleRangesForRange2 = function (_range) {\n    if (this.shouldRender()) {\n      // Cannot read from the DOM because it is dirty\n      // i.e. the model & the dom are out of sync, so I'd be reading something stale\n      return null;\n    }\n\n    var range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n\n    if (!range) {\n      return null;\n    }\n\n    var result = [];\n    var domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n\n    var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n    var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n    for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n      if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n        continue;\n      }\n\n      var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n      var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\n\n      var visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\n\n      if (!visibleRangesForLine || visibleRangesForLine.length === 0) {\n        continue;\n      }\n\n      result = result.concat(visibleRangesForLine);\n    }\n\n    if (result.length === 0) {\n      return null;\n    }\n\n    return result;\n  };\n\n  ViewLines.prototype.visibleRangeForPosition = function (position) {\n    var visibleRanges = this.visibleRangesForRange2(new Range(position.lineNumber, position.column, position.lineNumber, position.column));\n\n    if (!visibleRanges) {\n      return null;\n    }\n\n    return visibleRanges[0];\n  }; // --- implementation\n\n\n  ViewLines.prototype.updateLineWidths = function () {\n    this._updateLineWidths(false);\n  };\n  /**\n   * Updates the max line width if it is fast to compute.\n   * Returns true if all lines were taken into account.\n   * Returns false if some lines need to be reevaluated (in a slow fashion).\n   */\n\n\n  ViewLines.prototype._updateLineWidthsFast = function () {\n    return this._updateLineWidths(true);\n  };\n\n  ViewLines.prototype._updateLineWidthsSlow = function () {\n    this._updateLineWidths(false);\n  };\n\n  ViewLines.prototype._updateLineWidths = function (fast) {\n    var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n    var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n    var localMaxLineWidth = 1;\n    var allWidthsComputed = true;\n\n    for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n      var visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n\n      if (fast && !visibleLine.getWidthIsFast()) {\n        // Cannot compute width in a fast way for this line\n        allWidthsComputed = false;\n        continue;\n      }\n\n      localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());\n    }\n\n    if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {\n      // we know the max line width for all the lines\n      this._maxLineWidth = 0;\n    }\n\n    this._ensureMaxLineWidth(localMaxLineWidth);\n\n    return allWidthsComputed;\n  };\n\n  ViewLines.prototype.prepareRender = function () {\n    throw new Error('Not supported');\n  };\n\n  ViewLines.prototype.render = function () {\n    throw new Error('Not supported');\n  };\n\n  ViewLines.prototype.renderText = function (viewportData) {\n    // (1) render lines - ensures lines are in the DOM\n    this._visibleLines.renderLines(viewportData);\n\n    this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\n\n    this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\n    this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000)); // (2) compute horizontal scroll position:\n    //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\n    //  - it might change `scrollWidth` and `scrollLeft`\n\n    if (this._horizontalRevealRequest) {\n      var revealLineNumber = this._horizontalRevealRequest.lineNumber;\n      var revealStartColumn = this._horizontalRevealRequest.startColumn;\n      var revealEndColumn = this._horizontalRevealRequest.endColumn;\n      var scrollType = this._horizontalRevealRequest.scrollType; // Check that we have the line that contains the horizontal range in the viewport\n\n      if (viewportData.startLineNumber <= revealLineNumber && revealLineNumber <= viewportData.endLineNumber) {\n        this._horizontalRevealRequest = null; // allow `visibleRangesForRange2` to work\n\n        this.onDidRender(); // compute new scroll position\n\n        var newScrollLeft = this._computeScrollLeftToRevealRange(revealLineNumber, revealStartColumn, revealEndColumn);\n\n        var isViewportWrapping = this._isViewportWrapping;\n\n        if (!isViewportWrapping) {\n          // ensure `scrollWidth` is large enough\n          this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\n        } // set `scrollLeft`\n\n\n        if (scrollType === 0\n        /* Smooth */\n        ) {\n            this._context.viewLayout.setScrollPositionSmooth({\n              scrollLeft: newScrollLeft.scrollLeft\n            });\n          } else {\n          this._context.viewLayout.setScrollPositionNow({\n            scrollLeft: newScrollLeft.scrollLeft\n          });\n        }\n      }\n    } // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\n\n\n    if (!this._updateLineWidthsFast()) {\n      // Computing the width of some lines would be slow => delay it\n      this._asyncUpdateLineWidths.schedule();\n    } // (3) handle scrolling\n\n\n    this._linesContent.setLayerHinting(this._canUseLayerHinting);\n\n    var adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\n\n    this._linesContent.setTop(-adjustedScrollTop);\n\n    this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\n  }; // --- width\n\n\n  ViewLines.prototype._ensureMaxLineWidth = function (lineWidth) {\n    var iLineWidth = Math.ceil(lineWidth);\n\n    if (this._maxLineWidth < iLineWidth) {\n      this._maxLineWidth = iLineWidth;\n\n      this._context.viewLayout.onMaxLineWidthChanged(this._maxLineWidth);\n    }\n  };\n\n  ViewLines.prototype._computeScrollTopToRevealRange = function (viewport, range, verticalType) {\n    var viewportStartY = viewport.top;\n    var viewportHeight = viewport.height;\n    var viewportEndY = viewportStartY + viewportHeight;\n    var boxStartY;\n    var boxEndY; // Have a box that includes one extra line height (for the horizontal scrollbar)\n\n    boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\n    boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\n    var context = Math.min(viewportHeight / this._lineHeight / 2, this._scrollOff);\n    boxStartY -= context * this._lineHeight;\n    boxEndY += Math.max(0, context - 1) * this._lineHeight;\n\n    if (verticalType === 0\n    /* Simple */\n    || verticalType === 4\n    /* Bottom */\n    ) {\n        // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\n        boxEndY += this._lineHeight;\n      }\n\n    var newScrollTop;\n\n    if (verticalType === 1\n    /* Center */\n    || verticalType === 2\n    /* CenterIfOutsideViewport */\n    ) {\n        if (verticalType === 2\n        /* CenterIfOutsideViewport */\n        && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n          // Box is already in the viewport... do nothing\n          newScrollTop = viewportStartY;\n        } else {\n          // Box is outside the viewport... center it\n          var boxMiddleY = (boxStartY + boxEndY) / 2;\n          newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\n        }\n      } else {\n      newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3\n      /* Top */\n      , verticalType === 4\n      /* Bottom */\n      );\n    }\n\n    return newScrollTop;\n  };\n\n  ViewLines.prototype._computeScrollLeftToRevealRange = function (lineNumber, startColumn, endColumn) {\n    var maxHorizontalOffset = 0;\n\n    var viewport = this._context.viewLayout.getCurrentViewport();\n\n    var viewportStartX = viewport.left;\n    var viewportEndX = viewportStartX + viewport.width;\n    var visibleRanges = this.visibleRangesForRange2(new Range(lineNumber, startColumn, lineNumber, endColumn));\n    var boxStartX = Number.MAX_VALUE;\n    var boxEndX = 0;\n\n    if (!visibleRanges) {\n      // Unknown\n      return {\n        scrollLeft: viewportStartX,\n        maxHorizontalOffset: maxHorizontalOffset\n      };\n    }\n\n    for (var _i = 0, visibleRanges_1 = visibleRanges; _i < visibleRanges_1.length; _i++) {\n      var visibleRange = visibleRanges_1[_i];\n\n      if (visibleRange.left < boxStartX) {\n        boxStartX = visibleRange.left;\n      }\n\n      if (visibleRange.left + visibleRange.width > boxEndX) {\n        boxEndX = visibleRange.left + visibleRange.width;\n      }\n    }\n\n    maxHorizontalOffset = boxEndX;\n    boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\n    boxEndX += this._revealHorizontalRightPadding;\n\n    var newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\n\n    return {\n      scrollLeft: newScrollLeft,\n      maxHorizontalOffset: maxHorizontalOffset\n    };\n  };\n\n  ViewLines.prototype._computeMinimumScrolling = function (viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\n    viewportStart = viewportStart | 0;\n    viewportEnd = viewportEnd | 0;\n    boxStart = boxStart | 0;\n    boxEnd = boxEnd | 0;\n    revealAtStart = !!revealAtStart;\n    revealAtEnd = !!revealAtEnd;\n    var viewportLength = viewportEnd - viewportStart;\n    var boxLength = boxEnd - boxStart;\n\n    if (boxLength < viewportLength) {\n      // The box would fit in the viewport\n      if (revealAtStart) {\n        return boxStart;\n      }\n\n      if (revealAtEnd) {\n        return Math.max(0, boxEnd - viewportLength);\n      }\n\n      if (boxStart < viewportStart) {\n        // The box is above the viewport\n        return boxStart;\n      } else if (boxEnd > viewportEnd) {\n        // The box is below the viewport\n        return Math.max(0, boxEnd - viewportLength);\n      }\n    } else {\n      // The box would not fit in the viewport\n      // Reveal the beginning of the box\n      return boxStart;\n    }\n\n    return viewportStart;\n  };\n  /**\n   * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\n   */\n\n\n  ViewLines.HORIZONTAL_EXTRA_PX = 30;\n  return ViewLines;\n}(ViewPart);\n\nexport { ViewLines };","map":null,"metadata":{},"sourceType":"module"}