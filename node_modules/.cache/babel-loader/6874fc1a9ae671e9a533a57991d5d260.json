{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as nls from '../../../nls.js';\nimport { KeyChord } from '../../../base/common/keyCodes.js';\nimport { CoreEditingCommands } from '../../browser/controller/coreCommands.js';\nimport { EditorAction, registerEditorAction } from '../../browser/editorExtensions.js';\nimport { ReplaceCommand, ReplaceCommandThatPreservesSelection } from '../../common/commands/replaceCommand.js';\nimport { TrimTrailingWhitespaceCommand } from '../../common/commands/trimTrailingWhitespaceCommand.js';\nimport { TypeOperations } from '../../common/controller/cursorTypeOperations.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { EditorContextKeys } from '../../common/editorContextKeys.js';\nimport { CopyLinesCommand } from './copyLinesCommand.js';\nimport { MoveLinesCommand } from './moveLinesCommand.js';\nimport { SortLinesCommand } from './sortLinesCommand.js'; // copy lines\n\nvar AbstractCopyLinesAction =\n/** @class */\nfunction (_super) {\n  __extends(AbstractCopyLinesAction, _super);\n\n  function AbstractCopyLinesAction(down, opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.down = down;\n    return _this;\n  }\n\n  AbstractCopyLinesAction.prototype.run = function (_accessor, editor) {\n    var commands = [];\n    var selections = editor.getSelections() || [];\n\n    for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {\n      var selection = selections_1[_i];\n      commands.push(new CopyLinesCommand(selection, this.down));\n    }\n\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, commands);\n    editor.pushUndoStop();\n  };\n\n  return AbstractCopyLinesAction;\n}(EditorAction);\n\nvar CopyLinesUpAction =\n/** @class */\nfunction (_super) {\n  __extends(CopyLinesUpAction, _super);\n\n  function CopyLinesUpAction() {\n    return _super.call(this, false, {\n      id: 'editor.action.copyLinesUpAction',\n      label: nls.localize('lines.copyUp', \"Copy Line Up\"),\n      alias: 'Copy Line Up',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 512\n        /* Alt */\n        | 1024\n        /* Shift */\n        | 16\n        /* UpArrow */\n        ,\n        linux: {\n          primary: 2048\n          /* CtrlCmd */\n          | 512\n          /* Alt */\n          | 1024\n          /* Shift */\n          | 16\n          /* UpArrow */\n\n        },\n        weight: 100\n        /* EditorContrib */\n\n      },\n      menubarOpts: {\n        menuId: 22\n        /* MenubarSelectionMenu */\n        ,\n        group: '2_line',\n        title: nls.localize({\n          key: 'miCopyLinesUp',\n          comment: ['&& denotes a mnemonic']\n        }, \"&&Copy Line Up\"),\n        order: 1\n      }\n    }) || this;\n  }\n\n  return CopyLinesUpAction;\n}(AbstractCopyLinesAction);\n\nvar CopyLinesDownAction =\n/** @class */\nfunction (_super) {\n  __extends(CopyLinesDownAction, _super);\n\n  function CopyLinesDownAction() {\n    return _super.call(this, true, {\n      id: 'editor.action.copyLinesDownAction',\n      label: nls.localize('lines.copyDown', \"Copy Line Down\"),\n      alias: 'Copy Line Down',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 512\n        /* Alt */\n        | 1024\n        /* Shift */\n        | 18\n        /* DownArrow */\n        ,\n        linux: {\n          primary: 2048\n          /* CtrlCmd */\n          | 512\n          /* Alt */\n          | 1024\n          /* Shift */\n          | 18\n          /* DownArrow */\n\n        },\n        weight: 100\n        /* EditorContrib */\n\n      },\n      menubarOpts: {\n        menuId: 22\n        /* MenubarSelectionMenu */\n        ,\n        group: '2_line',\n        title: nls.localize({\n          key: 'miCopyLinesDown',\n          comment: ['&& denotes a mnemonic']\n        }, \"Co&&py Line Down\"),\n        order: 2\n      }\n    }) || this;\n  }\n\n  return CopyLinesDownAction;\n}(AbstractCopyLinesAction); // move lines\n\n\nvar AbstractMoveLinesAction =\n/** @class */\nfunction (_super) {\n  __extends(AbstractMoveLinesAction, _super);\n\n  function AbstractMoveLinesAction(down, opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.down = down;\n    return _this;\n  }\n\n  AbstractMoveLinesAction.prototype.run = function (_accessor, editor) {\n    var commands = [];\n    var selections = editor.getSelections() || [];\n    var autoIndent = editor.getConfiguration().autoIndent;\n\n    for (var _i = 0, selections_2 = selections; _i < selections_2.length; _i++) {\n      var selection = selections_2[_i];\n      commands.push(new MoveLinesCommand(selection, this.down, autoIndent));\n    }\n\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, commands);\n    editor.pushUndoStop();\n  };\n\n  return AbstractMoveLinesAction;\n}(EditorAction);\n\nvar MoveLinesUpAction =\n/** @class */\nfunction (_super) {\n  __extends(MoveLinesUpAction, _super);\n\n  function MoveLinesUpAction() {\n    return _super.call(this, false, {\n      id: 'editor.action.moveLinesUpAction',\n      label: nls.localize('lines.moveUp', \"Move Line Up\"),\n      alias: 'Move Line Up',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 512\n        /* Alt */\n        | 16\n        /* UpArrow */\n        ,\n        linux: {\n          primary: 512\n          /* Alt */\n          | 16\n          /* UpArrow */\n\n        },\n        weight: 100\n        /* EditorContrib */\n\n      },\n      menubarOpts: {\n        menuId: 22\n        /* MenubarSelectionMenu */\n        ,\n        group: '2_line',\n        title: nls.localize({\n          key: 'miMoveLinesUp',\n          comment: ['&& denotes a mnemonic']\n        }, \"Mo&&ve Line Up\"),\n        order: 3\n      }\n    }) || this;\n  }\n\n  return MoveLinesUpAction;\n}(AbstractMoveLinesAction);\n\nvar MoveLinesDownAction =\n/** @class */\nfunction (_super) {\n  __extends(MoveLinesDownAction, _super);\n\n  function MoveLinesDownAction() {\n    return _super.call(this, true, {\n      id: 'editor.action.moveLinesDownAction',\n      label: nls.localize('lines.moveDown', \"Move Line Down\"),\n      alias: 'Move Line Down',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 512\n        /* Alt */\n        | 18\n        /* DownArrow */\n        ,\n        linux: {\n          primary: 512\n          /* Alt */\n          | 18\n          /* DownArrow */\n\n        },\n        weight: 100\n        /* EditorContrib */\n\n      },\n      menubarOpts: {\n        menuId: 22\n        /* MenubarSelectionMenu */\n        ,\n        group: '2_line',\n        title: nls.localize({\n          key: 'miMoveLinesDown',\n          comment: ['&& denotes a mnemonic']\n        }, \"Move &&Line Down\"),\n        order: 4\n      }\n    }) || this;\n  }\n\n  return MoveLinesDownAction;\n}(AbstractMoveLinesAction);\n\nvar AbstractSortLinesAction =\n/** @class */\nfunction (_super) {\n  __extends(AbstractSortLinesAction, _super);\n\n  function AbstractSortLinesAction(descending, opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.descending = descending;\n    return _this;\n  }\n\n  AbstractSortLinesAction.prototype.run = function (_accessor, editor) {\n    var selections = editor.getSelections() || [];\n\n    for (var _i = 0, selections_3 = selections; _i < selections_3.length; _i++) {\n      var selection = selections_3[_i];\n\n      if (!SortLinesCommand.canRun(editor.getModel(), selection, this.descending)) {\n        return;\n      }\n    }\n\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new SortLinesCommand(selections[i], this.descending);\n    }\n\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, commands);\n    editor.pushUndoStop();\n  };\n\n  return AbstractSortLinesAction;\n}(EditorAction);\n\nexport { AbstractSortLinesAction };\n\nvar SortLinesAscendingAction =\n/** @class */\nfunction (_super) {\n  __extends(SortLinesAscendingAction, _super);\n\n  function SortLinesAscendingAction() {\n    return _super.call(this, false, {\n      id: 'editor.action.sortLinesAscending',\n      label: nls.localize('lines.sortAscending', \"Sort Lines Ascending\"),\n      alias: 'Sort Lines Ascending',\n      precondition: EditorContextKeys.writable\n    }) || this;\n  }\n\n  return SortLinesAscendingAction;\n}(AbstractSortLinesAction);\n\nexport { SortLinesAscendingAction };\n\nvar SortLinesDescendingAction =\n/** @class */\nfunction (_super) {\n  __extends(SortLinesDescendingAction, _super);\n\n  function SortLinesDescendingAction() {\n    return _super.call(this, true, {\n      id: 'editor.action.sortLinesDescending',\n      label: nls.localize('lines.sortDescending', \"Sort Lines Descending\"),\n      alias: 'Sort Lines Descending',\n      precondition: EditorContextKeys.writable\n    }) || this;\n  }\n\n  return SortLinesDescendingAction;\n}(AbstractSortLinesAction);\n\nexport { SortLinesDescendingAction };\n\nvar TrimTrailingWhitespaceAction =\n/** @class */\nfunction (_super) {\n  __extends(TrimTrailingWhitespaceAction, _super);\n\n  function TrimTrailingWhitespaceAction() {\n    return _super.call(this, {\n      id: TrimTrailingWhitespaceAction.ID,\n      label: nls.localize('lines.trimTrailingWhitespace', \"Trim Trailing Whitespace\"),\n      alias: 'Trim Trailing Whitespace',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: KeyChord(2048\n        /* CtrlCmd */\n        | 41\n        /* KEY_K */\n        , 2048\n        /* CtrlCmd */\n        | 54\n        /* KEY_X */\n        ),\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  TrimTrailingWhitespaceAction.prototype.run = function (_accessor, editor, args) {\n    var cursors = [];\n\n    if (args.reason === 'auto-save') {\n      // See https://github.com/editorconfig/editorconfig-vscode/issues/47\n      // It is very convenient for the editor config extension to invoke this action.\n      // So, if we get a reason:'auto-save' passed in, let's preserve cursor positions.\n      cursors = (editor.getSelections() || []).map(function (s) {\n        return new Position(s.positionLineNumber, s.positionColumn);\n      });\n    }\n\n    var selection = editor.getSelection();\n\n    if (selection === null) {\n      return;\n    }\n\n    var command = new TrimTrailingWhitespaceCommand(selection, cursors);\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, [command]);\n    editor.pushUndoStop();\n  };\n\n  TrimTrailingWhitespaceAction.ID = 'editor.action.trimTrailingWhitespace';\n  return TrimTrailingWhitespaceAction;\n}(EditorAction);\n\nexport { TrimTrailingWhitespaceAction };\n\nvar DeleteLinesAction =\n/** @class */\nfunction (_super) {\n  __extends(DeleteLinesAction, _super);\n\n  function DeleteLinesAction() {\n    return _super.call(this, {\n      id: 'editor.action.deleteLines',\n      label: nls.localize('lines.delete', \"Delete Line\"),\n      alias: 'Delete Line',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.textInputFocus,\n        primary: 2048\n        /* CtrlCmd */\n        | 1024\n        /* Shift */\n        | 41\n        /* KEY_K */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  DeleteLinesAction.prototype.run = function (_accessor, editor) {\n    if (!editor.hasModel()) {\n      return;\n    }\n\n    var ops = this._getLinesToRemove(editor);\n\n    var model = editor.getModel();\n\n    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n      // Model is empty\n      return;\n    }\n\n    var linesDeleted = 0;\n    var edits = [];\n    var cursorState = [];\n\n    for (var i = 0, len = ops.length; i < len; i++) {\n      var op = ops[i];\n      var startLineNumber = op.startLineNumber;\n      var endLineNumber = op.endLineNumber;\n      var startColumn = 1;\n      var endColumn = model.getLineMaxColumn(endLineNumber);\n\n      if (endLineNumber < model.getLineCount()) {\n        endLineNumber += 1;\n        endColumn = 1;\n      } else if (startLineNumber > 1) {\n        startLineNumber -= 1;\n        startColumn = model.getLineMaxColumn(startLineNumber);\n      }\n\n      edits.push(EditOperation.replace(new Selection(startLineNumber, startColumn, endLineNumber, endColumn), ''));\n      cursorState.push(new Selection(startLineNumber - linesDeleted, op.positionColumn, startLineNumber - linesDeleted, op.positionColumn));\n      linesDeleted += op.endLineNumber - op.startLineNumber + 1;\n    }\n\n    editor.pushUndoStop();\n    editor.executeEdits(this.id, edits, cursorState);\n    editor.pushUndoStop();\n  };\n\n  DeleteLinesAction.prototype._getLinesToRemove = function (editor) {\n    // Construct delete operations\n    var operations = editor.getSelections().map(function (s) {\n      var endLineNumber = s.endLineNumber;\n\n      if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n        endLineNumber -= 1;\n      }\n\n      return {\n        startLineNumber: s.startLineNumber,\n        selectionStartColumn: s.selectionStartColumn,\n        endLineNumber: endLineNumber,\n        positionColumn: s.positionColumn\n      };\n    }); // Sort delete operations\n\n    operations.sort(function (a, b) {\n      if (a.startLineNumber === b.startLineNumber) {\n        return a.endLineNumber - b.endLineNumber;\n      }\n\n      return a.startLineNumber - b.startLineNumber;\n    }); // Merge delete operations which are adjacent or overlapping\n\n    var mergedOperations = [];\n    var previousOperation = operations[0];\n\n    for (var i = 1; i < operations.length; i++) {\n      if (previousOperation.endLineNumber + 1 >= operations[i].startLineNumber) {\n        // Merge current operations into the previous one\n        previousOperation.endLineNumber = operations[i].endLineNumber;\n      } else {\n        // Push previous operation\n        mergedOperations.push(previousOperation);\n        previousOperation = operations[i];\n      }\n    } // Push the last operation\n\n\n    mergedOperations.push(previousOperation);\n    return mergedOperations;\n  };\n\n  return DeleteLinesAction;\n}(EditorAction);\n\nexport { DeleteLinesAction };\n\nvar IndentLinesAction =\n/** @class */\nfunction (_super) {\n  __extends(IndentLinesAction, _super);\n\n  function IndentLinesAction() {\n    return _super.call(this, {\n      id: 'editor.action.indentLines',\n      label: nls.localize('lines.indent', \"Indent Line\"),\n      alias: 'Indent Line',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 2048\n        /* CtrlCmd */\n        | 89\n        /* US_CLOSE_SQUARE_BRACKET */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  IndentLinesAction.prototype.run = function (_accessor, editor) {\n    var cursors = editor._getCursors();\n\n    if (!cursors) {\n      return;\n    }\n\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, TypeOperations.indent(cursors.context.config, editor.getModel(), editor.getSelections()));\n    editor.pushUndoStop();\n  };\n\n  return IndentLinesAction;\n}(EditorAction);\n\nexport { IndentLinesAction };\n\nvar OutdentLinesAction =\n/** @class */\nfunction (_super) {\n  __extends(OutdentLinesAction, _super);\n\n  function OutdentLinesAction() {\n    return _super.call(this, {\n      id: 'editor.action.outdentLines',\n      label: nls.localize('lines.outdent', \"Outdent Line\"),\n      alias: 'Outdent Line',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 2048\n        /* CtrlCmd */\n        | 87\n        /* US_OPEN_SQUARE_BRACKET */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  OutdentLinesAction.prototype.run = function (_accessor, editor) {\n    CoreEditingCommands.Outdent.runEditorCommand(_accessor, editor, null);\n  };\n\n  return OutdentLinesAction;\n}(EditorAction);\n\nvar InsertLineBeforeAction =\n/** @class */\nfunction (_super) {\n  __extends(InsertLineBeforeAction, _super);\n\n  function InsertLineBeforeAction() {\n    return _super.call(this, {\n      id: 'editor.action.insertLineBefore',\n      label: nls.localize('lines.insertBefore', \"Insert Line Above\"),\n      alias: 'Insert Line Above',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 2048\n        /* CtrlCmd */\n        | 1024\n        /* Shift */\n        | 3\n        /* Enter */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  InsertLineBeforeAction.prototype.run = function (_accessor, editor) {\n    var cursors = editor._getCursors();\n\n    if (!cursors) {\n      return;\n    }\n\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, TypeOperations.lineInsertBefore(cursors.context.config, editor.getModel(), editor.getSelections()));\n  };\n\n  return InsertLineBeforeAction;\n}(EditorAction);\n\nexport { InsertLineBeforeAction };\n\nvar InsertLineAfterAction =\n/** @class */\nfunction (_super) {\n  __extends(InsertLineAfterAction, _super);\n\n  function InsertLineAfterAction() {\n    return _super.call(this, {\n      id: 'editor.action.insertLineAfter',\n      label: nls.localize('lines.insertAfter', \"Insert Line Below\"),\n      alias: 'Insert Line Below',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 2048\n        /* CtrlCmd */\n        | 3\n        /* Enter */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  InsertLineAfterAction.prototype.run = function (_accessor, editor) {\n    var cursors = editor._getCursors();\n\n    if (!cursors) {\n      return;\n    }\n\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, TypeOperations.lineInsertAfter(cursors.context.config, editor.getModel(), editor.getSelections()));\n  };\n\n  return InsertLineAfterAction;\n}(EditorAction);\n\nexport { InsertLineAfterAction };\n\nvar AbstractDeleteAllToBoundaryAction =\n/** @class */\nfunction (_super) {\n  __extends(AbstractDeleteAllToBoundaryAction, _super);\n\n  function AbstractDeleteAllToBoundaryAction() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AbstractDeleteAllToBoundaryAction.prototype.run = function (_accessor, editor) {\n    if (!editor.hasModel()) {\n      return;\n    }\n\n    var primaryCursor = editor.getSelection();\n\n    var rangesToDelete = this._getRangesToDelete(editor); // merge overlapping selections\n\n\n    var effectiveRanges = [];\n\n    for (var i = 0, count = rangesToDelete.length - 1; i < count; i++) {\n      var range = rangesToDelete[i];\n      var nextRange = rangesToDelete[i + 1];\n\n      if (Range.intersectRanges(range, nextRange) === null) {\n        effectiveRanges.push(range);\n      } else {\n        rangesToDelete[i + 1] = Range.plusRange(range, nextRange);\n      }\n    }\n\n    effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);\n\n    var endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);\n\n    var edits = effectiveRanges.map(function (range) {\n      return EditOperation.replace(range, '');\n    });\n    editor.pushUndoStop();\n    editor.executeEdits(this.id, edits, endCursorState);\n    editor.pushUndoStop();\n  };\n\n  return AbstractDeleteAllToBoundaryAction;\n}(EditorAction);\n\nexport { AbstractDeleteAllToBoundaryAction };\n\nvar DeleteAllLeftAction =\n/** @class */\nfunction (_super) {\n  __extends(DeleteAllLeftAction, _super);\n\n  function DeleteAllLeftAction() {\n    return _super.call(this, {\n      id: 'deleteAllLeft',\n      label: nls.localize('lines.deleteAllLeft', \"Delete All Left\"),\n      alias: 'Delete All Left',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.textInputFocus,\n        primary: 0,\n        mac: {\n          primary: 2048\n          /* CtrlCmd */\n          | 1\n          /* Backspace */\n\n        },\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  DeleteAllLeftAction.prototype._getEndCursorState = function (primaryCursor, rangesToDelete) {\n    var endPrimaryCursor = null;\n    var endCursorState = [];\n    var deletedLines = 0;\n    rangesToDelete.forEach(function (range) {\n      var endCursor;\n\n      if (range.endColumn === 1 && deletedLines > 0) {\n        var newStartLine = range.startLineNumber - deletedLines;\n        endCursor = new Selection(newStartLine, range.startColumn, newStartLine, range.startColumn);\n      } else {\n        endCursor = new Selection(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n      }\n\n      deletedLines += range.endLineNumber - range.startLineNumber;\n\n      if (range.intersectRanges(primaryCursor)) {\n        endPrimaryCursor = endCursor;\n      } else {\n        endCursorState.push(endCursor);\n      }\n    });\n\n    if (endPrimaryCursor) {\n      endCursorState.unshift(endPrimaryCursor);\n    }\n\n    return endCursorState;\n  };\n\n  DeleteAllLeftAction.prototype._getRangesToDelete = function (editor) {\n    var selections = editor.getSelections();\n\n    if (selections === null) {\n      return [];\n    }\n\n    var rangesToDelete = selections;\n    var model = editor.getModel();\n\n    if (model === null) {\n      return [];\n    }\n\n    rangesToDelete.sort(Range.compareRangesUsingStarts);\n    rangesToDelete = rangesToDelete.map(function (selection) {\n      if (selection.isEmpty()) {\n        if (selection.startColumn === 1) {\n          var deleteFromLine = Math.max(1, selection.startLineNumber - 1);\n          var deleteFromColumn = selection.startLineNumber === 1 ? 1 : model.getLineContent(deleteFromLine).length + 1;\n          return new Range(deleteFromLine, deleteFromColumn, selection.startLineNumber, 1);\n        } else {\n          return new Range(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);\n        }\n      } else {\n        return new Range(selection.startLineNumber, 1, selection.endLineNumber, selection.endColumn);\n      }\n    });\n    return rangesToDelete;\n  };\n\n  return DeleteAllLeftAction;\n}(AbstractDeleteAllToBoundaryAction);\n\nexport { DeleteAllLeftAction };\n\nvar DeleteAllRightAction =\n/** @class */\nfunction (_super) {\n  __extends(DeleteAllRightAction, _super);\n\n  function DeleteAllRightAction() {\n    return _super.call(this, {\n      id: 'deleteAllRight',\n      label: nls.localize('lines.deleteAllRight', \"Delete All Right\"),\n      alias: 'Delete All Right',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.textInputFocus,\n        primary: 0,\n        mac: {\n          primary: 256\n          /* WinCtrl */\n          | 41\n          /* KEY_K */\n          ,\n          secondary: [2048\n          /* CtrlCmd */\n          | 20\n          /* Delete */\n          ]\n        },\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  DeleteAllRightAction.prototype._getEndCursorState = function (primaryCursor, rangesToDelete) {\n    var endPrimaryCursor = null;\n    var endCursorState = [];\n\n    for (var i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {\n      var range = rangesToDelete[i];\n      var endCursor = new Selection(range.startLineNumber - offset, range.startColumn, range.startLineNumber - offset, range.startColumn);\n\n      if (range.intersectRanges(primaryCursor)) {\n        endPrimaryCursor = endCursor;\n      } else {\n        endCursorState.push(endCursor);\n      }\n    }\n\n    if (endPrimaryCursor) {\n      endCursorState.unshift(endPrimaryCursor);\n    }\n\n    return endCursorState;\n  };\n\n  DeleteAllRightAction.prototype._getRangesToDelete = function (editor) {\n    var model = editor.getModel();\n\n    if (model === null) {\n      return [];\n    }\n\n    var selections = editor.getSelections();\n\n    if (selections === null) {\n      return [];\n    }\n\n    var rangesToDelete = selections.map(function (sel) {\n      if (sel.isEmpty()) {\n        var maxColumn = model.getLineMaxColumn(sel.startLineNumber);\n\n        if (sel.startColumn === maxColumn) {\n          return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);\n        } else {\n          return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);\n        }\n      }\n\n      return sel;\n    });\n    rangesToDelete.sort(Range.compareRangesUsingStarts);\n    return rangesToDelete;\n  };\n\n  return DeleteAllRightAction;\n}(AbstractDeleteAllToBoundaryAction);\n\nexport { DeleteAllRightAction };\n\nvar JoinLinesAction =\n/** @class */\nfunction (_super) {\n  __extends(JoinLinesAction, _super);\n\n  function JoinLinesAction() {\n    return _super.call(this, {\n      id: 'editor.action.joinLines',\n      label: nls.localize('lines.joinLines', \"Join Lines\"),\n      alias: 'Join Lines',\n      precondition: EditorContextKeys.writable,\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 0,\n        mac: {\n          primary: 256\n          /* WinCtrl */\n          | 40\n          /* KEY_J */\n\n        },\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  JoinLinesAction.prototype.run = function (_accessor, editor) {\n    var selections = editor.getSelections();\n\n    if (selections === null) {\n      return;\n    }\n\n    var primaryCursor = editor.getSelection();\n\n    if (primaryCursor === null) {\n      return;\n    }\n\n    selections.sort(Range.compareRangesUsingStarts);\n    var reducedSelections = [];\n    var lastSelection = selections.reduce(function (previousValue, currentValue) {\n      if (previousValue.isEmpty()) {\n        if (previousValue.endLineNumber === currentValue.startLineNumber) {\n          if (primaryCursor.equalsSelection(previousValue)) {\n            primaryCursor = currentValue;\n          }\n\n          return currentValue;\n        }\n\n        if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {\n          reducedSelections.push(previousValue);\n          return currentValue;\n        } else {\n          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);\n        }\n      } else {\n        if (currentValue.startLineNumber > previousValue.endLineNumber) {\n          reducedSelections.push(previousValue);\n          return currentValue;\n        } else {\n          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);\n        }\n      }\n    });\n    reducedSelections.push(lastSelection);\n    var model = editor.getModel();\n\n    if (model === null) {\n      return;\n    }\n\n    var edits = [];\n    var endCursorState = [];\n    var endPrimaryCursor = primaryCursor;\n    var lineOffset = 0;\n\n    for (var i = 0, len = reducedSelections.length; i < len; i++) {\n      var selection = reducedSelections[i];\n      var startLineNumber = selection.startLineNumber;\n      var startColumn = 1;\n      var columnDeltaOffset = 0;\n      var endLineNumber = void 0,\n          endColumn = void 0;\n      var selectionEndPositionOffset = model.getLineContent(selection.endLineNumber).length - selection.endColumn;\n\n      if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {\n        var position = selection.getStartPosition();\n\n        if (position.lineNumber < model.getLineCount()) {\n          endLineNumber = startLineNumber + 1;\n          endColumn = model.getLineMaxColumn(endLineNumber);\n        } else {\n          endLineNumber = position.lineNumber;\n          endColumn = model.getLineMaxColumn(position.lineNumber);\n        }\n      } else {\n        endLineNumber = selection.endLineNumber;\n        endColumn = model.getLineMaxColumn(endLineNumber);\n      }\n\n      var trimmedLinesContent = model.getLineContent(startLineNumber);\n\n      for (var i_1 = startLineNumber + 1; i_1 <= endLineNumber; i_1++) {\n        var lineText = model.getLineContent(i_1);\n        var firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i_1);\n\n        if (firstNonWhitespaceIdx >= 1) {\n          var insertSpace = true;\n\n          if (trimmedLinesContent === '') {\n            insertSpace = false;\n          }\n\n          if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === ' ' || trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === '\\t')) {\n            insertSpace = false;\n            trimmedLinesContent = trimmedLinesContent.replace(/[\\s\\uFEFF\\xA0]+$/g, ' ');\n          }\n\n          var lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);\n          trimmedLinesContent += (insertSpace ? ' ' : '') + lineTextWithoutIndent;\n\n          if (insertSpace) {\n            columnDeltaOffset = lineTextWithoutIndent.length + 1;\n          } else {\n            columnDeltaOffset = lineTextWithoutIndent.length;\n          }\n        } else {\n          columnDeltaOffset = 0;\n        }\n      }\n\n      var deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\n      if (!deleteSelection.isEmpty()) {\n        var resultSelection = void 0;\n\n        if (selection.isEmpty()) {\n          edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));\n          resultSelection = new Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);\n        } else {\n          if (selection.startLineNumber === selection.endLineNumber) {\n            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));\n            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);\n          } else {\n            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));\n            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);\n          }\n        }\n\n        if (Range.intersectRanges(deleteSelection, primaryCursor) !== null) {\n          endPrimaryCursor = resultSelection;\n        } else {\n          endCursorState.push(resultSelection);\n        }\n      }\n\n      lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;\n    }\n\n    endCursorState.unshift(endPrimaryCursor);\n    editor.pushUndoStop();\n    editor.executeEdits(this.id, edits, endCursorState);\n    editor.pushUndoStop();\n  };\n\n  return JoinLinesAction;\n}(EditorAction);\n\nexport { JoinLinesAction };\n\nvar TransposeAction =\n/** @class */\nfunction (_super) {\n  __extends(TransposeAction, _super);\n\n  function TransposeAction() {\n    return _super.call(this, {\n      id: 'editor.action.transpose',\n      label: nls.localize('editor.transpose', \"Transpose characters around the cursor\"),\n      alias: 'Transpose characters around the cursor',\n      precondition: EditorContextKeys.writable\n    }) || this;\n  }\n\n  TransposeAction.prototype.run = function (_accessor, editor) {\n    var selections = editor.getSelections();\n\n    if (selections === null) {\n      return;\n    }\n\n    var model = editor.getModel();\n\n    if (model === null) {\n      return;\n    }\n\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n\n      if (!selection.isEmpty()) {\n        continue;\n      }\n\n      var cursor = selection.getStartPosition();\n      var maxColumn = model.getLineMaxColumn(cursor.lineNumber);\n\n      if (cursor.column >= maxColumn) {\n        if (cursor.lineNumber === model.getLineCount()) {\n          continue;\n        } // The cursor is at the end of current line and current line is not empty\n        // then we transpose the character before the cursor and the line break if there is any following line.\n\n\n        var deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);\n        var chars = model.getValueInRange(deleteSelection).split('').reverse().join('');\n        commands.push(new ReplaceCommand(new Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));\n      } else {\n        var deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);\n        var chars = model.getValueInRange(deleteSelection).split('').reverse().join('');\n        commands.push(new ReplaceCommandThatPreservesSelection(deleteSelection, chars, new Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));\n      }\n    }\n\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, commands);\n    editor.pushUndoStop();\n  };\n\n  return TransposeAction;\n}(EditorAction);\n\nexport { TransposeAction };\n\nvar AbstractCaseAction =\n/** @class */\nfunction (_super) {\n  __extends(AbstractCaseAction, _super);\n\n  function AbstractCaseAction() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AbstractCaseAction.prototype.run = function (_accessor, editor) {\n    var selections = editor.getSelections();\n\n    if (selections === null) {\n      return;\n    }\n\n    var model = editor.getModel();\n\n    if (model === null) {\n      return;\n    }\n\n    var wordSeparators = editor.getConfiguration().wordSeparators;\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n\n      if (selection.isEmpty()) {\n        var cursor = selection.getStartPosition();\n        var word = model.getWordAtPosition(cursor);\n\n        if (!word) {\n          continue;\n        }\n\n        var wordRange = new Range(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);\n        var text = model.getValueInRange(wordRange);\n        commands.push(new ReplaceCommandThatPreservesSelection(wordRange, this._modifyText(text, wordSeparators), new Selection(cursor.lineNumber, cursor.column, cursor.lineNumber, cursor.column)));\n      } else {\n        var text = model.getValueInRange(selection);\n        commands.push(new ReplaceCommandThatPreservesSelection(selection, this._modifyText(text, wordSeparators), selection));\n      }\n    }\n\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, commands);\n    editor.pushUndoStop();\n  };\n\n  return AbstractCaseAction;\n}(EditorAction);\n\nexport { AbstractCaseAction };\n\nvar UpperCaseAction =\n/** @class */\nfunction (_super) {\n  __extends(UpperCaseAction, _super);\n\n  function UpperCaseAction() {\n    return _super.call(this, {\n      id: 'editor.action.transformToUppercase',\n      label: nls.localize('editor.transformToUppercase', \"Transform to Uppercase\"),\n      alias: 'Transform to Uppercase',\n      precondition: EditorContextKeys.writable\n    }) || this;\n  }\n\n  UpperCaseAction.prototype._modifyText = function (text, wordSeparators) {\n    return text.toLocaleUpperCase();\n  };\n\n  return UpperCaseAction;\n}(AbstractCaseAction);\n\nexport { UpperCaseAction };\n\nvar LowerCaseAction =\n/** @class */\nfunction (_super) {\n  __extends(LowerCaseAction, _super);\n\n  function LowerCaseAction() {\n    return _super.call(this, {\n      id: 'editor.action.transformToLowercase',\n      label: nls.localize('editor.transformToLowercase', \"Transform to Lowercase\"),\n      alias: 'Transform to Lowercase',\n      precondition: EditorContextKeys.writable\n    }) || this;\n  }\n\n  LowerCaseAction.prototype._modifyText = function (text, wordSeparators) {\n    return text.toLocaleLowerCase();\n  };\n\n  return LowerCaseAction;\n}(AbstractCaseAction);\n\nexport { LowerCaseAction };\n\nvar TitleCaseAction =\n/** @class */\nfunction (_super) {\n  __extends(TitleCaseAction, _super);\n\n  function TitleCaseAction() {\n    return _super.call(this, {\n      id: 'editor.action.transformToTitlecase',\n      label: nls.localize('editor.transformToTitlecase', \"Transform to Title Case\"),\n      alias: 'Transform to Title Case',\n      precondition: EditorContextKeys.writable\n    }) || this;\n  }\n\n  TitleCaseAction.prototype._modifyText = function (text, wordSeparators) {\n    var separators = '\\r\\n\\t ' + wordSeparators;\n    var excludedChars = separators.split('');\n    var title = '';\n    var startUpperCase = true;\n\n    for (var i = 0; i < text.length; i++) {\n      var currentChar = text[i];\n\n      if (excludedChars.indexOf(currentChar) >= 0) {\n        startUpperCase = true;\n        title += currentChar;\n      } else if (startUpperCase) {\n        startUpperCase = false;\n        title += currentChar.toLocaleUpperCase();\n      } else {\n        title += currentChar.toLocaleLowerCase();\n      }\n    }\n\n    return title;\n  };\n\n  return TitleCaseAction;\n}(AbstractCaseAction);\n\nexport { TitleCaseAction };\nregisterEditorAction(CopyLinesUpAction);\nregisterEditorAction(CopyLinesDownAction);\nregisterEditorAction(MoveLinesUpAction);\nregisterEditorAction(MoveLinesDownAction);\nregisterEditorAction(SortLinesAscendingAction);\nregisterEditorAction(SortLinesDescendingAction);\nregisterEditorAction(TrimTrailingWhitespaceAction);\nregisterEditorAction(DeleteLinesAction);\nregisterEditorAction(IndentLinesAction);\nregisterEditorAction(OutdentLinesAction);\nregisterEditorAction(InsertLineBeforeAction);\nregisterEditorAction(InsertLineAfterAction);\nregisterEditorAction(DeleteAllLeftAction);\nregisterEditorAction(DeleteAllRightAction);\nregisterEditorAction(JoinLinesAction);\nregisterEditorAction(TransposeAction);\nregisterEditorAction(UpperCaseAction);\nregisterEditorAction(LowerCaseAction);\nregisterEditorAction(TitleCaseAction);","map":null,"metadata":{},"sourceType":"module"}