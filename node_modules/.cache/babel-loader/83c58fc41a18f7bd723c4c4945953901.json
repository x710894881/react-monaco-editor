{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport './selections.css';\nimport * as browser from '../../../../base/browser/browser.js';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nimport { editorInactiveSelection, editorSelectionBackground, editorSelectionForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\n\nvar HorizontalRangeWithStyle =\n/** @class */\nfunction () {\n  function HorizontalRangeWithStyle(other) {\n    this.left = other.left;\n    this.width = other.width;\n    this.startStyle = null;\n    this.endStyle = null;\n  }\n\n  return HorizontalRangeWithStyle;\n}();\n\nvar LineVisibleRangesWithStyle =\n/** @class */\nfunction () {\n  function LineVisibleRangesWithStyle(lineNumber, ranges) {\n    this.lineNumber = lineNumber;\n    this.ranges = ranges;\n  }\n\n  return LineVisibleRangesWithStyle;\n}();\n\nfunction toStyledRange(item) {\n  return new HorizontalRangeWithStyle(item);\n}\n\nfunction toStyled(item) {\n  return new LineVisibleRangesWithStyle(item.lineNumber, item.ranges.map(toStyledRange));\n} // TODO@Alex: Remove this once IE11 fixes Bug #524217\n// The problem in IE11 is that it does some sort of auto-zooming to accomodate for displays with different pixel density.\n// Unfortunately, this auto-zooming is buggy around dealing with rounded borders\n\n\nvar isIEWithZoomingIssuesNearRoundedBorders = browser.isEdgeOrIE;\n\nvar SelectionsOverlay =\n/** @class */\nfunction (_super) {\n  __extends(SelectionsOverlay, _super);\n\n  function SelectionsOverlay(context) {\n    var _this = _super.call(this) || this;\n\n    _this._previousFrameVisibleRangesWithStyle = [];\n    _this._context = context;\n    _this._lineHeight = _this._context.configuration.editor.lineHeight;\n    _this._roundedSelection = _this._context.configuration.editor.viewInfo.roundedSelection;\n    _this._typicalHalfwidthCharacterWidth = _this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;\n    _this._selections = [];\n    _this._renderResult = null;\n\n    _this._context.addEventHandler(_this);\n\n    return _this;\n  }\n\n  SelectionsOverlay.prototype.dispose = function () {\n    this._context.removeEventHandler(this);\n\n    this._renderResult = null;\n\n    _super.prototype.dispose.call(this);\n  }; // --- begin event handlers\n\n\n  SelectionsOverlay.prototype.onConfigurationChanged = function (e) {\n    if (e.lineHeight) {\n      this._lineHeight = this._context.configuration.editor.lineHeight;\n    }\n\n    if (e.viewInfo) {\n      this._roundedSelection = this._context.configuration.editor.viewInfo.roundedSelection;\n    }\n\n    if (e.fontInfo) {\n      this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;\n    }\n\n    return true;\n  };\n\n  SelectionsOverlay.prototype.onCursorStateChanged = function (e) {\n    this._selections = e.selections.slice(0);\n    return true;\n  };\n\n  SelectionsOverlay.prototype.onDecorationsChanged = function (e) {\n    // true for inline decorations that can end up relayouting text\n    return true; //e.inlineDecorationsChanged;\n  };\n\n  SelectionsOverlay.prototype.onFlushed = function (e) {\n    return true;\n  };\n\n  SelectionsOverlay.prototype.onLinesChanged = function (e) {\n    return true;\n  };\n\n  SelectionsOverlay.prototype.onLinesDeleted = function (e) {\n    return true;\n  };\n\n  SelectionsOverlay.prototype.onLinesInserted = function (e) {\n    return true;\n  };\n\n  SelectionsOverlay.prototype.onScrollChanged = function (e) {\n    return e.scrollTopChanged;\n  };\n\n  SelectionsOverlay.prototype.onZonesChanged = function (e) {\n    return true;\n  }; // --- end event handlers\n\n\n  SelectionsOverlay.prototype._visibleRangesHaveGaps = function (linesVisibleRanges) {\n    for (var i = 0, len = linesVisibleRanges.length; i < len; i++) {\n      var lineVisibleRanges = linesVisibleRanges[i];\n\n      if (lineVisibleRanges.ranges.length > 1) {\n        // There are two ranges on the same line\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  SelectionsOverlay.prototype._enrichVisibleRangesWithStyle = function (viewport, linesVisibleRanges, previousFrame) {\n    var epsilon = this._typicalHalfwidthCharacterWidth / 4;\n    var previousFrameTop = null;\n    var previousFrameBottom = null;\n\n    if (previousFrame && previousFrame.length > 0 && linesVisibleRanges.length > 0) {\n      var topLineNumber = linesVisibleRanges[0].lineNumber;\n\n      if (topLineNumber === viewport.startLineNumber) {\n        for (var i = 0; !previousFrameTop && i < previousFrame.length; i++) {\n          if (previousFrame[i].lineNumber === topLineNumber) {\n            previousFrameTop = previousFrame[i].ranges[0];\n          }\n        }\n      }\n\n      var bottomLineNumber = linesVisibleRanges[linesVisibleRanges.length - 1].lineNumber;\n\n      if (bottomLineNumber === viewport.endLineNumber) {\n        for (var i = previousFrame.length - 1; !previousFrameBottom && i >= 0; i--) {\n          if (previousFrame[i].lineNumber === bottomLineNumber) {\n            previousFrameBottom = previousFrame[i].ranges[0];\n          }\n        }\n      }\n\n      if (previousFrameTop && !previousFrameTop.startStyle) {\n        previousFrameTop = null;\n      }\n\n      if (previousFrameBottom && !previousFrameBottom.startStyle) {\n        previousFrameBottom = null;\n      }\n    }\n\n    for (var i = 0, len = linesVisibleRanges.length; i < len; i++) {\n      // We know for a fact that there is precisely one range on each line\n      var curLineRange = linesVisibleRanges[i].ranges[0];\n      var curLeft = curLineRange.left;\n      var curRight = curLineRange.left + curLineRange.width;\n      var startStyle = {\n        top: 0\n        /* EXTERN */\n        ,\n        bottom: 0\n        /* EXTERN */\n\n      };\n      var endStyle = {\n        top: 0\n        /* EXTERN */\n        ,\n        bottom: 0\n        /* EXTERN */\n\n      };\n\n      if (i > 0) {\n        // Look above\n        var prevLeft = linesVisibleRanges[i - 1].ranges[0].left;\n        var prevRight = linesVisibleRanges[i - 1].ranges[0].left + linesVisibleRanges[i - 1].ranges[0].width;\n\n        if (abs(curLeft - prevLeft) < epsilon) {\n          startStyle.top = 2\n          /* FLAT */\n          ;\n        } else if (curLeft > prevLeft) {\n          startStyle.top = 1\n          /* INTERN */\n          ;\n        }\n\n        if (abs(curRight - prevRight) < epsilon) {\n          endStyle.top = 2\n          /* FLAT */\n          ;\n        } else if (prevLeft < curRight && curRight < prevRight) {\n          endStyle.top = 1\n          /* INTERN */\n          ;\n        }\n      } else if (previousFrameTop) {\n        // Accept some hick-ups near the viewport edges to save on repaints\n        startStyle.top = previousFrameTop.startStyle.top;\n        endStyle.top = previousFrameTop.endStyle.top;\n      }\n\n      if (i + 1 < len) {\n        // Look below\n        var nextLeft = linesVisibleRanges[i + 1].ranges[0].left;\n        var nextRight = linesVisibleRanges[i + 1].ranges[0].left + linesVisibleRanges[i + 1].ranges[0].width;\n\n        if (abs(curLeft - nextLeft) < epsilon) {\n          startStyle.bottom = 2\n          /* FLAT */\n          ;\n        } else if (nextLeft < curLeft && curLeft < nextRight) {\n          startStyle.bottom = 1\n          /* INTERN */\n          ;\n        }\n\n        if (abs(curRight - nextRight) < epsilon) {\n          endStyle.bottom = 2\n          /* FLAT */\n          ;\n        } else if (curRight < nextRight) {\n          endStyle.bottom = 1\n          /* INTERN */\n          ;\n        }\n      } else if (previousFrameBottom) {\n        // Accept some hick-ups near the viewport edges to save on repaints\n        startStyle.bottom = previousFrameBottom.startStyle.bottom;\n        endStyle.bottom = previousFrameBottom.endStyle.bottom;\n      }\n\n      curLineRange.startStyle = startStyle;\n      curLineRange.endStyle = endStyle;\n    }\n  };\n\n  SelectionsOverlay.prototype._getVisibleRangesWithStyle = function (selection, ctx, previousFrame) {\n    var _linesVisibleRanges = ctx.linesVisibleRangesForRange(selection, true) || [];\n\n    var linesVisibleRanges = _linesVisibleRanges.map(toStyled);\n\n    var visibleRangesHaveGaps = this._visibleRangesHaveGaps(linesVisibleRanges);\n\n    if (!isIEWithZoomingIssuesNearRoundedBorders && !visibleRangesHaveGaps && this._roundedSelection) {\n      this._enrichVisibleRangesWithStyle(ctx.visibleRange, linesVisibleRanges, previousFrame);\n    } // The visible ranges are sorted TOP-BOTTOM and LEFT-RIGHT\n\n\n    return linesVisibleRanges;\n  };\n\n  SelectionsOverlay.prototype._createSelectionPiece = function (top, height, className, left, width) {\n    return '<div class=\"cslr ' + className + '\" style=\"top:' + top.toString() + 'px;left:' + left.toString() + 'px;width:' + width.toString() + 'px;height:' + height + 'px;\"></div>';\n  };\n\n  SelectionsOverlay.prototype._actualRenderOneSelection = function (output2, visibleStartLineNumber, hasMultipleSelections, visibleRanges) {\n    var visibleRangesHaveStyle = visibleRanges.length > 0 && visibleRanges[0].ranges[0].startStyle;\n\n    var fullLineHeight = this._lineHeight.toString();\n\n    var reducedLineHeight = (this._lineHeight - 1).toString();\n    var firstLineNumber = visibleRanges.length > 0 ? visibleRanges[0].lineNumber : 0;\n    var lastLineNumber = visibleRanges.length > 0 ? visibleRanges[visibleRanges.length - 1].lineNumber : 0;\n\n    for (var i = 0, len = visibleRanges.length; i < len; i++) {\n      var lineVisibleRanges = visibleRanges[i];\n      var lineNumber = lineVisibleRanges.lineNumber;\n      var lineIndex = lineNumber - visibleStartLineNumber;\n      var lineHeight = hasMultipleSelections ? lineNumber === lastLineNumber || lineNumber === firstLineNumber ? reducedLineHeight : fullLineHeight : fullLineHeight;\n      var top_1 = hasMultipleSelections ? lineNumber === firstLineNumber ? 1 : 0 : 0;\n      var lineOutput = '';\n\n      for (var j = 0, lenJ = lineVisibleRanges.ranges.length; j < lenJ; j++) {\n        var visibleRange = lineVisibleRanges.ranges[j];\n\n        if (visibleRangesHaveStyle) {\n          var startStyle = visibleRange.startStyle;\n          var endStyle = visibleRange.endStyle;\n\n          if (startStyle.top === 1\n          /* INTERN */\n          || startStyle.bottom === 1\n          /* INTERN */\n          ) {\n              // Reverse rounded corner to the left\n              // First comes the selection (blue layer)\n              lineOutput += this._createSelectionPiece(top_1, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH); // Second comes the background (white layer) with inverse border radius\n\n              var className_1 = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;\n\n              if (startStyle.top === 1\n              /* INTERN */\n              ) {\n                  className_1 += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;\n                }\n\n              if (startStyle.bottom === 1\n              /* INTERN */\n              ) {\n                  className_1 += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;\n                }\n\n              lineOutput += this._createSelectionPiece(top_1, lineHeight, className_1, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n            }\n\n          if (endStyle.top === 1\n          /* INTERN */\n          || endStyle.bottom === 1\n          /* INTERN */\n          ) {\n              // Reverse rounded corner to the right\n              // First comes the selection (blue layer)\n              lineOutput += this._createSelectionPiece(top_1, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH); // Second comes the background (white layer) with inverse border radius\n\n              var className_2 = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;\n\n              if (endStyle.top === 1\n              /* INTERN */\n              ) {\n                  className_2 += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;\n                }\n\n              if (endStyle.bottom === 1\n              /* INTERN */\n              ) {\n                  className_2 += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;\n                }\n\n              lineOutput += this._createSelectionPiece(top_1, lineHeight, className_2, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);\n            }\n        }\n\n        var className = SelectionsOverlay.SELECTION_CLASS_NAME;\n\n        if (visibleRangesHaveStyle) {\n          var startStyle = visibleRange.startStyle;\n          var endStyle = visibleRange.endStyle;\n\n          if (startStyle.top === 0\n          /* EXTERN */\n          ) {\n              className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;\n            }\n\n          if (startStyle.bottom === 0\n          /* EXTERN */\n          ) {\n              className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;\n            }\n\n          if (endStyle.top === 0\n          /* EXTERN */\n          ) {\n              className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;\n            }\n\n          if (endStyle.bottom === 0\n          /* EXTERN */\n          ) {\n              className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;\n            }\n        }\n\n        lineOutput += this._createSelectionPiece(top_1, lineHeight, className, visibleRange.left, visibleRange.width);\n      }\n\n      output2[lineIndex] += lineOutput;\n    }\n  };\n\n  SelectionsOverlay.prototype.prepareRender = function (ctx) {\n    var output = [];\n    var visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n    var visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n\n    for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n      var lineIndex = lineNumber - visibleStartLineNumber;\n      output[lineIndex] = '';\n    }\n\n    var thisFrameVisibleRangesWithStyle = [];\n\n    for (var i = 0, len = this._selections.length; i < len; i++) {\n      var selection = this._selections[i];\n\n      if (selection.isEmpty()) {\n        thisFrameVisibleRangesWithStyle[i] = null;\n        continue;\n      }\n\n      var visibleRangesWithStyle = this._getVisibleRangesWithStyle(selection, ctx, this._previousFrameVisibleRangesWithStyle[i]);\n\n      thisFrameVisibleRangesWithStyle[i] = visibleRangesWithStyle;\n\n      this._actualRenderOneSelection(output, visibleStartLineNumber, this._selections.length > 1, visibleRangesWithStyle);\n    }\n\n    this._previousFrameVisibleRangesWithStyle = thisFrameVisibleRangesWithStyle;\n    this._renderResult = output;\n  };\n\n  SelectionsOverlay.prototype.render = function (startLineNumber, lineNumber) {\n    if (!this._renderResult) {\n      return '';\n    }\n\n    var lineIndex = lineNumber - startLineNumber;\n\n    if (lineIndex < 0 || lineIndex >= this._renderResult.length) {\n      return '';\n    }\n\n    return this._renderResult[lineIndex];\n  };\n\n  SelectionsOverlay.SELECTION_CLASS_NAME = 'selected-text';\n  SelectionsOverlay.SELECTION_TOP_LEFT = 'top-left-radius';\n  SelectionsOverlay.SELECTION_BOTTOM_LEFT = 'bottom-left-radius';\n  SelectionsOverlay.SELECTION_TOP_RIGHT = 'top-right-radius';\n  SelectionsOverlay.SELECTION_BOTTOM_RIGHT = 'bottom-right-radius';\n  SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME = 'monaco-editor-background';\n  SelectionsOverlay.ROUNDED_PIECE_WIDTH = 10;\n  return SelectionsOverlay;\n}(DynamicViewOverlay);\n\nexport { SelectionsOverlay };\nregisterThemingParticipant(function (theme, collector) {\n  var editorSelectionColor = theme.getColor(editorSelectionBackground);\n\n  if (editorSelectionColor) {\n    collector.addRule(\".monaco-editor .focused .selected-text { background-color: \" + editorSelectionColor + \"; }\");\n  }\n\n  var editorInactiveSelectionColor = theme.getColor(editorInactiveSelection);\n\n  if (editorInactiveSelectionColor) {\n    collector.addRule(\".monaco-editor .selected-text { background-color: \" + editorInactiveSelectionColor + \"; }\");\n  }\n\n  var editorSelectionForegroundColor = theme.getColor(editorSelectionForeground);\n\n  if (editorSelectionForegroundColor) {\n    collector.addRule(\".monaco-editor .view-line span.inline-selected-text { color: \" + editorSelectionForegroundColor + \"; }\");\n  }\n});\n\nfunction abs(n) {\n  return n < 0 ? -n : n;\n}","map":null,"metadata":{},"sourceType":"module"}