{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { toUint32Array } from '../core/uint.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\nimport { OutputPosition } from './splitLinesCollection.js';\n\nvar WrappingCharacterClassifier =\n/** @class */\nfunction (_super) {\n  __extends(WrappingCharacterClassifier, _super);\n\n  function WrappingCharacterClassifier(BREAK_BEFORE, BREAK_AFTER, BREAK_OBTRUSIVE) {\n    var _this = _super.call(this, 0\n    /* NONE */\n    ) || this;\n\n    for (var i = 0; i < BREAK_BEFORE.length; i++) {\n      _this.set(BREAK_BEFORE.charCodeAt(i), 1\n      /* BREAK_BEFORE */\n      );\n    }\n\n    for (var i = 0; i < BREAK_AFTER.length; i++) {\n      _this.set(BREAK_AFTER.charCodeAt(i), 2\n      /* BREAK_AFTER */\n      );\n    }\n\n    for (var i = 0; i < BREAK_OBTRUSIVE.length; i++) {\n      _this.set(BREAK_OBTRUSIVE.charCodeAt(i), 3\n      /* BREAK_OBTRUSIVE */\n      );\n    }\n\n    return _this;\n  }\n\n  WrappingCharacterClassifier.prototype.get = function (charCode) {\n    // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n    // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n    // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n    // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n    if (charCode >= 0x3040 && charCode <= 0x30FF || charCode >= 0x3400 && charCode <= 0x4DBF || charCode >= 0x4E00 && charCode <= 0x9FFF) {\n      return 4\n      /* BREAK_IDEOGRAPHIC */\n      ;\n    }\n\n    return _super.prototype.get.call(this, charCode);\n  };\n\n  return WrappingCharacterClassifier;\n}(CharacterClassifier);\n\nvar CharacterHardWrappingLineMapperFactory =\n/** @class */\nfunction () {\n  function CharacterHardWrappingLineMapperFactory(breakBeforeChars, breakAfterChars, breakObtrusiveChars) {\n    this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars, breakObtrusiveChars);\n  } // TODO@Alex -> duplicated in lineCommentCommand\n\n\n  CharacterHardWrappingLineMapperFactory.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {\n    currentVisibleColumn = +currentVisibleColumn; //@perf\n\n    tabSize = +tabSize; //@perf\n\n    columnSize = +columnSize; //@perf\n\n    if (isTab) {\n      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);\n    }\n\n    return currentVisibleColumn + columnSize;\n  };\n\n  CharacterHardWrappingLineMapperFactory.prototype.createLineMapping = function (lineText, tabSize, breakingColumn, columnsForFullWidthChar, hardWrappingIndent) {\n    if (breakingColumn === -1) {\n      return null;\n    }\n\n    tabSize = +tabSize; //@perf\n\n    breakingColumn = +breakingColumn; //@perf\n\n    columnsForFullWidthChar = +columnsForFullWidthChar; //@perf\n\n    hardWrappingIndent = +hardWrappingIndent; //@perf\n\n    var wrappedTextIndentVisibleColumn = 0;\n    var wrappedTextIndent = '';\n    var firstNonWhitespaceIndex = -1;\n\n    if (hardWrappingIndent !== 0\n    /* None */\n    ) {\n        firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n\n        if (firstNonWhitespaceIndex !== -1) {\n          // Track existing indent\n          wrappedTextIndent = lineText.substring(0, firstNonWhitespaceIndex);\n\n          for (var i = 0; i < firstNonWhitespaceIndex; i++) {\n            wrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, lineText.charCodeAt(i) === 9\n            /* Tab */\n            , 1);\n          } // Increase indent of continuation lines, if desired\n\n\n          var numberOfAdditionalTabs = 0;\n\n          if (hardWrappingIndent === 2\n          /* Indent */\n          ) {\n              numberOfAdditionalTabs = 1;\n            } else if (hardWrappingIndent === 3\n          /* DeepIndent */\n          ) {\n              numberOfAdditionalTabs = 2;\n            }\n\n          for (var i = 0; i < numberOfAdditionalTabs; i++) {\n            wrappedTextIndent += '\\t';\n            wrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, true, 1);\n          } // Force sticking to beginning of line if no character would fit except for the indentation\n\n\n          if (wrappedTextIndentVisibleColumn + columnsForFullWidthChar > breakingColumn) {\n            wrappedTextIndent = '';\n            wrappedTextIndentVisibleColumn = 0;\n          }\n        }\n      }\n\n    var classifier = this.classifier;\n    var lastBreakingOffset = 0; // Last 0-based offset in the lineText at which a break happened\n\n    var breakingLengths = []; // The length of each broken-up line text\n\n    var breakingLengthsIndex = 0; // The count of breaks already done\n\n    var visibleColumn = 0; // Visible column since the beginning of the current line\n\n    var niceBreakOffset = -1; // Last index of a character that indicates a break should happen before it (more desirable)\n\n    var niceBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `niceBreakOffset`\n\n    var obtrusiveBreakOffset = -1; // Last index of a character that indicates a break should happen before it (less desirable)\n\n    var obtrusiveBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `obtrusiveBreakOffset`\n\n    var len = lineText.length;\n\n    for (var i = 0; i < len; i++) {\n      // At this point, there is a certainty that the character before `i` fits on the current line,\n      // but the character at `i` might not fit\n      var charCode = lineText.charCodeAt(i);\n      var charCodeIsTab = charCode === 9\n      /* Tab */\n      ;\n      var charCodeClass = classifier.get(charCode);\n\n      if (strings.isLowSurrogate(charCode)\n      /*  && i + 1 < len */\n      ) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        // => advance visibleColumn by 1 and advance to next char code...\n        visibleColumn = visibleColumn + 1;\n        continue;\n      }\n\n      if (charCodeClass === 1\n      /* BREAK_BEFORE */\n      ) {\n          // This is a character that indicates that a break should happen before it\n          // Since we are certain the character before `i` fits, there's no extra checking needed,\n          // just mark it as a nice breaking opportunity\n          niceBreakOffset = i;\n          niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n        } // CJK breaking : before break\n\n\n      if (charCodeClass === 4\n      /* BREAK_IDEOGRAPHIC */\n      && i > 0) {\n        var prevCode = lineText.charCodeAt(i - 1);\n        var prevClass = classifier.get(prevCode);\n\n        if (prevClass !== 1\n        /* BREAK_BEFORE */\n        ) {\n            // Kinsoku Shori: Don't break after a leading character, like an open bracket\n            niceBreakOffset = i;\n            niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n          }\n      }\n\n      var charColumnSize = 1;\n\n      if (strings.isFullWidthCharacter(charCode)) {\n        charColumnSize = columnsForFullWidthChar;\n      } // Advance visibleColumn with character at `i`\n\n\n      visibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(visibleColumn, tabSize, charCodeIsTab, charColumnSize);\n\n      if (visibleColumn > breakingColumn && i !== 0) {\n        // We need to break at least before character at `i`:\n        //  - break before niceBreakLastOffset if it exists (and re-establish a correct visibleColumn by using niceBreakVisibleColumn + charAt(i))\n        //  - otherwise, break before obtrusiveBreakLastOffset if it exists (and re-establish a correct visibleColumn by using obtrusiveBreakVisibleColumn + charAt(i))\n        //  - otherwise, break before i (and re-establish a correct visibleColumn by charAt(i))\n        var breakBeforeOffset = void 0;\n        var restoreVisibleColumnFrom = void 0;\n\n        if (niceBreakOffset !== -1 && niceBreakVisibleColumn <= breakingColumn) {\n          // We will break before `niceBreakLastOffset`\n          breakBeforeOffset = niceBreakOffset;\n          restoreVisibleColumnFrom = niceBreakVisibleColumn;\n        } else if (obtrusiveBreakOffset !== -1 && obtrusiveBreakVisibleColumn <= breakingColumn) {\n          // We will break before `obtrusiveBreakLastOffset`\n          breakBeforeOffset = obtrusiveBreakOffset;\n          restoreVisibleColumnFrom = obtrusiveBreakVisibleColumn;\n        } else {\n          // We will break before `i`\n          breakBeforeOffset = i;\n          restoreVisibleColumnFrom = wrappedTextIndentVisibleColumn;\n        } // Break before character at `breakBeforeOffset`\n\n\n        breakingLengths[breakingLengthsIndex++] = breakBeforeOffset - lastBreakingOffset;\n        lastBreakingOffset = breakBeforeOffset; // Re-establish visibleColumn by taking character at `i` into account\n\n        visibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(restoreVisibleColumnFrom, tabSize, charCodeIsTab, charColumnSize); // Reset markers\n\n        niceBreakOffset = -1;\n        niceBreakVisibleColumn = 0;\n        obtrusiveBreakOffset = -1;\n        obtrusiveBreakVisibleColumn = 0;\n      } // At this point, there is a certainty that the character at `i` fits on the current line\n\n\n      if (niceBreakOffset !== -1) {\n        // Advance niceBreakVisibleColumn\n        niceBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(niceBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);\n      }\n\n      if (obtrusiveBreakOffset !== -1) {\n        // Advance obtrusiveBreakVisibleColumn\n        obtrusiveBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(obtrusiveBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);\n      }\n\n      if (charCodeClass === 2\n      /* BREAK_AFTER */\n      && (hardWrappingIndent === 0\n      /* None */\n      || i >= firstNonWhitespaceIndex)) {\n        // This is a character that indicates that a break should happen after it\n        niceBreakOffset = i + 1;\n        niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n      } // CJK breaking : after break\n\n\n      if (charCodeClass === 4\n      /* BREAK_IDEOGRAPHIC */\n      && i < len - 1) {\n        var nextCode = lineText.charCodeAt(i + 1);\n        var nextClass = classifier.get(nextCode);\n\n        if (nextClass !== 2\n        /* BREAK_AFTER */\n        ) {\n            // Kinsoku Shori: Don't break before a trailing character, like a period\n            niceBreakOffset = i + 1;\n            niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n          }\n      }\n\n      if (charCodeClass === 3\n      /* BREAK_OBTRUSIVE */\n      ) {\n          // This is an obtrusive character that indicates that a break should happen after it\n          obtrusiveBreakOffset = i + 1;\n          obtrusiveBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n        }\n    }\n\n    if (breakingLengthsIndex === 0) {\n      return null;\n    } // Add last segment\n\n\n    breakingLengths[breakingLengthsIndex++] = len - lastBreakingOffset;\n    return new CharacterHardWrappingLineMapping(new PrefixSumComputer(toUint32Array(breakingLengths)), wrappedTextIndent);\n  };\n\n  return CharacterHardWrappingLineMapperFactory;\n}();\n\nexport { CharacterHardWrappingLineMapperFactory };\n\nvar CharacterHardWrappingLineMapping =\n/** @class */\nfunction () {\n  function CharacterHardWrappingLineMapping(prefixSums, wrappedLinesIndent) {\n    this._prefixSums = prefixSums;\n    this._wrappedLinesIndent = wrappedLinesIndent;\n  }\n\n  CharacterHardWrappingLineMapping.prototype.getOutputLineCount = function () {\n    return this._prefixSums.getCount();\n  };\n\n  CharacterHardWrappingLineMapping.prototype.getWrappedLinesIndent = function () {\n    return this._wrappedLinesIndent;\n  };\n\n  CharacterHardWrappingLineMapping.prototype.getInputOffsetOfOutputPosition = function (outputLineIndex, outputOffset) {\n    if (outputLineIndex === 0) {\n      return outputOffset;\n    } else {\n      return this._prefixSums.getAccumulatedValue(outputLineIndex - 1) + outputOffset;\n    }\n  };\n\n  CharacterHardWrappingLineMapping.prototype.getOutputPositionOfInputOffset = function (inputOffset) {\n    var r = this._prefixSums.getIndexOf(inputOffset);\n\n    return new OutputPosition(r.index, r.remainder);\n  };\n\n  return CharacterHardWrappingLineMapping;\n}();\n\nexport { CharacterHardWrappingLineMapping };","map":null,"metadata":{},"sourceType":"module"}