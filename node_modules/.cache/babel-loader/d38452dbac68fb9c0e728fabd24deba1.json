{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nimport { TextModel } from '../../common/model/textModel.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nvar MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5000;\nexport var ID_INDENT_PROVIDER = 'indent';\n\nvar IndentRangeProvider =\n/** @class */\nfunction () {\n  function IndentRangeProvider(editorModel) {\n    this.editorModel = editorModel;\n    this.id = ID_INDENT_PROVIDER;\n  }\n\n  IndentRangeProvider.prototype.dispose = function () {};\n\n  IndentRangeProvider.prototype.compute = function (cancelationToken) {\n    var foldingRules = LanguageConfigurationRegistry.getFoldingRules(this.editorModel.getLanguageIdentifier().id);\n    var offSide = foldingRules && !!foldingRules.offSide;\n    var markers = foldingRules && foldingRules.markers;\n    return Promise.resolve(computeRanges(this.editorModel, offSide, markers));\n  };\n\n  return IndentRangeProvider;\n}();\n\nexport { IndentRangeProvider }; // public only for testing\n\nvar RangesCollector =\n/** @class */\nfunction () {\n  function RangesCollector(foldingRangesLimit) {\n    this._startIndexes = [];\n    this._endIndexes = [];\n    this._indentOccurrences = [];\n    this._length = 0;\n    this._foldingRangesLimit = foldingRangesLimit;\n  }\n\n  RangesCollector.prototype.insertFirst = function (startLineNumber, endLineNumber, indent) {\n    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n      return;\n    }\n\n    var index = this._length;\n    this._startIndexes[index] = startLineNumber;\n    this._endIndexes[index] = endLineNumber;\n    this._length++;\n\n    if (indent < 1000) {\n      this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\n    }\n  };\n\n  RangesCollector.prototype.toIndentRanges = function (model) {\n    if (this._length <= this._foldingRangesLimit) {\n      // reverse and create arrays of the exact length\n      var startIndexes = new Uint32Array(this._length);\n      var endIndexes = new Uint32Array(this._length);\n\n      for (var i = this._length - 1, k = 0; i >= 0; i--, k++) {\n        startIndexes[k] = this._startIndexes[i];\n        endIndexes[k] = this._endIndexes[i];\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes);\n    } else {\n      var entries = 0;\n      var maxIndent = this._indentOccurrences.length;\n\n      for (var i = 0; i < this._indentOccurrences.length; i++) {\n        var n = this._indentOccurrences[i];\n\n        if (n) {\n          if (n + entries > this._foldingRangesLimit) {\n            maxIndent = i;\n            break;\n          }\n\n          entries += n;\n        }\n      }\n\n      var tabSize = model.getOptions().tabSize; // reverse and create arrays of the exact length\n\n      var startIndexes = new Uint32Array(this._foldingRangesLimit);\n      var endIndexes = new Uint32Array(this._foldingRangesLimit);\n\n      for (var i = this._length - 1, k = 0; i >= 0; i--) {\n        var startIndex = this._startIndexes[i];\n        var lineContent = model.getLineContent(startIndex);\n        var indent = TextModel.computeIndentLevel(lineContent, tabSize);\n\n        if (indent < maxIndent || indent === maxIndent && entries++ < this._foldingRangesLimit) {\n          startIndexes[k] = startIndex;\n          endIndexes[k] = this._endIndexes[i];\n          k++;\n        }\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes);\n    }\n  };\n\n  return RangesCollector;\n}();\n\nexport { RangesCollector };\nexport function computeRanges(model, offSide, markers, foldingRangesLimit) {\n  if (foldingRangesLimit === void 0) {\n    foldingRangesLimit = MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT;\n  }\n\n  var tabSize = model.getOptions().tabSize;\n  var result = new RangesCollector(foldingRangesLimit);\n  var pattern = undefined;\n\n  if (markers) {\n    pattern = new RegExp(\"(\" + markers.start.source + \")|(?:\" + markers.end.source + \")\");\n  }\n\n  var previousRegions = [];\n  var line = model.getLineCount() + 1;\n  previousRegions.push({\n    indent: -1,\n    endAbove: line,\n    line: line\n  }); // sentinel, to make sure there's at least one entry\n\n  for (var line_1 = model.getLineCount(); line_1 > 0; line_1--) {\n    var lineContent = model.getLineContent(line_1);\n    var indent = TextModel.computeIndentLevel(lineContent, tabSize);\n    var previous = previousRegions[previousRegions.length - 1];\n\n    if (indent === -1) {\n      if (offSide) {\n        // for offSide languages, empty lines are associated to the previous block\n        // note: the next block is already written to the results, so this only\n        // impacts the end position of the block before\n        previous.endAbove = line_1;\n      }\n\n      continue; // only whitespace\n    }\n\n    var m = void 0;\n\n    if (pattern && (m = lineContent.match(pattern))) {\n      // folding pattern match\n      if (m[1]) {\n        // start pattern match\n        // discard all regions until the folding pattern\n        var i = previousRegions.length - 1;\n\n        while (i > 0 && previousRegions[i].indent !== -2) {\n          i--;\n        }\n\n        if (i > 0) {\n          previousRegions.length = i + 1;\n          previous = previousRegions[i]; // new folding range from pattern, includes the end line\n\n          result.insertFirst(line_1, previous.line, indent);\n          previous.line = line_1;\n          previous.indent = indent;\n          previous.endAbove = line_1;\n          continue;\n        } else {// no end marker found, treat line as a regular line\n        }\n      } else {\n        // end pattern match\n        previousRegions.push({\n          indent: -2,\n          endAbove: line_1,\n          line: line_1\n        });\n        continue;\n      }\n    }\n\n    if (previous.indent > indent) {\n      // discard all regions with larger indent\n      do {\n        previousRegions.pop();\n        previous = previousRegions[previousRegions.length - 1];\n      } while (previous.indent > indent); // new folding range\n\n\n      var endLineNumber = previous.endAbove - 1;\n\n      if (endLineNumber - line_1 >= 1) {\n        // needs at east size 1\n        result.insertFirst(line_1, endLineNumber, indent);\n      }\n    }\n\n    if (previous.indent === indent) {\n      previous.endAbove = line_1;\n    } else {\n      // previous.indent < indent\n      // new region with a bigger indent\n      previousRegions.push({\n        indent: indent,\n        endAbove: line_1,\n        line: line_1\n      });\n    }\n  }\n\n  return result.toIndentRanges(model);\n}","map":null,"metadata":{},"sourceType":"module"}