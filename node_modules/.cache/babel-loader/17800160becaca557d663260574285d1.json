{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { alert } from '../../../base/browser/ui/aria/aria.js';\nimport { isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { illegalArgument, onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../browser/core/editorState.js';\nimport { isCodeEditor } from '../../browser/editorBrowser.js';\nimport { registerLanguageCommand } from '../../browser/editorExtensions.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { DocumentFormattingEditProviderRegistry, DocumentRangeFormattingEditProviderRegistry, OnTypeFormattingEditProviderRegistry } from '../../common/modes.js';\nimport { IEditorWorkerService } from '../../common/services/editorWorkerService.js';\nimport { IModelService } from '../../common/services/modelService.js';\nimport { FormattingEdit } from './formattingEdit.js';\nimport * as nls from '../../../nls.js';\nimport { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport function alertFormattingEdits(edits) {\n  edits = edits.filter(function (edit) {\n    return edit.range;\n  });\n\n  if (!edits.length) {\n    return;\n  }\n\n  var range = edits[0].range;\n\n  for (var i = 1; i < edits.length; i++) {\n    range = Range.plusRange(range, edits[i].range);\n  }\n\n  var startLineNumber = range.startLineNumber,\n      endLineNumber = range.endLineNumber;\n\n  if (startLineNumber === endLineNumber) {\n    if (edits.length === 1) {\n      alert(nls.localize('hint11', \"Made 1 formatting edit on line {0}\", startLineNumber));\n    } else {\n      alert(nls.localize('hintn1', \"Made {0} formatting edits on line {1}\", edits.length, startLineNumber));\n    }\n  } else {\n    if (edits.length === 1) {\n      alert(nls.localize('hint1n', \"Made 1 formatting edit between lines {0} and {1}\", startLineNumber, endLineNumber));\n    } else {\n      alert(nls.localize('hintnn', \"Made {0} formatting edits between lines {1} and {2}\", edits.length, startLineNumber, endLineNumber));\n    }\n  }\n}\nexport function getRealAndSyntheticDocumentFormattersOrdered(model) {\n  var result = [];\n  var seen = new Set(); // (1) add all document formatter\n\n  var docFormatter = DocumentFormattingEditProviderRegistry.ordered(model);\n\n  for (var _i = 0, docFormatter_1 = docFormatter; _i < docFormatter_1.length; _i++) {\n    var formatter = docFormatter_1[_i];\n    result.push(formatter);\n\n    if (formatter.extensionId) {\n      seen.add(ExtensionIdentifier.toKey(formatter.extensionId));\n    }\n  } // (2) add all range formatter as document formatter (unless the same extension already did that)\n\n\n  var rangeFormatter = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n\n  var _loop_1 = function (formatter) {\n    if (formatter.extensionId) {\n      if (seen.has(ExtensionIdentifier.toKey(formatter.extensionId))) {\n        return \"continue\";\n      }\n\n      seen.add(ExtensionIdentifier.toKey(formatter.extensionId));\n    }\n\n    result.push({\n      displayName: formatter.displayName,\n      extensionId: formatter.extensionId,\n      provideDocumentFormattingEdits: function (model, options, token) {\n        return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n      }\n    });\n  };\n\n  for (var _a = 0, rangeFormatter_1 = rangeFormatter; _a < rangeFormatter_1.length; _a++) {\n    var formatter = rangeFormatter_1[_a];\n\n    _loop_1(formatter);\n  }\n\n  return result;\n}\n\nvar FormattingConflicts =\n/** @class */\nfunction () {\n  function FormattingConflicts() {}\n\n  FormattingConflicts.select = function (formatter, document, mode) {\n    return __awaiter(this, void 0, void 0, function () {\n      var selector;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (formatter.length === 0) {\n              return [2\n              /*return*/\n              , undefined];\n            }\n\n            selector = FormattingConflicts._selectors.iterator().next().value;\n            if (!selector) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , selector(formatter, document, mode)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 2:\n            return [2\n            /*return*/\n            , formatter[0]];\n        }\n      });\n    });\n  };\n\n  FormattingConflicts._selectors = new LinkedList();\n  return FormattingConflicts;\n}();\n\nexport { FormattingConflicts };\nexport function formatDocumentRangeWithSelectedProvider(accessor, editorOrModel, range, mode, token) {\n  return __awaiter(this, void 0, void 0, function () {\n    var instaService, model, provider, selected;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          instaService = accessor.get(IInstantiationService);\n          model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n          provider = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n          return [4\n          /*yield*/\n          , FormattingConflicts.select(provider, model, mode)];\n\n        case 1:\n          selected = _a.sent();\n          if (!selected) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , instaService.invokeFunction(formatDocumentRangeWithProvider, selected, editorOrModel, range, token)];\n\n        case 2:\n          _a.sent();\n\n          _a.label = 3;\n\n        case 3:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\nexport function formatDocumentRangeWithProvider(accessor, provider, editorOrModel, range, token) {\n  return __awaiter(this, void 0, void 0, function () {\n    var workerService, model, cts, edits, rawEdits, range_1, initialSelection_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          workerService = accessor.get(IEditorWorkerService);\n\n          if (isCodeEditor(editorOrModel)) {\n            model = editorOrModel.getModel();\n            cts = new EditorStateCancellationTokenSource(editorOrModel, 1\n            /* Value */\n            | 4\n            /* Position */\n            , token);\n          } else {\n            model = editorOrModel;\n            cts = new TextModelCancellationTokenSource(editorOrModel, token);\n          }\n\n          _a.label = 1;\n\n        case 1:\n          _a.trys.push([1,, 4, 5]);\n\n          return [4\n          /*yield*/\n          , provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token)];\n\n        case 2:\n          rawEdits = _a.sent();\n          return [4\n          /*yield*/\n          , workerService.computeMoreMinimalEdits(model.uri, rawEdits)];\n\n        case 3:\n          edits = _a.sent();\n\n          if (cts.token.isCancellationRequested) {\n            return [2\n            /*return*/\n            , true];\n          }\n\n          return [3\n          /*break*/\n          , 5];\n\n        case 4:\n          cts.dispose();\n          return [7\n          /*endfinally*/\n          ];\n\n        case 5:\n          if (!edits || edits.length === 0) {\n            return [2\n            /*return*/\n            , false];\n          }\n\n          if (isCodeEditor(editorOrModel)) {\n            // use editor to apply edits\n            FormattingEdit.execute(editorOrModel, edits);\n            alertFormattingEdits(edits);\n            editorOrModel.pushUndoStop();\n            editorOrModel.focus();\n            editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1\n            /* Immediate */\n            );\n          } else {\n            range_1 = edits[0].range;\n            initialSelection_1 = new Selection(range_1.startLineNumber, range_1.startColumn, range_1.endLineNumber, range_1.endColumn);\n            model.pushEditOperations([initialSelection_1], edits.map(function (edit) {\n              return {\n                text: edit.text,\n                range: Range.lift(edit.range),\n                forceMoveMarkers: true\n              };\n            }), function (undoEdits) {\n              for (var _i = 0, undoEdits_1 = undoEdits; _i < undoEdits_1.length; _i++) {\n                var range_2 = undoEdits_1[_i].range;\n\n                if (Range.areIntersectingOrTouching(range_2, initialSelection_1)) {\n                  return [new Selection(range_2.startLineNumber, range_2.startColumn, range_2.endLineNumber, range_2.endColumn)];\n                }\n              }\n\n              return null;\n            });\n          }\n\n          return [2\n          /*return*/\n          , true];\n      }\n    });\n  });\n}\nexport function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, token) {\n  return __awaiter(this, void 0, void 0, function () {\n    var instaService, model, provider, selected;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          instaService = accessor.get(IInstantiationService);\n          model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n          provider = getRealAndSyntheticDocumentFormattersOrdered(model);\n          return [4\n          /*yield*/\n          , FormattingConflicts.select(provider, model, mode)];\n\n        case 1:\n          selected = _a.sent();\n          if (!selected) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token)];\n\n        case 2:\n          _a.sent();\n\n          _a.label = 3;\n\n        case 3:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\nexport function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {\n  return __awaiter(this, void 0, void 0, function () {\n    var workerService, model, cts, edits, rawEdits, range, initialSelection_2;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          workerService = accessor.get(IEditorWorkerService);\n\n          if (isCodeEditor(editorOrModel)) {\n            model = editorOrModel.getModel();\n            cts = new EditorStateCancellationTokenSource(editorOrModel, 1\n            /* Value */\n            | 4\n            /* Position */\n            , token);\n          } else {\n            model = editorOrModel;\n            cts = new TextModelCancellationTokenSource(editorOrModel, token);\n          }\n\n          _a.label = 1;\n\n        case 1:\n          _a.trys.push([1,, 4, 5]);\n\n          return [4\n          /*yield*/\n          , provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token)];\n\n        case 2:\n          rawEdits = _a.sent();\n          return [4\n          /*yield*/\n          , workerService.computeMoreMinimalEdits(model.uri, rawEdits)];\n\n        case 3:\n          edits = _a.sent();\n\n          if (cts.token.isCancellationRequested) {\n            return [2\n            /*return*/\n            , true];\n          }\n\n          return [3\n          /*break*/\n          , 5];\n\n        case 4:\n          cts.dispose();\n          return [7\n          /*endfinally*/\n          ];\n\n        case 5:\n          if (!edits || edits.length === 0) {\n            return [2\n            /*return*/\n            , false];\n          }\n\n          if (isCodeEditor(editorOrModel)) {\n            // use editor to apply edits\n            FormattingEdit.execute(editorOrModel, edits);\n\n            if (mode !== 2\n            /* Silent */\n            ) {\n                alertFormattingEdits(edits);\n                editorOrModel.pushUndoStop();\n                editorOrModel.focus();\n                editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1\n                /* Immediate */\n                );\n              }\n          } else {\n            range = edits[0].range;\n            initialSelection_2 = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n            model.pushEditOperations([initialSelection_2], edits.map(function (edit) {\n              return {\n                text: edit.text,\n                range: Range.lift(edit.range),\n                forceMoveMarkers: true\n              };\n            }), function (undoEdits) {\n              for (var _i = 0, undoEdits_2 = undoEdits; _i < undoEdits_2.length; _i++) {\n                var range_3 = undoEdits_2[_i].range;\n\n                if (Range.areIntersectingOrTouching(range_3, initialSelection_2)) {\n                  return [new Selection(range_3.startLineNumber, range_3.startColumn, range_3.endLineNumber, range_3.endColumn)];\n                }\n              }\n\n              return null;\n            });\n          }\n\n          return [2\n          /*return*/\n          , true];\n      }\n    });\n  });\n}\nexport function getDocumentRangeFormattingEditsUntilResult(workerService, model, range, options, token) {\n  return __awaiter(this, void 0, void 0, function () {\n    var providers, _i, providers_1, provider, rawEdits;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          providers = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n          _i = 0, providers_1 = providers;\n          _a.label = 1;\n\n        case 1:\n          if (!(_i < providers_1.length)) return [3\n          /*break*/\n          , 5];\n          provider = providers_1[_i];\n          return [4\n          /*yield*/\n          , Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError)];\n\n        case 2:\n          rawEdits = _a.sent();\n          if (!isNonEmptyArray(rawEdits)) return [3\n          /*break*/\n          , 4];\n          return [4\n          /*yield*/\n          , workerService.computeMoreMinimalEdits(model.uri, rawEdits)];\n\n        case 3:\n          return [2\n          /*return*/\n          , _a.sent()];\n\n        case 4:\n          _i++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 5:\n          return [2\n          /*return*/\n          , undefined];\n      }\n    });\n  });\n}\nexport function getDocumentFormattingEditsUntilResult(workerService, model, options, token) {\n  return __awaiter(this, void 0, void 0, function () {\n    var providers, _i, providers_2, provider, rawEdits;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          providers = getRealAndSyntheticDocumentFormattersOrdered(model);\n          _i = 0, providers_2 = providers;\n          _a.label = 1;\n\n        case 1:\n          if (!(_i < providers_2.length)) return [3\n          /*break*/\n          , 5];\n          provider = providers_2[_i];\n          return [4\n          /*yield*/\n          , Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError)];\n\n        case 2:\n          rawEdits = _a.sent();\n          if (!isNonEmptyArray(rawEdits)) return [3\n          /*break*/\n          , 4];\n          return [4\n          /*yield*/\n          , workerService.computeMoreMinimalEdits(model.uri, rawEdits)];\n\n        case 3:\n          return [2\n          /*return*/\n          , _a.sent()];\n\n        case 4:\n          _i++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 5:\n          return [2\n          /*return*/\n          , undefined];\n      }\n    });\n  });\n}\nexport function getOnTypeFormattingEdits(workerService, model, position, ch, options) {\n  var providers = OnTypeFormattingEditProviderRegistry.ordered(model);\n\n  if (providers.length === 0) {\n    return Promise.resolve(undefined);\n  }\n\n  if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n    return Promise.resolve(undefined);\n  }\n\n  return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, CancellationToken.None)).catch(onUnexpectedExternalError).then(function (edits) {\n    return workerService.computeMoreMinimalEdits(model.uri, edits);\n  });\n}\nregisterLanguageCommand('_executeFormatRangeProvider', function (accessor, args) {\n  var resource = args.resource,\n      range = args.range,\n      options = args.options;\n\n  if (!(resource instanceof URI) || !Range.isIRange(range)) {\n    throw illegalArgument();\n  }\n\n  var model = accessor.get(IModelService).getModel(resource);\n\n  if (!model) {\n    throw illegalArgument('resource');\n  }\n\n  return getDocumentRangeFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, Range.lift(range), options, CancellationToken.None);\n});\nregisterLanguageCommand('_executeFormatDocumentProvider', function (accessor, args) {\n  var resource = args.resource,\n      options = args.options;\n\n  if (!(resource instanceof URI)) {\n    throw illegalArgument('resource');\n  }\n\n  var model = accessor.get(IModelService).getModel(resource);\n\n  if (!model) {\n    throw illegalArgument('resource');\n  }\n\n  return getDocumentFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, options, CancellationToken.None);\n});\nregisterLanguageCommand('_executeFormatOnTypeProvider', function (accessor, args) {\n  var resource = args.resource,\n      position = args.position,\n      ch = args.ch,\n      options = args.options;\n\n  if (!(resource instanceof URI) || !Position.isIPosition(position) || typeof ch !== 'string') {\n    throw illegalArgument();\n  }\n\n  var model = accessor.get(IModelService).getModel(resource);\n\n  if (!model) {\n    throw illegalArgument('resource');\n  }\n\n  return getOnTypeFormattingEdits(accessor.get(IEditorWorkerService), model, Position.lift(position), ch, options);\n});","map":null,"metadata":{},"sourceType":"module"}