{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js'; // const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\n\nexport var AverageBufferSize = 65535;\nexport function createUintArray(arr) {\n  var r;\n\n  if (arr[arr.length - 1] < 65536) {\n    r = new Uint16Array(arr.length);\n  } else {\n    r = new Uint32Array(arr.length);\n  }\n\n  r.set(arr, 0);\n  return r;\n}\n\nvar LineStarts =\n/** @class */\nfunction () {\n  function LineStarts(lineStarts, cr, lf, crlf, isBasicASCII) {\n    this.lineStarts = lineStarts;\n    this.cr = cr;\n    this.lf = lf;\n    this.crlf = crlf;\n    this.isBasicASCII = isBasicASCII;\n  }\n\n  return LineStarts;\n}();\n\nexport { LineStarts };\nexport function createLineStartsFast(str, readonly) {\n  if (readonly === void 0) {\n    readonly = true;\n  }\n\n  var r = [0],\n      rLength = 1;\n\n  for (var i = 0, len = str.length; i < len; i++) {\n    var chr = str.charCodeAt(i);\n\n    if (chr === 13\n    /* CarriageReturn */\n    ) {\n        if (i + 1 < len && str.charCodeAt(i + 1) === 10\n        /* LineFeed */\n        ) {\n            // \\r\\n... case\n            r[rLength++] = i + 2;\n            i++; // skip \\n\n          } else {\n          // \\r... case\n          r[rLength++] = i + 1;\n        }\n      } else if (chr === 10\n    /* LineFeed */\n    ) {\n        r[rLength++] = i + 1;\n      }\n  }\n\n  if (readonly) {\n    return createUintArray(r);\n  } else {\n    return r;\n  }\n}\nexport function createLineStarts(r, str) {\n  r.length = 0;\n  r[0] = 0;\n  var rLength = 1;\n  var cr = 0,\n      lf = 0,\n      crlf = 0;\n  var isBasicASCII = true;\n\n  for (var i = 0, len = str.length; i < len; i++) {\n    var chr = str.charCodeAt(i);\n\n    if (chr === 13\n    /* CarriageReturn */\n    ) {\n        if (i + 1 < len && str.charCodeAt(i + 1) === 10\n        /* LineFeed */\n        ) {\n            // \\r\\n... case\n            crlf++;\n            r[rLength++] = i + 2;\n            i++; // skip \\n\n          } else {\n          cr++; // \\r... case\n\n          r[rLength++] = i + 1;\n        }\n      } else if (chr === 10\n    /* LineFeed */\n    ) {\n        lf++;\n        r[rLength++] = i + 1;\n      } else {\n      if (isBasicASCII) {\n        if (chr !== 9\n        /* Tab */\n        && (chr < 32 || chr > 126)) {\n          isBasicASCII = false;\n        }\n      }\n    }\n  }\n\n  var result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n  r.length = 0;\n  return result;\n}\n\nvar Piece =\n/** @class */\nfunction () {\n  function Piece(bufferIndex, start, end, lineFeedCnt, length) {\n    this.bufferIndex = bufferIndex;\n    this.start = start;\n    this.end = end;\n    this.lineFeedCnt = lineFeedCnt;\n    this.length = length;\n  }\n\n  return Piece;\n}();\n\nexport { Piece };\n\nvar StringBuffer =\n/** @class */\nfunction () {\n  function StringBuffer(buffer, lineStarts) {\n    this.buffer = buffer;\n    this.lineStarts = lineStarts;\n  }\n\n  return StringBuffer;\n}();\n\nexport { StringBuffer };\n\nvar PieceTreeSearchCache =\n/** @class */\nfunction () {\n  function PieceTreeSearchCache(limit) {\n    this._limit = limit;\n    this._cache = [];\n  }\n\n  PieceTreeSearchCache.prototype.get = function (offset) {\n    for (var i = this._cache.length - 1; i >= 0; i--) {\n      var nodePos = this._cache[i];\n\n      if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n        return nodePos;\n      }\n    }\n\n    return null;\n  };\n\n  PieceTreeSearchCache.prototype.get2 = function (lineNumber) {\n    for (var i = this._cache.length - 1; i >= 0; i--) {\n      var nodePos = this._cache[i];\n\n      if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n        return nodePos;\n      }\n    }\n\n    return null;\n  };\n\n  PieceTreeSearchCache.prototype.set = function (nodePosition) {\n    if (this._cache.length >= this._limit) {\n      this._cache.shift();\n    }\n\n    this._cache.push(nodePosition);\n  };\n\n  PieceTreeSearchCache.prototype.valdiate = function (offset) {\n    var hasInvalidVal = false;\n    var tmp = this._cache;\n\n    for (var i = 0; i < tmp.length; i++) {\n      var nodePos = tmp[i];\n\n      if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n        tmp[i] = null;\n        hasInvalidVal = true;\n        continue;\n      }\n    }\n\n    if (hasInvalidVal) {\n      var newArr = [];\n\n      for (var _i = 0, tmp_1 = tmp; _i < tmp_1.length; _i++) {\n        var entry = tmp_1[_i];\n\n        if (entry !== null) {\n          newArr.push(entry);\n        }\n      }\n\n      this._cache = newArr;\n    }\n  };\n\n  return PieceTreeSearchCache;\n}();\n\nvar PieceTreeBase =\n/** @class */\nfunction () {\n  function PieceTreeBase(chunks, eol, eolNormalized) {\n    this.create(chunks, eol, eolNormalized);\n  }\n\n  PieceTreeBase.prototype.create = function (chunks, eol, eolNormalized) {\n    this._buffers = [new StringBuffer('', [0])];\n    this._lastChangeBufferPos = {\n      line: 0,\n      column: 0\n    };\n    this.root = SENTINEL;\n    this._lineCnt = 1;\n    this._length = 0;\n    this._EOL = eol;\n    this._EOLLength = eol.length;\n    this._EOLNormalized = eolNormalized;\n    var lastNode = null;\n\n    for (var i = 0, len = chunks.length; i < len; i++) {\n      if (chunks[i].buffer.length > 0) {\n        if (!chunks[i].lineStarts) {\n          chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n        }\n\n        var piece = new Piece(i + 1, {\n          line: 0,\n          column: 0\n        }, {\n          line: chunks[i].lineStarts.length - 1,\n          column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1]\n        }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n\n        this._buffers.push(chunks[i]);\n\n        lastNode = this.rbInsertRight(lastNode, piece);\n      }\n    }\n\n    this._searchCache = new PieceTreeSearchCache(1);\n    this._lastVisitedLine = {\n      lineNumber: 0,\n      value: ''\n    };\n    this.computeBufferMetadata();\n  };\n\n  PieceTreeBase.prototype.normalizeEOL = function (eol) {\n    var _this = this;\n\n    var averageBufferSize = AverageBufferSize;\n    var min = averageBufferSize - Math.floor(averageBufferSize / 3);\n    var max = min * 2;\n    var tempChunk = '';\n    var tempChunkLen = 0;\n    var chunks = [];\n    this.iterate(this.root, function (node) {\n      var str = _this.getNodeContent(node);\n\n      var len = str.length;\n\n      if (tempChunkLen <= min || tempChunkLen + len < max) {\n        tempChunk += str;\n        tempChunkLen += len;\n        return true;\n      } // flush anyways\n\n\n      var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n      chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n      tempChunk = str;\n      tempChunkLen = len;\n      return true;\n    });\n\n    if (tempChunkLen > 0) {\n      var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n      chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n    }\n\n    this.create(chunks, eol, true);\n  }; // #region Buffer API\n\n\n  PieceTreeBase.prototype.getEOL = function () {\n    return this._EOL;\n  };\n\n  PieceTreeBase.prototype.setEOL = function (newEOL) {\n    this._EOL = newEOL;\n    this._EOLLength = this._EOL.length;\n    this.normalizeEOL(newEOL);\n  };\n\n  PieceTreeBase.prototype.getOffsetAt = function (lineNumber, column) {\n    var leftLen = 0; // inorder\n\n    var x = this.root;\n\n    while (x !== SENTINEL) {\n      if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n        x = x.left;\n      } else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n        leftLen += x.size_left; // lineNumber >= 2\n\n        var accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n        return leftLen += accumualtedValInCurrentIndex + column - 1;\n      } else {\n        lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n        leftLen += x.size_left + x.piece.length;\n        x = x.right;\n      }\n    }\n\n    return leftLen;\n  };\n\n  PieceTreeBase.prototype.getPositionAt = function (offset) {\n    offset = Math.floor(offset);\n    offset = Math.max(0, offset);\n    var x = this.root;\n    var lfCnt = 0;\n    var originalOffset = offset;\n\n    while (x !== SENTINEL) {\n      if (x.size_left !== 0 && x.size_left >= offset) {\n        x = x.left;\n      } else if (x.size_left + x.piece.length >= offset) {\n        var out = this.getIndexOf(x, offset - x.size_left);\n        lfCnt += x.lf_left + out.index;\n\n        if (out.index === 0) {\n          var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n          var column = originalOffset - lineStartOffset;\n          return new Position(lfCnt + 1, column + 1);\n        }\n\n        return new Position(lfCnt + 1, out.remainder + 1);\n      } else {\n        offset -= x.size_left + x.piece.length;\n        lfCnt += x.lf_left + x.piece.lineFeedCnt;\n\n        if (x.right === SENTINEL) {\n          // last node\n          var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n          var column = originalOffset - offset - lineStartOffset;\n          return new Position(lfCnt + 1, column + 1);\n        } else {\n          x = x.right;\n        }\n      }\n    }\n\n    return new Position(1, 1);\n  };\n\n  PieceTreeBase.prototype.getValueInRange = function (range, eol) {\n    if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n      return '';\n    }\n\n    var startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n    var endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n    var value = this.getValueInRange2(startPosition, endPosition);\n\n    if (eol) {\n      if (eol !== this._EOL || !this._EOLNormalized) {\n        return value.replace(/\\r\\n|\\r|\\n/g, eol);\n      }\n\n      if (eol === this.getEOL() && this._EOLNormalized) {\n        if (eol === '\\r\\n') {}\n\n        return value;\n      }\n\n      return value.replace(/\\r\\n|\\r|\\n/g, eol);\n    }\n\n    return value;\n  };\n\n  PieceTreeBase.prototype.getValueInRange2 = function (startPosition, endPosition) {\n    if (startPosition.node === endPosition.node) {\n      var node = startPosition.node;\n      var buffer_1 = this._buffers[node.piece.bufferIndex].buffer;\n      var startOffset_1 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n      return buffer_1.substring(startOffset_1 + startPosition.remainder, startOffset_1 + endPosition.remainder);\n    }\n\n    var x = startPosition.node;\n    var buffer = this._buffers[x.piece.bufferIndex].buffer;\n    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n    var ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n    x = x.next();\n\n    while (x !== SENTINEL) {\n      var buffer_2 = this._buffers[x.piece.bufferIndex].buffer;\n      var startOffset_2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n      if (x === endPosition.node) {\n        ret += buffer_2.substring(startOffset_2, startOffset_2 + endPosition.remainder);\n        break;\n      } else {\n        ret += buffer_2.substr(startOffset_2, x.piece.length);\n      }\n\n      x = x.next();\n    }\n\n    return ret;\n  };\n\n  PieceTreeBase.prototype.getLinesContent = function () {\n    return this.getContentOfSubTree(this.root).split(/\\r\\n|\\r|\\n/);\n  };\n\n  PieceTreeBase.prototype.getLength = function () {\n    return this._length;\n  };\n\n  PieceTreeBase.prototype.getLineCount = function () {\n    return this._lineCnt;\n  };\n\n  PieceTreeBase.prototype.getLineContent = function (lineNumber) {\n    if (this._lastVisitedLine.lineNumber === lineNumber) {\n      return this._lastVisitedLine.value;\n    }\n\n    this._lastVisitedLine.lineNumber = lineNumber;\n\n    if (lineNumber === this._lineCnt) {\n      this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n    } else if (this._EOLNormalized) {\n      this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n    } else {\n      this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n    }\n\n    return this._lastVisitedLine.value;\n  };\n\n  PieceTreeBase.prototype.getLineCharCode = function (lineNumber, index) {\n    var nodePos = this.nodeAt2(lineNumber, index + 1);\n\n    if (nodePos.remainder === nodePos.node.piece.length) {\n      // the char we want to fetch is at the head of next node.\n      var matchingNode = nodePos.node.next();\n\n      if (!matchingNode) {\n        return 0;\n      }\n\n      var buffer = this._buffers[matchingNode.piece.bufferIndex];\n      var startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n      return buffer.buffer.charCodeAt(startOffset);\n    } else {\n      var buffer = this._buffers[nodePos.node.piece.bufferIndex];\n      var startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n      var targetOffset = startOffset + nodePos.remainder;\n      return buffer.buffer.charCodeAt(targetOffset);\n    }\n  };\n\n  PieceTreeBase.prototype.getLineLength = function (lineNumber) {\n    if (lineNumber === this.getLineCount()) {\n      var startOffset = this.getOffsetAt(lineNumber, 1);\n      return this.getLength() - startOffset;\n    }\n\n    return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n  };\n\n  PieceTreeBase.prototype.findMatchesInNode = function (node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n    var buffer = this._buffers[node.piece.bufferIndex];\n    var startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n    var start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n    var end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n    var m; // Reset regex to search from the beginning\n\n    searcher.reset(start);\n    var ret = {\n      line: 0,\n      column: 0\n    };\n\n    do {\n      m = searcher.next(buffer.buffer);\n\n      if (m) {\n        if (m.index >= end) {\n          return resultLen;\n        }\n\n        this.positionInBuffer(node, m.index - startOffsetInBuffer, ret);\n        var lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n        var retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n        var retEndColumn = retStartColumn + m[0].length;\n        result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n\n        if (m.index + m[0].length >= end) {\n          return resultLen;\n        }\n\n        if (resultLen >= limitResultCount) {\n          return resultLen;\n        }\n      }\n    } while (m);\n\n    return resultLen;\n  };\n\n  PieceTreeBase.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\n    var result = [];\n    var resultLen = 0;\n    var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n    var startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n\n    if (startPosition === null) {\n      return [];\n    }\n\n    var endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n\n    if (endPosition === null) {\n      return [];\n    }\n\n    var start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n    var end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n\n    if (startPosition.node === endPosition.node) {\n      this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n      return result;\n    }\n\n    var startLineNumber = searchRange.startLineNumber;\n    var currentNode = startPosition.node;\n\n    while (currentNode !== endPosition.node) {\n      var lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n\n      if (lineBreakCnt >= 1) {\n        // last line break position\n        var lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n        var startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n        var nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n        var startColumn_1 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn_1, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n\n        if (resultLen >= limitResultCount) {\n          return result;\n        }\n\n        startLineNumber += lineBreakCnt;\n      }\n\n      var startColumn_2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0; // search for the remaining content\n\n      if (startLineNumber === searchRange.endLineNumber) {\n        var text = this.getLineContent(startLineNumber).substring(startColumn_2, searchRange.endColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);\n        return result;\n      }\n\n      resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn_2), startLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);\n\n      if (resultLen >= limitResultCount) {\n        return result;\n      }\n\n      startLineNumber++;\n      startPosition = this.nodeAt2(startLineNumber, 1);\n      currentNode = startPosition.node;\n      start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n    }\n\n    if (startLineNumber === searchRange.endLineNumber) {\n      var startColumn_3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n      var text = this.getLineContent(startLineNumber).substring(startColumn_3, searchRange.endColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_3, resultLen, result, captureMatches, limitResultCount);\n      return result;\n    }\n\n    var startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n    resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n    return result;\n  };\n\n  PieceTreeBase.prototype._findMatchesInLine = function (searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n    var wordSeparators = searchData.wordSeparators;\n\n    if (!captureMatches && searchData.simpleSearch) {\n      var searchString = searchData.simpleSearch;\n      var searchStringLen = searchString.length;\n      var textLength = text.length;\n      var lastMatchIndex = -searchStringLen;\n\n      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n        if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      }\n\n      return resultLen;\n    }\n\n    var m; // Reset regex to search from the beginning\n\n    searcher.reset(0);\n\n    do {\n      m = searcher.next(text);\n\n      if (m) {\n        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\n        if (resultLen >= limitResultCount) {\n          return resultLen;\n        }\n      }\n    } while (m);\n\n    return resultLen;\n  }; // #endregion\n  // #region Piece Table\n\n\n  PieceTreeBase.prototype.insert = function (offset, value, eolNormalized) {\n    if (eolNormalized === void 0) {\n      eolNormalized = false;\n    }\n\n    this._EOLNormalized = this._EOLNormalized && eolNormalized;\n    this._lastVisitedLine.lineNumber = 0;\n    this._lastVisitedLine.value = '';\n\n    if (this.root !== SENTINEL) {\n      var _a = this.nodeAt(offset),\n          node = _a.node,\n          remainder = _a.remainder,\n          nodeStartOffset = _a.nodeStartOffset;\n\n      var piece = node.piece;\n      var bufferIndex = piece.bufferIndex;\n      var insertPosInBuffer = this.positionInBuffer(node, remainder);\n\n      if (node.piece.bufferIndex === 0 && piece.end.line === this._lastChangeBufferPos.line && piece.end.column === this._lastChangeBufferPos.column && nodeStartOffset + piece.length === offset && value.length < AverageBufferSize) {\n        // changed buffer\n        this.appendToNode(node, value);\n        this.computeBufferMetadata();\n        return;\n      }\n\n      if (nodeStartOffset === offset) {\n        this.insertContentToNodeLeft(value, node);\n\n        this._searchCache.valdiate(offset);\n      } else if (nodeStartOffset + node.piece.length > offset) {\n        // we are inserting into the middle of a node.\n        var nodesToDel = [];\n        var newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n          var headOfRight = this.nodeCharCodeAt(node, remainder);\n\n          if (headOfRight === 10\n          /** \\n */\n          ) {\n              var newStart = {\n                line: newRightPiece.start.line + 1,\n                column: 0\n              };\n              newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n              value += '\\n';\n            }\n        } // reuse node for content before insertion point.\n\n\n        if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n          var tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n\n          if (tailOfLeft === 13\n          /** \\r */\n          ) {\n              var previousPos = this.positionInBuffer(node, remainder - 1);\n              this.deleteNodeTail(node, previousPos);\n              value = '\\r' + value;\n\n              if (node.piece.length === 0) {\n                nodesToDel.push(node);\n              }\n            } else {\n            this.deleteNodeTail(node, insertPosInBuffer);\n          }\n        } else {\n          this.deleteNodeTail(node, insertPosInBuffer);\n        }\n\n        var newPieces = this.createNewPieces(value);\n\n        if (newRightPiece.length > 0) {\n          this.rbInsertRight(node, newRightPiece);\n        }\n\n        var tmpNode = node;\n\n        for (var k = 0; k < newPieces.length; k++) {\n          tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n\n        this.deleteNodes(nodesToDel);\n      } else {\n        this.insertContentToNodeRight(value, node);\n      }\n    } else {\n      // insert new node\n      var pieces = this.createNewPieces(value);\n      var node = this.rbInsertLeft(null, pieces[0]);\n\n      for (var k = 1; k < pieces.length; k++) {\n        node = this.rbInsertRight(node, pieces[k]);\n      }\n    } // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n\n\n    this.computeBufferMetadata();\n  };\n\n  PieceTreeBase.prototype.delete = function (offset, cnt) {\n    this._lastVisitedLine.lineNumber = 0;\n    this._lastVisitedLine.value = '';\n\n    if (cnt <= 0 || this.root === SENTINEL) {\n      return;\n    }\n\n    var startPosition = this.nodeAt(offset);\n    var endPosition = this.nodeAt(offset + cnt);\n    var startNode = startPosition.node;\n    var endNode = endPosition.node;\n\n    if (startNode === endNode) {\n      var startSplitPosInBuffer_1 = this.positionInBuffer(startNode, startPosition.remainder);\n      var endSplitPosInBuffer_1 = this.positionInBuffer(startNode, endPosition.remainder);\n\n      if (startPosition.nodeStartOffset === offset) {\n        if (cnt === startNode.piece.length) {\n          // delete node\n          var next = startNode.next();\n          rbDelete(this, startNode);\n          this.validateCRLFWithPrevNode(next);\n          this.computeBufferMetadata();\n          return;\n        }\n\n        this.deleteNodeHead(startNode, endSplitPosInBuffer_1);\n\n        this._searchCache.valdiate(offset);\n\n        this.validateCRLFWithPrevNode(startNode);\n        this.computeBufferMetadata();\n        return;\n      }\n\n      if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n        this.deleteNodeTail(startNode, startSplitPosInBuffer_1);\n        this.validateCRLFWithNextNode(startNode);\n        this.computeBufferMetadata();\n        return;\n      } // delete content in the middle, this node will be splitted to nodes\n\n\n      this.shrinkNode(startNode, startSplitPosInBuffer_1, endSplitPosInBuffer_1);\n      this.computeBufferMetadata();\n      return;\n    }\n\n    var nodesToDel = [];\n    var startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n    this.deleteNodeTail(startNode, startSplitPosInBuffer);\n\n    this._searchCache.valdiate(offset);\n\n    if (startNode.piece.length === 0) {\n      nodesToDel.push(startNode);\n    } // update last touched node\n\n\n    var endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n    this.deleteNodeHead(endNode, endSplitPosInBuffer);\n\n    if (endNode.piece.length === 0) {\n      nodesToDel.push(endNode);\n    } // delete nodes in between\n\n\n    var secondNode = startNode.next();\n\n    for (var node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n      nodesToDel.push(node);\n    }\n\n    var prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n    this.deleteNodes(nodesToDel);\n    this.validateCRLFWithNextNode(prev);\n    this.computeBufferMetadata();\n  };\n\n  PieceTreeBase.prototype.insertContentToNodeLeft = function (value, node) {\n    // we are inserting content to the beginning of node\n    var nodesToDel = [];\n\n    if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n      // move `\\n` to new node.\n      var piece = node.piece;\n      var newStart = {\n        line: piece.start.line + 1,\n        column: 0\n      };\n      var nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n      node.piece = nPiece;\n      value += '\\n';\n      updateTreeMetadata(this, node, -1, -1);\n\n      if (node.piece.length === 0) {\n        nodesToDel.push(node);\n      }\n    }\n\n    var newPieces = this.createNewPieces(value);\n    var newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n\n    for (var k = newPieces.length - 2; k >= 0; k--) {\n      newNode = this.rbInsertLeft(newNode, newPieces[k]);\n    }\n\n    this.validateCRLFWithPrevNode(newNode);\n    this.deleteNodes(nodesToDel);\n  };\n\n  PieceTreeBase.prototype.insertContentToNodeRight = function (value, node) {\n    // we are inserting to the right of this node.\n    if (this.adjustCarriageReturnFromNext(value, node)) {\n      // move \\n to the new node.\n      value += '\\n';\n    }\n\n    var newPieces = this.createNewPieces(value);\n    var newNode = this.rbInsertRight(node, newPieces[0]);\n    var tmpNode = newNode;\n\n    for (var k = 1; k < newPieces.length; k++) {\n      tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n    }\n\n    this.validateCRLFWithPrevNode(newNode);\n  };\n\n  PieceTreeBase.prototype.positionInBuffer = function (node, remainder, ret) {\n    var piece = node.piece;\n    var bufferIndex = node.piece.bufferIndex;\n    var lineStarts = this._buffers[bufferIndex].lineStarts;\n    var startOffset = lineStarts[piece.start.line] + piece.start.column;\n    var offset = startOffset + remainder; // binary search offset between startOffset and endOffset\n\n    var low = piece.start.line;\n    var high = piece.end.line;\n    var mid = 0;\n    var midStop = 0;\n    var midStart = 0;\n\n    while (low <= high) {\n      mid = low + (high - low) / 2 | 0;\n      midStart = lineStarts[mid];\n\n      if (mid === high) {\n        break;\n      }\n\n      midStop = lineStarts[mid + 1];\n\n      if (offset < midStart) {\n        high = mid - 1;\n      } else if (offset >= midStop) {\n        low = mid + 1;\n      } else {\n        break;\n      }\n    }\n\n    if (ret) {\n      ret.line = mid;\n      ret.column = offset - midStart;\n      return null;\n    }\n\n    return {\n      line: mid,\n      column: offset - midStart\n    };\n  };\n\n  PieceTreeBase.prototype.getLineFeedCnt = function (bufferIndex, start, end) {\n    // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n    // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n    if (end.column === 0) {\n      return end.line - start.line;\n    }\n\n    var lineStarts = this._buffers[bufferIndex].lineStarts;\n\n    if (end.line === lineStarts.length - 1) {\n      // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n      return end.line - start.line;\n    }\n\n    var nextLineStartOffset = lineStarts[end.line + 1];\n    var endOffset = lineStarts[end.line] + end.column;\n\n    if (nextLineStartOffset > endOffset + 1) {\n      // there are more than 1 character after end, which means it can't be \\n\n      return end.line - start.line;\n    } // endOffset + 1 === nextLineStartOffset\n    // character at endOffset is \\n, so we check the character before first\n    // if character at endOffset is \\r, end.column is 0 and we can't get here.\n\n\n    var previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n\n    var buffer = this._buffers[bufferIndex].buffer;\n\n    if (buffer.charCodeAt(previousCharOffset) === 13) {\n      return end.line - start.line + 1;\n    } else {\n      return end.line - start.line;\n    }\n  };\n\n  PieceTreeBase.prototype.offsetInBuffer = function (bufferIndex, cursor) {\n    var lineStarts = this._buffers[bufferIndex].lineStarts;\n    return lineStarts[cursor.line] + cursor.column;\n  };\n\n  PieceTreeBase.prototype.deleteNodes = function (nodes) {\n    for (var i = 0; i < nodes.length; i++) {\n      rbDelete(this, nodes[i]);\n    }\n  };\n\n  PieceTreeBase.prototype.createNewPieces = function (text) {\n    if (text.length > AverageBufferSize) {\n      // the content is large, operations like substring, charCode becomes slow\n      // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n      var newPieces = [];\n\n      while (text.length > AverageBufferSize) {\n        var lastChar = text.charCodeAt(AverageBufferSize - 1);\n        var splitText = void 0;\n\n        if (lastChar === 13\n        /* CarriageReturn */\n        || lastChar >= 0xD800 && lastChar <= 0xDBFF) {\n          // last character is \\r or a high surrogate => keep it back\n          splitText = text.substring(0, AverageBufferSize - 1);\n          text = text.substring(AverageBufferSize - 1);\n        } else {\n          splitText = text.substring(0, AverageBufferSize);\n          text = text.substring(AverageBufferSize);\n        }\n\n        var lineStarts_1 = createLineStartsFast(splitText);\n        newPieces.push(new Piece(this._buffers.length,\n        /* buffer index */\n        {\n          line: 0,\n          column: 0\n        }, {\n          line: lineStarts_1.length - 1,\n          column: splitText.length - lineStarts_1[lineStarts_1.length - 1]\n        }, lineStarts_1.length - 1, splitText.length));\n\n        this._buffers.push(new StringBuffer(splitText, lineStarts_1));\n      }\n\n      var lineStarts_2 = createLineStartsFast(text);\n      newPieces.push(new Piece(this._buffers.length,\n      /* buffer index */\n      {\n        line: 0,\n        column: 0\n      }, {\n        line: lineStarts_2.length - 1,\n        column: text.length - lineStarts_2[lineStarts_2.length - 1]\n      }, lineStarts_2.length - 1, text.length));\n\n      this._buffers.push(new StringBuffer(text, lineStarts_2));\n\n      return newPieces;\n    }\n\n    var startOffset = this._buffers[0].buffer.length;\n    var lineStarts = createLineStartsFast(text, false);\n    var start = this._lastChangeBufferPos;\n\n    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset && startOffset !== 0 && this.startWithLF(text) && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n    ) {\n      this._lastChangeBufferPos = {\n        line: this._lastChangeBufferPos.line,\n        column: this._lastChangeBufferPos.column + 1\n      };\n      start = this._lastChangeBufferPos;\n\n      for (var i = 0; i < lineStarts.length; i++) {\n        lineStarts[i] += startOffset + 1;\n      }\n\n      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n      this._buffers[0].buffer += '_' + text;\n      startOffset += 1;\n    } else {\n      if (startOffset !== 0) {\n        for (var i = 0; i < lineStarts.length; i++) {\n          lineStarts[i] += startOffset;\n        }\n      }\n\n      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n      this._buffers[0].buffer += text;\n    }\n\n    var endOffset = this._buffers[0].buffer.length;\n    var endIndex = this._buffers[0].lineStarts.length - 1;\n    var endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n    var endPos = {\n      line: endIndex,\n      column: endColumn\n    };\n    var newPiece = new Piece(0,\n    /** todo@peng */\n    start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n    this._lastChangeBufferPos = endPos;\n    return [newPiece];\n  };\n\n  PieceTreeBase.prototype.getLineRawContent = function (lineNumber, endOffset) {\n    if (endOffset === void 0) {\n      endOffset = 0;\n    }\n\n    var x = this.root;\n    var ret = '';\n\n    var cache = this._searchCache.get2(lineNumber);\n\n    if (cache) {\n      x = cache.node;\n      var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n      var buffer = this._buffers[x.piece.bufferIndex].buffer;\n      var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n      if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n        ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\n      } else {\n        var accumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n        return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\n      }\n    } else {\n      var nodeStartOffset = 0;\n      var originalLineNumber = lineNumber;\n\n      while (x !== SENTINEL) {\n        if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n          x = x.left;\n        } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n          var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n          var buffer = this._buffers[x.piece.bufferIndex].buffer;\n          var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n          nodeStartOffset += x.size_left;\n\n          this._searchCache.set({\n            node: x,\n            nodeStartOffset: nodeStartOffset,\n            nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n          });\n\n          return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\n        } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n          var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          var buffer = this._buffers[x.piece.bufferIndex].buffer;\n          var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n          ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\n          break;\n        } else {\n          lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n          nodeStartOffset += x.size_left + x.piece.length;\n          x = x.right;\n        }\n      }\n    } // search in order, to find the node contains end column\n\n\n    x = x.next();\n\n    while (x !== SENTINEL) {\n      var buffer = this._buffers[x.piece.bufferIndex].buffer;\n\n      if (x.piece.lineFeedCnt > 0) {\n        var accumualtedValue = this.getAccumulatedValue(x, 0);\n        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        ret += buffer.substring(startOffset, startOffset + accumualtedValue - endOffset);\n        return ret;\n      } else {\n        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        ret += buffer.substr(startOffset, x.piece.length);\n      }\n\n      x = x.next();\n    }\n\n    return ret;\n  };\n\n  PieceTreeBase.prototype.computeBufferMetadata = function () {\n    var x = this.root;\n    var lfCnt = 1;\n    var len = 0;\n\n    while (x !== SENTINEL) {\n      lfCnt += x.lf_left + x.piece.lineFeedCnt;\n      len += x.size_left + x.piece.length;\n      x = x.right;\n    }\n\n    this._lineCnt = lfCnt;\n    this._length = len;\n\n    this._searchCache.valdiate(this._length);\n  }; // #region node operations\n\n\n  PieceTreeBase.prototype.getIndexOf = function (node, accumulatedValue) {\n    var piece = node.piece;\n    var pos = this.positionInBuffer(node, accumulatedValue);\n    var lineCnt = pos.line - piece.start.line;\n\n    if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n      // we are checking the end of this node, so a CRLF check is necessary.\n      var realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n\n      if (realLineCnt !== lineCnt) {\n        // aha yes, CRLF\n        return {\n          index: realLineCnt,\n          remainder: 0\n        };\n      }\n    }\n\n    return {\n      index: lineCnt,\n      remainder: pos.column\n    };\n  };\n\n  PieceTreeBase.prototype.getAccumulatedValue = function (node, index) {\n    if (index < 0) {\n      return 0;\n    }\n\n    var piece = node.piece;\n    var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n    var expectedLineStartIndex = piece.start.line + index + 1;\n\n    if (expectedLineStartIndex > piece.end.line) {\n      return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n    } else {\n      return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n    }\n  };\n\n  PieceTreeBase.prototype.deleteNodeTail = function (node, pos) {\n    var piece = node.piece;\n    var originalLFCnt = piece.lineFeedCnt;\n    var originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n    var newEnd = pos;\n    var newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n    var lf_delta = newLineFeedCnt - originalLFCnt;\n    var size_delta = newEndOffset - originalEndOffset;\n    var newLength = piece.length + size_delta;\n    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, node, size_delta, lf_delta);\n  };\n\n  PieceTreeBase.prototype.deleteNodeHead = function (node, pos) {\n    var piece = node.piece;\n    var originalLFCnt = piece.lineFeedCnt;\n    var originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n    var newStart = pos;\n    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n    var newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n    var lf_delta = newLineFeedCnt - originalLFCnt;\n    var size_delta = originalStartOffset - newStartOffset;\n    var newLength = piece.length + size_delta;\n    node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, node, size_delta, lf_delta);\n  };\n\n  PieceTreeBase.prototype.shrinkNode = function (node, start, end) {\n    var piece = node.piece;\n    var originalStartPos = piece.start;\n    var originalEndPos = piece.end; // old piece, originalStartPos, start\n\n    var oldLength = piece.length;\n    var oldLFCnt = piece.lineFeedCnt;\n    var newEnd = start;\n    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n    var newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt); // new right piece, end, originalEndPos\n\n    var newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n    var newNode = this.rbInsertRight(node, newPiece);\n    this.validateCRLFWithPrevNode(newNode);\n  };\n\n  PieceTreeBase.prototype.appendToNode = function (node, value) {\n    if (this.adjustCarriageReturnFromNext(value, node)) {\n      value += '\\n';\n    }\n\n    var hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n    var startOffset = this._buffers[0].buffer.length;\n    this._buffers[0].buffer += value;\n    var lineStarts = createLineStartsFast(value, false);\n\n    for (var i = 0; i < lineStarts.length; i++) {\n      lineStarts[i] += startOffset;\n    }\n\n    if (hitCRLF) {\n      var prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n\n      this._buffers[0].lineStarts.pop(); // _lastChangeBufferPos is already wrong\n\n\n      this._lastChangeBufferPos = {\n        line: this._lastChangeBufferPos.line - 1,\n        column: startOffset - prevStartOffset\n      };\n    }\n\n    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n    var endIndex = this._buffers[0].lineStarts.length - 1;\n    var endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n    var newEnd = {\n      line: endIndex,\n      column: endColumn\n    };\n    var newLength = node.piece.length + value.length;\n    var oldLineFeedCnt = node.piece.lineFeedCnt;\n    var newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n    var lf_delta = newLineFeedCnt - oldLineFeedCnt;\n    node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n    this._lastChangeBufferPos = newEnd;\n    updateTreeMetadata(this, node, value.length, lf_delta);\n  };\n\n  PieceTreeBase.prototype.nodeAt = function (offset) {\n    var x = this.root;\n\n    var cache = this._searchCache.get(offset);\n\n    if (cache) {\n      return {\n        node: cache.node,\n        nodeStartOffset: cache.nodeStartOffset,\n        remainder: offset - cache.nodeStartOffset\n      };\n    }\n\n    var nodeStartOffset = 0;\n\n    while (x !== SENTINEL) {\n      if (x.size_left > offset) {\n        x = x.left;\n      } else if (x.size_left + x.piece.length >= offset) {\n        nodeStartOffset += x.size_left;\n        var ret = {\n          node: x,\n          remainder: offset - x.size_left,\n          nodeStartOffset: nodeStartOffset\n        };\n\n        this._searchCache.set(ret);\n\n        return ret;\n      } else {\n        offset -= x.size_left + x.piece.length;\n        nodeStartOffset += x.size_left + x.piece.length;\n        x = x.right;\n      }\n    }\n\n    return null;\n  };\n\n  PieceTreeBase.prototype.nodeAt2 = function (lineNumber, column) {\n    var x = this.root;\n    var nodeStartOffset = 0;\n\n    while (x !== SENTINEL) {\n      if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n        x = x.left;\n      } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n        var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n        var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n        nodeStartOffset += x.size_left;\n        return {\n          node: x,\n          remainder: Math.min(prevAccumualtedValue + column - 1, accumualtedValue),\n          nodeStartOffset: nodeStartOffset\n        };\n      } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n        var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\n        if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n          return {\n            node: x,\n            remainder: prevAccumualtedValue + column - 1,\n            nodeStartOffset: nodeStartOffset\n          };\n        } else {\n          column -= x.piece.length - prevAccumualtedValue;\n          break;\n        }\n      } else {\n        lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n        nodeStartOffset += x.size_left + x.piece.length;\n        x = x.right;\n      }\n    } // search in order, to find the node contains position.column\n\n\n    x = x.next();\n\n    while (x !== SENTINEL) {\n      if (x.piece.lineFeedCnt > 0) {\n        var accumualtedValue = this.getAccumulatedValue(x, 0);\n        var nodeStartOffset_1 = this.offsetOfNode(x);\n        return {\n          node: x,\n          remainder: Math.min(column - 1, accumualtedValue),\n          nodeStartOffset: nodeStartOffset_1\n        };\n      } else {\n        if (x.piece.length >= column - 1) {\n          var nodeStartOffset_2 = this.offsetOfNode(x);\n          return {\n            node: x,\n            remainder: column - 1,\n            nodeStartOffset: nodeStartOffset_2\n          };\n        } else {\n          column -= x.piece.length;\n        }\n      }\n\n      x = x.next();\n    }\n\n    return null;\n  };\n\n  PieceTreeBase.prototype.nodeCharCodeAt = function (node, offset) {\n    if (node.piece.lineFeedCnt < 1) {\n      return -1;\n    }\n\n    var buffer = this._buffers[node.piece.bufferIndex];\n    var newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n    return buffer.buffer.charCodeAt(newOffset);\n  };\n\n  PieceTreeBase.prototype.offsetOfNode = function (node) {\n    if (!node) {\n      return 0;\n    }\n\n    var pos = node.size_left;\n\n    while (node !== this.root) {\n      if (node.parent.right === node) {\n        pos += node.parent.size_left + node.parent.piece.length;\n      }\n\n      node = node.parent;\n    }\n\n    return pos;\n  }; // #endregion\n  // #region CRLF\n\n\n  PieceTreeBase.prototype.shouldCheckCRLF = function () {\n    return !(this._EOLNormalized && this._EOL === '\\n');\n  };\n\n  PieceTreeBase.prototype.startWithLF = function (val) {\n    if (typeof val === 'string') {\n      return val.charCodeAt(0) === 10;\n    }\n\n    if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n      return false;\n    }\n\n    var piece = val.piece;\n    var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n    var line = piece.start.line;\n    var startOffset = lineStarts[line] + piece.start.column;\n\n    if (line === lineStarts.length - 1) {\n      // last line, so there is no line feed at the end of this line\n      return false;\n    }\n\n    var nextLineOffset = lineStarts[line + 1];\n\n    if (nextLineOffset > startOffset + 1) {\n      return false;\n    }\n\n    return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n  };\n\n  PieceTreeBase.prototype.endWithCR = function (val) {\n    if (typeof val === 'string') {\n      return val.charCodeAt(val.length - 1) === 13;\n    }\n\n    if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n      return false;\n    }\n\n    return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n  };\n\n  PieceTreeBase.prototype.validateCRLFWithPrevNode = function (nextNode) {\n    if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n      var node = nextNode.prev();\n\n      if (this.endWithCR(node)) {\n        this.fixCRLF(node, nextNode);\n      }\n    }\n  };\n\n  PieceTreeBase.prototype.validateCRLFWithNextNode = function (node) {\n    if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n      var nextNode = node.next();\n\n      if (this.startWithLF(nextNode)) {\n        this.fixCRLF(node, nextNode);\n      }\n    }\n  };\n\n  PieceTreeBase.prototype.fixCRLF = function (prev, next) {\n    var nodesToDel = []; // update node\n\n    var lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n    var newEnd;\n\n    if (prev.piece.end.column === 0) {\n      // it means, last line ends with \\r, not \\r\\n\n      newEnd = {\n        line: prev.piece.end.line - 1,\n        column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1\n      };\n    } else {\n      // \\r\\n\n      newEnd = {\n        line: prev.piece.end.line,\n        column: prev.piece.end.column - 1\n      };\n    }\n\n    var prevNewLength = prev.piece.length - 1;\n    var prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n    prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n    updateTreeMetadata(this, prev, -1, -1);\n\n    if (prev.piece.length === 0) {\n      nodesToDel.push(prev);\n    } // update nextNode\n\n\n    var newStart = {\n      line: next.piece.start.line + 1,\n      column: 0\n    };\n    var newLength = next.piece.length - 1;\n    var newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n    next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, next, -1, -1);\n\n    if (next.piece.length === 0) {\n      nodesToDel.push(next);\n    } // create new piece which contains \\r\\n\n\n\n    var pieces = this.createNewPieces('\\r\\n');\n    this.rbInsertRight(prev, pieces[0]); // delete empty nodes\n\n    for (var i = 0; i < nodesToDel.length; i++) {\n      rbDelete(this, nodesToDel[i]);\n    }\n  };\n\n  PieceTreeBase.prototype.adjustCarriageReturnFromNext = function (value, node) {\n    if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n      var nextNode = node.next();\n\n      if (this.startWithLF(nextNode)) {\n        // move `\\n` forward\n        value += '\\n';\n\n        if (nextNode.piece.length === 1) {\n          rbDelete(this, nextNode);\n        } else {\n          var piece = nextNode.piece;\n          var newStart = {\n            line: piece.start.line + 1,\n            column: 0\n          };\n          var newLength = piece.length - 1;\n          var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n          nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n          updateTreeMetadata(this, nextNode, -1, -1);\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }; // #endregion\n  // #endregion\n  // #region Tree operations\n\n\n  PieceTreeBase.prototype.iterate = function (node, callback) {\n    if (node === SENTINEL) {\n      return callback(SENTINEL);\n    }\n\n    var leftRet = this.iterate(node.left, callback);\n\n    if (!leftRet) {\n      return leftRet;\n    }\n\n    return callback(node) && this.iterate(node.right, callback);\n  };\n\n  PieceTreeBase.prototype.getNodeContent = function (node) {\n    if (node === SENTINEL) {\n      return '';\n    }\n\n    var buffer = this._buffers[node.piece.bufferIndex];\n    var currentContent;\n    var piece = node.piece;\n    var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n    var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n    currentContent = buffer.buffer.substring(startOffset, endOffset);\n    return currentContent;\n  };\n  /**\n   *      node              node\n   *     /  \\              /  \\\n   *    a   b    <----   a    b\n   *                         /\n   *                        z\n   */\n\n\n  PieceTreeBase.prototype.rbInsertRight = function (node, p) {\n    var z = new TreeNode(p, 1\n    /* Red */\n    );\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    z.parent = SENTINEL;\n    z.size_left = 0;\n    z.lf_left = 0;\n    var x = this.root;\n\n    if (x === SENTINEL) {\n      this.root = z;\n      z.color = 0\n      /* Black */\n      ;\n    } else if (node.right === SENTINEL) {\n      node.right = z;\n      z.parent = node;\n    } else {\n      var nextNode = leftest(node.right);\n      nextNode.left = z;\n      z.parent = nextNode;\n    }\n\n    fixInsert(this, z);\n    return z;\n  };\n  /**\n   *      node              node\n   *     /  \\              /  \\\n   *    a   b     ---->   a    b\n   *                       \\\n   *                        z\n   */\n\n\n  PieceTreeBase.prototype.rbInsertLeft = function (node, p) {\n    var z = new TreeNode(p, 1\n    /* Red */\n    );\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    z.parent = SENTINEL;\n    z.size_left = 0;\n    z.lf_left = 0;\n\n    if (this.root === SENTINEL) {\n      this.root = z;\n      z.color = 0\n      /* Black */\n      ;\n    } else if (node.left === SENTINEL) {\n      node.left = z;\n      z.parent = node;\n    } else {\n      var prevNode = righttest(node.left); // a\n\n      prevNode.right = z;\n      z.parent = prevNode;\n    }\n\n    fixInsert(this, z);\n    return z;\n  };\n\n  PieceTreeBase.prototype.getContentOfSubTree = function (node) {\n    var _this = this;\n\n    var str = '';\n    this.iterate(node, function (node) {\n      str += _this.getNodeContent(node);\n      return true;\n    });\n    return str;\n  };\n\n  return PieceTreeBase;\n}();\n\nexport { PieceTreeBase };","map":null,"metadata":{},"sourceType":"module"}