{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport * as nls from '../../../nls.js';\nimport { IContextKeyService, ContextKeyExpr } from '../../../platform/contextkey/common/contextkey.js';\nimport { KeybindingsRegistry } from '../../../platform/keybinding/common/keybindingsRegistry.js';\nimport { Position } from '../../common/core/position.js';\nimport { registerEditorAction, EditorAction, registerEditorContribution, registerDefaultLanguageCommand } from '../../browser/editorExtensions.js';\nimport { ReferenceProviderRegistry } from '../../common/modes.js';\nimport { Range } from '../../common/core/range.js';\nimport { PeekContext, getOuterEditor } from './peekViewWidget.js';\nimport { ReferencesController, ctxReferenceSearchVisible } from './referencesController.js';\nimport { ReferencesModel, OneReference } from './referencesModel.js';\nimport { createCancelablePromise } from '../../../base/common/async.js';\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { EditorContextKeys } from '../../common/editorContextKeys.js';\nimport { EmbeddedCodeEditorWidget } from '../../browser/widget/embeddedCodeEditorWidget.js';\nimport { isCodeEditor } from '../../browser/editorBrowser.js';\nimport { IListService } from '../../../platform/list/browser/listService.js';\nimport { ctxReferenceWidgetSearchTreeFocused } from './referencesWidget.js';\nimport { CommandsRegistry } from '../../../platform/commands/common/commands.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ICodeEditorService } from '../../browser/services/codeEditorService.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { coalesce, flatten } from '../../../base/common/arrays.js';\nexport var defaultReferenceSearchOptions = {\n  getMetaTitle: function (model) {\n    return model.references.length > 1 ? nls.localize('meta.titleReference', \" â€“ {0} references\", model.references.length) : '';\n  }\n};\n\nvar ReferenceController =\n/** @class */\nfunction () {\n  function ReferenceController(editor, contextKeyService) {\n    if (editor instanceof EmbeddedCodeEditorWidget) {\n      PeekContext.inPeekEditor.bindTo(contextKeyService);\n    }\n  }\n\n  ReferenceController.prototype.dispose = function () {};\n\n  ReferenceController.prototype.getId = function () {\n    return ReferenceController.ID;\n  };\n\n  ReferenceController.ID = 'editor.contrib.referenceController';\n  ReferenceController = __decorate([__param(1, IContextKeyService)], ReferenceController);\n  return ReferenceController;\n}();\n\nexport { ReferenceController };\n\nvar ReferenceAction =\n/** @class */\nfunction (_super) {\n  __extends(ReferenceAction, _super);\n\n  function ReferenceAction() {\n    return _super.call(this, {\n      id: 'editor.action.referenceSearch.trigger',\n      label: nls.localize('references.action.label', \"Peek References\"),\n      alias: 'Peek References',\n      precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInEmbeddedEditor.toNegated()),\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 1024\n        /* Shift */\n        | 70\n        /* F12 */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      },\n      menuOpts: {\n        group: 'navigation',\n        order: 1.5\n      }\n    }) || this;\n  }\n\n  ReferenceAction.prototype.run = function (_accessor, editor) {\n    var controller = ReferencesController.get(editor);\n\n    if (!controller) {\n      return;\n    }\n\n    if (editor.hasModel()) {\n      var range_1 = editor.getSelection();\n      var model_1 = editor.getModel();\n      var references = createCancelablePromise(function (token) {\n        return provideReferences(model_1, range_1.getStartPosition(), token).then(function (references) {\n          return new ReferencesModel(references);\n        });\n      });\n      controller.toggleWidget(range_1, references, defaultReferenceSearchOptions);\n    }\n  };\n\n  return ReferenceAction;\n}(EditorAction);\n\nexport { ReferenceAction };\nregisterEditorContribution(ReferenceController);\nregisterEditorAction(ReferenceAction);\n\nvar findReferencesCommand = function (accessor, resource, position) {\n  if (!(resource instanceof URI)) {\n    throw new Error('illegal argument, uri');\n  }\n\n  if (!position) {\n    throw new Error('illegal argument, position');\n  }\n\n  var codeEditorService = accessor.get(ICodeEditorService);\n  return codeEditorService.openCodeEditor({\n    resource: resource\n  }, codeEditorService.getFocusedCodeEditor()).then(function (control) {\n    if (!isCodeEditor(control) || !control.hasModel()) {\n      return undefined;\n    }\n\n    var controller = ReferencesController.get(control);\n\n    if (!controller) {\n      return undefined;\n    }\n\n    var references = createCancelablePromise(function (token) {\n      return provideReferences(control.getModel(), Position.lift(position), token).then(function (references) {\n        return new ReferencesModel(references);\n      });\n    });\n    var range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);\n    return Promise.resolve(controller.toggleWidget(range, references, defaultReferenceSearchOptions));\n  });\n};\n\nvar showReferencesCommand = function (accessor, resource, position, references) {\n  if (!(resource instanceof URI)) {\n    throw new Error('illegal argument, uri expected');\n  }\n\n  if (!references) {\n    throw new Error('missing references');\n  }\n\n  var codeEditorService = accessor.get(ICodeEditorService);\n  return codeEditorService.openCodeEditor({\n    resource: resource\n  }, codeEditorService.getFocusedCodeEditor()).then(function (control) {\n    if (!isCodeEditor(control)) {\n      return undefined;\n    }\n\n    var controller = ReferencesController.get(control);\n\n    if (!controller) {\n      return undefined;\n    }\n\n    return controller.toggleWidget(new Range(position.lineNumber, position.column, position.lineNumber, position.column), createCancelablePromise(function (_) {\n      return Promise.resolve(new ReferencesModel(references));\n    }), defaultReferenceSearchOptions);\n  });\n}; // register commands\n\n\nCommandsRegistry.registerCommand({\n  id: 'editor.action.findReferences',\n  handler: findReferencesCommand\n});\nCommandsRegistry.registerCommand({\n  id: 'editor.action.showReferences',\n  handler: showReferencesCommand,\n  description: {\n    description: 'Show references at a position in a file',\n    args: [{\n      name: 'uri',\n      description: 'The text document in which to show references',\n      constraint: URI\n    }, {\n      name: 'position',\n      description: 'The position at which to show',\n      constraint: Position.isIPosition\n    }, {\n      name: 'locations',\n      description: 'An array of locations.',\n      constraint: Array\n    }]\n  }\n});\n\nfunction closeActiveReferenceSearch(accessor, args) {\n  withController(accessor, function (controller) {\n    return controller.closeWidget();\n  });\n}\n\nfunction openReferenceToSide(accessor, args) {\n  var listService = accessor.get(IListService);\n  var focus = listService.lastFocusedList && listService.lastFocusedList.getFocus();\n\n  if (focus instanceof OneReference) {\n    withController(accessor, function (controller) {\n      return controller.openReference(focus, true);\n    });\n  }\n}\n\nfunction withController(accessor, fn) {\n  var outerEditor = getOuterEditor(accessor);\n\n  if (!outerEditor) {\n    return;\n  }\n\n  var controller = ReferencesController.get(outerEditor);\n\n  if (!controller) {\n    return;\n  }\n\n  fn(controller);\n}\n\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n  id: 'goToNextReference',\n  weight: 200\n  /* WorkbenchContrib */\n  + 50,\n  primary: 62\n  /* F4 */\n  ,\n  when: ctxReferenceSearchVisible,\n  handler: function (accessor) {\n    withController(accessor, function (controller) {\n      controller.goToNextOrPreviousReference(true);\n    });\n  }\n});\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n  id: 'goToNextReferenceFromEmbeddedEditor',\n  weight: 100\n  /* EditorContrib */\n  + 50,\n  primary: 62\n  /* F4 */\n  ,\n  when: PeekContext.inPeekEditor,\n  handler: function (accessor) {\n    withController(accessor, function (controller) {\n      controller.goToNextOrPreviousReference(true);\n    });\n  }\n});\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n  id: 'goToPreviousReference',\n  weight: 200\n  /* WorkbenchContrib */\n  + 50,\n  primary: 1024\n  /* Shift */\n  | 62\n  /* F4 */\n  ,\n  when: ctxReferenceSearchVisible,\n  handler: function (accessor) {\n    withController(accessor, function (controller) {\n      controller.goToNextOrPreviousReference(false);\n    });\n  }\n});\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n  id: 'goToPreviousReferenceFromEmbeddedEditor',\n  weight: 100\n  /* EditorContrib */\n  + 50,\n  primary: 1024\n  /* Shift */\n  | 62\n  /* F4 */\n  ,\n  when: PeekContext.inPeekEditor,\n  handler: function (accessor) {\n    withController(accessor, function (controller) {\n      controller.goToNextOrPreviousReference(false);\n    });\n  }\n});\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n  id: 'closeReferenceSearch',\n  weight: 200\n  /* WorkbenchContrib */\n  + 50,\n  primary: 9\n  /* Escape */\n  ,\n  secondary: [1024\n  /* Shift */\n  | 9\n  /* Escape */\n  ],\n  when: ContextKeyExpr.and(ctxReferenceSearchVisible, ContextKeyExpr.not('config.editor.stablePeek')),\n  handler: closeActiveReferenceSearch\n});\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n  id: 'closeReferenceSearchEditor',\n  weight: 100\n  /* EditorContrib */\n  - 101,\n  primary: 9\n  /* Escape */\n  ,\n  secondary: [1024\n  /* Shift */\n  | 9\n  /* Escape */\n  ],\n  when: ContextKeyExpr.and(PeekContext.inPeekEditor, ContextKeyExpr.not('config.editor.stablePeek')),\n  handler: closeActiveReferenceSearch\n});\nKeybindingsRegistry.registerCommandAndKeybindingRule({\n  id: 'openReferenceToSide',\n  weight: 100\n  /* EditorContrib */\n  ,\n  primary: 2048\n  /* CtrlCmd */\n  | 3\n  /* Enter */\n  ,\n  mac: {\n    primary: 256\n    /* WinCtrl */\n    | 3\n    /* Enter */\n\n  },\n  when: ContextKeyExpr.and(ctxReferenceSearchVisible, ctxReferenceWidgetSearchTreeFocused),\n  handler: openReferenceToSide\n});\nexport function provideReferences(model, position, token) {\n  // collect references from all providers\n  var promises = ReferenceProviderRegistry.ordered(model).map(function (provider) {\n    return Promise.resolve(provider.provideReferences(model, position, {\n      includeDeclaration: true\n    }, token)).then(function (result) {\n      if (Array.isArray(result)) {\n        return result;\n      }\n\n      return undefined;\n    }, function (err) {\n      onUnexpectedExternalError(err);\n    });\n  });\n  return Promise.all(promises).then(function (references) {\n    return flatten(coalesce(references));\n  });\n}\nregisterDefaultLanguageCommand('_executeReferenceProvider', function (model, position) {\n  return provideReferences(model, position, CancellationToken.None);\n});","map":null,"metadata":{},"sourceType":"module"}