{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../model/wordHelper.js';\nimport { IndentAction } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\n\nvar RichEditSupport =\n/** @class */\nfunction () {\n  function RichEditSupport(languageIdentifier, previous, rawConf) {\n    this._languageIdentifier = languageIdentifier;\n    this._brackets = null;\n    this._electricCharacter = null;\n    var prev = null;\n\n    if (previous) {\n      prev = previous._conf;\n    }\n\n    this._conf = RichEditSupport._mergeConf(prev, rawConf);\n    this.onEnter = RichEditSupport._handleOnEnter(this._conf);\n    this.comments = RichEditSupport._handleComments(this._conf);\n    this.characterPair = new CharacterPairSupport(this._conf);\n    this.wordDefinition = this._conf.wordPattern || DEFAULT_WORD_REGEXP;\n    this.indentationRules = this._conf.indentationRules;\n\n    if (this._conf.indentationRules) {\n      this.indentRulesSupport = new IndentRulesSupport(this._conf.indentationRules);\n    } else {\n      this.indentRulesSupport = null;\n    }\n\n    this.foldingRules = this._conf.folding || {};\n  }\n\n  Object.defineProperty(RichEditSupport.prototype, \"brackets\", {\n    get: function () {\n      if (!this._brackets && this._conf.brackets) {\n        this._brackets = new RichEditBrackets(this._languageIdentifier, this._conf.brackets);\n      }\n\n      return this._brackets;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RichEditSupport.prototype, \"electricCharacter\", {\n    get: function () {\n      if (!this._electricCharacter) {\n        this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n      }\n\n      return this._electricCharacter;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  RichEditSupport._mergeConf = function (prev, current) {\n    return {\n      comments: prev ? current.comments || prev.comments : current.comments,\n      brackets: prev ? current.brackets || prev.brackets : current.brackets,\n      wordPattern: prev ? current.wordPattern || prev.wordPattern : current.wordPattern,\n      indentationRules: prev ? current.indentationRules || prev.indentationRules : current.indentationRules,\n      onEnterRules: prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules,\n      autoClosingPairs: prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs,\n      surroundingPairs: prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs,\n      autoCloseBefore: prev ? current.autoCloseBefore || prev.autoCloseBefore : current.autoCloseBefore,\n      folding: prev ? current.folding || prev.folding : current.folding,\n      __electricCharacterSupport: prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport\n    };\n  };\n\n  RichEditSupport._handleOnEnter = function (conf) {\n    // on enter\n    var onEnter = {};\n    var empty = true;\n\n    if (conf.brackets) {\n      empty = false;\n      onEnter.brackets = conf.brackets;\n    }\n\n    if (conf.indentationRules) {\n      empty = false;\n    }\n\n    if (conf.onEnterRules) {\n      empty = false;\n      onEnter.regExpRules = conf.onEnterRules;\n    }\n\n    if (!empty) {\n      return new OnEnterSupport(onEnter);\n    }\n\n    return null;\n  };\n\n  RichEditSupport._handleComments = function (conf) {\n    var commentRule = conf.comments;\n\n    if (!commentRule) {\n      return null;\n    } // comment configuration\n\n\n    var comments = {};\n\n    if (commentRule.lineComment) {\n      comments.lineCommentToken = commentRule.lineComment;\n    }\n\n    if (commentRule.blockComment) {\n      var _a = commentRule.blockComment,\n          blockStart = _a[0],\n          blockEnd = _a[1];\n      comments.blockCommentStartToken = blockStart;\n      comments.blockCommentEndToken = blockEnd;\n    }\n\n    return comments;\n  };\n\n  return RichEditSupport;\n}();\n\nexport { RichEditSupport };\n\nvar LanguageConfigurationChangeEvent =\n/** @class */\nfunction () {\n  function LanguageConfigurationChangeEvent(languageIdentifier) {\n    this.languageIdentifier = languageIdentifier;\n  }\n\n  return LanguageConfigurationChangeEvent;\n}();\n\nexport { LanguageConfigurationChangeEvent };\n\nvar LanguageConfigurationRegistryImpl =\n/** @class */\nfunction () {\n  function LanguageConfigurationRegistryImpl() {\n    this._entries = new Map();\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n  }\n\n  LanguageConfigurationRegistryImpl.prototype.register = function (languageIdentifier, configuration) {\n    var _this = this;\n\n    var previous = this._getRichEditSupport(languageIdentifier.id);\n\n    var current = new RichEditSupport(languageIdentifier, previous, configuration);\n\n    this._entries.set(languageIdentifier.id, current);\n\n    this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));\n\n    return toDisposable(function () {\n      if (_this._entries.get(languageIdentifier.id) === current) {\n        _this._entries.set(languageIdentifier.id, previous);\n\n        _this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));\n      }\n    });\n  };\n\n  LanguageConfigurationRegistryImpl.prototype._getRichEditSupport = function (languageId) {\n    return this._entries.get(languageId);\n  }; // begin electricCharacter\n\n\n  LanguageConfigurationRegistryImpl.prototype._getElectricCharacterSupport = function (languageId) {\n    var value = this._getRichEditSupport(languageId);\n\n    if (!value) {\n      return null;\n    }\n\n    return value.electricCharacter || null;\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.getElectricCharacters = function (languageId) {\n    var electricCharacterSupport = this._getElectricCharacterSupport(languageId);\n\n    if (!electricCharacterSupport) {\n      return [];\n    }\n\n    return electricCharacterSupport.getElectricCharacters();\n  };\n  /**\n   * Should return opening bracket type to match indentation with\n   */\n\n\n  LanguageConfigurationRegistryImpl.prototype.onElectricCharacter = function (character, context, column) {\n    var scopedLineTokens = createScopedLineTokens(context, column - 1);\n\n    var electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);\n\n    if (!electricCharacterSupport) {\n      return null;\n    }\n\n    return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n  }; // end electricCharacter\n\n\n  LanguageConfigurationRegistryImpl.prototype.getComments = function (languageId) {\n    var value = this._getRichEditSupport(languageId);\n\n    if (!value) {\n      return null;\n    }\n\n    return value.comments || null;\n  }; // begin characterPair\n\n\n  LanguageConfigurationRegistryImpl.prototype._getCharacterPairSupport = function (languageId) {\n    var value = this._getRichEditSupport(languageId);\n\n    if (!value) {\n      return null;\n    }\n\n    return value.characterPair || null;\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.getAutoClosingPairs = function (languageId) {\n    var characterPairSupport = this._getCharacterPairSupport(languageId);\n\n    if (!characterPairSupport) {\n      return [];\n    }\n\n    return characterPairSupport.getAutoClosingPairs();\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.getAutoCloseBeforeSet = function (languageId) {\n    var characterPairSupport = this._getCharacterPairSupport(languageId);\n\n    if (!characterPairSupport) {\n      return CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n    }\n\n    return characterPairSupport.getAutoCloseBeforeSet();\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.getSurroundingPairs = function (languageId) {\n    var characterPairSupport = this._getCharacterPairSupport(languageId);\n\n    if (!characterPairSupport) {\n      return [];\n    }\n\n    return characterPairSupport.getSurroundingPairs();\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.shouldAutoClosePair = function (autoClosingPair, context, column) {\n    var scopedLineTokens = createScopedLineTokens(context, column - 1);\n    return CharacterPairSupport.shouldAutoClosePair(autoClosingPair, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n  }; // end characterPair\n\n\n  LanguageConfigurationRegistryImpl.prototype.getWordDefinition = function (languageId) {\n    var value = this._getRichEditSupport(languageId);\n\n    if (!value) {\n      return ensureValidWordDefinition(null);\n    }\n\n    return ensureValidWordDefinition(value.wordDefinition || null);\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.getFoldingRules = function (languageId) {\n    var value = this._getRichEditSupport(languageId);\n\n    if (!value) {\n      return {};\n    }\n\n    return value.foldingRules;\n  }; // begin Indent Rules\n\n\n  LanguageConfigurationRegistryImpl.prototype.getIndentRulesSupport = function (languageId) {\n    var value = this._getRichEditSupport(languageId);\n\n    if (!value) {\n      return null;\n    }\n\n    return value.indentRulesSupport || null;\n  };\n  /**\n   * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.\n   * Result:\n   * -1: run into the boundary of embedded languages\n   * 0: every line above are invalid\n   * else: nearest preceding line of the same language\n   */\n\n\n  LanguageConfigurationRegistryImpl.prototype.getPrecedingValidLine = function (model, lineNumber, indentRulesSupport) {\n    var languageID = model.getLanguageIdAtPosition(lineNumber, 0);\n\n    if (lineNumber > 1) {\n      var lastLineNumber = void 0;\n      var resultLineNumber = -1;\n\n      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n        if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {\n          return resultLineNumber;\n        }\n\n        var text = model.getLineContent(lastLineNumber);\n\n        if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n          resultLineNumber = lastLineNumber;\n          continue;\n        }\n\n        return lastLineNumber;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Get inherited indentation from above lines.\n   * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n   * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n   * 3. If this line doesn't match any indent rules\n   *   a. check whether the line above it matches indentNextLinePattern\n   *   b. If not, the indent level of this line is the result\n   *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n   * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n   *\n   * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n   */\n\n\n  LanguageConfigurationRegistryImpl.prototype.getInheritIndentForLine = function (model, lineNumber, honorIntentialIndent) {\n    if (honorIntentialIndent === void 0) {\n      honorIntentialIndent = true;\n    }\n\n    var indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    if (lineNumber <= 1) {\n      return {\n        indentation: '',\n        action: null\n      };\n    }\n\n    var precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n\n    if (precedingUnIgnoredLine < 0) {\n      return null;\n    } else if (precedingUnIgnoredLine < 1) {\n      return {\n        indentation: '',\n        action: null\n      };\n    }\n\n    var precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n\n    if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n      return {\n        indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n        action: IndentAction.Indent,\n        line: precedingUnIgnoredLine\n      };\n    } else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n      return {\n        indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n        action: null,\n        line: precedingUnIgnoredLine\n      };\n    } else {\n      // precedingUnIgnoredLine can not be ignored.\n      // it doesn't increase indent of following lines\n      // it doesn't increase just next line\n      // so current line is not affect by precedingUnIgnoredLine\n      // and then we should get a correct inheritted indentation from above lines\n      if (precedingUnIgnoredLine === 1) {\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n          action: null,\n          line: precedingUnIgnoredLine\n        };\n      }\n\n      var previousLine = precedingUnIgnoredLine - 1;\n      var previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n\n      if (!(previousLineIndentMetadata & (1\n      /* INCREASE_MASK */\n      | 2\n      /* DECREASE_MASK */\n      )) && previousLineIndentMetadata & 4\n      /* INDENT_NEXTLINE_MASK */\n      ) {\n        var stopLine = 0;\n\n        for (var i = previousLine - 1; i > 0; i--) {\n          if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n            continue;\n          }\n\n          stopLine = i;\n          break;\n        }\n\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n          action: null,\n          line: stopLine + 1\n        };\n      }\n\n      if (honorIntentialIndent) {\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n          action: null,\n          line: precedingUnIgnoredLine\n        };\n      } else {\n        // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n        for (var i = precedingUnIgnoredLine; i > 0; i--) {\n          var lineContent = model.getLineContent(i);\n\n          if (indentRulesSupport.shouldIncrease(lineContent)) {\n            return {\n              indentation: strings.getLeadingWhitespace(lineContent),\n              action: IndentAction.Indent,\n              line: i\n            };\n          } else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n            var stopLine = 0;\n\n            for (var j = i - 1; j > 0; j--) {\n              if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                continue;\n              }\n\n              stopLine = j;\n              break;\n            }\n\n            return {\n              indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n              action: null,\n              line: stopLine + 1\n            };\n          } else if (indentRulesSupport.shouldDecrease(lineContent)) {\n            return {\n              indentation: strings.getLeadingWhitespace(lineContent),\n              action: null,\n              line: i\n            };\n          }\n        }\n\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n          action: null,\n          line: 1\n        };\n      }\n    }\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.getGoodIndentForLine = function (virtualModel, languageId, lineNumber, indentConverter) {\n    var indentRulesSupport = this.getIndentRulesSupport(languageId);\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    var indent = this.getInheritIndentForLine(virtualModel, lineNumber);\n    var lineContent = virtualModel.getLineContent(lineNumber);\n\n    if (indent) {\n      var inheritLine = indent.line;\n\n      if (inheritLine !== undefined) {\n        var onEnterSupport = this._getOnEnterSupport(languageId);\n\n        var enterResult = null;\n\n        try {\n          if (onEnterSupport) {\n            enterResult = onEnterSupport.onEnter('', virtualModel.getLineContent(inheritLine), '');\n          }\n        } catch (e) {\n          onUnexpectedError(e);\n        }\n\n        if (enterResult) {\n          var indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n\n          if (enterResult.removeText) {\n            indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n          }\n\n          if (enterResult.indentAction === IndentAction.Indent || enterResult.indentAction === IndentAction.IndentOutdent) {\n            indentation = indentConverter.shiftIndent(indentation);\n          } else if (enterResult.indentAction === IndentAction.Outdent) {\n            indentation = indentConverter.unshiftIndent(indentation);\n          }\n\n          if (indentRulesSupport.shouldDecrease(lineContent)) {\n            indentation = indentConverter.unshiftIndent(indentation);\n          }\n\n          if (enterResult.appendText) {\n            indentation += enterResult.appendText;\n          }\n\n          return strings.getLeadingWhitespace(indentation);\n        }\n      }\n\n      if (indentRulesSupport.shouldDecrease(lineContent)) {\n        if (indent.action === IndentAction.Indent) {\n          return indent.indentation;\n        } else {\n          return indentConverter.unshiftIndent(indent.indentation);\n        }\n      } else {\n        if (indent.action === IndentAction.Indent) {\n          return indentConverter.shiftIndent(indent.indentation);\n        } else {\n          return indent.indentation;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.getIndentForEnter = function (model, range, indentConverter, autoIndent) {\n    model.forceTokenization(range.startLineNumber);\n    var lineTokens = model.getLineTokens(range.startLineNumber);\n    var beforeEnterText;\n    var afterEnterText;\n    var scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n    var scopedLineText = scopedLineTokens.getLineContent();\n    var embeddedLanguage = false;\n\n    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n      // we are in the embeded language content\n      embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n\n      beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n    }\n\n    if (range.isEmpty()) {\n      afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n      afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n\n    var indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    var beforeEnterResult = beforeEnterText;\n    var beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n\n    if (!autoIndent && !embeddedLanguage) {\n      var beforeEnterIndentAction = this.getInheritIndentForLine(model, range.startLineNumber);\n\n      if (indentRulesSupport.shouldDecrease(beforeEnterText)) {\n        if (beforeEnterIndentAction) {\n          beforeEnterIndent = beforeEnterIndentAction.indentation;\n\n          if (beforeEnterIndentAction.action !== IndentAction.Indent) {\n            beforeEnterIndent = indentConverter.unshiftIndent(beforeEnterIndent);\n          }\n        }\n      }\n\n      beforeEnterResult = beforeEnterIndent + strings.ltrim(strings.ltrim(beforeEnterText, ' '), '\\t');\n    }\n\n    var virtualModel = {\n      getLineTokens: function (lineNumber) {\n        return model.getLineTokens(lineNumber);\n      },\n      getLanguageIdentifier: function () {\n        return model.getLanguageIdentifier();\n      },\n      getLanguageIdAtPosition: function (lineNumber, column) {\n        return model.getLanguageIdAtPosition(lineNumber, column);\n      },\n      getLineContent: function (lineNumber) {\n        if (lineNumber === range.startLineNumber) {\n          return beforeEnterResult;\n        } else {\n          return model.getLineContent(lineNumber);\n        }\n      }\n    };\n    var currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n    var afterEnterAction = this.getInheritIndentForLine(virtualModel, range.startLineNumber + 1);\n\n    if (!afterEnterAction) {\n      var beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n      return {\n        beforeEnter: beforeEnter,\n        afterEnter: beforeEnter\n      };\n    }\n\n    var afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n\n    if (afterEnterAction.action === IndentAction.Indent) {\n      afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n    }\n\n    if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n      afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n    }\n\n    return {\n      beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n      afterEnter: afterEnterIndent\n    };\n  };\n  /**\n   * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n   * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n   */\n\n\n  LanguageConfigurationRegistryImpl.prototype.getIndentActionForType = function (model, range, ch, indentConverter) {\n    var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    var indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    var scopedLineText = scopedLineTokens.getLineContent();\n    var beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    var afterTypeText; // selection support\n\n    if (range.isEmpty()) {\n      afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n      afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    } // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n    // Users might change the indentation by purpose and we should honor that instead of readjusting.\n\n\n    if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n      // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n      // 1. Get inherited indent action\n      var r = this.getInheritIndentForLine(model, range.startLineNumber, false);\n\n      if (!r) {\n        return null;\n      }\n\n      var indentation = r.indentation;\n\n      if (r.action !== IndentAction.Indent) {\n        indentation = indentConverter.unshiftIndent(indentation);\n      }\n\n      return indentation;\n    }\n\n    return null;\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.getIndentMetadata = function (model, lineNumber) {\n    var indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n\n    if (!indentRulesSupport) {\n      return null;\n    }\n\n    if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n      return null;\n    }\n\n    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n  }; // end Indent Rules\n  // begin onEnter\n\n\n  LanguageConfigurationRegistryImpl.prototype._getOnEnterSupport = function (languageId) {\n    var value = this._getRichEditSupport(languageId);\n\n    if (!value) {\n      return null;\n    }\n\n    return value.onEnter || null;\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.getRawEnterActionAtPosition = function (model, lineNumber, column) {\n    var r = this.getEnterAction(model, new Range(lineNumber, column, lineNumber, column));\n    return r ? r.enterAction : null;\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.getEnterAction = function (model, range) {\n    var indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n\n    var onEnterSupport = this._getOnEnterSupport(scopedLineTokens.languageId);\n\n    if (!onEnterSupport) {\n      return null;\n    }\n\n    var scopedLineText = scopedLineTokens.getLineContent();\n    var beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    var afterEnterText; // selection support\n\n    if (range.isEmpty()) {\n      afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n      afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n\n    var lineNumber = range.startLineNumber;\n    var oneLineAboveText = '';\n\n    if (lineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n      // This is not the first line and the entire line belongs to this mode\n      var oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, lineNumber - 1);\n\n      if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n        // The line above ends with text belonging to the same mode\n        oneLineAboveText = oneLineAboveScopedLineTokens.getLineContent();\n      }\n    }\n\n    var enterResult = null;\n\n    try {\n      enterResult = onEnterSupport.onEnter(oneLineAboveText, beforeEnterText, afterEnterText);\n    } catch (e) {\n      onUnexpectedError(e);\n    }\n\n    if (!enterResult) {\n      return null;\n    } else {\n      // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n      if (!enterResult.appendText) {\n        if (enterResult.indentAction === IndentAction.Indent || enterResult.indentAction === IndentAction.IndentOutdent) {\n          enterResult.appendText = '\\t';\n        } else {\n          enterResult.appendText = '';\n        }\n      }\n    }\n\n    if (enterResult.removeText) {\n      indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n    }\n\n    return {\n      enterAction: enterResult,\n      indentation: indentation\n    };\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.getIndentationAtPosition = function (model, lineNumber, column) {\n    var lineText = model.getLineContent(lineNumber);\n    var indentation = strings.getLeadingWhitespace(lineText);\n\n    if (indentation.length > column - 1) {\n      indentation = indentation.substring(0, column - 1);\n    }\n\n    return indentation;\n  };\n\n  LanguageConfigurationRegistryImpl.prototype.getScopedLineTokens = function (model, lineNumber, columnNumber) {\n    model.forceTokenization(lineNumber);\n    var lineTokens = model.getLineTokens(lineNumber);\n    var column = typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1;\n    var scopedLineTokens = createScopedLineTokens(lineTokens, column);\n    return scopedLineTokens;\n  }; // end onEnter\n\n\n  LanguageConfigurationRegistryImpl.prototype.getBracketsSupport = function (languageId) {\n    var value = this._getRichEditSupport(languageId);\n\n    if (!value) {\n      return null;\n    }\n\n    return value.brackets || null;\n  };\n\n  return LanguageConfigurationRegistryImpl;\n}();\n\nexport { LanguageConfigurationRegistryImpl };\nexport var LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();","map":null,"metadata":{},"sourceType":"module"}