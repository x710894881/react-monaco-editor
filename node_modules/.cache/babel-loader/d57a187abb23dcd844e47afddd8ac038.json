{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint32 } from '../core/uint.js';\n\nvar PrefixSumIndexOfResult =\n/** @class */\nfunction () {\n  function PrefixSumIndexOfResult(index, remainder) {\n    this.index = index;\n    this.remainder = remainder;\n  }\n\n  return PrefixSumIndexOfResult;\n}();\n\nexport { PrefixSumIndexOfResult };\n\nvar PrefixSumComputer =\n/** @class */\nfunction () {\n  function PrefixSumComputer(values) {\n    this.values = values;\n    this.prefixSum = new Uint32Array(values.length);\n    this.prefixSumValidIndex = new Int32Array(1);\n    this.prefixSumValidIndex[0] = -1;\n  }\n\n  PrefixSumComputer.prototype.getCount = function () {\n    return this.values.length;\n  };\n\n  PrefixSumComputer.prototype.insertValues = function (insertIndex, insertValues) {\n    insertIndex = toUint32(insertIndex);\n    var oldValues = this.values;\n    var oldPrefixSum = this.prefixSum;\n    var insertValuesLen = insertValues.length;\n\n    if (insertValuesLen === 0) {\n      return false;\n    }\n\n    this.values = new Uint32Array(oldValues.length + insertValuesLen);\n    this.values.set(oldValues.subarray(0, insertIndex), 0);\n    this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n    this.values.set(insertValues, insertIndex);\n\n    if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n      this.prefixSumValidIndex[0] = insertIndex - 1;\n    }\n\n    this.prefixSum = new Uint32Array(this.values.length);\n\n    if (this.prefixSumValidIndex[0] >= 0) {\n      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n    }\n\n    return true;\n  };\n\n  PrefixSumComputer.prototype.changeValue = function (index, value) {\n    index = toUint32(index);\n    value = toUint32(value);\n\n    if (this.values[index] === value) {\n      return false;\n    }\n\n    this.values[index] = value;\n\n    if (index - 1 < this.prefixSumValidIndex[0]) {\n      this.prefixSumValidIndex[0] = index - 1;\n    }\n\n    return true;\n  };\n\n  PrefixSumComputer.prototype.removeValues = function (startIndex, cnt) {\n    startIndex = toUint32(startIndex);\n    cnt = toUint32(cnt);\n    var oldValues = this.values;\n    var oldPrefixSum = this.prefixSum;\n\n    if (startIndex >= oldValues.length) {\n      return false;\n    }\n\n    var maxCnt = oldValues.length - startIndex;\n\n    if (cnt >= maxCnt) {\n      cnt = maxCnt;\n    }\n\n    if (cnt === 0) {\n      return false;\n    }\n\n    this.values = new Uint32Array(oldValues.length - cnt);\n    this.values.set(oldValues.subarray(0, startIndex), 0);\n    this.values.set(oldValues.subarray(startIndex + cnt), startIndex);\n    this.prefixSum = new Uint32Array(this.values.length);\n\n    if (startIndex - 1 < this.prefixSumValidIndex[0]) {\n      this.prefixSumValidIndex[0] = startIndex - 1;\n    }\n\n    if (this.prefixSumValidIndex[0] >= 0) {\n      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n    }\n\n    return true;\n  };\n\n  PrefixSumComputer.prototype.getTotalValue = function () {\n    if (this.values.length === 0) {\n      return 0;\n    }\n\n    return this._getAccumulatedValue(this.values.length - 1);\n  };\n\n  PrefixSumComputer.prototype.getAccumulatedValue = function (index) {\n    if (index < 0) {\n      return 0;\n    }\n\n    index = toUint32(index);\n    return this._getAccumulatedValue(index);\n  };\n\n  PrefixSumComputer.prototype._getAccumulatedValue = function (index) {\n    if (index <= this.prefixSumValidIndex[0]) {\n      return this.prefixSum[index];\n    }\n\n    var startIndex = this.prefixSumValidIndex[0] + 1;\n\n    if (startIndex === 0) {\n      this.prefixSum[0] = this.values[0];\n      startIndex++;\n    }\n\n    if (index >= this.values.length) {\n      index = this.values.length - 1;\n    }\n\n    for (var i = startIndex; i <= index; i++) {\n      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n    }\n\n    this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n    return this.prefixSum[index];\n  };\n\n  PrefixSumComputer.prototype.getIndexOf = function (accumulatedValue) {\n    accumulatedValue = Math.floor(accumulatedValue); //@perf\n    // Compute all sums (to get a fully valid prefixSum)\n\n    this.getTotalValue();\n    var low = 0;\n    var high = this.values.length - 1;\n    var mid = 0;\n    var midStop = 0;\n    var midStart = 0;\n\n    while (low <= high) {\n      mid = low + (high - low) / 2 | 0;\n      midStop = this.prefixSum[mid];\n      midStart = midStop - this.values[mid];\n\n      if (accumulatedValue < midStart) {\n        high = mid - 1;\n      } else if (accumulatedValue >= midStop) {\n        low = mid + 1;\n      } else {\n        break;\n      }\n    }\n\n    return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);\n  };\n\n  return PrefixSumComputer;\n}();\n\nexport { PrefixSumComputer };\n\nvar PrefixSumComputerWithCache =\n/** @class */\nfunction () {\n  function PrefixSumComputerWithCache(values) {\n    this._cacheAccumulatedValueStart = 0;\n    this._cache = null;\n    this._actual = new PrefixSumComputer(values);\n\n    this._bustCache();\n  }\n\n  PrefixSumComputerWithCache.prototype._bustCache = function () {\n    this._cacheAccumulatedValueStart = 0;\n    this._cache = null;\n  };\n\n  PrefixSumComputerWithCache.prototype.insertValues = function (insertIndex, insertValues) {\n    if (this._actual.insertValues(insertIndex, insertValues)) {\n      this._bustCache();\n    }\n  };\n\n  PrefixSumComputerWithCache.prototype.changeValue = function (index, value) {\n    if (this._actual.changeValue(index, value)) {\n      this._bustCache();\n    }\n  };\n\n  PrefixSumComputerWithCache.prototype.removeValues = function (startIndex, cnt) {\n    if (this._actual.removeValues(startIndex, cnt)) {\n      this._bustCache();\n    }\n  };\n\n  PrefixSumComputerWithCache.prototype.getTotalValue = function () {\n    return this._actual.getTotalValue();\n  };\n\n  PrefixSumComputerWithCache.prototype.getAccumulatedValue = function (index) {\n    return this._actual.getAccumulatedValue(index);\n  };\n\n  PrefixSumComputerWithCache.prototype.getIndexOf = function (accumulatedValue) {\n    accumulatedValue = Math.floor(accumulatedValue); //@perf\n\n    if (this._cache !== null) {\n      var cacheIndex = accumulatedValue - this._cacheAccumulatedValueStart;\n\n      if (cacheIndex >= 0 && cacheIndex < this._cache.length) {\n        // Cache hit!\n        return this._cache[cacheIndex];\n      }\n    } // Cache miss!\n\n\n    return this._actual.getIndexOf(accumulatedValue);\n  };\n  /**\n   * Gives a hint that a lot of requests are about to come in for these accumulated values.\n   */\n\n\n  PrefixSumComputerWithCache.prototype.warmUpCache = function (accumulatedValueStart, accumulatedValueEnd) {\n    var newCache = [];\n\n    for (var accumulatedValue = accumulatedValueStart; accumulatedValue <= accumulatedValueEnd; accumulatedValue++) {\n      newCache[accumulatedValue - accumulatedValueStart] = this.getIndexOf(accumulatedValue);\n    }\n\n    this._cache = newCache;\n    this._cacheAccumulatedValueStart = accumulatedValueStart;\n  };\n\n  return PrefixSumComputerWithCache;\n}();\n\nexport { PrefixSumComputerWithCache };","map":null,"metadata":{},"sourceType":"module"}