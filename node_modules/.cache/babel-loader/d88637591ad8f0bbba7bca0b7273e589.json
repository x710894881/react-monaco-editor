{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { IntervalTimer } from '../../../base/common/async.js';\nimport { Disposable, dispose, toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { SimpleWorkerClient, logOnceWebWorkerWarning } from '../../../base/common/worker/simpleWorker.js';\nimport { DefaultWorkerFactory } from '../../../base/worker/defaultWorkerFactory.js';\nimport * as modes from '../modes.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nimport { EditorSimpleWorker } from './editorSimpleWorker.js';\nimport { IModelService } from './modelService.js';\nimport { ITextResourceConfigurationService } from './resourceConfiguration.js';\nimport { regExpFlags } from '../../../base/common/strings.js';\nimport { isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\n/**\n * Stop syncing a model to the worker if it was not needed for 1 min.\n */\n\nvar STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1000;\n/**\n * Stop the worker if it was not needed for 5 min.\n */\n\nvar STOP_WORKER_DELTA_TIME_MS = 5 * 60 * 1000;\n\nfunction canSyncModel(modelService, resource) {\n  var model = modelService.getModel(resource);\n\n  if (!model) {\n    return false;\n  }\n\n  if (model.isTooLargeForSyncing()) {\n    return false;\n  }\n\n  return true;\n}\n\nvar EditorWorkerServiceImpl =\n/** @class */\nfunction (_super) {\n  __extends(EditorWorkerServiceImpl, _super);\n\n  function EditorWorkerServiceImpl(modelService, configurationService, logService) {\n    var _this = _super.call(this) || this;\n\n    _this._modelService = modelService;\n    _this._workerManager = _this._register(new WorkerManager(_this._modelService));\n    _this._logService = logService; // todo@joh make sure this happens only once\n\n    _this._register(modes.LinkProviderRegistry.register('*', {\n      provideLinks: function (model, token) {\n        if (!canSyncModel(_this._modelService, model.uri)) {\n          return Promise.resolve({\n            links: []\n          }); // File too large\n        }\n\n        return _this._workerManager.withWorker().then(function (client) {\n          return client.computeLinks(model.uri);\n        }).then(function (links) {\n          return links && {\n            links: links\n          };\n        });\n      }\n    }));\n\n    _this._register(modes.CompletionProviderRegistry.register('*', new WordBasedCompletionItemProvider(_this._workerManager, configurationService, _this._modelService)));\n\n    return _this;\n  }\n\n  EditorWorkerServiceImpl.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n  };\n\n  EditorWorkerServiceImpl.prototype.canComputeDiff = function (original, modified) {\n    return canSyncModel(this._modelService, original) && canSyncModel(this._modelService, modified);\n  };\n\n  EditorWorkerServiceImpl.prototype.computeDiff = function (original, modified, ignoreTrimWhitespace) {\n    return this._workerManager.withWorker().then(function (client) {\n      return client.computeDiff(original, modified, ignoreTrimWhitespace);\n    });\n  };\n\n  EditorWorkerServiceImpl.prototype.computeMoreMinimalEdits = function (resource, edits) {\n    var _this = this;\n\n    if (isNonEmptyArray(edits)) {\n      if (!canSyncModel(this._modelService, resource)) {\n        return Promise.resolve(edits); // File too large\n      }\n\n      var sw_1 = StopWatch.create(true);\n\n      var result = this._workerManager.withWorker().then(function (client) {\n        return client.computeMoreMinimalEdits(resource, edits);\n      });\n\n      result.finally(function () {\n        return _this._logService.trace('FORMAT#computeMoreMinimalEdits', resource.toString(true), sw_1.elapsed());\n      });\n      return result;\n    } else {\n      return Promise.resolve(undefined);\n    }\n  };\n\n  EditorWorkerServiceImpl.prototype.canNavigateValueSet = function (resource) {\n    return canSyncModel(this._modelService, resource);\n  };\n\n  EditorWorkerServiceImpl.prototype.navigateValueSet = function (resource, range, up) {\n    return this._workerManager.withWorker().then(function (client) {\n      return client.navigateValueSet(resource, range, up);\n    });\n  };\n\n  EditorWorkerServiceImpl.prototype.canComputeWordRanges = function (resource) {\n    return canSyncModel(this._modelService, resource);\n  };\n\n  EditorWorkerServiceImpl.prototype.computeWordRanges = function (resource, range) {\n    return this._workerManager.withWorker().then(function (client) {\n      return client.computeWordRanges(resource, range);\n    });\n  };\n\n  EditorWorkerServiceImpl = __decorate([__param(0, IModelService), __param(1, ITextResourceConfigurationService), __param(2, ILogService)], EditorWorkerServiceImpl);\n  return EditorWorkerServiceImpl;\n}(Disposable);\n\nexport { EditorWorkerServiceImpl };\n\nvar WordBasedCompletionItemProvider =\n/** @class */\nfunction () {\n  function WordBasedCompletionItemProvider(workerManager, configurationService, modelService) {\n    this._debugDisplayName = 'wordbasedCompletions';\n    this._workerManager = workerManager;\n    this._configurationService = configurationService;\n    this._modelService = modelService;\n  }\n\n  WordBasedCompletionItemProvider.prototype.provideCompletionItems = function (model, position) {\n    var wordBasedSuggestions = this._configurationService.getValue(model.uri, position, 'editor').wordBasedSuggestions;\n\n    if (!wordBasedSuggestions) {\n      return undefined;\n    }\n\n    if (!canSyncModel(this._modelService, model.uri)) {\n      return undefined; // File too large\n    }\n\n    return this._workerManager.withWorker().then(function (client) {\n      return client.textualSuggest(model.uri, position);\n    });\n  };\n\n  return WordBasedCompletionItemProvider;\n}();\n\nvar WorkerManager =\n/** @class */\nfunction (_super) {\n  __extends(WorkerManager, _super);\n\n  function WorkerManager(modelService) {\n    var _this = _super.call(this) || this;\n\n    _this._modelService = modelService;\n    _this._editorWorkerClient = null;\n    _this._lastWorkerUsedTime = new Date().getTime();\n\n    var stopWorkerInterval = _this._register(new IntervalTimer());\n\n    stopWorkerInterval.cancelAndSet(function () {\n      return _this._checkStopIdleWorker();\n    }, Math.round(STOP_WORKER_DELTA_TIME_MS / 2));\n\n    _this._register(_this._modelService.onModelRemoved(function (_) {\n      return _this._checkStopEmptyWorker();\n    }));\n\n    return _this;\n  }\n\n  WorkerManager.prototype.dispose = function () {\n    if (this._editorWorkerClient) {\n      this._editorWorkerClient.dispose();\n\n      this._editorWorkerClient = null;\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\n   * Check if the model service has no more models and stop the worker if that is the case.\n   */\n\n\n  WorkerManager.prototype._checkStopEmptyWorker = function () {\n    if (!this._editorWorkerClient) {\n      return;\n    }\n\n    var models = this._modelService.getModels();\n\n    if (models.length === 0) {\n      // There are no more models => nothing possible for me to do\n      this._editorWorkerClient.dispose();\n\n      this._editorWorkerClient = null;\n    }\n  };\n  /**\n   * Check if the worker has been idle for a while and then stop it.\n   */\n\n\n  WorkerManager.prototype._checkStopIdleWorker = function () {\n    if (!this._editorWorkerClient) {\n      return;\n    }\n\n    var timeSinceLastWorkerUsedTime = new Date().getTime() - this._lastWorkerUsedTime;\n\n    if (timeSinceLastWorkerUsedTime > STOP_WORKER_DELTA_TIME_MS) {\n      this._editorWorkerClient.dispose();\n\n      this._editorWorkerClient = null;\n    }\n  };\n\n  WorkerManager.prototype.withWorker = function () {\n    this._lastWorkerUsedTime = new Date().getTime();\n\n    if (!this._editorWorkerClient) {\n      this._editorWorkerClient = new EditorWorkerClient(this._modelService, 'editorWorkerService');\n    }\n\n    return Promise.resolve(this._editorWorkerClient);\n  };\n\n  return WorkerManager;\n}(Disposable);\n\nvar EditorModelManager =\n/** @class */\nfunction (_super) {\n  __extends(EditorModelManager, _super);\n\n  function EditorModelManager(proxy, modelService, keepIdleModels) {\n    var _this = _super.call(this) || this;\n\n    _this._syncedModels = Object.create(null);\n    _this._syncedModelsLastUsedTime = Object.create(null);\n    _this._proxy = proxy;\n    _this._modelService = modelService;\n\n    if (!keepIdleModels) {\n      var timer = new IntervalTimer();\n      timer.cancelAndSet(function () {\n        return _this._checkStopModelSync();\n      }, Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));\n\n      _this._register(timer);\n    }\n\n    return _this;\n  }\n\n  EditorModelManager.prototype.dispose = function () {\n    for (var modelUrl in this._syncedModels) {\n      dispose(this._syncedModels[modelUrl]);\n    }\n\n    this._syncedModels = Object.create(null);\n    this._syncedModelsLastUsedTime = Object.create(null);\n\n    _super.prototype.dispose.call(this);\n  };\n\n  EditorModelManager.prototype.ensureSyncedResources = function (resources) {\n    for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {\n      var resource = resources_1[_i];\n      var resourceStr = resource.toString();\n\n      if (!this._syncedModels[resourceStr]) {\n        this._beginModelSync(resource);\n      }\n\n      if (this._syncedModels[resourceStr]) {\n        this._syncedModelsLastUsedTime[resourceStr] = new Date().getTime();\n      }\n    }\n  };\n\n  EditorModelManager.prototype._checkStopModelSync = function () {\n    var currentTime = new Date().getTime();\n    var toRemove = [];\n\n    for (var modelUrl in this._syncedModelsLastUsedTime) {\n      var elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];\n\n      if (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {\n        toRemove.push(modelUrl);\n      }\n    }\n\n    for (var _i = 0, toRemove_1 = toRemove; _i < toRemove_1.length; _i++) {\n      var e = toRemove_1[_i];\n\n      this._stopModelSync(e);\n    }\n  };\n\n  EditorModelManager.prototype._beginModelSync = function (resource) {\n    var _this = this;\n\n    var model = this._modelService.getModel(resource);\n\n    if (!model) {\n      return;\n    }\n\n    if (model.isTooLargeForSyncing()) {\n      return;\n    }\n\n    var modelUrl = resource.toString();\n\n    this._proxy.acceptNewModel({\n      url: model.uri.toString(),\n      lines: model.getLinesContent(),\n      EOL: model.getEOL(),\n      versionId: model.getVersionId()\n    });\n\n    var toDispose = new DisposableStore();\n    toDispose.add(model.onDidChangeContent(function (e) {\n      _this._proxy.acceptModelChanged(modelUrl.toString(), e);\n    }));\n    toDispose.add(model.onWillDispose(function () {\n      _this._stopModelSync(modelUrl);\n    }));\n    toDispose.add(toDisposable(function () {\n      _this._proxy.acceptRemovedModel(modelUrl);\n    }));\n    this._syncedModels[modelUrl] = toDispose;\n  };\n\n  EditorModelManager.prototype._stopModelSync = function (modelUrl) {\n    var toDispose = this._syncedModels[modelUrl];\n    delete this._syncedModels[modelUrl];\n    delete this._syncedModelsLastUsedTime[modelUrl];\n    dispose(toDispose);\n  };\n\n  return EditorModelManager;\n}(Disposable);\n\nvar SynchronousWorkerClient =\n/** @class */\nfunction () {\n  function SynchronousWorkerClient(instance) {\n    this._instance = instance;\n    this._proxyObj = Promise.resolve(this._instance);\n  }\n\n  SynchronousWorkerClient.prototype.dispose = function () {\n    this._instance.dispose();\n  };\n\n  SynchronousWorkerClient.prototype.getProxyObject = function () {\n    return this._proxyObj;\n  };\n\n  return SynchronousWorkerClient;\n}();\n\nvar EditorWorkerHost =\n/** @class */\nfunction () {\n  function EditorWorkerHost(workerClient) {\n    this._workerClient = workerClient;\n  } // foreign host request\n\n\n  EditorWorkerHost.prototype.fhr = function (method, args) {\n    return this._workerClient.fhr(method, args);\n  };\n\n  return EditorWorkerHost;\n}();\n\nexport { EditorWorkerHost };\n\nvar EditorWorkerClient =\n/** @class */\nfunction (_super) {\n  __extends(EditorWorkerClient, _super);\n\n  function EditorWorkerClient(modelService, label) {\n    var _this = _super.call(this) || this;\n\n    _this._modelService = modelService;\n    _this._workerFactory = new DefaultWorkerFactory(label);\n    _this._worker = null;\n    _this._modelManager = null;\n    return _this;\n  } // foreign host request\n\n\n  EditorWorkerClient.prototype.fhr = function (method, args) {\n    throw new Error(\"Not implemented!\");\n  };\n\n  EditorWorkerClient.prototype._getOrCreateWorker = function () {\n    if (!this._worker) {\n      try {\n        this._worker = this._register(new SimpleWorkerClient(this._workerFactory, 'vs/editor/common/services/editorSimpleWorker', new EditorWorkerHost(this)));\n      } catch (err) {\n        logOnceWebWorkerWarning(err);\n        this._worker = new SynchronousWorkerClient(new EditorSimpleWorker(new EditorWorkerHost(this), null));\n      }\n    }\n\n    return this._worker;\n  };\n\n  EditorWorkerClient.prototype._getProxy = function () {\n    var _this = this;\n\n    return this._getOrCreateWorker().getProxyObject().then(undefined, function (err) {\n      logOnceWebWorkerWarning(err);\n      _this._worker = new SynchronousWorkerClient(new EditorSimpleWorker(new EditorWorkerHost(_this), null));\n      return _this._getOrCreateWorker().getProxyObject();\n    });\n  };\n\n  EditorWorkerClient.prototype._getOrCreateModelManager = function (proxy) {\n    if (!this._modelManager) {\n      this._modelManager = this._register(new EditorModelManager(proxy, this._modelService, false));\n    }\n\n    return this._modelManager;\n  };\n\n  EditorWorkerClient.prototype._withSyncedResources = function (resources) {\n    var _this = this;\n\n    return this._getProxy().then(function (proxy) {\n      _this._getOrCreateModelManager(proxy).ensureSyncedResources(resources);\n\n      return proxy;\n    });\n  };\n\n  EditorWorkerClient.prototype.computeDiff = function (original, modified, ignoreTrimWhitespace) {\n    return this._withSyncedResources([original, modified]).then(function (proxy) {\n      return proxy.computeDiff(original.toString(), modified.toString(), ignoreTrimWhitespace);\n    });\n  };\n\n  EditorWorkerClient.prototype.computeMoreMinimalEdits = function (resource, edits) {\n    return this._withSyncedResources([resource]).then(function (proxy) {\n      return proxy.computeMoreMinimalEdits(resource.toString(), edits);\n    });\n  };\n\n  EditorWorkerClient.prototype.computeLinks = function (resource) {\n    return this._withSyncedResources([resource]).then(function (proxy) {\n      return proxy.computeLinks(resource.toString());\n    });\n  };\n\n  EditorWorkerClient.prototype.textualSuggest = function (resource, position) {\n    var _this = this;\n\n    return this._withSyncedResources([resource]).then(function (proxy) {\n      var model = _this._modelService.getModel(resource);\n\n      if (!model) {\n        return null;\n      }\n\n      var wordDefRegExp = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);\n      var wordDef = wordDefRegExp.source;\n      var wordDefFlags = regExpFlags(wordDefRegExp);\n      return proxy.textualSuggest(resource.toString(), position, wordDef, wordDefFlags);\n    });\n  };\n\n  EditorWorkerClient.prototype.computeWordRanges = function (resource, range) {\n    var _this = this;\n\n    return this._withSyncedResources([resource]).then(function (proxy) {\n      var model = _this._modelService.getModel(resource);\n\n      if (!model) {\n        return Promise.resolve(null);\n      }\n\n      var wordDefRegExp = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);\n      var wordDef = wordDefRegExp.source;\n      var wordDefFlags = regExpFlags(wordDefRegExp);\n      return proxy.computeWordRanges(resource.toString(), range, wordDef, wordDefFlags);\n    });\n  };\n\n  EditorWorkerClient.prototype.navigateValueSet = function (resource, range, up) {\n    var _this = this;\n\n    return this._withSyncedResources([resource]).then(function (proxy) {\n      var model = _this._modelService.getModel(resource);\n\n      if (!model) {\n        return null;\n      }\n\n      var wordDefRegExp = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);\n      var wordDef = wordDefRegExp.source;\n      var wordDefFlags = regExpFlags(wordDefRegExp);\n      return proxy.navigateValueSet(resource.toString(), range, up, wordDef, wordDefFlags);\n    });\n  };\n\n  return EditorWorkerClient;\n}(Disposable);\n\nexport { EditorWorkerClient };","map":null,"metadata":{},"sourceType":"module"}