{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as browser from '../../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { RangeUtil } from './rangeUtil.js';\nimport { HorizontalRange } from '../../../common/view/renderingContext.js';\nimport { LineDecoration } from '../../../common/viewLayout/lineDecorations.js';\nimport { CharacterMapping, RenderLineInput, renderViewLine, LineRange } from '../../../common/viewLayout/viewLineRenderer.js';\nimport { HIGH_CONTRAST } from '../../../../platform/theme/common/themeService.js';\n\nvar canUseFastRenderedViewLine = function () {\n  if (platform.isNative) {\n    // In VSCode we know very well when the zoom level changes\n    return true;\n  }\n\n  if (platform.isLinux || browser.isFirefox || browser.isSafari) {\n    // On Linux, it appears that zooming affects char widths (in pixels), which is unexpected.\n    // --\n    // Even though we read character widths correctly, having read them at a specific zoom level\n    // does not mean they are the same at the current zoom level.\n    // --\n    // This could be improved if we ever figure out how to get an event when browsers zoom,\n    // but until then we have to stick with reading client rects.\n    // --\n    // The same has been observed with Firefox on Windows7\n    // --\n    // The same has been oversved with Safari\n    return false;\n  }\n\n  return true;\n}();\n\nvar alwaysRenderInlineSelection = browser.isEdgeOrIE;\n\nvar DomReadingContext =\n/** @class */\nfunction () {\n  function DomReadingContext(domNode, endNode) {\n    this._domNode = domNode;\n    this._clientRectDeltaLeft = 0;\n    this._clientRectDeltaLeftRead = false;\n    this.endNode = endNode;\n  }\n\n  Object.defineProperty(DomReadingContext.prototype, \"clientRectDeltaLeft\", {\n    get: function () {\n      if (!this._clientRectDeltaLeftRead) {\n        this._clientRectDeltaLeftRead = true;\n        this._clientRectDeltaLeft = this._domNode.getBoundingClientRect().left;\n      }\n\n      return this._clientRectDeltaLeft;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DomReadingContext;\n}();\n\nexport { DomReadingContext };\n\nvar ViewLineOptions =\n/** @class */\nfunction () {\n  function ViewLineOptions(config, themeType) {\n    this.themeType = themeType;\n    this.renderWhitespace = config.editor.viewInfo.renderWhitespace;\n    this.renderControlCharacters = config.editor.viewInfo.renderControlCharacters;\n    this.spaceWidth = config.editor.fontInfo.spaceWidth;\n    this.useMonospaceOptimizations = config.editor.fontInfo.isMonospace && !config.editor.viewInfo.disableMonospaceOptimizations;\n    this.canUseHalfwidthRightwardsArrow = config.editor.fontInfo.canUseHalfwidthRightwardsArrow;\n    this.lineHeight = config.editor.lineHeight;\n    this.stopRenderingLineAfter = config.editor.viewInfo.stopRenderingLineAfter;\n    this.fontLigatures = config.editor.viewInfo.fontLigatures;\n  }\n\n  ViewLineOptions.prototype.equals = function (other) {\n    return this.themeType === other.themeType && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.spaceWidth === other.spaceWidth && this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineHeight === other.lineHeight && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.fontLigatures === other.fontLigatures;\n  };\n\n  return ViewLineOptions;\n}();\n\nexport { ViewLineOptions };\n\nvar ViewLine =\n/** @class */\nfunction () {\n  function ViewLine(options) {\n    this._options = options;\n    this._isMaybeInvalid = true;\n    this._renderedViewLine = null;\n  } // --- begin IVisibleLineData\n\n\n  ViewLine.prototype.getDomNode = function () {\n    if (this._renderedViewLine && this._renderedViewLine.domNode) {\n      return this._renderedViewLine.domNode.domNode;\n    }\n\n    return null;\n  };\n\n  ViewLine.prototype.setDomNode = function (domNode) {\n    if (this._renderedViewLine) {\n      this._renderedViewLine.domNode = createFastDomNode(domNode);\n    } else {\n      throw new Error('I have no rendered view line to set the dom node to...');\n    }\n  };\n\n  ViewLine.prototype.onContentChanged = function () {\n    this._isMaybeInvalid = true;\n  };\n\n  ViewLine.prototype.onTokensChanged = function () {\n    this._isMaybeInvalid = true;\n  };\n\n  ViewLine.prototype.onDecorationsChanged = function () {\n    this._isMaybeInvalid = true;\n  };\n\n  ViewLine.prototype.onOptionsChanged = function (newOptions) {\n    this._isMaybeInvalid = true;\n    this._options = newOptions;\n  };\n\n  ViewLine.prototype.onSelectionChanged = function () {\n    if (alwaysRenderInlineSelection || this._options.themeType === HIGH_CONTRAST || this._options.renderWhitespace === 'selection') {\n      this._isMaybeInvalid = true;\n      return true;\n    }\n\n    return false;\n  };\n\n  ViewLine.prototype.renderLine = function (lineNumber, deltaTop, viewportData, sb) {\n    if (this._isMaybeInvalid === false) {\n      // it appears that nothing relevant has changed\n      return false;\n    }\n\n    this._isMaybeInvalid = false;\n    var lineData = viewportData.getViewLineRenderingData(lineNumber);\n    var options = this._options;\n    var actualInlineDecorations = LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn); // Only send selection information when needed for rendering whitespace\n\n    var selectionsOnLine = null;\n\n    if (alwaysRenderInlineSelection || options.themeType === HIGH_CONTRAST || this._options.renderWhitespace === 'selection') {\n      var selections = viewportData.selections;\n\n      for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {\n        var selection = selections_1[_i];\n\n        if (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {\n          // Selection does not intersect line\n          continue;\n        }\n\n        var startColumn = selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn;\n        var endColumn = selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn;\n\n        if (startColumn < endColumn) {\n          if (this._options.renderWhitespace !== 'selection') {\n            actualInlineDecorations.push(new LineDecoration(startColumn, endColumn, 'inline-selected-text', 0\n            /* Regular */\n            ));\n          } else {\n            if (!selectionsOnLine) {\n              selectionsOnLine = [];\n            }\n\n            selectionsOnLine.push(new LineRange(startColumn - 1, endColumn - 1));\n          }\n        }\n      }\n    }\n\n    var renderLineInput = new RenderLineInput(options.useMonospaceOptimizations, options.canUseHalfwidthRightwardsArrow, lineData.content, lineData.continuesWithWrappedLine, lineData.isBasicASCII, lineData.containsRTL, lineData.minColumn - 1, lineData.tokens, actualInlineDecorations, lineData.tabSize, options.spaceWidth, options.stopRenderingLineAfter, options.renderWhitespace, options.renderControlCharacters, options.fontLigatures, selectionsOnLine);\n\n    if (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {\n      // no need to do anything, we have the same render input\n      return false;\n    }\n\n    sb.appendASCIIString('<div style=\"top:');\n    sb.appendASCIIString(String(deltaTop));\n    sb.appendASCIIString('px;height:');\n    sb.appendASCIIString(String(this._options.lineHeight));\n    sb.appendASCIIString('px;\" class=\"');\n    sb.appendASCIIString(ViewLine.CLASS_NAME);\n    sb.appendASCIIString('\">');\n    var output = renderViewLine(renderLineInput, sb);\n    sb.appendASCIIString('</div>');\n    var renderedViewLine = null;\n\n    if (canUseFastRenderedViewLine && lineData.isBasicASCII && options.useMonospaceOptimizations && output.containsForeignElements === 0\n    /* None */\n    ) {\n        if (lineData.content.length < 300 && renderLineInput.lineTokens.getCount() < 100) {\n          // Browser rounding errors have been observed in Chrome and IE, so using the fast\n          // view line only for short lines. Please test before removing the length check...\n          // ---\n          // Another rounding error has been observed on Linux in VSCode, where <span> width\n          // rounding errors add up to an observable large number...\n          // ---\n          // Also see another example of rounding errors on Windows in\n          // https://github.com/Microsoft/vscode/issues/33178\n          renderedViewLine = new FastRenderedViewLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping);\n        }\n      }\n\n    if (!renderedViewLine) {\n      renderedViewLine = createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping, output.containsRTL, output.containsForeignElements);\n    }\n\n    this._renderedViewLine = renderedViewLine;\n    return true;\n  };\n\n  ViewLine.prototype.layoutLine = function (lineNumber, deltaTop) {\n    if (this._renderedViewLine && this._renderedViewLine.domNode) {\n      this._renderedViewLine.domNode.setTop(deltaTop);\n\n      this._renderedViewLine.domNode.setHeight(this._options.lineHeight);\n    }\n  }; // --- end IVisibleLineData\n\n\n  ViewLine.prototype.getWidth = function () {\n    if (!this._renderedViewLine) {\n      return 0;\n    }\n\n    return this._renderedViewLine.getWidth();\n  };\n\n  ViewLine.prototype.getWidthIsFast = function () {\n    if (!this._renderedViewLine) {\n      return true;\n    }\n\n    return this._renderedViewLine.getWidthIsFast();\n  };\n\n  ViewLine.prototype.getVisibleRangesForRange = function (startColumn, endColumn, context) {\n    if (!this._renderedViewLine) {\n      return null;\n    }\n\n    startColumn = startColumn | 0; // @perf\n\n    endColumn = endColumn | 0; // @perf\n\n    startColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));\n    endColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));\n    var stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter | 0; // @perf\n\n    if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter && endColumn > stopRenderingLineAfter) {\n      // This range is obviously not visible\n      return null;\n    }\n\n    if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter) {\n      startColumn = stopRenderingLineAfter;\n    }\n\n    if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter) {\n      endColumn = stopRenderingLineAfter;\n    }\n\n    return this._renderedViewLine.getVisibleRangesForRange(startColumn, endColumn, context);\n  };\n\n  ViewLine.prototype.getColumnOfNodeOffset = function (lineNumber, spanNode, offset) {\n    if (!this._renderedViewLine) {\n      return 1;\n    }\n\n    return this._renderedViewLine.getColumnOfNodeOffset(lineNumber, spanNode, offset);\n  };\n\n  ViewLine.CLASS_NAME = 'view-line';\n  return ViewLine;\n}();\n\nexport { ViewLine };\n/**\n * A rendered line which is guaranteed to contain only regular ASCII and is rendered with a monospace font.\n */\n\nvar FastRenderedViewLine =\n/** @class */\nfunction () {\n  function FastRenderedViewLine(domNode, renderLineInput, characterMapping) {\n    this.domNode = domNode;\n    this.input = renderLineInput;\n    this._characterMapping = characterMapping;\n    this._charWidth = renderLineInput.spaceWidth;\n  }\n\n  FastRenderedViewLine.prototype.getWidth = function () {\n    return this._getCharPosition(this._characterMapping.length);\n  };\n\n  FastRenderedViewLine.prototype.getWidthIsFast = function () {\n    return true;\n  };\n\n  FastRenderedViewLine.prototype.getVisibleRangesForRange = function (startColumn, endColumn, context) {\n    var startPosition = this._getCharPosition(startColumn);\n\n    var endPosition = this._getCharPosition(endColumn);\n\n    return [new HorizontalRange(startPosition, endPosition - startPosition)];\n  };\n\n  FastRenderedViewLine.prototype._getCharPosition = function (column) {\n    var charOffset = this._characterMapping.getAbsoluteOffsets();\n\n    if (charOffset.length === 0) {\n      // No characters on this line\n      return 0;\n    }\n\n    return Math.round(this._charWidth * charOffset[column - 1]);\n  };\n\n  FastRenderedViewLine.prototype.getColumnOfNodeOffset = function (lineNumber, spanNode, offset) {\n    var spanNodeTextContentLength = spanNode.textContent.length;\n    var spanIndex = -1;\n\n    while (spanNode) {\n      spanNode = spanNode.previousSibling;\n      spanIndex++;\n    }\n\n    var charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);\n\n    return charOffset + 1;\n  };\n\n  return FastRenderedViewLine;\n}();\n/**\n * Every time we render a line, we save what we have rendered in an instance of this class.\n */\n\n\nvar RenderedViewLine =\n/** @class */\nfunction () {\n  function RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n    this.domNode = domNode;\n    this.input = renderLineInput;\n    this._characterMapping = characterMapping;\n    this._isWhitespaceOnly = /^\\s*$/.test(renderLineInput.lineContent);\n    this._containsForeignElements = containsForeignElements;\n    this._cachedWidth = -1;\n    this._pixelOffsetCache = null;\n\n    if (!containsRTL || this._characterMapping.length === 0\n    /* the line is empty */\n    ) {\n        this._pixelOffsetCache = new Int32Array(Math.max(2, this._characterMapping.length + 1));\n\n        for (var column = 0, len = this._characterMapping.length; column <= len; column++) {\n          this._pixelOffsetCache[column] = -1;\n        }\n      }\n  } // --- Reading from the DOM methods\n\n\n  RenderedViewLine.prototype._getReadingTarget = function () {\n    return this.domNode.domNode.firstChild;\n  };\n  /**\n   * Width of the line in pixels\n   */\n\n\n  RenderedViewLine.prototype.getWidth = function () {\n    if (this._cachedWidth === -1) {\n      this._cachedWidth = this._getReadingTarget().offsetWidth;\n    }\n\n    return this._cachedWidth;\n  };\n\n  RenderedViewLine.prototype.getWidthIsFast = function () {\n    if (this._cachedWidth === -1) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Visible ranges for a model range\n   */\n\n\n  RenderedViewLine.prototype.getVisibleRangesForRange = function (startColumn, endColumn, context) {\n    if (this._pixelOffsetCache !== null) {\n      // the text is LTR\n      var startOffset = this._readPixelOffset(startColumn, context);\n\n      if (startOffset === -1) {\n        return null;\n      }\n\n      var endOffset = this._readPixelOffset(endColumn, context);\n\n      if (endOffset === -1) {\n        return null;\n      }\n\n      return [new HorizontalRange(startOffset, endOffset - startOffset)];\n    }\n\n    return this._readVisibleRangesForRange(startColumn, endColumn, context);\n  };\n\n  RenderedViewLine.prototype._readVisibleRangesForRange = function (startColumn, endColumn, context) {\n    if (startColumn === endColumn) {\n      var pixelOffset = this._readPixelOffset(startColumn, context);\n\n      if (pixelOffset === -1) {\n        return null;\n      } else {\n        return [new HorizontalRange(pixelOffset, 0)];\n      }\n    } else {\n      return this._readRawVisibleRangesForRange(startColumn, endColumn, context);\n    }\n  };\n\n  RenderedViewLine.prototype._readPixelOffset = function (column, context) {\n    if (this._characterMapping.length === 0) {\n      // This line has no content\n      if (this._containsForeignElements === 0\n      /* None */\n      ) {\n          // We can assume the line is really empty\n          return 0;\n        }\n\n      if (this._containsForeignElements === 2\n      /* After */\n      ) {\n          // We have foreign elements after the (empty) line\n          return 0;\n        }\n\n      if (this._containsForeignElements === 1\n      /* Before */\n      ) {\n          // We have foreign element before the (empty) line\n          return this.getWidth();\n        }\n    }\n\n    if (this._pixelOffsetCache !== null) {\n      // the text is LTR\n      var cachedPixelOffset = this._pixelOffsetCache[column];\n\n      if (cachedPixelOffset !== -1) {\n        return cachedPixelOffset;\n      }\n\n      var result = this._actualReadPixelOffset(column, context);\n\n      this._pixelOffsetCache[column] = result;\n      return result;\n    }\n\n    return this._actualReadPixelOffset(column, context);\n  };\n\n  RenderedViewLine.prototype._actualReadPixelOffset = function (column, context) {\n    if (this._characterMapping.length === 0) {\n      // This line has no content\n      var r_1 = RangeUtil.readHorizontalRanges(this._getReadingTarget(), 0, 0, 0, 0, context.clientRectDeltaLeft, context.endNode);\n\n      if (!r_1 || r_1.length === 0) {\n        return -1;\n      }\n\n      return r_1[0].left;\n    }\n\n    if (column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0\n    /* None */\n    ) {\n        // This branch helps in the case of whitespace only lines which have a width set\n        return this.getWidth();\n      }\n\n    var partData = this._characterMapping.charOffsetToPartData(column - 1);\n\n    var partIndex = CharacterMapping.getPartIndex(partData);\n    var charOffsetInPart = CharacterMapping.getCharIndex(partData);\n    var r = RangeUtil.readHorizontalRanges(this._getReadingTarget(), partIndex, charOffsetInPart, partIndex, charOffsetInPart, context.clientRectDeltaLeft, context.endNode);\n\n    if (!r || r.length === 0) {\n      return -1;\n    }\n\n    return r[0].left;\n  };\n\n  RenderedViewLine.prototype._readRawVisibleRangesForRange = function (startColumn, endColumn, context) {\n    if (startColumn === 1 && endColumn === this._characterMapping.length) {\n      // This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line\n      return [new HorizontalRange(0, this.getWidth())];\n    }\n\n    var startPartData = this._characterMapping.charOffsetToPartData(startColumn - 1);\n\n    var startPartIndex = CharacterMapping.getPartIndex(startPartData);\n    var startCharOffsetInPart = CharacterMapping.getCharIndex(startPartData);\n\n    var endPartData = this._characterMapping.charOffsetToPartData(endColumn - 1);\n\n    var endPartIndex = CharacterMapping.getPartIndex(endPartData);\n    var endCharOffsetInPart = CharacterMapping.getCharIndex(endPartData);\n    return RangeUtil.readHorizontalRanges(this._getReadingTarget(), startPartIndex, startCharOffsetInPart, endPartIndex, endCharOffsetInPart, context.clientRectDeltaLeft, context.endNode);\n  };\n  /**\n   * Returns the column for the text found at a specific offset inside a rendered dom node\n   */\n\n\n  RenderedViewLine.prototype.getColumnOfNodeOffset = function (lineNumber, spanNode, offset) {\n    var spanNodeTextContentLength = spanNode.textContent.length;\n    var spanIndex = -1;\n\n    while (spanNode) {\n      spanNode = spanNode.previousSibling;\n      spanIndex++;\n    }\n\n    var charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);\n\n    return charOffset + 1;\n  };\n\n  return RenderedViewLine;\n}();\n\nvar WebKitRenderedViewLine =\n/** @class */\nfunction (_super) {\n  __extends(WebKitRenderedViewLine, _super);\n\n  function WebKitRenderedViewLine() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  WebKitRenderedViewLine.prototype._readVisibleRangesForRange = function (startColumn, endColumn, context) {\n    var output = _super.prototype._readVisibleRangesForRange.call(this, startColumn, endColumn, context);\n\n    if (!output || output.length === 0 || startColumn === endColumn || startColumn === 1 && endColumn === this._characterMapping.length) {\n      return output;\n    } // WebKit is buggy and returns an expanded range (to contain words in some cases)\n    // The last client rect is enlarged (I think)\n\n\n    if (!this.input.containsRTL) {\n      // This is an attempt to patch things up\n      // Find position of last column\n      var endPixelOffset = this._readPixelOffset(endColumn, context);\n\n      if (endPixelOffset !== -1) {\n        var lastRange = output[output.length - 1];\n\n        if (lastRange.left < endPixelOffset) {\n          // Trim down the width of the last visible range to not go after the last column's position\n          lastRange.width = endPixelOffset - lastRange.left;\n        }\n      }\n    }\n\n    return output;\n  };\n\n  return WebKitRenderedViewLine;\n}(RenderedViewLine);\n\nvar createRenderedLine = function () {\n  if (browser.isWebKit) {\n    return createWebKitRenderedLine;\n  }\n\n  return createNormalRenderedLine;\n}();\n\nfunction createWebKitRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n  return new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}\n\nfunction createNormalRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n  return new RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}","map":null,"metadata":{},"sourceType":"module"}