{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as Json from '../../jsonc-parser/main.js';\nimport { isNumber, equals, isBoolean, isString, isDefined } from '../utils/objects.js';\nimport { ErrorCode } from '../jsonLanguageTypes.js';\nimport * as nls from '../../../fillers/vscode-nls.js';\nimport { Diagnostic, DiagnosticSeverity, Range } from '../_deps/vscode-languageserver-types/main.js';\nvar localize = nls.loadMessageBundle();\nvar formats = {\n  'color-hex': {\n    errorMessage: localize('colorHexFormatWarning', 'Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.'),\n    pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/\n  },\n  'date-time': {\n    errorMessage: localize('dateTimeFormatWarning', 'String is not a RFC3339 date-time.'),\n    pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i\n  },\n  'date': {\n    errorMessage: localize('dateFormatWarning', 'String is not a RFC3339 date.'),\n    pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i\n  },\n  'time': {\n    errorMessage: localize('timeFormatWarning', 'String is not a RFC3339 time.'),\n    pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i\n  },\n  'email': {\n    errorMessage: localize('emailFormatWarning', 'String is not an e-mail address.'),\n    pattern: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n  }\n};\n\nvar ASTNodeImpl =\n/** @class */\nfunction () {\n  function ASTNodeImpl(parent, offset, length) {\n    this.offset = offset;\n    this.length = length;\n    this.parent = parent;\n  }\n\n  Object.defineProperty(ASTNodeImpl.prototype, \"children\", {\n    get: function () {\n      return [];\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ASTNodeImpl.prototype.toString = function () {\n    return 'type: ' + this.type + ' (' + this.offset + '/' + this.length + ')' + (this.parent ? ' parent: {' + this.parent.toString() + '}' : '');\n  };\n\n  return ASTNodeImpl;\n}();\n\nexport { ASTNodeImpl };\n\nvar NullASTNodeImpl =\n/** @class */\nfunction (_super) {\n  __extends(NullASTNodeImpl, _super);\n\n  function NullASTNodeImpl(parent, offset) {\n    var _this = _super.call(this, parent, offset) || this;\n\n    _this.type = 'null';\n    _this.value = null;\n    return _this;\n  }\n\n  return NullASTNodeImpl;\n}(ASTNodeImpl);\n\nexport { NullASTNodeImpl };\n\nvar BooleanASTNodeImpl =\n/** @class */\nfunction (_super) {\n  __extends(BooleanASTNodeImpl, _super);\n\n  function BooleanASTNodeImpl(parent, boolValue, offset) {\n    var _this = _super.call(this, parent, offset) || this;\n\n    _this.type = 'boolean';\n    _this.value = boolValue;\n    return _this;\n  }\n\n  return BooleanASTNodeImpl;\n}(ASTNodeImpl);\n\nexport { BooleanASTNodeImpl };\n\nvar ArrayASTNodeImpl =\n/** @class */\nfunction (_super) {\n  __extends(ArrayASTNodeImpl, _super);\n\n  function ArrayASTNodeImpl(parent, offset) {\n    var _this = _super.call(this, parent, offset) || this;\n\n    _this.type = 'array';\n    _this.items = [];\n    return _this;\n  }\n\n  Object.defineProperty(ArrayASTNodeImpl.prototype, \"children\", {\n    get: function () {\n      return this.items;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return ArrayASTNodeImpl;\n}(ASTNodeImpl);\n\nexport { ArrayASTNodeImpl };\n\nvar NumberASTNodeImpl =\n/** @class */\nfunction (_super) {\n  __extends(NumberASTNodeImpl, _super);\n\n  function NumberASTNodeImpl(parent, offset) {\n    var _this = _super.call(this, parent, offset) || this;\n\n    _this.type = 'number';\n    _this.isInteger = true;\n    _this.value = Number.NaN;\n    return _this;\n  }\n\n  return NumberASTNodeImpl;\n}(ASTNodeImpl);\n\nexport { NumberASTNodeImpl };\n\nvar StringASTNodeImpl =\n/** @class */\nfunction (_super) {\n  __extends(StringASTNodeImpl, _super);\n\n  function StringASTNodeImpl(parent, offset, length) {\n    var _this = _super.call(this, parent, offset, length) || this;\n\n    _this.type = 'string';\n    _this.value = '';\n    return _this;\n  }\n\n  return StringASTNodeImpl;\n}(ASTNodeImpl);\n\nexport { StringASTNodeImpl };\n\nvar PropertyASTNodeImpl =\n/** @class */\nfunction (_super) {\n  __extends(PropertyASTNodeImpl, _super);\n\n  function PropertyASTNodeImpl(parent, offset) {\n    var _this = _super.call(this, parent, offset) || this;\n\n    _this.type = 'property';\n    _this.colonOffset = -1;\n    return _this;\n  }\n\n  Object.defineProperty(PropertyASTNodeImpl.prototype, \"children\", {\n    get: function () {\n      return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return PropertyASTNodeImpl;\n}(ASTNodeImpl);\n\nexport { PropertyASTNodeImpl };\n\nvar ObjectASTNodeImpl =\n/** @class */\nfunction (_super) {\n  __extends(ObjectASTNodeImpl, _super);\n\n  function ObjectASTNodeImpl(parent, offset) {\n    var _this = _super.call(this, parent, offset) || this;\n\n    _this.type = 'object';\n    _this.properties = [];\n    return _this;\n  }\n\n  Object.defineProperty(ObjectASTNodeImpl.prototype, \"children\", {\n    get: function () {\n      return this.properties;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return ObjectASTNodeImpl;\n}(ASTNodeImpl);\n\nexport { ObjectASTNodeImpl };\nexport function asSchema(schema) {\n  if (isBoolean(schema)) {\n    return schema ? {} : {\n      \"not\": {}\n    };\n  }\n\n  return schema;\n}\nexport var EnumMatch;\n\n(function (EnumMatch) {\n  EnumMatch[EnumMatch[\"Key\"] = 0] = \"Key\";\n  EnumMatch[EnumMatch[\"Enum\"] = 1] = \"Enum\";\n})(EnumMatch || (EnumMatch = {}));\n\nvar SchemaCollector =\n/** @class */\nfunction () {\n  function SchemaCollector(focusOffset, exclude) {\n    if (focusOffset === void 0) {\n      focusOffset = -1;\n    }\n\n    if (exclude === void 0) {\n      exclude = null;\n    }\n\n    this.focusOffset = focusOffset;\n    this.exclude = exclude;\n    this.schemas = [];\n  }\n\n  SchemaCollector.prototype.add = function (schema) {\n    this.schemas.push(schema);\n  };\n\n  SchemaCollector.prototype.merge = function (other) {\n    var _a;\n\n    (_a = this.schemas).push.apply(_a, other.schemas);\n  };\n\n  SchemaCollector.prototype.include = function (node) {\n    return (this.focusOffset === -1 || contains(node, this.focusOffset)) && node !== this.exclude;\n  };\n\n  SchemaCollector.prototype.newSub = function () {\n    return new SchemaCollector(-1, this.exclude);\n  };\n\n  return SchemaCollector;\n}();\n\nvar NoOpSchemaCollector =\n/** @class */\nfunction () {\n  function NoOpSchemaCollector() {}\n\n  Object.defineProperty(NoOpSchemaCollector.prototype, \"schemas\", {\n    get: function () {\n      return [];\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  NoOpSchemaCollector.prototype.add = function (schema) {};\n\n  NoOpSchemaCollector.prototype.merge = function (other) {};\n\n  NoOpSchemaCollector.prototype.include = function (node) {\n    return true;\n  };\n\n  NoOpSchemaCollector.prototype.newSub = function () {\n    return this;\n  };\n\n  NoOpSchemaCollector.instance = new NoOpSchemaCollector();\n  return NoOpSchemaCollector;\n}();\n\nvar ValidationResult =\n/** @class */\nfunction () {\n  function ValidationResult() {\n    this.problems = [];\n    this.propertiesMatches = 0;\n    this.propertiesValueMatches = 0;\n    this.primaryValueMatches = 0;\n    this.enumValueMatch = false;\n    this.enumValues = null;\n  }\n\n  ValidationResult.prototype.hasProblems = function () {\n    return !!this.problems.length;\n  };\n\n  ValidationResult.prototype.mergeAll = function (validationResults) {\n    for (var _i = 0, validationResults_1 = validationResults; _i < validationResults_1.length; _i++) {\n      var validationResult = validationResults_1[_i];\n      this.merge(validationResult);\n    }\n  };\n\n  ValidationResult.prototype.merge = function (validationResult) {\n    this.problems = this.problems.concat(validationResult.problems);\n  };\n\n  ValidationResult.prototype.mergeEnumValues = function (validationResult) {\n    if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {\n      this.enumValues = this.enumValues.concat(validationResult.enumValues);\n\n      for (var _i = 0, _a = this.problems; _i < _a.length; _i++) {\n        var error = _a[_i];\n\n        if (error.code === ErrorCode.EnumValueMismatch) {\n          error.message = localize('enumWarning', 'Value is not accepted. Valid values: {0}.', this.enumValues.map(function (v) {\n            return JSON.stringify(v);\n          }).join(', '));\n        }\n      }\n    }\n  };\n\n  ValidationResult.prototype.mergePropertyMatch = function (propertyValidationResult) {\n    this.merge(propertyValidationResult);\n    this.propertiesMatches++;\n\n    if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {\n      this.propertiesValueMatches++;\n    }\n\n    if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues && propertyValidationResult.enumValues.length === 1) {\n      this.primaryValueMatches++;\n    }\n  };\n\n  ValidationResult.prototype.compare = function (other) {\n    var hasProblems = this.hasProblems();\n\n    if (hasProblems !== other.hasProblems()) {\n      return hasProblems ? -1 : 1;\n    }\n\n    if (this.enumValueMatch !== other.enumValueMatch) {\n      return other.enumValueMatch ? -1 : 1;\n    }\n\n    if (this.primaryValueMatches !== other.primaryValueMatches) {\n      return this.primaryValueMatches - other.primaryValueMatches;\n    }\n\n    if (this.propertiesValueMatches !== other.propertiesValueMatches) {\n      return this.propertiesValueMatches - other.propertiesValueMatches;\n    }\n\n    return this.propertiesMatches - other.propertiesMatches;\n  };\n\n  return ValidationResult;\n}();\n\nexport { ValidationResult };\nexport function newJSONDocument(root, diagnostics) {\n  if (diagnostics === void 0) {\n    diagnostics = [];\n  }\n\n  return new JSONDocument(root, diagnostics, []);\n}\nexport function getNodeValue(node) {\n  return Json.getNodeValue(node);\n}\nexport function getNodePath(node) {\n  return Json.getNodePath(node);\n}\nexport function contains(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n\n  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;\n}\n\nvar JSONDocument =\n/** @class */\nfunction () {\n  function JSONDocument(root, syntaxErrors, comments) {\n    if (syntaxErrors === void 0) {\n      syntaxErrors = [];\n    }\n\n    if (comments === void 0) {\n      comments = [];\n    }\n\n    this.root = root;\n    this.syntaxErrors = syntaxErrors;\n    this.comments = comments;\n  }\n\n  JSONDocument.prototype.getNodeFromOffset = function (offset, includeRightBound) {\n    if (includeRightBound === void 0) {\n      includeRightBound = false;\n    }\n\n    if (this.root) {\n      return Json.findNodeAtOffset(this.root, offset, includeRightBound);\n    }\n\n    return void 0;\n  };\n\n  JSONDocument.prototype.visit = function (visitor) {\n    if (this.root) {\n      var doVisit_1 = function (node) {\n        var ctn = visitor(node);\n        var children = node.children;\n\n        if (Array.isArray(children)) {\n          for (var i = 0; i < children.length && ctn; i++) {\n            ctn = doVisit_1(children[i]);\n          }\n        }\n\n        return ctn;\n      };\n\n      doVisit_1(this.root);\n    }\n  };\n\n  JSONDocument.prototype.validate = function (textDocument, schema) {\n    if (this.root && schema) {\n      var validationResult = new ValidationResult();\n      validate(this.root, schema, validationResult, NoOpSchemaCollector.instance);\n      return validationResult.problems.map(function (p) {\n        var range = Range.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));\n        return Diagnostic.create(range, p.message, p.severity, p.code);\n      });\n    }\n\n    return null;\n  };\n\n  JSONDocument.prototype.getMatchingSchemas = function (schema, focusOffset, exclude) {\n    if (focusOffset === void 0) {\n      focusOffset = -1;\n    }\n\n    if (exclude === void 0) {\n      exclude = null;\n    }\n\n    var matchingSchemas = new SchemaCollector(focusOffset, exclude);\n\n    if (this.root && schema) {\n      validate(this.root, schema, new ValidationResult(), matchingSchemas);\n    }\n\n    return matchingSchemas.schemas;\n  };\n\n  return JSONDocument;\n}();\n\nexport { JSONDocument };\n\nfunction validate(node, schema, validationResult, matchingSchemas) {\n  if (!node || !matchingSchemas.include(node)) {\n    return;\n  }\n\n  switch (node.type) {\n    case 'object':\n      _validateObjectNode(node, schema, validationResult, matchingSchemas);\n\n      break;\n\n    case 'array':\n      _validateArrayNode(node, schema, validationResult, matchingSchemas);\n\n      break;\n\n    case 'string':\n      _validateStringNode(node, schema, validationResult, matchingSchemas);\n\n      break;\n\n    case 'number':\n      _validateNumberNode(node, schema, validationResult, matchingSchemas);\n\n      break;\n\n    case 'property':\n      return validate(node.valueNode, schema, validationResult, matchingSchemas);\n  }\n\n  _validateNode();\n\n  matchingSchemas.add({\n    node: node,\n    schema: schema\n  });\n\n  function _validateNode() {\n    function matchesType(type) {\n      return node.type === type || type === 'integer' && node.type === 'number' && node.isInteger;\n    }\n\n    if (Array.isArray(schema.type)) {\n      if (!schema.type.some(matchesType)) {\n        validationResult.problems.push({\n          location: {\n            offset: node.offset,\n            length: node.length\n          },\n          severity: DiagnosticSeverity.Warning,\n          message: schema.errorMessage || localize('typeArrayMismatchWarning', 'Incorrect type. Expected one of {0}.', schema.type.join(', '))\n        });\n      }\n    } else if (schema.type) {\n      if (!matchesType(schema.type)) {\n        validationResult.problems.push({\n          location: {\n            offset: node.offset,\n            length: node.length\n          },\n          severity: DiagnosticSeverity.Warning,\n          message: schema.errorMessage || localize('typeMismatchWarning', 'Incorrect type. Expected \"{0}\".', schema.type)\n        });\n      }\n    }\n\n    if (Array.isArray(schema.allOf)) {\n      for (var _i = 0, _a = schema.allOf; _i < _a.length; _i++) {\n        var subSchemaRef = _a[_i];\n        validate(node, asSchema(subSchemaRef), validationResult, matchingSchemas);\n      }\n    }\n\n    var notSchema = asSchema(schema.not);\n\n    if (notSchema) {\n      var subValidationResult = new ValidationResult();\n      var subMatchingSchemas = matchingSchemas.newSub();\n      validate(node, notSchema, subValidationResult, subMatchingSchemas);\n\n      if (!subValidationResult.hasProblems()) {\n        validationResult.problems.push({\n          location: {\n            offset: node.offset,\n            length: node.length\n          },\n          severity: DiagnosticSeverity.Warning,\n          message: localize('notSchemaWarning', \"Matches a schema that is not allowed.\")\n        });\n      }\n\n      for (var _b = 0, _c = subMatchingSchemas.schemas; _b < _c.length; _b++) {\n        var ms = _c[_b];\n        ms.inverted = !ms.inverted;\n        matchingSchemas.add(ms);\n      }\n    }\n\n    var testAlternatives = function (alternatives, maxOneMatch) {\n      var matches = []; // remember the best match that is used for error messages\n\n      var bestMatch = null;\n\n      for (var _i = 0, alternatives_1 = alternatives; _i < alternatives_1.length; _i++) {\n        var subSchemaRef = alternatives_1[_i];\n        var subSchema = asSchema(subSchemaRef);\n        var subValidationResult = new ValidationResult();\n        var subMatchingSchemas = matchingSchemas.newSub();\n        validate(node, subSchema, subValidationResult, subMatchingSchemas);\n\n        if (!subValidationResult.hasProblems()) {\n          matches.push(subSchema);\n        }\n\n        if (!bestMatch) {\n          bestMatch = {\n            schema: subSchema,\n            validationResult: subValidationResult,\n            matchingSchemas: subMatchingSchemas\n          };\n        } else {\n          if (!maxOneMatch && !subValidationResult.hasProblems() && !bestMatch.validationResult.hasProblems()) {\n            // no errors, both are equally good matches\n            bestMatch.matchingSchemas.merge(subMatchingSchemas);\n            bestMatch.validationResult.propertiesMatches += subValidationResult.propertiesMatches;\n            bestMatch.validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;\n          } else {\n            var compareResult = subValidationResult.compare(bestMatch.validationResult);\n\n            if (compareResult > 0) {\n              // our node is the best matching so far\n              bestMatch = {\n                schema: subSchema,\n                validationResult: subValidationResult,\n                matchingSchemas: subMatchingSchemas\n              };\n            } else if (compareResult === 0) {\n              // there's already a best matching but we are as good\n              bestMatch.matchingSchemas.merge(subMatchingSchemas);\n              bestMatch.validationResult.mergeEnumValues(subValidationResult);\n            }\n          }\n        }\n      }\n\n      if (matches.length > 1 && maxOneMatch) {\n        validationResult.problems.push({\n          location: {\n            offset: node.offset,\n            length: 1\n          },\n          severity: DiagnosticSeverity.Warning,\n          message: localize('oneOfWarning', \"Matches multiple schemas when only one must validate.\")\n        });\n      }\n\n      if (bestMatch !== null) {\n        validationResult.merge(bestMatch.validationResult);\n        validationResult.propertiesMatches += bestMatch.validationResult.propertiesMatches;\n        validationResult.propertiesValueMatches += bestMatch.validationResult.propertiesValueMatches;\n        matchingSchemas.merge(bestMatch.matchingSchemas);\n      }\n\n      return matches.length;\n    };\n\n    if (Array.isArray(schema.anyOf)) {\n      testAlternatives(schema.anyOf, false);\n    }\n\n    if (Array.isArray(schema.oneOf)) {\n      testAlternatives(schema.oneOf, true);\n    }\n\n    var testBranch = function (schema) {\n      var subValidationResult = new ValidationResult();\n      var subMatchingSchemas = matchingSchemas.newSub();\n      validate(node, asSchema(schema), subValidationResult, subMatchingSchemas);\n      validationResult.merge(subValidationResult);\n      validationResult.propertiesMatches += subValidationResult.propertiesMatches;\n      validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;\n      matchingSchemas.merge(subMatchingSchemas);\n    };\n\n    var testCondition = function (ifSchema, thenSchema, elseSchema) {\n      var subSchema = asSchema(ifSchema);\n      var subValidationResult = new ValidationResult();\n      var subMatchingSchemas = matchingSchemas.newSub();\n      validate(node, subSchema, subValidationResult, subMatchingSchemas);\n      matchingSchemas.merge(subMatchingSchemas);\n\n      if (!subValidationResult.hasProblems()) {\n        if (thenSchema) {\n          testBranch(thenSchema);\n        }\n      } else if (elseSchema) {\n        testBranch(elseSchema);\n      }\n    };\n\n    var ifSchema = asSchema(schema.if);\n\n    if (ifSchema) {\n      testCondition(ifSchema, asSchema(schema.then), asSchema(schema.else));\n    }\n\n    if (Array.isArray(schema.enum)) {\n      var val = getNodeValue(node);\n      var enumValueMatch = false;\n\n      for (var _d = 0, _e = schema.enum; _d < _e.length; _d++) {\n        var e = _e[_d];\n\n        if (equals(val, e)) {\n          enumValueMatch = true;\n          break;\n        }\n      }\n\n      validationResult.enumValues = schema.enum;\n      validationResult.enumValueMatch = enumValueMatch;\n\n      if (!enumValueMatch) {\n        validationResult.problems.push({\n          location: {\n            offset: node.offset,\n            length: node.length\n          },\n          severity: DiagnosticSeverity.Warning,\n          code: ErrorCode.EnumValueMismatch,\n          message: schema.errorMessage || localize('enumWarning', 'Value is not accepted. Valid values: {0}.', schema.enum.map(function (v) {\n            return JSON.stringify(v);\n          }).join(', '))\n        });\n      }\n    }\n\n    if (isDefined(schema.const)) {\n      var val = getNodeValue(node);\n\n      if (!equals(val, schema.const)) {\n        validationResult.problems.push({\n          location: {\n            offset: node.offset,\n            length: node.length\n          },\n          severity: DiagnosticSeverity.Warning,\n          code: ErrorCode.EnumValueMismatch,\n          message: schema.errorMessage || localize('constWarning', 'Value must be {0}.', JSON.stringify(schema.const))\n        });\n        validationResult.enumValueMatch = false;\n      } else {\n        validationResult.enumValueMatch = true;\n      }\n\n      validationResult.enumValues = [schema.const];\n    }\n\n    if (schema.deprecationMessage && node.parent) {\n      validationResult.problems.push({\n        location: {\n          offset: node.parent.offset,\n          length: node.parent.length\n        },\n        severity: DiagnosticSeverity.Warning,\n        message: schema.deprecationMessage\n      });\n    }\n  }\n\n  function _validateNumberNode(node, schema, validationResult, matchingSchemas) {\n    var val = node.value;\n\n    if (isNumber(schema.multipleOf)) {\n      if (val % schema.multipleOf !== 0) {\n        validationResult.problems.push({\n          location: {\n            offset: node.offset,\n            length: node.length\n          },\n          severity: DiagnosticSeverity.Warning,\n          message: localize('multipleOfWarning', 'Value is not divisible by {0}.', schema.multipleOf)\n        });\n      }\n    }\n\n    function getExclusiveLimit(limit, exclusive) {\n      if (isNumber(exclusive)) {\n        return exclusive;\n      }\n\n      if (isBoolean(exclusive) && exclusive) {\n        return limit;\n      }\n\n      return void 0;\n    }\n\n    function getLimit(limit, exclusive) {\n      if (!isBoolean(exclusive) || !exclusive) {\n        return limit;\n      }\n\n      return void 0;\n    }\n\n    var exclusiveMinimum = getExclusiveLimit(schema.minimum, schema.exclusiveMinimum);\n\n    if (isNumber(exclusiveMinimum) && val <= exclusiveMinimum) {\n      validationResult.problems.push({\n        location: {\n          offset: node.offset,\n          length: node.length\n        },\n        severity: DiagnosticSeverity.Warning,\n        message: localize('exclusiveMinimumWarning', 'Value is below the exclusive minimum of {0}.', exclusiveMinimum)\n      });\n    }\n\n    var exclusiveMaximum = getExclusiveLimit(schema.maximum, schema.exclusiveMaximum);\n\n    if (isNumber(exclusiveMaximum) && val >= exclusiveMaximum) {\n      validationResult.problems.push({\n        location: {\n          offset: node.offset,\n          length: node.length\n        },\n        severity: DiagnosticSeverity.Warning,\n        message: localize('exclusiveMaximumWarning', 'Value is above the exclusive maximum of {0}.', exclusiveMaximum)\n      });\n    }\n\n    var minimum = getLimit(schema.minimum, schema.exclusiveMinimum);\n\n    if (isNumber(minimum) && val < minimum) {\n      validationResult.problems.push({\n        location: {\n          offset: node.offset,\n          length: node.length\n        },\n        severity: DiagnosticSeverity.Warning,\n        message: localize('minimumWarning', 'Value is below the minimum of {0}.', minimum)\n      });\n    }\n\n    var maximum = getLimit(schema.maximum, schema.exclusiveMaximum);\n\n    if (isNumber(maximum) && val > maximum) {\n      validationResult.problems.push({\n        location: {\n          offset: node.offset,\n          length: node.length\n        },\n        severity: DiagnosticSeverity.Warning,\n        message: localize('maximumWarning', 'Value is above the maximum of {0}.', maximum)\n      });\n    }\n  }\n\n  function _validateStringNode(node, schema, validationResult, matchingSchemas) {\n    if (isNumber(schema.minLength) && node.value.length < schema.minLength) {\n      validationResult.problems.push({\n        location: {\n          offset: node.offset,\n          length: node.length\n        },\n        severity: DiagnosticSeverity.Warning,\n        message: localize('minLengthWarning', 'String is shorter than the minimum length of {0}.', schema.minLength)\n      });\n    }\n\n    if (isNumber(schema.maxLength) && node.value.length > schema.maxLength) {\n      validationResult.problems.push({\n        location: {\n          offset: node.offset,\n          length: node.length\n        },\n        severity: DiagnosticSeverity.Warning,\n        message: localize('maxLengthWarning', 'String is longer than the maximum length of {0}.', schema.maxLength)\n      });\n    }\n\n    if (isString(schema.pattern)) {\n      var regex = new RegExp(schema.pattern);\n\n      if (!regex.test(node.value)) {\n        validationResult.problems.push({\n          location: {\n            offset: node.offset,\n            length: node.length\n          },\n          severity: DiagnosticSeverity.Warning,\n          message: schema.patternErrorMessage || schema.errorMessage || localize('patternWarning', 'String does not match the pattern of \"{0}\".', schema.pattern)\n        });\n      }\n    }\n\n    if (schema.format) {\n      switch (schema.format) {\n        case 'uri':\n        case 'uri-reference':\n          {\n            var errorMessage = void 0;\n\n            if (!node.value) {\n              errorMessage = localize('uriEmpty', 'URI expected.');\n            } else {\n              var match = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/.exec(node.value);\n\n              if (!match) {\n                errorMessage = localize('uriMissing', 'URI is expected.');\n              } else if (!match[2] && schema.format === 'uri') {\n                errorMessage = localize('uriSchemeMissing', 'URI with a scheme is expected.');\n              }\n            }\n\n            if (errorMessage) {\n              validationResult.problems.push({\n                location: {\n                  offset: node.offset,\n                  length: node.length\n                },\n                severity: DiagnosticSeverity.Warning,\n                message: schema.patternErrorMessage || schema.errorMessage || localize('uriFormatWarning', 'String is not a URI: {0}', errorMessage)\n              });\n            }\n          }\n          break;\n\n        case 'color-hex':\n        case 'date-time':\n        case 'date':\n        case 'time':\n        case 'email':\n          var format = formats[schema.format];\n\n          if (!node.value || !format.pattern.exec(node.value)) {\n            validationResult.problems.push({\n              location: {\n                offset: node.offset,\n                length: node.length\n              },\n              severity: DiagnosticSeverity.Warning,\n              message: schema.patternErrorMessage || schema.errorMessage || format.errorMessage\n            });\n          }\n\n        default:\n      }\n    }\n  }\n\n  function _validateArrayNode(node, schema, validationResult, matchingSchemas) {\n    if (Array.isArray(schema.items)) {\n      var subSchemas = schema.items;\n\n      for (var index = 0; index < subSchemas.length; index++) {\n        var subSchemaRef = subSchemas[index];\n        var subSchema = asSchema(subSchemaRef);\n        var itemValidationResult = new ValidationResult();\n        var item = node.items[index];\n\n        if (item) {\n          validate(item, subSchema, itemValidationResult, matchingSchemas);\n          validationResult.mergePropertyMatch(itemValidationResult);\n        } else if (node.items.length >= subSchemas.length) {\n          validationResult.propertiesValueMatches++;\n        }\n      }\n\n      if (node.items.length > subSchemas.length) {\n        if (typeof schema.additionalItems === 'object') {\n          for (var i = subSchemas.length; i < node.items.length; i++) {\n            var itemValidationResult = new ValidationResult();\n            validate(node.items[i], schema.additionalItems, itemValidationResult, matchingSchemas);\n            validationResult.mergePropertyMatch(itemValidationResult);\n          }\n        } else if (schema.additionalItems === false) {\n          validationResult.problems.push({\n            location: {\n              offset: node.offset,\n              length: node.length\n            },\n            severity: DiagnosticSeverity.Warning,\n            message: localize('additionalItemsWarning', 'Array has too many items according to schema. Expected {0} or fewer.', subSchemas.length)\n          });\n        }\n      }\n    } else {\n      var itemSchema = asSchema(schema.items);\n\n      if (itemSchema) {\n        for (var _i = 0, _a = node.items; _i < _a.length; _i++) {\n          var item = _a[_i];\n          var itemValidationResult = new ValidationResult();\n          validate(item, itemSchema, itemValidationResult, matchingSchemas);\n          validationResult.mergePropertyMatch(itemValidationResult);\n        }\n      }\n    }\n\n    var containsSchema = asSchema(schema.contains);\n\n    if (containsSchema) {\n      var doesContain = node.items.some(function (item) {\n        var itemValidationResult = new ValidationResult();\n        validate(item, containsSchema, itemValidationResult, NoOpSchemaCollector.instance);\n        return !itemValidationResult.hasProblems();\n      });\n\n      if (!doesContain) {\n        validationResult.problems.push({\n          location: {\n            offset: node.offset,\n            length: node.length\n          },\n          severity: DiagnosticSeverity.Warning,\n          message: schema.errorMessage || localize('requiredItemMissingWarning', 'Array does not contain required item.')\n        });\n      }\n    }\n\n    if (isNumber(schema.minItems) && node.items.length < schema.minItems) {\n      validationResult.problems.push({\n        location: {\n          offset: node.offset,\n          length: node.length\n        },\n        severity: DiagnosticSeverity.Warning,\n        message: localize('minItemsWarning', 'Array has too few items. Expected {0} or more.', schema.minItems)\n      });\n    }\n\n    if (isNumber(schema.maxItems) && node.items.length > schema.maxItems) {\n      validationResult.problems.push({\n        location: {\n          offset: node.offset,\n          length: node.length\n        },\n        severity: DiagnosticSeverity.Warning,\n        message: localize('maxItemsWarning', 'Array has too many items. Expected {0} or fewer.', schema.maxItems)\n      });\n    }\n\n    if (schema.uniqueItems === true) {\n      var values_1 = getNodeValue(node);\n      var duplicates = values_1.some(function (value, index) {\n        return index !== values_1.lastIndexOf(value);\n      });\n\n      if (duplicates) {\n        validationResult.problems.push({\n          location: {\n            offset: node.offset,\n            length: node.length\n          },\n          severity: DiagnosticSeverity.Warning,\n          message: localize('uniqueItemsWarning', 'Array has duplicate items.')\n        });\n      }\n    }\n  }\n\n  function _validateObjectNode(node, schema, validationResult, matchingSchemas) {\n    var seenKeys = Object.create(null);\n    var unprocessedProperties = [];\n\n    for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {\n      var propertyNode = _a[_i];\n      var key = propertyNode.keyNode.value;\n      seenKeys[key] = propertyNode.valueNode;\n      unprocessedProperties.push(key);\n    }\n\n    if (Array.isArray(schema.required)) {\n      for (var _b = 0, _c = schema.required; _b < _c.length; _b++) {\n        var propertyName = _c[_b];\n\n        if (!seenKeys[propertyName]) {\n          var keyNode = node.parent && node.parent.type === 'property' && node.parent.keyNode;\n          var location = keyNode ? {\n            offset: keyNode.offset,\n            length: keyNode.length\n          } : {\n            offset: node.offset,\n            length: 1\n          };\n          validationResult.problems.push({\n            location: location,\n            severity: DiagnosticSeverity.Warning,\n            message: localize('MissingRequiredPropWarning', 'Missing property \"{0}\".', propertyName)\n          });\n        }\n      }\n    }\n\n    var propertyProcessed = function (prop) {\n      var index = unprocessedProperties.indexOf(prop);\n\n      while (index >= 0) {\n        unprocessedProperties.splice(index, 1);\n        index = unprocessedProperties.indexOf(prop);\n      }\n    };\n\n    if (schema.properties) {\n      for (var _d = 0, _e = Object.keys(schema.properties); _d < _e.length; _d++) {\n        var propertyName = _e[_d];\n        propertyProcessed(propertyName);\n        var propertySchema = schema.properties[propertyName];\n        var child = seenKeys[propertyName];\n\n        if (child) {\n          if (isBoolean(propertySchema)) {\n            if (!propertySchema) {\n              var propertyNode = child.parent;\n              validationResult.problems.push({\n                location: {\n                  offset: propertyNode.keyNode.offset,\n                  length: propertyNode.keyNode.length\n                },\n                severity: DiagnosticSeverity.Warning,\n                message: schema.errorMessage || localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName)\n              });\n            } else {\n              validationResult.propertiesMatches++;\n              validationResult.propertiesValueMatches++;\n            }\n          } else {\n            var propertyValidationResult = new ValidationResult();\n            validate(child, propertySchema, propertyValidationResult, matchingSchemas);\n            validationResult.mergePropertyMatch(propertyValidationResult);\n          }\n        }\n      }\n    }\n\n    if (schema.patternProperties) {\n      for (var _f = 0, _g = Object.keys(schema.patternProperties); _f < _g.length; _f++) {\n        var propertyPattern = _g[_f];\n        var regex = new RegExp(propertyPattern);\n\n        for (var _h = 0, _j = unprocessedProperties.slice(0); _h < _j.length; _h++) {\n          var propertyName = _j[_h];\n\n          if (regex.test(propertyName)) {\n            propertyProcessed(propertyName);\n            var child = seenKeys[propertyName];\n\n            if (child) {\n              var propertySchema = schema.patternProperties[propertyPattern];\n\n              if (isBoolean(propertySchema)) {\n                if (!propertySchema) {\n                  var propertyNode = child.parent;\n                  validationResult.problems.push({\n                    location: {\n                      offset: propertyNode.keyNode.offset,\n                      length: propertyNode.keyNode.length\n                    },\n                    severity: DiagnosticSeverity.Warning,\n                    message: schema.errorMessage || localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName)\n                  });\n                } else {\n                  validationResult.propertiesMatches++;\n                  validationResult.propertiesValueMatches++;\n                }\n              } else {\n                var propertyValidationResult = new ValidationResult();\n                validate(child, propertySchema, propertyValidationResult, matchingSchemas);\n                validationResult.mergePropertyMatch(propertyValidationResult);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (typeof schema.additionalProperties === 'object') {\n      for (var _k = 0, unprocessedProperties_1 = unprocessedProperties; _k < unprocessedProperties_1.length; _k++) {\n        var propertyName = unprocessedProperties_1[_k];\n        var child = seenKeys[propertyName];\n\n        if (child) {\n          var propertyValidationResult = new ValidationResult();\n          validate(child, schema.additionalProperties, propertyValidationResult, matchingSchemas);\n          validationResult.mergePropertyMatch(propertyValidationResult);\n        }\n      }\n    } else if (schema.additionalProperties === false) {\n      if (unprocessedProperties.length > 0) {\n        for (var _l = 0, unprocessedProperties_2 = unprocessedProperties; _l < unprocessedProperties_2.length; _l++) {\n          var propertyName = unprocessedProperties_2[_l];\n          var child = seenKeys[propertyName];\n\n          if (child) {\n            var propertyNode = child.parent;\n            validationResult.problems.push({\n              location: {\n                offset: propertyNode.keyNode.offset,\n                length: propertyNode.keyNode.length\n              },\n              severity: DiagnosticSeverity.Warning,\n              message: schema.errorMessage || localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName)\n            });\n          }\n        }\n      }\n    }\n\n    if (isNumber(schema.maxProperties)) {\n      if (node.properties.length > schema.maxProperties) {\n        validationResult.problems.push({\n          location: {\n            offset: node.offset,\n            length: node.length\n          },\n          severity: DiagnosticSeverity.Warning,\n          message: localize('MaxPropWarning', 'Object has more properties than limit of {0}.', schema.maxProperties)\n        });\n      }\n    }\n\n    if (isNumber(schema.minProperties)) {\n      if (node.properties.length < schema.minProperties) {\n        validationResult.problems.push({\n          location: {\n            offset: node.offset,\n            length: node.length\n          },\n          severity: DiagnosticSeverity.Warning,\n          message: localize('MinPropWarning', 'Object has fewer properties than the required number of {0}', schema.minProperties)\n        });\n      }\n    }\n\n    if (schema.dependencies) {\n      for (var _m = 0, _o = Object.keys(schema.dependencies); _m < _o.length; _m++) {\n        var key = _o[_m];\n        var prop = seenKeys[key];\n\n        if (prop) {\n          var propertyDep = schema.dependencies[key];\n\n          if (Array.isArray(propertyDep)) {\n            for (var _p = 0, propertyDep_1 = propertyDep; _p < propertyDep_1.length; _p++) {\n              var requiredProp = propertyDep_1[_p];\n\n              if (!seenKeys[requiredProp]) {\n                validationResult.problems.push({\n                  location: {\n                    offset: node.offset,\n                    length: node.length\n                  },\n                  severity: DiagnosticSeverity.Warning,\n                  message: localize('RequiredDependentPropWarning', 'Object is missing property {0} required by property {1}.', requiredProp, key)\n                });\n              } else {\n                validationResult.propertiesValueMatches++;\n              }\n            }\n          } else {\n            var propertySchema = asSchema(propertyDep);\n\n            if (propertySchema) {\n              var propertyValidationResult = new ValidationResult();\n              validate(node, propertySchema, propertyValidationResult, matchingSchemas);\n              validationResult.mergePropertyMatch(propertyValidationResult);\n            }\n          }\n        }\n      }\n    }\n\n    var propertyNames = asSchema(schema.propertyNames);\n\n    if (propertyNames) {\n      for (var _q = 0, _r = node.properties; _q < _r.length; _q++) {\n        var f = _r[_q];\n        var key = f.keyNode;\n\n        if (key) {\n          validate(key, propertyNames, validationResult, NoOpSchemaCollector.instance);\n        }\n      }\n    }\n  }\n}\n\nexport function parse(textDocument, config) {\n  var problems = [];\n  var lastProblemOffset = -1;\n  var text = textDocument.getText();\n  var scanner = Json.createScanner(text, false);\n  var commentRanges = config && config.collectComments ? [] : void 0;\n\n  function _scanNext() {\n    while (true) {\n      var token_1 = scanner.scan();\n\n      _checkScanError();\n\n      switch (token_1) {\n        case 12\n        /* LineCommentTrivia */\n        :\n        case 13\n        /* BlockCommentTrivia */\n        :\n          if (Array.isArray(commentRanges)) {\n            commentRanges.push(Range.create(textDocument.positionAt(scanner.getTokenOffset()), textDocument.positionAt(scanner.getTokenOffset() + scanner.getTokenLength())));\n          }\n\n          break;\n\n        case 15\n        /* Trivia */\n        :\n        case 14\n        /* LineBreakTrivia */\n        :\n          break;\n\n        default:\n          return token_1;\n      }\n    }\n  }\n\n  function _accept(token) {\n    if (scanner.getToken() === token) {\n      _scanNext();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function _errorAtRange(message, code, startOffset, endOffset, severity) {\n    if (severity === void 0) {\n      severity = DiagnosticSeverity.Error;\n    }\n\n    if (problems.length === 0 || startOffset !== lastProblemOffset) {\n      var range = Range.create(textDocument.positionAt(startOffset), textDocument.positionAt(endOffset));\n      problems.push(Diagnostic.create(range, message, severity, code, textDocument.languageId));\n      lastProblemOffset = startOffset;\n    }\n  }\n\n  function _error(message, code, node, skipUntilAfter, skipUntil) {\n    if (node === void 0) {\n      node = null;\n    }\n\n    if (skipUntilAfter === void 0) {\n      skipUntilAfter = [];\n    }\n\n    if (skipUntil === void 0) {\n      skipUntil = [];\n    }\n\n    var start = scanner.getTokenOffset();\n    var end = scanner.getTokenOffset() + scanner.getTokenLength();\n\n    if (start === end && start > 0) {\n      start--;\n\n      while (start > 0 && /\\s/.test(text.charAt(start))) {\n        start--;\n      }\n\n      end = start + 1;\n    }\n\n    _errorAtRange(message, code, start, end);\n\n    if (node) {\n      _finalize(node, false);\n    }\n\n    if (skipUntilAfter.length + skipUntil.length > 0) {\n      var token_2 = scanner.getToken();\n\n      while (token_2 !== 17\n      /* EOF */\n      ) {\n        if (skipUntilAfter.indexOf(token_2) !== -1) {\n          _scanNext();\n\n          break;\n        } else if (skipUntil.indexOf(token_2) !== -1) {\n          break;\n        }\n\n        token_2 = _scanNext();\n      }\n    }\n\n    return node;\n  }\n\n  function _checkScanError() {\n    switch (scanner.getTokenError()) {\n      case 4\n      /* InvalidUnicode */\n      :\n        _error(localize('InvalidUnicode', 'Invalid unicode sequence in string.'), ErrorCode.InvalidUnicode);\n\n        return true;\n\n      case 5\n      /* InvalidEscapeCharacter */\n      :\n        _error(localize('InvalidEscapeCharacter', 'Invalid escape character in string.'), ErrorCode.InvalidEscapeCharacter);\n\n        return true;\n\n      case 3\n      /* UnexpectedEndOfNumber */\n      :\n        _error(localize('UnexpectedEndOfNumber', 'Unexpected end of number.'), ErrorCode.UnexpectedEndOfNumber);\n\n        return true;\n\n      case 1\n      /* UnexpectedEndOfComment */\n      :\n        _error(localize('UnexpectedEndOfComment', 'Unexpected end of comment.'), ErrorCode.UnexpectedEndOfComment);\n\n        return true;\n\n      case 2\n      /* UnexpectedEndOfString */\n      :\n        _error(localize('UnexpectedEndOfString', 'Unexpected end of string.'), ErrorCode.UnexpectedEndOfString);\n\n        return true;\n\n      case 6\n      /* InvalidCharacter */\n      :\n        _error(localize('InvalidCharacter', 'Invalid characters in string. Control characters must be escaped.'), ErrorCode.InvalidCharacter);\n\n        return true;\n    }\n\n    return false;\n  }\n\n  function _finalize(node, scanNext) {\n    node.length = scanner.getTokenOffset() + scanner.getTokenLength() - node.offset;\n\n    if (scanNext) {\n      _scanNext();\n    }\n\n    return node;\n  }\n\n  function _parseArray(parent) {\n    if (scanner.getToken() !== 3\n    /* OpenBracketToken */\n    ) {\n        return null;\n      }\n\n    var node = new ArrayASTNodeImpl(parent, scanner.getTokenOffset());\n\n    _scanNext(); // consume OpenBracketToken\n\n\n    var count = 0;\n    var needsComma = false;\n\n    while (scanner.getToken() !== 4\n    /* CloseBracketToken */\n    && scanner.getToken() !== 17\n    /* EOF */\n    ) {\n      if (scanner.getToken() === 5\n      /* CommaToken */\n      ) {\n          if (!needsComma) {\n            _error(localize('ValueExpected', 'Value expected'), ErrorCode.ValueExpected);\n          }\n\n          var commaOffset = scanner.getTokenOffset();\n\n          _scanNext(); // consume comma\n\n\n          if (scanner.getToken() === 4\n          /* CloseBracketToken */\n          ) {\n              if (needsComma) {\n                _errorAtRange(localize('TrailingComma', 'Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);\n              }\n\n              continue;\n            }\n        } else if (needsComma) {\n        _error(localize('ExpectedComma', 'Expected comma'), ErrorCode.CommaExpected);\n      }\n\n      var item = _parseValue(node, count++);\n\n      if (!item) {\n        _error(localize('PropertyExpected', 'Value expected'), ErrorCode.ValueExpected, null, [], [4\n        /* CloseBracketToken */\n        , 5\n        /* CommaToken */\n        ]);\n      } else {\n        node.items.push(item);\n      }\n\n      needsComma = true;\n    }\n\n    if (scanner.getToken() !== 4\n    /* CloseBracketToken */\n    ) {\n        return _error(localize('ExpectedCloseBracket', 'Expected comma or closing bracket'), ErrorCode.CommaOrCloseBacketExpected, node);\n      }\n\n    return _finalize(node, true);\n  }\n\n  function _parseProperty(parent, keysSeen) {\n    var node = new PropertyASTNodeImpl(parent, scanner.getTokenOffset());\n\n    var key = _parseString(node);\n\n    if (!key) {\n      if (scanner.getToken() === 16\n      /* Unknown */\n      ) {\n          // give a more helpful error message\n          _error(localize('DoubleQuotesExpected', 'Property keys must be doublequoted'), ErrorCode.Undefined);\n\n          var keyNode = new StringASTNodeImpl(node, scanner.getTokenOffset(), scanner.getTokenLength());\n          keyNode.value = scanner.getTokenValue();\n          key = keyNode;\n\n          _scanNext(); // consume Unknown\n\n        } else {\n        return null;\n      }\n    }\n\n    node.keyNode = key;\n    var seen = keysSeen[key.value];\n\n    if (seen) {\n      _errorAtRange(localize('DuplicateKeyWarning', \"Duplicate object key\"), ErrorCode.DuplicateKey, node.keyNode.offset, node.keyNode.offset + node.keyNode.length, DiagnosticSeverity.Warning);\n\n      if (typeof seen === 'object') {\n        _errorAtRange(localize('DuplicateKeyWarning', \"Duplicate object key\"), ErrorCode.DuplicateKey, seen.keyNode.offset, seen.keyNode.offset + seen.keyNode.length, DiagnosticSeverity.Warning);\n      }\n\n      keysSeen[key.value] = true; // if the same key is duplicate again, avoid duplicate error reporting\n    } else {\n      keysSeen[key.value] = node;\n    }\n\n    if (scanner.getToken() === 6\n    /* ColonToken */\n    ) {\n        node.colonOffset = scanner.getTokenOffset();\n\n        _scanNext(); // consume ColonToken\n\n      } else {\n      _error(localize('ColonExpected', 'Colon expected'), ErrorCode.ColonExpected);\n\n      if (scanner.getToken() === 10\n      /* StringLiteral */\n      && textDocument.positionAt(key.offset + key.length).line < textDocument.positionAt(scanner.getTokenOffset()).line) {\n        node.length = key.length;\n        return node;\n      }\n    }\n\n    var value = _parseValue(node, key.value);\n\n    if (!value) {\n      return _error(localize('ValueExpected', 'Value expected'), ErrorCode.ValueExpected, node, [], [2\n      /* CloseBraceToken */\n      , 5\n      /* CommaToken */\n      ]);\n    }\n\n    node.valueNode = value;\n    node.length = value.offset + value.length - node.offset;\n    return node;\n  }\n\n  function _parseObject(parent) {\n    if (scanner.getToken() !== 1\n    /* OpenBraceToken */\n    ) {\n        return null;\n      }\n\n    var node = new ObjectASTNodeImpl(parent, scanner.getTokenOffset());\n    var keysSeen = Object.create(null);\n\n    _scanNext(); // consume OpenBraceToken\n\n\n    var needsComma = false;\n\n    while (scanner.getToken() !== 2\n    /* CloseBraceToken */\n    && scanner.getToken() !== 17\n    /* EOF */\n    ) {\n      if (scanner.getToken() === 5\n      /* CommaToken */\n      ) {\n          if (!needsComma) {\n            _error(localize('PropertyExpected', 'Property expected'), ErrorCode.PropertyExpected);\n          }\n\n          var commaOffset = scanner.getTokenOffset();\n\n          _scanNext(); // consume comma\n\n\n          if (scanner.getToken() === 2\n          /* CloseBraceToken */\n          ) {\n              if (needsComma) {\n                _errorAtRange(localize('TrailingComma', 'Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);\n              }\n\n              continue;\n            }\n        } else if (needsComma) {\n        _error(localize('ExpectedComma', 'Expected comma'), ErrorCode.CommaExpected);\n      }\n\n      var property = _parseProperty(node, keysSeen);\n\n      if (!property) {\n        _error(localize('PropertyExpected', 'Property expected'), ErrorCode.PropertyExpected, null, [], [2\n        /* CloseBraceToken */\n        , 5\n        /* CommaToken */\n        ]);\n      } else {\n        node.properties.push(property);\n      }\n\n      needsComma = true;\n    }\n\n    if (scanner.getToken() !== 2\n    /* CloseBraceToken */\n    ) {\n        return _error(localize('ExpectedCloseBrace', 'Expected comma or closing brace'), ErrorCode.CommaOrCloseBraceExpected, node);\n      }\n\n    return _finalize(node, true);\n  }\n\n  function _parseString(parent) {\n    if (scanner.getToken() !== 10\n    /* StringLiteral */\n    ) {\n        return null;\n      }\n\n    var node = new StringASTNodeImpl(parent, scanner.getTokenOffset());\n    node.value = scanner.getTokenValue();\n    return _finalize(node, true);\n  }\n\n  function _parseNumber(parent) {\n    if (scanner.getToken() !== 11\n    /* NumericLiteral */\n    ) {\n        return null;\n      }\n\n    var node = new NumberASTNodeImpl(parent, scanner.getTokenOffset());\n\n    if (scanner.getTokenError() === 0\n    /* None */\n    ) {\n        var tokenValue = scanner.getTokenValue();\n\n        try {\n          var numberValue = JSON.parse(tokenValue);\n\n          if (!isNumber(numberValue)) {\n            return _error(localize('InvalidNumberFormat', 'Invalid number format.'), ErrorCode.Undefined, node);\n          }\n\n          node.value = numberValue;\n        } catch (e) {\n          return _error(localize('InvalidNumberFormat', 'Invalid number format.'), ErrorCode.Undefined, node);\n        }\n\n        node.isInteger = tokenValue.indexOf('.') === -1;\n      }\n\n    return _finalize(node, true);\n  }\n\n  function _parseLiteral(parent) {\n    var node;\n\n    switch (scanner.getToken()) {\n      case 7\n      /* NullKeyword */\n      :\n        return _finalize(new NullASTNodeImpl(parent, scanner.getTokenOffset()), true);\n\n      case 8\n      /* TrueKeyword */\n      :\n        return _finalize(new BooleanASTNodeImpl(parent, true, scanner.getTokenOffset()), true);\n\n      case 9\n      /* FalseKeyword */\n      :\n        return _finalize(new BooleanASTNodeImpl(parent, false, scanner.getTokenOffset()), true);\n\n      default:\n        return null;\n    }\n  }\n\n  function _parseValue(parent, name) {\n    return _parseArray(parent) || _parseObject(parent) || _parseString(parent) || _parseNumber(parent) || _parseLiteral(parent);\n  }\n\n  var _root = null;\n\n  var token = _scanNext();\n\n  if (token !== 17\n  /* EOF */\n  ) {\n      _root = _parseValue(null, null);\n\n      if (!_root) {\n        _error(localize('Invalid symbol', 'Expected a JSON object, array or literal.'), ErrorCode.Undefined);\n      } else if (scanner.getToken() !== 17\n      /* EOF */\n      ) {\n          _error(localize('End of file expected', 'End of file expected.'), ErrorCode.Undefined);\n        }\n    }\n\n  return new JSONDocument(_root, problems, commentRanges);\n}","map":null,"metadata":{},"sourceType":"module"}