{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/range.js';\n/**\n * Returns the intersection between a ranged group and a range.\n * Returns `[]` if the intersection is empty.\n */\n\nexport function groupIntersect(range, groups) {\n  var result = [];\n\n  for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {\n    var r = groups_1[_i];\n\n    if (range.start >= r.range.end) {\n      continue;\n    }\n\n    if (range.end < r.range.start) {\n      break;\n    }\n\n    var intersection = Range.intersect(range, r.range);\n\n    if (Range.isEmpty(intersection)) {\n      continue;\n    }\n\n    result.push({\n      range: intersection,\n      size: r.size\n    });\n  }\n\n  return result;\n}\n/**\n * Shifts a range by that `much`.\n */\n\nexport function shift(_a, much) {\n  var start = _a.start,\n      end = _a.end;\n  return {\n    start: start + much,\n    end: end + much\n  };\n}\n/**\n * Consolidates a collection of ranged groups.\n *\n * Consolidation is the process of merging consecutive ranged groups\n * that share the same `size`.\n */\n\nexport function consolidate(groups) {\n  var result = [];\n  var previousGroup = null;\n\n  for (var _i = 0, groups_2 = groups; _i < groups_2.length; _i++) {\n    var group = groups_2[_i];\n    var start = group.range.start;\n    var end = group.range.end;\n    var size = group.size;\n\n    if (previousGroup && size === previousGroup.size) {\n      previousGroup.range.end = end;\n      continue;\n    }\n\n    previousGroup = {\n      range: {\n        start: start,\n        end: end\n      },\n      size: size\n    };\n    result.push(previousGroup);\n  }\n\n  return result;\n}\n/**\n * Concatenates several collections of ranged groups into a single\n * collection.\n */\n\nfunction concat() {\n  var groups = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    groups[_i] = arguments[_i];\n  }\n\n  return consolidate(groups.reduce(function (r, g) {\n    return r.concat(g);\n  }, []));\n}\n\nvar RangeMap =\n/** @class */\nfunction () {\n  function RangeMap() {\n    this.groups = [];\n    this._size = 0;\n  }\n\n  RangeMap.prototype.splice = function (index, deleteCount, items) {\n    if (items === void 0) {\n      items = [];\n    }\n\n    var diff = items.length - deleteCount;\n    var before = groupIntersect({\n      start: 0,\n      end: index\n    }, this.groups);\n    var after = groupIntersect({\n      start: index + deleteCount,\n      end: Number.POSITIVE_INFINITY\n    }, this.groups).map(function (g) {\n      return {\n        range: shift(g.range, diff),\n        size: g.size\n      };\n    });\n    var middle = items.map(function (item, i) {\n      return {\n        range: {\n          start: index + i,\n          end: index + i + 1\n        },\n        size: item.size\n      };\n    });\n    this.groups = concat(before, middle, after);\n    this._size = this.groups.reduce(function (t, g) {\n      return t + g.size * (g.range.end - g.range.start);\n    }, 0);\n  };\n\n  Object.defineProperty(RangeMap.prototype, \"count\", {\n    /**\n     * Returns the number of items in the range map.\n     */\n    get: function () {\n      var len = this.groups.length;\n\n      if (!len) {\n        return 0;\n      }\n\n      return this.groups[len - 1].range.end;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RangeMap.prototype, \"size\", {\n    /**\n     * Returns the sum of the sizes of all items in the range map.\n     */\n    get: function () {\n      return this._size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns the index of the item at the given position.\n   */\n\n  RangeMap.prototype.indexAt = function (position) {\n    if (position < 0) {\n      return -1;\n    }\n\n    var index = 0;\n    var size = 0;\n\n    for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {\n      var group = _a[_i];\n      var count = group.range.end - group.range.start;\n      var newSize = size + count * group.size;\n\n      if (position < newSize) {\n        return index + Math.floor((position - size) / group.size);\n      }\n\n      index += count;\n      size = newSize;\n    }\n\n    return index;\n  };\n  /**\n   * Returns the index of the item right after the item at the\n   * index of the given position.\n   */\n\n\n  RangeMap.prototype.indexAfter = function (position) {\n    return Math.min(this.indexAt(position) + 1, this.count);\n  };\n  /**\n   * Returns the start position of the item at the given index.\n   */\n\n\n  RangeMap.prototype.positionAt = function (index) {\n    if (index < 0) {\n      return -1;\n    }\n\n    var position = 0;\n    var count = 0;\n\n    for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {\n      var group = _a[_i];\n      var groupCount = group.range.end - group.range.start;\n      var newCount = count + groupCount;\n\n      if (index < newCount) {\n        return position + (index - count) * group.size;\n      }\n\n      position += groupCount * group.size;\n      count = newCount;\n    }\n\n    return -1;\n  };\n\n  RangeMap.prototype.dispose = function () {\n    this.groups = null; // StrictNullOverride: nulling out ok in dispose\n  };\n\n  return RangeMap;\n}();\n\nexport { RangeMap };","map":null,"metadata":{},"sourceType":"module"}