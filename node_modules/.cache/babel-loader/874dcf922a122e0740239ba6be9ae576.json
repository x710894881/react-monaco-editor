{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as arrays from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { TokenizationRegistry } from '../modes.js';\nimport { nullTokenize2 } from '../modes/nullMode.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { MultilineTokensBuilder, countEOL } from './tokensStore.js';\n\nvar TokenizationStateStore =\n/** @class */\nfunction () {\n  function TokenizationStateStore() {\n    this._beginState = [];\n    this._valid = [];\n    this._len = 0;\n    this._invalidLineStartIndex = 0;\n  }\n\n  TokenizationStateStore.prototype._reset = function (initialState) {\n    this._beginState = [];\n    this._valid = [];\n    this._len = 0;\n    this._invalidLineStartIndex = 0;\n\n    if (initialState) {\n      this._setBeginState(0, initialState);\n    }\n  };\n\n  TokenizationStateStore.prototype.flush = function (initialState) {\n    this._reset(initialState);\n  };\n\n  Object.defineProperty(TokenizationStateStore.prototype, \"invalidLineStartIndex\", {\n    get: function () {\n      return this._invalidLineStartIndex;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TokenizationStateStore.prototype._invalidateLine = function (lineIndex) {\n    if (lineIndex < this._len) {\n      this._valid[lineIndex] = false;\n    }\n\n    if (lineIndex < this._invalidLineStartIndex) {\n      this._invalidLineStartIndex = lineIndex;\n    }\n  };\n\n  TokenizationStateStore.prototype._isValid = function (lineIndex) {\n    if (lineIndex < this._len) {\n      return this._valid[lineIndex];\n    }\n\n    return false;\n  };\n\n  TokenizationStateStore.prototype.getBeginState = function (lineIndex) {\n    if (lineIndex < this._len) {\n      return this._beginState[lineIndex];\n    }\n\n    return null;\n  };\n\n  TokenizationStateStore.prototype._ensureLine = function (lineIndex) {\n    while (lineIndex >= this._len) {\n      this._beginState[this._len] = null;\n      this._valid[this._len] = false;\n      this._len++;\n    }\n  };\n\n  TokenizationStateStore.prototype._deleteLines = function (start, deleteCount) {\n    if (deleteCount === 0) {\n      return;\n    }\n\n    if (start + deleteCount > this._len) {\n      deleteCount = this._len - start;\n    }\n\n    this._beginState.splice(start, deleteCount);\n\n    this._valid.splice(start, deleteCount);\n\n    this._len -= deleteCount;\n  };\n\n  TokenizationStateStore.prototype._insertLines = function (insertIndex, insertCount) {\n    if (insertCount === 0) {\n      return;\n    }\n\n    var beginState = [];\n    var valid = [];\n\n    for (var i = 0; i < insertCount; i++) {\n      beginState[i] = null;\n      valid[i] = false;\n    }\n\n    this._beginState = arrays.arrayInsert(this._beginState, insertIndex, beginState);\n    this._valid = arrays.arrayInsert(this._valid, insertIndex, valid);\n    this._len += insertCount;\n  };\n\n  TokenizationStateStore.prototype._setValid = function (lineIndex, valid) {\n    this._ensureLine(lineIndex);\n\n    this._valid[lineIndex] = valid;\n  };\n\n  TokenizationStateStore.prototype._setBeginState = function (lineIndex, beginState) {\n    this._ensureLine(lineIndex);\n\n    this._beginState[lineIndex] = beginState;\n  };\n\n  TokenizationStateStore.prototype.setEndState = function (linesLength, lineIndex, endState) {\n    this._setValid(lineIndex, true);\n\n    this._invalidLineStartIndex = lineIndex + 1; // Check if this was the last line\n\n    if (lineIndex === linesLength - 1) {\n      return;\n    } // Check if the end state has changed\n\n\n    var previousEndState = this.getBeginState(lineIndex + 1);\n\n    if (previousEndState === null || !endState.equals(previousEndState)) {\n      this._setBeginState(lineIndex + 1, endState);\n\n      this._invalidateLine(lineIndex + 1);\n\n      return;\n    } // Perhaps we can skip tokenizing some lines...\n\n\n    var i = lineIndex + 1;\n\n    while (i < linesLength) {\n      if (!this._isValid(i)) {\n        break;\n      }\n\n      i++;\n    }\n\n    this._invalidLineStartIndex = i;\n  };\n\n  TokenizationStateStore.prototype.setFakeTokens = function (lineIndex) {\n    this._setValid(lineIndex, false);\n  }; //#region Editing\n\n\n  TokenizationStateStore.prototype.applyEdits = function (range, eolCount) {\n    var deletingLinesCnt = range.endLineNumber - range.startLineNumber;\n    var insertingLinesCnt = eolCount;\n    var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n\n    for (var j = editingLinesCnt; j >= 0; j--) {\n      this._invalidateLine(range.startLineNumber + j - 1);\n    }\n\n    this._acceptDeleteRange(range);\n\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount);\n  };\n\n  TokenizationStateStore.prototype._acceptDeleteRange = function (range) {\n    var firstLineIndex = range.startLineNumber - 1;\n\n    if (firstLineIndex >= this._len) {\n      return;\n    }\n\n    this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n  };\n\n  TokenizationStateStore.prototype._acceptInsertText = function (position, eolCount) {\n    var lineIndex = position.lineNumber - 1;\n\n    if (lineIndex >= this._len) {\n      return;\n    }\n\n    this._insertLines(position.lineNumber, eolCount);\n  };\n\n  return TokenizationStateStore;\n}();\n\nexport { TokenizationStateStore };\n\nvar TextModelTokenization =\n/** @class */\nfunction (_super) {\n  __extends(TextModelTokenization, _super);\n\n  function TextModelTokenization(textModel) {\n    var _this = _super.call(this) || this;\n\n    _this._textModel = textModel;\n    _this._tokenizationStateStore = new TokenizationStateStore();\n    _this._revalidateTokensTimeout = -1;\n    _this._tokenizationSupport = null;\n\n    _this._register(TokenizationRegistry.onDidChange(function (e) {\n      var languageIdentifier = _this._textModel.getLanguageIdentifier();\n\n      if (e.changedLanguages.indexOf(languageIdentifier.language) === -1) {\n        return;\n      }\n\n      _this._resetTokenizationState();\n\n      _this._textModel.clearTokens();\n    }));\n\n    _this._register(_this._textModel.onDidChangeRawContentFast(function (e) {\n      if (e.containsEvent(1\n      /* Flush */\n      )) {\n        _this._resetTokenizationState();\n\n        return;\n      }\n    }));\n\n    _this._register(_this._textModel.onDidChangeContentFast(function (e) {\n      for (var i = 0, len = e.changes.length; i < len; i++) {\n        var change = e.changes[i];\n        var eolCount = countEOL(change.text)[0];\n\n        _this._tokenizationStateStore.applyEdits(change.range, eolCount);\n      }\n\n      _this._beginBackgroundTokenization();\n    }));\n\n    _this._register(_this._textModel.onDidChangeAttached(function () {\n      _this._beginBackgroundTokenization();\n    }));\n\n    _this._register(_this._textModel.onDidChangeLanguage(function () {\n      _this._resetTokenizationState();\n\n      _this._textModel.clearTokens();\n    }));\n\n    _this._resetTokenizationState();\n\n    return _this;\n  }\n\n  TextModelTokenization.prototype.dispose = function () {\n    this._clearTimers();\n\n    _super.prototype.dispose.call(this);\n  };\n\n  TextModelTokenization.prototype._clearTimers = function () {\n    if (this._revalidateTokensTimeout !== -1) {\n      clearTimeout(this._revalidateTokensTimeout);\n      this._revalidateTokensTimeout = -1;\n    }\n  };\n\n  TextModelTokenization.prototype._resetTokenizationState = function () {\n    this._clearTimers();\n\n    var _a = initializeTokenization(this._textModel),\n        tokenizationSupport = _a[0],\n        initialState = _a[1];\n\n    this._tokenizationSupport = tokenizationSupport;\n\n    this._tokenizationStateStore.flush(initialState);\n\n    this._beginBackgroundTokenization();\n  };\n\n  TextModelTokenization.prototype._beginBackgroundTokenization = function () {\n    var _this = this;\n\n    if (this._textModel.isAttachedToEditor() && this._hasLinesToTokenize() && this._revalidateTokensTimeout === -1) {\n      this._revalidateTokensTimeout = setTimeout(function () {\n        _this._revalidateTokensTimeout = -1;\n\n        _this._revalidateTokensNow();\n      }, 0);\n    }\n  };\n\n  TextModelTokenization.prototype._revalidateTokensNow = function (toLineNumber) {\n    if (toLineNumber === void 0) {\n      toLineNumber = this._textModel.getLineCount();\n    }\n\n    var MAX_ALLOWED_TIME = 20;\n    var builder = new MultilineTokensBuilder();\n    var sw = StopWatch.create(false);\n\n    while (this._hasLinesToTokenize()) {\n      if (sw.elapsed() > MAX_ALLOWED_TIME) {\n        // Stop if MAX_ALLOWED_TIME is reached\n        break;\n      }\n\n      var tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n      if (tokenizedLineNumber >= toLineNumber) {\n        break;\n      }\n    }\n\n    this._beginBackgroundTokenization();\n\n    this._textModel.setTokens(builder.tokens);\n  };\n\n  TextModelTokenization.prototype.tokenizeViewport = function (startLineNumber, endLineNumber) {\n    var builder = new MultilineTokensBuilder();\n\n    this._tokenizeViewport(builder, startLineNumber, endLineNumber);\n\n    this._textModel.setTokens(builder.tokens);\n  };\n\n  TextModelTokenization.prototype.reset = function () {\n    this._resetTokenizationState();\n\n    this._textModel.clearTokens();\n  };\n\n  TextModelTokenization.prototype.forceTokenization = function (lineNumber) {\n    var builder = new MultilineTokensBuilder();\n\n    this._updateTokensUntilLine(builder, lineNumber);\n\n    this._textModel.setTokens(builder.tokens);\n  };\n\n  TextModelTokenization.prototype.isCheapToTokenize = function (lineNumber) {\n    if (!this._tokenizationSupport) {\n      return true;\n    }\n\n    var firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n\n    if (lineNumber > firstInvalidLineNumber) {\n      return false;\n    }\n\n    if (lineNumber < firstInvalidLineNumber) {\n      return true;\n    }\n\n    if (this._textModel.getLineLength(lineNumber) < 2048\n    /* CHEAP_TOKENIZATION_LENGTH_LIMIT */\n    ) {\n        return true;\n      }\n\n    return false;\n  };\n\n  TextModelTokenization.prototype._hasLinesToTokenize = function () {\n    if (!this._tokenizationSupport) {\n      return false;\n    }\n\n    return this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount();\n  };\n\n  TextModelTokenization.prototype._tokenizeOneInvalidLine = function (builder) {\n    if (!this._hasLinesToTokenize()) {\n      return this._textModel.getLineCount() + 1;\n    }\n\n    var lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n\n    this._updateTokensUntilLine(builder, lineNumber);\n\n    return lineNumber;\n  };\n\n  TextModelTokenization.prototype._updateTokensUntilLine = function (builder, lineNumber) {\n    if (!this._tokenizationSupport) {\n      return;\n    }\n\n    var languageIdentifier = this._textModel.getLanguageIdentifier();\n\n    var linesLength = this._textModel.getLineCount();\n\n    var endLineIndex = lineNumber - 1; // Validate all states up to and including endLineIndex\n\n    for (var lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n      var text = this._textModel.getLineContent(lineIndex + 1);\n\n      var lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\n\n      var r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, lineStartState);\n      builder.add(lineIndex + 1, r.tokens);\n\n      this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\n\n      lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\n    }\n  };\n\n  TextModelTokenization.prototype._tokenizeViewport = function (builder, startLineNumber, endLineNumber) {\n    if (!this._tokenizationSupport) {\n      // nothing to do\n      return;\n    }\n\n    if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n      // nothing to do\n      return;\n    }\n\n    if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n      // tokenization has reached the viewport start...\n      this._updateTokensUntilLine(builder, endLineNumber);\n\n      return;\n    }\n\n    var nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\n\n    var fakeLines = [];\n    var initialState = null;\n\n    for (var i = startLineNumber - 1; nonWhitespaceColumn > 0 && i >= 1; i--) {\n      var newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n\n      if (newNonWhitespaceIndex === 0) {\n        continue;\n      }\n\n      if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n        initialState = this._tokenizationStateStore.getBeginState(i - 1);\n\n        if (initialState) {\n          break;\n        }\n\n        fakeLines.push(this._textModel.getLineContent(i));\n        nonWhitespaceColumn = newNonWhitespaceIndex;\n      }\n    }\n\n    if (!initialState) {\n      initialState = this._tokenizationSupport.getInitialState();\n    }\n\n    var languageIdentifier = this._textModel.getLanguageIdentifier();\n\n    var state = initialState;\n\n    for (var i = fakeLines.length - 1; i >= 0; i--) {\n      var r = safeTokenize(languageIdentifier, this._tokenizationSupport, fakeLines[i], state);\n      state = r.endState;\n    }\n\n    for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      var text = this._textModel.getLineContent(lineNumber);\n\n      var r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, state);\n      builder.add(lineNumber, r.tokens);\n\n      this._tokenizationStateStore.setFakeTokens(lineNumber - 1);\n\n      state = r.endState;\n    }\n  };\n\n  return TextModelTokenization;\n}(Disposable);\n\nexport { TextModelTokenization };\n\nfunction initializeTokenization(textModel) {\n  var languageIdentifier = textModel.getLanguageIdentifier();\n  var tokenizationSupport = textModel.isTooLargeForTokenization() ? null : TokenizationRegistry.get(languageIdentifier.language);\n  var initialState = null;\n\n  if (tokenizationSupport) {\n    try {\n      initialState = tokenizationSupport.getInitialState();\n    } catch (e) {\n      onUnexpectedError(e);\n      tokenizationSupport = null;\n    }\n  }\n\n  return [tokenizationSupport, initialState];\n}\n\nfunction safeTokenize(languageIdentifier, tokenizationSupport, text, state) {\n  var r = null;\n\n  if (tokenizationSupport) {\n    try {\n      r = tokenizationSupport.tokenize2(text, state.clone(), 0);\n    } catch (e) {\n      onUnexpectedError(e);\n    }\n  }\n\n  if (!r) {\n    r = nullTokenize2(languageIdentifier.id, text, state, 0);\n  }\n\n  LineTokens.convertToEndOffset(r.tokens, text.length);\n  return r;\n}","map":null,"metadata":{},"sourceType":"module"}