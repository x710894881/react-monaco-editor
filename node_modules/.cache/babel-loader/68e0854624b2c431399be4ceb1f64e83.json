{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { escapeRegExpCharacters } from '../../../base/common/strings.js';\nimport { EditorAction, EditorCommand } from '../../browser/editorExtensions.js';\nimport { IBulkEditService } from '../../browser/services/bulkEditService.js';\nimport { EditorContextKeys } from '../../common/editorContextKeys.js';\nimport { CodeActionUi } from './codeActionUi.js';\nimport { MessageController } from '../message/messageController.js';\nimport * as nls from '../../../nls.js';\nimport { ICommandService } from '../../../platform/commands/common/commands.js';\nimport { ContextKeyExpr, IContextKeyService } from '../../../platform/contextkey/common/contextkey.js';\nimport { IContextMenuService } from '../../../platform/contextview/browser/contextView.js';\nimport { IKeybindingService } from '../../../platform/keybinding/common/keybinding.js';\nimport { IMarkerService } from '../../../platform/markers/common/markers.js';\nimport { IEditorProgressService } from '../../../platform/progress/common/progress.js';\nimport { CodeActionModel, SUPPORTED_CODE_ACTIONS } from './codeActionModel.js';\nimport { CodeActionKind } from './codeActionTrigger.js';\n\nfunction contextKeyForSupportedActions(kind) {\n  return ContextKeyExpr.regex(SUPPORTED_CODE_ACTIONS.keys()[0], new RegExp('(\\\\s|^)' + escapeRegExpCharacters(kind.value) + '\\\\b'));\n}\n\nvar QuickFixController =\n/** @class */\nfunction (_super) {\n  __extends(QuickFixController, _super);\n\n  function QuickFixController(editor, markerService, contextKeyService, progressService, contextMenuService, keybindingService, _commandService, _bulkEditService) {\n    var _this = _super.call(this) || this;\n\n    _this._commandService = _commandService;\n    _this._bulkEditService = _bulkEditService;\n    _this._editor = editor;\n    _this._model = _this._register(new CodeActionModel(_this._editor, markerService, contextKeyService, progressService));\n\n    _this._register(_this._model.onDidChangeState(function (newState) {\n      return _this.update(newState);\n    }));\n\n    _this._ui = _this._register(new CodeActionUi(editor, QuickFixAction.Id, {\n      applyCodeAction: function (action, retrigger) {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0,, 2, 3]);\n\n                return [4\n                /*yield*/\n                , this._applyCodeAction(action)];\n\n              case 1:\n                _a.sent();\n\n                return [3\n                /*break*/\n                , 3];\n\n              case 2:\n                if (retrigger) {\n                  this._trigger({\n                    type: 'auto',\n                    filter: {}\n                  });\n                }\n\n                return [7\n                /*endfinally*/\n                ];\n\n              case 3:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      }\n    }, contextMenuService, keybindingService));\n    return _this;\n  }\n\n  QuickFixController.get = function (editor) {\n    return editor.getContribution(QuickFixController.ID);\n  };\n\n  QuickFixController.prototype.update = function (newState) {\n    this._ui.update(newState);\n  };\n\n  QuickFixController.prototype.showCodeActions = function (actions, at) {\n    return this._ui.showCodeActionList(actions, at);\n  };\n\n  QuickFixController.prototype.getId = function () {\n    return QuickFixController.ID;\n  };\n\n  QuickFixController.prototype.manualTriggerAtCurrentPosition = function (notAvailableMessage, filter, autoApply) {\n    if (!this._editor.hasModel()) {\n      return;\n    }\n\n    MessageController.get(this._editor).closeMessage();\n\n    var triggerPosition = this._editor.getPosition();\n\n    this._trigger({\n      type: 'manual',\n      filter: filter,\n      autoApply: autoApply,\n      context: {\n        notAvailableMessage: notAvailableMessage,\n        position: triggerPosition\n      }\n    });\n  };\n\n  QuickFixController.prototype._trigger = function (trigger) {\n    return this._model.trigger(trigger);\n  };\n\n  QuickFixController.prototype._applyCodeAction = function (action) {\n    return applyCodeAction(action, this._bulkEditService, this._commandService, this._editor);\n  };\n\n  QuickFixController.ID = 'editor.contrib.quickFixController';\n  QuickFixController = __decorate([__param(1, IMarkerService), __param(2, IContextKeyService), __param(3, IEditorProgressService), __param(4, IContextMenuService), __param(5, IKeybindingService), __param(6, ICommandService), __param(7, IBulkEditService)], QuickFixController);\n  return QuickFixController;\n}(Disposable);\n\nexport { QuickFixController };\nexport function applyCodeAction(action, bulkEditService, commandService, editor) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!action.edit) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , bulkEditService.apply(action.edit, {\n            editor: editor\n          })];\n\n        case 1:\n          _a.sent();\n\n          _a.label = 2;\n\n        case 2:\n          if (!action.command) return [3\n          /*break*/\n          , 4];\n          return [4\n          /*yield*/\n          , commandService.executeCommand.apply(commandService, [action.command.id].concat(action.command.arguments || []))];\n\n        case 3:\n          _a.sent();\n\n          _a.label = 4;\n\n        case 4:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction triggerCodeActionsForEditorSelection(editor, notAvailableMessage, filter, autoApply) {\n  if (editor.hasModel()) {\n    var controller = QuickFixController.get(editor);\n\n    if (controller) {\n      controller.manualTriggerAtCurrentPosition(notAvailableMessage, filter, autoApply);\n    }\n  }\n}\n\nvar QuickFixAction =\n/** @class */\nfunction (_super) {\n  __extends(QuickFixAction, _super);\n\n  function QuickFixAction() {\n    return _super.call(this, {\n      id: QuickFixAction.Id,\n      label: nls.localize('quickfix.trigger.label', \"Quick Fix...\"),\n      alias: 'Quick Fix...',\n      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 2048\n        /* CtrlCmd */\n        | 84\n        /* US_DOT */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  QuickFixAction.prototype.run = function (_accessor, editor) {\n    return triggerCodeActionsForEditorSelection(editor, nls.localize('editor.action.quickFix.noneMessage', \"No code actions available\"), undefined, undefined);\n  };\n\n  QuickFixAction.Id = 'editor.action.quickFix';\n  return QuickFixAction;\n}(EditorAction);\n\nexport { QuickFixAction };\n\nvar CodeActionCommandArgs =\n/** @class */\nfunction () {\n  function CodeActionCommandArgs(kind, apply, preferred) {\n    this.kind = kind;\n    this.apply = apply;\n    this.preferred = preferred;\n  }\n\n  CodeActionCommandArgs.fromUser = function (arg, defaults) {\n    if (!arg || typeof arg !== 'object') {\n      return new CodeActionCommandArgs(defaults.kind, defaults.apply, false);\n    }\n\n    return new CodeActionCommandArgs(CodeActionCommandArgs.getKindFromUser(arg, defaults.kind), CodeActionCommandArgs.getApplyFromUser(arg, defaults.apply), CodeActionCommandArgs.getPreferredUser(arg));\n  };\n\n  CodeActionCommandArgs.getApplyFromUser = function (arg, defaultAutoApply) {\n    switch (typeof arg.apply === 'string' ? arg.apply.toLowerCase() : '') {\n      case 'first':\n        return 1\n        /* First */\n        ;\n\n      case 'never':\n        return 2\n        /* Never */\n        ;\n\n      case 'ifsingle':\n        return 0\n        /* IfSingle */\n        ;\n\n      default:\n        return defaultAutoApply;\n    }\n  };\n\n  CodeActionCommandArgs.getKindFromUser = function (arg, defaultKind) {\n    return typeof arg.kind === 'string' ? new CodeActionKind(arg.kind) : defaultKind;\n  };\n\n  CodeActionCommandArgs.getPreferredUser = function (arg) {\n    return typeof arg.preferred === 'boolean' ? arg.preferred : false;\n  };\n\n  return CodeActionCommandArgs;\n}();\n\nvar CodeActionCommand =\n/** @class */\nfunction (_super) {\n  __extends(CodeActionCommand, _super);\n\n  function CodeActionCommand() {\n    return _super.call(this, {\n      id: CodeActionCommand.Id,\n      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),\n      description: {\n        description: \"Trigger a code action\",\n        args: [{\n          name: 'args',\n          schema: {\n            'type': 'object',\n            'required': ['kind'],\n            'properties': {\n              'kind': {\n                'type': 'string'\n              },\n              'apply': {\n                'type': 'string',\n                'default': 'ifSingle',\n                'enum': ['first', 'ifSingle', 'never']\n              }\n            }\n          }\n        }]\n      }\n    }) || this;\n  }\n\n  CodeActionCommand.prototype.runEditorCommand = function (_accessor, editor, userArg) {\n    var args = CodeActionCommandArgs.fromUser(userArg, {\n      kind: CodeActionKind.Empty,\n      apply: 0\n      /* IfSingle */\n\n    });\n    return triggerCodeActionsForEditorSelection(editor, nls.localize('editor.action.quickFix.noneMessage', \"No code actions available\"), {\n      kind: args.kind,\n      includeSourceActions: true,\n      onlyIncludePreferredActions: args.preferred\n    }, args.apply);\n  };\n\n  CodeActionCommand.Id = 'editor.action.codeAction';\n  return CodeActionCommand;\n}(EditorCommand);\n\nexport { CodeActionCommand };\n\nvar RefactorAction =\n/** @class */\nfunction (_super) {\n  __extends(RefactorAction, _super);\n\n  function RefactorAction() {\n    return _super.call(this, {\n      id: RefactorAction.Id,\n      label: nls.localize('refactor.label', \"Refactor...\"),\n      alias: 'Refactor...',\n      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 2048\n        /* CtrlCmd */\n        | 1024\n        /* Shift */\n        | 48\n        /* KEY_R */\n        ,\n        mac: {\n          primary: 256\n          /* WinCtrl */\n          | 1024\n          /* Shift */\n          | 48\n          /* KEY_R */\n\n        },\n        weight: 100\n        /* EditorContrib */\n\n      },\n      menuOpts: {\n        group: '1_modification',\n        order: 2,\n        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Refactor))\n      },\n      description: {\n        description: 'Refactor...',\n        args: [{\n          name: 'args',\n          schema: {\n            'type': 'object',\n            'properties': {\n              'kind': {\n                'type': 'string'\n              },\n              'apply': {\n                'type': 'string',\n                'default': 'never',\n                'enum': ['first', 'ifSingle', 'never']\n              }\n            }\n          }\n        }]\n      }\n    }) || this;\n  }\n\n  RefactorAction.prototype.run = function (_accessor, editor, userArg) {\n    var args = CodeActionCommandArgs.fromUser(userArg, {\n      kind: CodeActionKind.Refactor,\n      apply: 2\n      /* Never */\n\n    });\n    return triggerCodeActionsForEditorSelection(editor, nls.localize('editor.action.refactor.noneMessage', \"No refactorings available\"), {\n      kind: CodeActionKind.Refactor.contains(args.kind) ? args.kind : CodeActionKind.Empty,\n      onlyIncludePreferredActions: args.preferred\n    }, args.apply);\n  };\n\n  RefactorAction.Id = 'editor.action.refactor';\n  return RefactorAction;\n}(EditorAction);\n\nexport { RefactorAction };\n\nvar SourceAction =\n/** @class */\nfunction (_super) {\n  __extends(SourceAction, _super);\n\n  function SourceAction() {\n    return _super.call(this, {\n      id: SourceAction.Id,\n      label: nls.localize('source.label', \"Source Action...\"),\n      alias: 'Source Action...',\n      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),\n      menuOpts: {\n        group: '1_modification',\n        order: 2.1,\n        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Source))\n      },\n      description: {\n        description: 'Source Action...',\n        args: [{\n          name: 'args',\n          schema: {\n            'type': 'object',\n            'properties': {\n              'kind': {\n                'type': 'string'\n              },\n              'apply': {\n                'type': 'string',\n                'default': 'never',\n                'enum': ['first', 'ifSingle', 'never']\n              }\n            }\n          }\n        }]\n      }\n    }) || this;\n  }\n\n  SourceAction.prototype.run = function (_accessor, editor, userArg) {\n    var args = CodeActionCommandArgs.fromUser(userArg, {\n      kind: CodeActionKind.Source,\n      apply: 2\n      /* Never */\n\n    });\n    return triggerCodeActionsForEditorSelection(editor, nls.localize('editor.action.source.noneMessage', \"No source actions available\"), {\n      kind: CodeActionKind.Source.contains(args.kind) ? args.kind : CodeActionKind.Empty,\n      includeSourceActions: true,\n      onlyIncludePreferredActions: args.preferred\n    }, args.apply);\n  };\n\n  SourceAction.Id = 'editor.action.sourceAction';\n  return SourceAction;\n}(EditorAction);\n\nexport { SourceAction };\n\nvar OrganizeImportsAction =\n/** @class */\nfunction (_super) {\n  __extends(OrganizeImportsAction, _super);\n\n  function OrganizeImportsAction() {\n    return _super.call(this, {\n      id: OrganizeImportsAction.Id,\n      label: nls.localize('organizeImports.label', \"Organize Imports\"),\n      alias: 'Organize Imports',\n      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceOrganizeImports)),\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 1024\n        /* Shift */\n        | 512\n        /* Alt */\n        | 45\n        /* KEY_O */\n        ,\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  OrganizeImportsAction.prototype.run = function (_accessor, editor) {\n    return triggerCodeActionsForEditorSelection(editor, nls.localize('editor.action.organize.noneMessage', \"No organize imports action available\"), {\n      kind: CodeActionKind.SourceOrganizeImports,\n      includeSourceActions: true\n    }, 0\n    /* IfSingle */\n    );\n  };\n\n  OrganizeImportsAction.Id = 'editor.action.organizeImports';\n  return OrganizeImportsAction;\n}(EditorAction);\n\nexport { OrganizeImportsAction };\n\nvar FixAllAction =\n/** @class */\nfunction (_super) {\n  __extends(FixAllAction, _super);\n\n  function FixAllAction() {\n    return _super.call(this, {\n      id: FixAllAction.Id,\n      label: nls.localize('fixAll.label', \"Fix All\"),\n      alias: 'Fix All',\n      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceFixAll))\n    }) || this;\n  }\n\n  FixAllAction.prototype.run = function (_accessor, editor) {\n    return triggerCodeActionsForEditorSelection(editor, nls.localize('fixAll.noneMessage', \"No fix all action available\"), {\n      kind: CodeActionKind.SourceFixAll,\n      includeSourceActions: true\n    }, 0\n    /* IfSingle */\n    );\n  };\n\n  FixAllAction.Id = 'editor.action.fixAll';\n  return FixAllAction;\n}(EditorAction);\n\nexport { FixAllAction };\n\nvar AutoFixAction =\n/** @class */\nfunction (_super) {\n  __extends(AutoFixAction, _super);\n\n  function AutoFixAction() {\n    return _super.call(this, {\n      id: AutoFixAction.Id,\n      label: nls.localize('autoFix.label', \"Auto Fix...\"),\n      alias: 'Auto Fix...',\n      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.QuickFix)),\n      kbOpts: {\n        kbExpr: EditorContextKeys.editorTextFocus,\n        primary: 512\n        /* Alt */\n        | 1024\n        /* Shift */\n        | 84\n        /* US_DOT */\n        ,\n        mac: {\n          primary: 2048\n          /* CtrlCmd */\n          | 512\n          /* Alt */\n          | 84\n          /* US_DOT */\n\n        },\n        weight: 100\n        /* EditorContrib */\n\n      }\n    }) || this;\n  }\n\n  AutoFixAction.prototype.run = function (_accessor, editor) {\n    return triggerCodeActionsForEditorSelection(editor, nls.localize('editor.action.autoFix.noneMessage', \"No auto fixes available\"), {\n      kind: CodeActionKind.QuickFix,\n      onlyIncludePreferredActions: true\n    }, 0\n    /* IfSingle */\n    );\n  };\n\n  AutoFixAction.Id = 'editor.action.autoFix';\n  return AutoFixAction;\n}(EditorAction);\n\nexport { AutoFixAction };","map":null,"metadata":{},"sourceType":"module"}