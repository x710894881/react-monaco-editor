{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as Parser from '../parser/jsonParser.js';\nimport * as Json from '../../jsonc-parser/main.js';\nimport { stringifyObject } from '../utils/json.js';\nimport { endsWith } from '../utils/strings.js';\nimport { isDefined } from '../utils/objects.js';\nimport { CompletionItem, CompletionItemKind, Range, TextEdit, InsertTextFormat, MarkupKind } from '../_deps/vscode-languageserver-types/main.js';\nimport * as nls from '../../../fillers/vscode-nls.js';\nvar localize = nls.loadMessageBundle();\n\nvar JSONCompletion =\n/** @class */\nfunction () {\n  function JSONCompletion(schemaService, contributions, promiseConstructor, clientCapabilities) {\n    if (contributions === void 0) {\n      contributions = [];\n    }\n\n    if (promiseConstructor === void 0) {\n      promiseConstructor = Promise;\n    }\n\n    if (clientCapabilities === void 0) {\n      clientCapabilities = {};\n    }\n\n    this.schemaService = schemaService;\n    this.contributions = contributions;\n    this.promiseConstructor = promiseConstructor;\n    this.clientCapabilities = clientCapabilities;\n    this.templateVarIdCounter = 0;\n  }\n\n  JSONCompletion.prototype.doResolve = function (item) {\n    for (var i = this.contributions.length - 1; i >= 0; i--) {\n      if (this.contributions[i].resolveCompletion) {\n        var resolver = this.contributions[i].resolveCompletion(item);\n\n        if (resolver) {\n          return resolver;\n        }\n      }\n    }\n\n    return this.promiseConstructor.resolve(item);\n  };\n\n  JSONCompletion.prototype.doComplete = function (document, position, doc) {\n    var _this = this;\n\n    var result = {\n      items: [],\n      isIncomplete: false\n    };\n    var offset = document.offsetAt(position);\n    var node = doc.getNodeFromOffset(offset, true);\n\n    if (this.isInComment(document, node ? node.offset : 0, offset)) {\n      return Promise.resolve(result);\n    }\n\n    var currentWord = this.getCurrentWord(document, offset);\n    var overwriteRange = null;\n\n    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n      overwriteRange = Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));\n    } else {\n      var overwriteStart = offset - currentWord.length;\n\n      if (overwriteStart > 0 && document.getText()[overwriteStart - 1] === '\"') {\n        overwriteStart--;\n      }\n\n      overwriteRange = Range.create(document.positionAt(overwriteStart), position);\n    }\n\n    var proposed = {};\n    var collector = {\n      add: function (suggestion) {\n        var existing = proposed[suggestion.label];\n\n        if (!existing) {\n          proposed[suggestion.label] = suggestion;\n\n          if (overwriteRange) {\n            suggestion.textEdit = TextEdit.replace(overwriteRange, suggestion.insertText);\n          }\n\n          result.items.push(suggestion);\n        } else if (!existing.documentation) {\n          existing.documentation = suggestion.documentation;\n        }\n      },\n      setAsIncomplete: function () {\n        result.isIncomplete = true;\n      },\n      error: function (message) {\n        console.error(message);\n      },\n      log: function (message) {\n        console.log(message);\n      },\n      getNumberOfProposals: function () {\n        return result.items.length;\n      }\n    };\n    return this.schemaService.getSchemaForResource(document.uri, doc).then(function (schema) {\n      var collectionPromises = [];\n      var addValue = true;\n      var currentKey = '';\n      var currentProperty = null;\n\n      if (node) {\n        if (node.type === 'string') {\n          var parent = node.parent;\n\n          if (parent && parent.type === 'property' && parent.keyNode === node) {\n            addValue = !parent.valueNode;\n            currentProperty = parent;\n            currentKey = document.getText().substr(node.offset + 1, node.length - 2);\n\n            if (parent) {\n              node = parent.parent;\n            }\n          }\n        }\n      } // proposals for properties\n\n\n      if (node && node.type === 'object') {\n        // don't suggest keys when the cursor is just before the opening curly brace\n        if (node.offset === offset) {\n          return result;\n        } // don't suggest properties that are already present\n\n\n        var properties = node.properties;\n        properties.forEach(function (p) {\n          if (!currentProperty || currentProperty !== p) {\n            proposed[p.keyNode.value] = CompletionItem.create('__');\n          }\n        });\n        var separatorAfter_1 = '';\n\n        if (addValue) {\n          separatorAfter_1 = _this.evaluateSeparatorAfter(document, document.offsetAt(overwriteRange.end));\n        }\n\n        if (schema) {\n          // property proposals with schema\n          _this.getPropertyCompletions(schema, doc, node, addValue, separatorAfter_1, collector);\n        } else {\n          // property proposals without schema\n          _this.getSchemaLessPropertyCompletions(doc, node, currentKey, collector);\n        }\n\n        var location_1 = Parser.getNodePath(node);\n\n        _this.contributions.forEach(function (contribution) {\n          var collectPromise = contribution.collectPropertyCompletions(document.uri, location_1, currentWord, addValue, separatorAfter_1 === '', collector);\n\n          if (collectPromise) {\n            collectionPromises.push(collectPromise);\n          }\n        });\n\n        if (!schema && currentWord.length > 0 && document.getText().charAt(offset - currentWord.length - 1) !== '\"') {\n          collector.add({\n            kind: CompletionItemKind.Property,\n            label: _this.getLabelForValue(currentWord),\n            insertText: _this.getInsertTextForProperty(currentWord, null, false, separatorAfter_1),\n            insertTextFormat: InsertTextFormat.Snippet,\n            documentation: ''\n          });\n          collector.setAsIncomplete();\n        }\n      } // proposals for values\n\n\n      var types = {};\n\n      if (schema) {\n        // value proposals with schema\n        _this.getValueCompletions(schema, doc, node, offset, document, collector, types);\n      } else {\n        // value proposals without schema\n        _this.getSchemaLessValueCompletions(doc, node, offset, document, collector);\n      }\n\n      if (_this.contributions.length > 0) {\n        _this.getContributedValueCompletions(doc, node, offset, document, collector, collectionPromises);\n      }\n\n      return _this.promiseConstructor.all(collectionPromises).then(function () {\n        if (collector.getNumberOfProposals() === 0) {\n          var offsetForSeparator = offset;\n\n          if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n            offsetForSeparator = node.offset + node.length;\n          }\n\n          var separatorAfter = _this.evaluateSeparatorAfter(document, offsetForSeparator);\n\n          _this.addFillerValueCompletions(types, separatorAfter, collector);\n        }\n\n        return result;\n      });\n    });\n  };\n\n  JSONCompletion.prototype.getPropertyCompletions = function (schema, doc, node, addValue, separatorAfter, collector) {\n    var _this = this;\n\n    var matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);\n    matchingSchemas.forEach(function (s) {\n      if (s.node === node && !s.inverted) {\n        var schemaProperties_1 = s.schema.properties;\n\n        if (schemaProperties_1) {\n          Object.keys(schemaProperties_1).forEach(function (key) {\n            var propertySchema = schemaProperties_1[key];\n\n            if (typeof propertySchema === 'object' && !propertySchema.deprecationMessage && !propertySchema.doNotSuggest) {\n              var proposal = {\n                kind: CompletionItemKind.Property,\n                label: _this.sanitizeLabel(key),\n                insertText: _this.getInsertTextForProperty(key, propertySchema, addValue, separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                filterText: _this.getFilterTextForValue(key),\n                documentation: _this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || ''\n              };\n\n              if (endsWith(proposal.insertText, \"$1\" + separatorAfter)) {\n                proposal.command = {\n                  title: 'Suggest',\n                  command: 'editor.action.triggerSuggest'\n                };\n              }\n\n              collector.add(proposal);\n            }\n          });\n        }\n      }\n    });\n  };\n\n  JSONCompletion.prototype.getSchemaLessPropertyCompletions = function (doc, node, currentKey, collector) {\n    var _this = this;\n\n    var collectCompletionsForSimilarObject = function (obj) {\n      obj.properties.forEach(function (p) {\n        var key = p.keyNode.value;\n        collector.add({\n          kind: CompletionItemKind.Property,\n          label: _this.sanitizeLabel(key),\n          insertText: _this.getInsertTextForValue(key, ''),\n          insertTextFormat: InsertTextFormat.Snippet,\n          filterText: _this.getFilterTextForValue(key),\n          documentation: ''\n        });\n      });\n    };\n\n    if (node.parent) {\n      if (node.parent.type === 'property') {\n        // if the object is a property value, check the tree for other objects that hang under a property of the same name\n        var parentKey_1 = node.parent.keyNode.value;\n        doc.visit(function (n) {\n          if (n.type === 'property' && n !== node.parent && n.keyNode.value === parentKey_1 && n.valueNode && n.valueNode.type === 'object') {\n            collectCompletionsForSimilarObject(n.valueNode);\n          }\n\n          return true;\n        });\n      } else if (node.parent.type === 'array') {\n        // if the object is in an array, use all other array elements as similar objects\n        node.parent.items.forEach(function (n) {\n          if (n.type === 'object' && n !== node) {\n            collectCompletionsForSimilarObject(n);\n          }\n        });\n      }\n    } else if (node.type === 'object') {\n      collector.add({\n        kind: CompletionItemKind.Property,\n        label: '$schema',\n        insertText: this.getInsertTextForProperty('$schema', null, true, ''),\n        insertTextFormat: InsertTextFormat.Snippet,\n        documentation: '',\n        filterText: this.getFilterTextForValue(\"$schema\")\n      });\n    }\n  };\n\n  JSONCompletion.prototype.getSchemaLessValueCompletions = function (doc, node, offset, document, collector) {\n    var _this = this;\n\n    var offsetForSeparator = offset;\n\n    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n      offsetForSeparator = node.offset + node.length;\n      node = node.parent;\n    }\n\n    if (!node) {\n      collector.add({\n        kind: this.getSuggestionKind('object'),\n        label: 'Empty object',\n        insertText: this.getInsertTextForValue({}, ''),\n        insertTextFormat: InsertTextFormat.Snippet,\n        documentation: ''\n      });\n      collector.add({\n        kind: this.getSuggestionKind('array'),\n        label: 'Empty array',\n        insertText: this.getInsertTextForValue([], ''),\n        insertTextFormat: InsertTextFormat.Snippet,\n        documentation: ''\n      });\n      return;\n    }\n\n    var separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);\n\n    var collectSuggestionsForValues = function (value) {\n      if (!Parser.contains(value.parent, offset, true)) {\n        collector.add({\n          kind: _this.getSuggestionKind(value.type),\n          label: _this.getLabelTextForMatchingNode(value, document),\n          insertText: _this.getInsertTextForMatchingNode(value, document, separatorAfter),\n          insertTextFormat: InsertTextFormat.Snippet,\n          documentation: ''\n        });\n      }\n\n      if (value.type === 'boolean') {\n        _this.addBooleanValueCompletion(!value.value, separatorAfter, collector);\n      }\n    };\n\n    if (node.type === 'property') {\n      if (offset > node.colonOffset) {\n        var valueNode = node.valueNode;\n\n        if (valueNode && (offset > valueNode.offset + valueNode.length || valueNode.type === 'object' || valueNode.type === 'array')) {\n          return;\n        } // suggest values at the same key\n\n\n        var parentKey_2 = node.keyNode.value;\n        doc.visit(function (n) {\n          if (n.type === 'property' && n.keyNode.value === parentKey_2 && n.valueNode) {\n            collectSuggestionsForValues(n.valueNode);\n          }\n\n          return true;\n        });\n\n        if (parentKey_2 === '$schema' && node.parent && !node.parent.parent) {\n          this.addDollarSchemaCompletions(separatorAfter, collector);\n        }\n      }\n    }\n\n    if (node.type === 'array') {\n      if (node.parent && node.parent.type === 'property') {\n        // suggest items of an array at the same key\n        var parentKey_3 = node.parent.keyNode.value;\n        doc.visit(function (n) {\n          if (n.type === 'property' && n.keyNode.value === parentKey_3 && n.valueNode && n.valueNode.type === 'array') {\n            n.valueNode.items.forEach(collectSuggestionsForValues);\n          }\n\n          return true;\n        });\n      } else {\n        // suggest items in the same array\n        node.items.forEach(collectSuggestionsForValues);\n      }\n    }\n  };\n\n  JSONCompletion.prototype.getValueCompletions = function (schema, doc, node, offset, document, collector, types) {\n    var _this = this;\n\n    var offsetForSeparator = offset;\n    var parentKey = null;\n    var valueNode = null;\n\n    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n      offsetForSeparator = node.offset + node.length;\n      valueNode = node;\n      node = node.parent;\n    }\n\n    if (!node) {\n      this.addSchemaValueCompletions(schema.schema, '', collector, types);\n      return;\n    }\n\n    if (node.type === 'property' && offset > node.colonOffset) {\n      var valueNode_1 = node.valueNode;\n\n      if (valueNode_1 && offset > valueNode_1.offset + valueNode_1.length) {\n        return; // we are past the value node\n      }\n\n      parentKey = node.keyNode.value;\n      node = node.parent;\n    }\n\n    if (node && (parentKey !== null || node.type === 'array')) {\n      var separatorAfter_2 = this.evaluateSeparatorAfter(document, offsetForSeparator);\n      var matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset, valueNode);\n      matchingSchemas.forEach(function (s) {\n        if (s.node === node && !s.inverted && s.schema) {\n          if (node.type === 'array' && s.schema.items) {\n            if (Array.isArray(s.schema.items)) {\n              var index = _this.findItemAtOffset(node, document, offset);\n\n              if (index < s.schema.items.length) {\n                _this.addSchemaValueCompletions(s.schema.items[index], separatorAfter_2, collector, types);\n              }\n            } else {\n              _this.addSchemaValueCompletions(s.schema.items, separatorAfter_2, collector, types);\n            }\n          }\n\n          if (s.schema.properties) {\n            var propertySchema = s.schema.properties[parentKey];\n\n            if (propertySchema) {\n              _this.addSchemaValueCompletions(propertySchema, separatorAfter_2, collector, types);\n            }\n          }\n        }\n      });\n\n      if (parentKey === '$schema' && !node.parent) {\n        this.addDollarSchemaCompletions(separatorAfter_2, collector);\n      }\n\n      if (types['boolean']) {\n        this.addBooleanValueCompletion(true, separatorAfter_2, collector);\n        this.addBooleanValueCompletion(false, separatorAfter_2, collector);\n      }\n\n      if (types['null']) {\n        this.addNullValueCompletion(separatorAfter_2, collector);\n      }\n    }\n  };\n\n  JSONCompletion.prototype.getContributedValueCompletions = function (doc, node, offset, document, collector, collectionPromises) {\n    if (!node) {\n      this.contributions.forEach(function (contribution) {\n        var collectPromise = contribution.collectDefaultCompletions(document.uri, collector);\n\n        if (collectPromise) {\n          collectionPromises.push(collectPromise);\n        }\n      });\n    } else {\n      if (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null') {\n        node = node.parent;\n      }\n\n      if (node.type === 'property' && offset > node.colonOffset) {\n        var parentKey_4 = node.keyNode.value;\n        var valueNode = node.valueNode;\n\n        if (!valueNode || offset <= valueNode.offset + valueNode.length) {\n          var location_2 = Parser.getNodePath(node.parent);\n          this.contributions.forEach(function (contribution) {\n            var collectPromise = contribution.collectValueCompletions(document.uri, location_2, parentKey_4, collector);\n\n            if (collectPromise) {\n              collectionPromises.push(collectPromise);\n            }\n          });\n        }\n      }\n    }\n  };\n\n  JSONCompletion.prototype.addSchemaValueCompletions = function (schema, separatorAfter, collector, types) {\n    var _this = this;\n\n    if (typeof schema === 'object') {\n      this.addEnumValueCompletions(schema, separatorAfter, collector);\n      this.addDefaultValueCompletions(schema, separatorAfter, collector);\n      this.collectTypes(schema, types);\n\n      if (Array.isArray(schema.allOf)) {\n        schema.allOf.forEach(function (s) {\n          return _this.addSchemaValueCompletions(s, separatorAfter, collector, types);\n        });\n      }\n\n      if (Array.isArray(schema.anyOf)) {\n        schema.anyOf.forEach(function (s) {\n          return _this.addSchemaValueCompletions(s, separatorAfter, collector, types);\n        });\n      }\n\n      if (Array.isArray(schema.oneOf)) {\n        schema.oneOf.forEach(function (s) {\n          return _this.addSchemaValueCompletions(s, separatorAfter, collector, types);\n        });\n      }\n    }\n  };\n\n  JSONCompletion.prototype.addDefaultValueCompletions = function (schema, separatorAfter, collector, arrayDepth) {\n    var _this = this;\n\n    if (arrayDepth === void 0) {\n      arrayDepth = 0;\n    }\n\n    var hasProposals = false;\n\n    if (isDefined(schema.default)) {\n      var type = schema.type;\n      var value = schema.default;\n\n      for (var i = arrayDepth; i > 0; i--) {\n        value = [value];\n        type = 'array';\n      }\n\n      collector.add({\n        kind: this.getSuggestionKind(type),\n        label: this.getLabelForValue(value),\n        insertText: this.getInsertTextForValue(value, separatorAfter),\n        insertTextFormat: InsertTextFormat.Snippet,\n        detail: localize('json.suggest.default', 'Default value')\n      });\n      hasProposals = true;\n    }\n\n    if (Array.isArray(schema.examples)) {\n      schema.examples.forEach(function (example) {\n        var type = schema.type;\n        var value = example;\n\n        for (var i = arrayDepth; i > 0; i--) {\n          value = [value];\n          type = 'array';\n        }\n\n        collector.add({\n          kind: _this.getSuggestionKind(type),\n          label: _this.getLabelForValue(value),\n          insertText: _this.getInsertTextForValue(value, separatorAfter),\n          insertTextFormat: InsertTextFormat.Snippet\n        });\n        hasProposals = true;\n      });\n    }\n\n    if (Array.isArray(schema.defaultSnippets)) {\n      schema.defaultSnippets.forEach(function (s) {\n        var type = schema.type;\n        var value = s.body;\n        var label = s.label;\n        var insertText;\n        var filterText;\n\n        if (isDefined(value)) {\n          var type_1 = schema.type;\n\n          for (var i = arrayDepth; i > 0; i--) {\n            value = [value];\n            type_1 = 'array';\n          }\n\n          insertText = _this.getInsertTextForSnippetValue(value, separatorAfter);\n          filterText = _this.getFilterTextForSnippetValue(value);\n          label = label || _this.getLabelForSnippetValue(value);\n        } else if (typeof s.bodyText === 'string') {\n          var prefix = '',\n              suffix = '',\n              indent = '';\n\n          for (var i = arrayDepth; i > 0; i--) {\n            prefix = prefix + indent + '[\\n';\n            suffix = suffix + '\\n' + indent + ']';\n            indent += '\\t';\n            type = 'array';\n          }\n\n          insertText = prefix + indent + s.bodyText.split('\\n').join('\\n' + indent) + suffix + separatorAfter;\n          label = label || _this.sanitizeLabel(insertText), filterText = insertText.replace(/[\\n]/g, ''); // remove new lines\n        }\n\n        collector.add({\n          kind: _this.getSuggestionKind(type),\n          label: label,\n          documentation: _this.fromMarkup(s.markdownDescription) || s.description,\n          insertText: insertText,\n          insertTextFormat: InsertTextFormat.Snippet,\n          filterText: filterText\n        });\n        hasProposals = true;\n      });\n    }\n\n    if (!hasProposals && typeof schema.items === 'object' && !Array.isArray(schema.items)) {\n      this.addDefaultValueCompletions(schema.items, separatorAfter, collector, arrayDepth + 1);\n    }\n  };\n\n  JSONCompletion.prototype.addEnumValueCompletions = function (schema, separatorAfter, collector) {\n    if (isDefined(schema.const)) {\n      collector.add({\n        kind: this.getSuggestionKind(schema.type),\n        label: this.getLabelForValue(schema.const),\n        insertText: this.getInsertTextForValue(schema.const, separatorAfter),\n        insertTextFormat: InsertTextFormat.Snippet,\n        documentation: this.fromMarkup(schema.markdownDescription) || schema.description\n      });\n    }\n\n    if (Array.isArray(schema.enum)) {\n      for (var i = 0, length = schema.enum.length; i < length; i++) {\n        var enm = schema.enum[i];\n        var documentation = this.fromMarkup(schema.markdownDescription) || schema.description;\n\n        if (schema.markdownEnumDescriptions && i < schema.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {\n          documentation = this.fromMarkup(schema.markdownEnumDescriptions[i]);\n        } else if (schema.enumDescriptions && i < schema.enumDescriptions.length) {\n          documentation = schema.enumDescriptions[i];\n        }\n\n        collector.add({\n          kind: this.getSuggestionKind(schema.type),\n          label: this.getLabelForValue(enm),\n          insertText: this.getInsertTextForValue(enm, separatorAfter),\n          insertTextFormat: InsertTextFormat.Snippet,\n          documentation: documentation\n        });\n      }\n    }\n  };\n\n  JSONCompletion.prototype.collectTypes = function (schema, types) {\n    if (Array.isArray(schema.enum) || isDefined(schema.const)) {\n      return;\n    }\n\n    var type = schema.type;\n\n    if (Array.isArray(type)) {\n      type.forEach(function (t) {\n        return types[t] = true;\n      });\n    } else {\n      types[type] = true;\n    }\n  };\n\n  JSONCompletion.prototype.addFillerValueCompletions = function (types, separatorAfter, collector) {\n    if (types['object']) {\n      collector.add({\n        kind: this.getSuggestionKind('object'),\n        label: '{}',\n        insertText: this.getInsertTextForGuessedValue({}, separatorAfter),\n        insertTextFormat: InsertTextFormat.Snippet,\n        detail: localize('defaults.object', 'New object'),\n        documentation: ''\n      });\n    }\n\n    if (types['array']) {\n      collector.add({\n        kind: this.getSuggestionKind('array'),\n        label: '[]',\n        insertText: this.getInsertTextForGuessedValue([], separatorAfter),\n        insertTextFormat: InsertTextFormat.Snippet,\n        detail: localize('defaults.array', 'New array'),\n        documentation: ''\n      });\n    }\n  };\n\n  JSONCompletion.prototype.addBooleanValueCompletion = function (value, separatorAfter, collector) {\n    collector.add({\n      kind: this.getSuggestionKind('boolean'),\n      label: value ? 'true' : 'false',\n      insertText: this.getInsertTextForValue(value, separatorAfter),\n      insertTextFormat: InsertTextFormat.Snippet,\n      documentation: ''\n    });\n  };\n\n  JSONCompletion.prototype.addNullValueCompletion = function (separatorAfter, collector) {\n    collector.add({\n      kind: this.getSuggestionKind('null'),\n      label: 'null',\n      insertText: 'null' + separatorAfter,\n      insertTextFormat: InsertTextFormat.Snippet,\n      documentation: ''\n    });\n  };\n\n  JSONCompletion.prototype.addDollarSchemaCompletions = function (separatorAfter, collector) {\n    var _this = this;\n\n    var schemaIds = this.schemaService.getRegisteredSchemaIds(function (schema) {\n      return schema === 'http' || schema === 'https';\n    });\n    schemaIds.forEach(function (schemaId) {\n      return collector.add({\n        kind: CompletionItemKind.Module,\n        label: _this.getLabelForValue(schemaId),\n        filterText: _this.getFilterTextForValue(schemaId),\n        insertText: _this.getInsertTextForValue(schemaId, separatorAfter),\n        insertTextFormat: InsertTextFormat.Snippet,\n        documentation: ''\n      });\n    });\n  };\n\n  JSONCompletion.prototype.sanitizeLabel = function (label) {\n    label = label.replace(/[\\n]/g, '↵');\n\n    if (label.length > 57) {\n      label = label.substr(0, 57).trim() + '...';\n    }\n\n    return label;\n  };\n\n  JSONCompletion.prototype.getLabelForValue = function (value) {\n    return this.sanitizeLabel(JSON.stringify(value));\n  };\n\n  JSONCompletion.prototype.getFilterTextForValue = function (value) {\n    return JSON.stringify(value);\n  };\n\n  JSONCompletion.prototype.getFilterTextForSnippetValue = function (value) {\n    return JSON.stringify(value).replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, '$1');\n  };\n\n  JSONCompletion.prototype.getLabelForSnippetValue = function (value) {\n    var label = JSON.stringify(value);\n    label = label.replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, '$1');\n    return this.sanitizeLabel(label);\n  };\n\n  JSONCompletion.prototype.getInsertTextForPlainText = function (text) {\n    return text.replace(/[\\\\\\$\\}]/g, '\\\\$&'); // escape $, \\ and } \n  };\n\n  JSONCompletion.prototype.getInsertTextForValue = function (value, separatorAfter) {\n    var text = JSON.stringify(value, null, '\\t');\n\n    if (text === '{}') {\n      return '{$1}' + separatorAfter;\n    } else if (text === '[]') {\n      return '[$1]' + separatorAfter;\n    }\n\n    return this.getInsertTextForPlainText(text + separatorAfter);\n  };\n\n  JSONCompletion.prototype.getInsertTextForSnippetValue = function (value, separatorAfter) {\n    var replacer = function (value) {\n      if (typeof value === 'string') {\n        if (value[0] === '^') {\n          return value.substr(1);\n        }\n      }\n\n      return JSON.stringify(value);\n    };\n\n    return stringifyObject(value, '', replacer) + separatorAfter;\n  };\n\n  JSONCompletion.prototype.getInsertTextForGuessedValue = function (value, separatorAfter) {\n    switch (typeof value) {\n      case 'object':\n        if (value === null) {\n          return '${1:null}' + separatorAfter;\n        }\n\n        return this.getInsertTextForValue(value, separatorAfter);\n\n      case 'string':\n        var snippetValue = JSON.stringify(value);\n        snippetValue = snippetValue.substr(1, snippetValue.length - 2); // remove quotes\n\n        snippetValue = this.getInsertTextForPlainText(snippetValue); // escape \\ and }\n\n        return '\"${1:' + snippetValue + '}\"' + separatorAfter;\n\n      case 'number':\n      case 'boolean':\n        return '${1:' + JSON.stringify(value) + '}' + separatorAfter;\n    }\n\n    return this.getInsertTextForValue(value, separatorAfter);\n  };\n\n  JSONCompletion.prototype.getSuggestionKind = function (type) {\n    if (Array.isArray(type)) {\n      var array = type;\n      type = array.length > 0 ? array[0] : null;\n    }\n\n    if (!type) {\n      return CompletionItemKind.Value;\n    }\n\n    switch (type) {\n      case 'string':\n        return CompletionItemKind.Value;\n\n      case 'object':\n        return CompletionItemKind.Module;\n\n      case 'property':\n        return CompletionItemKind.Property;\n\n      default:\n        return CompletionItemKind.Value;\n    }\n  };\n\n  JSONCompletion.prototype.getLabelTextForMatchingNode = function (node, document) {\n    switch (node.type) {\n      case 'array':\n        return '[]';\n\n      case 'object':\n        return '{}';\n\n      default:\n        var content = document.getText().substr(node.offset, node.length);\n        return content;\n    }\n  };\n\n  JSONCompletion.prototype.getInsertTextForMatchingNode = function (node, document, separatorAfter) {\n    switch (node.type) {\n      case 'array':\n        return this.getInsertTextForValue([], separatorAfter);\n\n      case 'object':\n        return this.getInsertTextForValue({}, separatorAfter);\n\n      default:\n        var content = document.getText().substr(node.offset, node.length) + separatorAfter;\n        return this.getInsertTextForPlainText(content);\n    }\n  };\n\n  JSONCompletion.prototype.getInsertTextForProperty = function (key, propertySchema, addValue, separatorAfter) {\n    var propertyText = this.getInsertTextForValue(key, '');\n\n    if (!addValue) {\n      return propertyText;\n    }\n\n    var resultText = propertyText + ': ';\n    var value;\n    var nValueProposals = 0;\n\n    if (propertySchema) {\n      if (Array.isArray(propertySchema.defaultSnippets)) {\n        if (propertySchema.defaultSnippets.length === 1) {\n          var body = propertySchema.defaultSnippets[0].body;\n\n          if (isDefined(body)) {\n            value = this.getInsertTextForSnippetValue(body, '');\n          }\n        }\n\n        nValueProposals += propertySchema.defaultSnippets.length;\n      }\n\n      if (propertySchema.enum) {\n        if (!value && propertySchema.enum.length === 1) {\n          value = this.getInsertTextForGuessedValue(propertySchema.enum[0], '');\n        }\n\n        nValueProposals += propertySchema.enum.length;\n      }\n\n      if (isDefined(propertySchema.default)) {\n        if (!value) {\n          value = this.getInsertTextForGuessedValue(propertySchema.default, '');\n        }\n\n        nValueProposals++;\n      }\n\n      if (nValueProposals === 0) {\n        var type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;\n\n        if (!type) {\n          if (propertySchema.properties) {\n            type = 'object';\n          } else if (propertySchema.items) {\n            type = 'array';\n          }\n        }\n\n        switch (type) {\n          case 'boolean':\n            value = '$1';\n            break;\n\n          case 'string':\n            value = '\"$1\"';\n            break;\n\n          case 'object':\n            value = '{$1}';\n            break;\n\n          case 'array':\n            value = '[$1]';\n            break;\n\n          case 'number':\n          case 'integer':\n            value = '${1:0}';\n            break;\n\n          case 'null':\n            value = '${1:null}';\n            break;\n\n          default:\n            return propertyText;\n        }\n      }\n    }\n\n    if (!value || nValueProposals > 1) {\n      value = '$1';\n    }\n\n    return resultText + value + separatorAfter;\n  };\n\n  JSONCompletion.prototype.getCurrentWord = function (document, offset) {\n    var i = offset - 1;\n    var text = document.getText();\n\n    while (i >= 0 && ' \\t\\n\\r\\v\":{[,]}'.indexOf(text.charAt(i)) === -1) {\n      i--;\n    }\n\n    return text.substring(i + 1, offset);\n  };\n\n  JSONCompletion.prototype.evaluateSeparatorAfter = function (document, offset) {\n    var scanner = Json.createScanner(document.getText(), true);\n    scanner.setPosition(offset);\n    var token = scanner.scan();\n\n    switch (token) {\n      case 5\n      /* CommaToken */\n      :\n      case 2\n      /* CloseBraceToken */\n      :\n      case 4\n      /* CloseBracketToken */\n      :\n      case 17\n      /* EOF */\n      :\n        return '';\n\n      default:\n        return ',';\n    }\n  };\n\n  JSONCompletion.prototype.findItemAtOffset = function (node, document, offset) {\n    var scanner = Json.createScanner(document.getText(), true);\n    var children = node.items;\n\n    for (var i = children.length - 1; i >= 0; i--) {\n      var child = children[i];\n\n      if (offset > child.offset + child.length) {\n        scanner.setPosition(child.offset + child.length);\n        var token = scanner.scan();\n\n        if (token === 5\n        /* CommaToken */\n        && offset >= scanner.getTokenOffset() + scanner.getTokenLength()) {\n          return i + 1;\n        }\n\n        return i;\n      } else if (offset >= child.offset) {\n        return i;\n      }\n    }\n\n    return 0;\n  };\n\n  JSONCompletion.prototype.isInComment = function (document, start, offset) {\n    var scanner = Json.createScanner(document.getText(), false);\n    scanner.setPosition(start);\n    var token = scanner.scan();\n\n    while (token !== 17\n    /* EOF */\n    && scanner.getTokenOffset() + scanner.getTokenLength() < offset) {\n      token = scanner.scan();\n    }\n\n    return (token === 12\n    /* LineCommentTrivia */\n    || token === 13\n    /* BlockCommentTrivia */\n    ) && scanner.getTokenOffset() <= offset;\n  };\n\n  JSONCompletion.prototype.fromMarkup = function (markupString) {\n    if (markupString && this.doesSupportMarkdown()) {\n      return {\n        kind: MarkupKind.Markdown,\n        value: markupString\n      };\n    }\n\n    return undefined;\n  };\n\n  JSONCompletion.prototype.doesSupportMarkdown = function () {\n    if (!isDefined(this.supportsMarkdown)) {\n      var completion = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;\n      this.supportsMarkdown = completion && completion.completionItem && Array.isArray(completion.completionItem.documentationFormat) && completion.completionItem.documentationFormat.indexOf(MarkupKind.Markdown) !== -1;\n    }\n\n    return this.supportsMarkdown;\n  };\n\n  return JSONCompletion;\n}();\n\nexport { JSONCompletion };","map":null,"metadata":{},"sourceType":"module"}