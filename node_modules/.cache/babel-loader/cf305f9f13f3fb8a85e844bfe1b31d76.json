{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nvar ErrorHandler =\n/** @class */\nfunction () {\n  function ErrorHandler() {\n    this.listeners = [];\n\n    this.unexpectedErrorHandler = function (e) {\n      setTimeout(function () {\n        if (e.stack) {\n          throw new Error(e.message + '\\n\\n' + e.stack);\n        }\n\n        throw e;\n      }, 0);\n    };\n  }\n\n  ErrorHandler.prototype.emit = function (e) {\n    this.listeners.forEach(function (listener) {\n      listener(e);\n    });\n  };\n\n  ErrorHandler.prototype.onUnexpectedError = function (e) {\n    this.unexpectedErrorHandler(e);\n    this.emit(e);\n  }; // For external errors, we don't want the listeners to be called\n\n\n  ErrorHandler.prototype.onUnexpectedExternalError = function (e) {\n    this.unexpectedErrorHandler(e);\n  };\n\n  return ErrorHandler;\n}();\n\nexport { ErrorHandler };\nexport var errorHandler = new ErrorHandler();\nexport function onUnexpectedError(e) {\n  // ignore errors from cancelled promises\n  if (!isPromiseCanceledError(e)) {\n    errorHandler.onUnexpectedError(e);\n  }\n\n  return undefined;\n}\nexport function onUnexpectedExternalError(e) {\n  // ignore errors from cancelled promises\n  if (!isPromiseCanceledError(e)) {\n    errorHandler.onUnexpectedExternalError(e);\n  }\n\n  return undefined;\n}\nexport function transformErrorForSerialization(error) {\n  if (error instanceof Error) {\n    var name_1 = error.name,\n        message = error.message;\n    var stack = error.stacktrace || error.stack;\n    return {\n      $isError: true,\n      name: name_1,\n      message: message,\n      stack: stack\n    };\n  } // return as is\n\n\n  return error;\n}\nvar canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\n\nexport function isPromiseCanceledError(error) {\n  return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n/**\n * Returns an error that signals cancellation.\n */\n\nexport function canceled() {\n  var error = new Error(canceledName);\n  error.name = error.message;\n  return error;\n}\nexport function illegalArgument(name) {\n  if (name) {\n    return new Error(\"Illegal argument: \" + name);\n  } else {\n    return new Error('Illegal argument');\n  }\n}\nexport function illegalState(name) {\n  if (name) {\n    return new Error(\"Illegal state: \" + name);\n  } else {\n    return new Error('Illegal state');\n  }\n}","map":null,"metadata":{},"sourceType":"module"}