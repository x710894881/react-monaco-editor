{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { RGBA8 } from '../core/rgba.js';\nimport { TokenizationRegistry } from '../modes.js';\n\nvar MinimapTokensColorTracker =\n/** @class */\nfunction () {\n  function MinimapTokensColorTracker() {\n    var _this = this;\n\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n\n    this._updateColorMap();\n\n    TokenizationRegistry.onDidChange(function (e) {\n      if (e.changedColorMap) {\n        _this._updateColorMap();\n      }\n    });\n  }\n\n  MinimapTokensColorTracker.getInstance = function () {\n    if (!this._INSTANCE) {\n      this._INSTANCE = new MinimapTokensColorTracker();\n    }\n\n    return this._INSTANCE;\n  };\n\n  MinimapTokensColorTracker.prototype._updateColorMap = function () {\n    var colorMap = TokenizationRegistry.getColorMap();\n\n    if (!colorMap) {\n      this._colors = [RGBA8.Empty];\n      this._backgroundIsLight = true;\n      return;\n    }\n\n    this._colors = [RGBA8.Empty];\n\n    for (var colorId = 1; colorId < colorMap.length; colorId++) {\n      var source = colorMap[colorId].rgba; // Use a VM friendly data-type\n\n      this._colors[colorId] = new RGBA8(source.r, source.g, source.b, Math.round(source.a * 255));\n    }\n\n    var backgroundLuminosity = colorMap[2\n    /* DefaultBackground */\n    ].getRelativeLuminance();\n    this._backgroundIsLight = backgroundLuminosity >= 0.5;\n\n    this._onDidChange.fire(undefined);\n  };\n\n  MinimapTokensColorTracker.prototype.getColor = function (colorId) {\n    if (colorId < 1 || colorId >= this._colors.length) {\n      // background color (basically invisible)\n      colorId = 2\n      /* DefaultBackground */\n      ;\n    }\n\n    return this._colors[colorId];\n  };\n\n  MinimapTokensColorTracker.prototype.backgroundIsLight = function () {\n    return this._backgroundIsLight;\n  };\n\n  MinimapTokensColorTracker._INSTANCE = null;\n  return MinimapTokensColorTracker;\n}();\n\nexport { MinimapTokensColorTracker };\n\nvar MinimapCharRenderer =\n/** @class */\nfunction () {\n  function MinimapCharRenderer(x2CharData, x1CharData) {\n    var x2ExpectedLen = 4\n    /* x2_CHAR_HEIGHT */\n    * 2\n    /* x2_CHAR_WIDTH */\n    * 95\n    /* CHAR_COUNT */\n    ;\n\n    if (x2CharData.length !== x2ExpectedLen) {\n      throw new Error('Invalid x2CharData');\n    }\n\n    var x1ExpectedLen = 2\n    /* x1_CHAR_HEIGHT */\n    * 1\n    /* x1_CHAR_WIDTH */\n    * 95\n    /* CHAR_COUNT */\n    ;\n\n    if (x1CharData.length !== x1ExpectedLen) {\n      throw new Error('Invalid x1CharData');\n    }\n\n    this.x2charData = x2CharData;\n    this.x1charData = x1CharData;\n    this.x2charDataLight = MinimapCharRenderer.soften(x2CharData, 12 / 15);\n    this.x1charDataLight = MinimapCharRenderer.soften(x1CharData, 50 / 60);\n  }\n\n  MinimapCharRenderer.soften = function (input, ratio) {\n    var result = new Uint8ClampedArray(input.length);\n\n    for (var i = 0, len = input.length; i < len; i++) {\n      result[i] = input[i] * ratio;\n    }\n\n    return result;\n  };\n\n  MinimapCharRenderer._getChIndex = function (chCode) {\n    chCode -= 32\n    /* START_CH_CODE */\n    ;\n\n    if (chCode < 0) {\n      chCode += 95\n      /* CHAR_COUNT */\n      ;\n    }\n\n    return chCode % 95\n    /* CHAR_COUNT */\n    ;\n  };\n\n  MinimapCharRenderer.prototype.x2RenderChar = function (target, dx, dy, chCode, color, backgroundColor, useLighterFont) {\n    if (dx + 2\n    /* x2_CHAR_WIDTH */\n    > target.width || dy + 4\n    /* x2_CHAR_HEIGHT */\n    > target.height) {\n      console.warn('bad render request outside image data');\n      return;\n    }\n\n    var x2CharData = useLighterFont ? this.x2charDataLight : this.x2charData;\n\n    var chIndex = MinimapCharRenderer._getChIndex(chCode);\n\n    var outWidth = target.width * 4\n    /* RGBA_CHANNELS_CNT */\n    ;\n    var backgroundR = backgroundColor.r;\n    var backgroundG = backgroundColor.g;\n    var backgroundB = backgroundColor.b;\n    var deltaR = color.r - backgroundR;\n    var deltaG = color.g - backgroundG;\n    var deltaB = color.b - backgroundB;\n    var dest = target.data;\n    var sourceOffset = chIndex * 4\n    /* x2_CHAR_HEIGHT */\n    * 2\n    /* x2_CHAR_WIDTH */\n    ;\n    var destOffset = dy * outWidth + dx * 4\n    /* RGBA_CHANNELS_CNT */\n    ;\n    {\n      var c = x2CharData[sourceOffset] / 255;\n      dest[destOffset + 0] = backgroundR + deltaR * c;\n      dest[destOffset + 1] = backgroundG + deltaG * c;\n      dest[destOffset + 2] = backgroundB + deltaB * c;\n    }\n    {\n      var c = x2CharData[sourceOffset + 1] / 255;\n      dest[destOffset + 4] = backgroundR + deltaR * c;\n      dest[destOffset + 5] = backgroundG + deltaG * c;\n      dest[destOffset + 6] = backgroundB + deltaB * c;\n    }\n    destOffset += outWidth;\n    {\n      var c = x2CharData[sourceOffset + 2] / 255;\n      dest[destOffset + 0] = backgroundR + deltaR * c;\n      dest[destOffset + 1] = backgroundG + deltaG * c;\n      dest[destOffset + 2] = backgroundB + deltaB * c;\n    }\n    {\n      var c = x2CharData[sourceOffset + 3] / 255;\n      dest[destOffset + 4] = backgroundR + deltaR * c;\n      dest[destOffset + 5] = backgroundG + deltaG * c;\n      dest[destOffset + 6] = backgroundB + deltaB * c;\n    }\n    destOffset += outWidth;\n    {\n      var c = x2CharData[sourceOffset + 4] / 255;\n      dest[destOffset + 0] = backgroundR + deltaR * c;\n      dest[destOffset + 1] = backgroundG + deltaG * c;\n      dest[destOffset + 2] = backgroundB + deltaB * c;\n    }\n    {\n      var c = x2CharData[sourceOffset + 5] / 255;\n      dest[destOffset + 4] = backgroundR + deltaR * c;\n      dest[destOffset + 5] = backgroundG + deltaG * c;\n      dest[destOffset + 6] = backgroundB + deltaB * c;\n    }\n    destOffset += outWidth;\n    {\n      var c = x2CharData[sourceOffset + 6] / 255;\n      dest[destOffset + 0] = backgroundR + deltaR * c;\n      dest[destOffset + 1] = backgroundG + deltaG * c;\n      dest[destOffset + 2] = backgroundB + deltaB * c;\n    }\n    {\n      var c = x2CharData[sourceOffset + 7] / 255;\n      dest[destOffset + 4] = backgroundR + deltaR * c;\n      dest[destOffset + 5] = backgroundG + deltaG * c;\n      dest[destOffset + 6] = backgroundB + deltaB * c;\n    }\n  };\n\n  MinimapCharRenderer.prototype.x1RenderChar = function (target, dx, dy, chCode, color, backgroundColor, useLighterFont) {\n    if (dx + 1\n    /* x1_CHAR_WIDTH */\n    > target.width || dy + 2\n    /* x1_CHAR_HEIGHT */\n    > target.height) {\n      console.warn('bad render request outside image data');\n      return;\n    }\n\n    var x1CharData = useLighterFont ? this.x1charDataLight : this.x1charData;\n\n    var chIndex = MinimapCharRenderer._getChIndex(chCode);\n\n    var outWidth = target.width * 4\n    /* RGBA_CHANNELS_CNT */\n    ;\n    var backgroundR = backgroundColor.r;\n    var backgroundG = backgroundColor.g;\n    var backgroundB = backgroundColor.b;\n    var deltaR = color.r - backgroundR;\n    var deltaG = color.g - backgroundG;\n    var deltaB = color.b - backgroundB;\n    var dest = target.data;\n    var sourceOffset = chIndex * 2\n    /* x1_CHAR_HEIGHT */\n    * 1\n    /* x1_CHAR_WIDTH */\n    ;\n    var destOffset = dy * outWidth + dx * 4\n    /* RGBA_CHANNELS_CNT */\n    ;\n    {\n      var c = x1CharData[sourceOffset] / 255;\n      dest[destOffset + 0] = backgroundR + deltaR * c;\n      dest[destOffset + 1] = backgroundG + deltaG * c;\n      dest[destOffset + 2] = backgroundB + deltaB * c;\n    }\n    destOffset += outWidth;\n    {\n      var c = x1CharData[sourceOffset + 1] / 255;\n      dest[destOffset + 0] = backgroundR + deltaR * c;\n      dest[destOffset + 1] = backgroundG + deltaG * c;\n      dest[destOffset + 2] = backgroundB + deltaB * c;\n    }\n  };\n\n  MinimapCharRenderer.prototype.x2BlockRenderChar = function (target, dx, dy, color, backgroundColor, useLighterFont) {\n    if (dx + 2\n    /* x2_CHAR_WIDTH */\n    > target.width || dy + 4\n    /* x2_CHAR_HEIGHT */\n    > target.height) {\n      console.warn('bad render request outside image data');\n      return;\n    }\n\n    var outWidth = target.width * 4\n    /* RGBA_CHANNELS_CNT */\n    ;\n    var c = 0.5;\n    var backgroundR = backgroundColor.r;\n    var backgroundG = backgroundColor.g;\n    var backgroundB = backgroundColor.b;\n    var deltaR = color.r - backgroundR;\n    var deltaG = color.g - backgroundG;\n    var deltaB = color.b - backgroundB;\n    var colorR = backgroundR + deltaR * c;\n    var colorG = backgroundG + deltaG * c;\n    var colorB = backgroundB + deltaB * c;\n    var dest = target.data;\n    var destOffset = dy * outWidth + dx * 4\n    /* RGBA_CHANNELS_CNT */\n    ;\n    {\n      dest[destOffset + 0] = colorR;\n      dest[destOffset + 1] = colorG;\n      dest[destOffset + 2] = colorB;\n    }\n    {\n      dest[destOffset + 4] = colorR;\n      dest[destOffset + 5] = colorG;\n      dest[destOffset + 6] = colorB;\n    }\n    destOffset += outWidth;\n    {\n      dest[destOffset + 0] = colorR;\n      dest[destOffset + 1] = colorG;\n      dest[destOffset + 2] = colorB;\n    }\n    {\n      dest[destOffset + 4] = colorR;\n      dest[destOffset + 5] = colorG;\n      dest[destOffset + 6] = colorB;\n    }\n    destOffset += outWidth;\n    {\n      dest[destOffset + 0] = colorR;\n      dest[destOffset + 1] = colorG;\n      dest[destOffset + 2] = colorB;\n    }\n    {\n      dest[destOffset + 4] = colorR;\n      dest[destOffset + 5] = colorG;\n      dest[destOffset + 6] = colorB;\n    }\n    destOffset += outWidth;\n    {\n      dest[destOffset + 0] = colorR;\n      dest[destOffset + 1] = colorG;\n      dest[destOffset + 2] = colorB;\n    }\n    {\n      dest[destOffset + 4] = colorR;\n      dest[destOffset + 5] = colorG;\n      dest[destOffset + 6] = colorB;\n    }\n  };\n\n  MinimapCharRenderer.prototype.x1BlockRenderChar = function (target, dx, dy, color, backgroundColor, useLighterFont) {\n    if (dx + 1\n    /* x1_CHAR_WIDTH */\n    > target.width || dy + 2\n    /* x1_CHAR_HEIGHT */\n    > target.height) {\n      console.warn('bad render request outside image data');\n      return;\n    }\n\n    var outWidth = target.width * 4\n    /* RGBA_CHANNELS_CNT */\n    ;\n    var c = 0.5;\n    var backgroundR = backgroundColor.r;\n    var backgroundG = backgroundColor.g;\n    var backgroundB = backgroundColor.b;\n    var deltaR = color.r - backgroundR;\n    var deltaG = color.g - backgroundG;\n    var deltaB = color.b - backgroundB;\n    var colorR = backgroundR + deltaR * c;\n    var colorG = backgroundG + deltaG * c;\n    var colorB = backgroundB + deltaB * c;\n    var dest = target.data;\n    var destOffset = dy * outWidth + dx * 4\n    /* RGBA_CHANNELS_CNT */\n    ;\n    {\n      dest[destOffset + 0] = colorR;\n      dest[destOffset + 1] = colorG;\n      dest[destOffset + 2] = colorB;\n    }\n    destOffset += outWidth;\n    {\n      dest[destOffset + 0] = colorR;\n      dest[destOffset + 1] = colorG;\n      dest[destOffset + 2] = colorB;\n    }\n  };\n\n  return MinimapCharRenderer;\n}();\n\nexport { MinimapCharRenderer };","map":null,"metadata":{},"sourceType":"module"}