{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _typeof = {\n  number: 'number',\n  string: 'string',\n  undefined: 'undefined',\n  object: 'object',\n  function: 'function'\n};\n/**\n * @returns whether the provided parameter is a JavaScript Array or not.\n */\n\nexport function isArray(array) {\n  if (Array.isArray) {\n    return Array.isArray(array);\n  }\n\n  if (array && typeof array.length === _typeof.number && array.constructor === Array) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\n\nexport function isString(str) {\n  if (typeof str === _typeof.string || str instanceof String) {\n    return true;\n  }\n\n  return false;\n}\n/**\n *\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\n\nexport function isObject(obj) {\n  // The method can't do a type cast since there are type (like strings) which\n  // are subclasses of any put not positvely matched by the function. Hence type\n  // narrowing results in wrong results.\n  return typeof obj === _typeof.object && obj !== null && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);\n}\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\n\nexport function isNumber(obj) {\n  if ((typeof obj === _typeof.number || obj instanceof Number) && !isNaN(obj)) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\n\nexport function isBoolean(obj) {\n  return obj === true || obj === false;\n}\n/**\n * @returns whether the provided parameter is undefined.\n */\n\nexport function isUndefined(obj) {\n  return typeof obj === _typeof.undefined;\n}\n/**\n * @returns whether the provided parameter is undefined or null.\n */\n\nexport function isUndefinedOrNull(obj) {\n  return isUndefined(obj) || obj === null;\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\n\nexport function isEmptyObject(obj) {\n  if (!isObject(obj)) {\n    return false;\n  }\n\n  for (var key in obj) {\n    if (hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\n\nexport function isFunction(obj) {\n  return typeof obj === _typeof.function;\n}\nexport function validateConstraints(args, constraints) {\n  var len = Math.min(args.length, constraints.length);\n\n  for (var i = 0; i < len; i++) {\n    validateConstraint(args[i], constraints[i]);\n  }\n}\nexport function validateConstraint(arg, constraint) {\n  if (isString(constraint)) {\n    if (typeof arg !== constraint) {\n      throw new Error(\"argument does not match constraint: typeof \" + constraint);\n    }\n  } else if (isFunction(constraint)) {\n    try {\n      if (arg instanceof constraint) {\n        return;\n      }\n    } catch (_a) {// ignore\n    }\n\n    if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {\n      return;\n    }\n\n    if (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n      return;\n    }\n\n    throw new Error(\"argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true\");\n  }\n}\nexport function getAllPropertyNames(obj) {\n  var res = [];\n  var proto = Object.getPrototypeOf(obj);\n\n  while (Object.prototype !== proto) {\n    res = res.concat(Object.getOwnPropertyNames(proto));\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return res;\n}\nexport function getAllMethodNames(obj) {\n  var methods = [];\n\n  for (var _i = 0, _a = getAllPropertyNames(obj); _i < _a.length; _i++) {\n    var prop = _a[_i];\n\n    if (typeof obj[prop] === 'function') {\n      methods.push(prop);\n    }\n  }\n\n  return methods;\n}\nexport function createProxyObject(methodNames, invoke) {\n  var createProxyMethod = function (method) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments, 0);\n      return invoke(method, args);\n    };\n  };\n\n  var result = {};\n\n  for (var _i = 0, methodNames_1 = methodNames; _i < methodNames_1.length; _i++) {\n    var methodName = methodNames_1[_i];\n    result[methodName] = createProxyMethod(methodName);\n  }\n\n  return result;\n}\n/**\n * Converts null to undefined, passes all other values through.\n */\n\nexport function withNullAsUndefined(x) {\n  return x === null ? undefined : x;\n}\n/**\n * Converts undefined to null, passes all other values through.\n */\n\nexport function withUndefinedAsNull(x) {\n  return typeof x === 'undefined' ? null : x;\n}","map":null,"metadata":{},"sourceType":"module"}