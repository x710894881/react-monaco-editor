{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as nls from '../../../nls.js';\nimport { IntervalTimer } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\n\nvar AbstractKeybindingService =\n/** @class */\nfunction (_super) {\n  __extends(AbstractKeybindingService, _super);\n\n  function AbstractKeybindingService(_contextKeyService, _commandService, _telemetryService, _notificationService) {\n    var _this = _super.call(this) || this;\n\n    _this._contextKeyService = _contextKeyService;\n    _this._commandService = _commandService;\n    _this._telemetryService = _telemetryService;\n    _this._notificationService = _notificationService;\n    _this._onDidUpdateKeybindings = _this._register(new Emitter());\n    _this._currentChord = null;\n    _this._currentChordChecker = new IntervalTimer();\n    _this._currentChordStatusMessage = null;\n    return _this;\n  }\n\n  Object.defineProperty(AbstractKeybindingService.prototype, \"onDidUpdateKeybindings\", {\n    get: function () {\n      return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AbstractKeybindingService.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n  };\n\n  AbstractKeybindingService.prototype.lookupKeybinding = function (commandId) {\n    var result = this._getResolver().lookupPrimaryKeybinding(commandId);\n\n    if (!result) {\n      return undefined;\n    }\n\n    return result.resolvedKeybinding;\n  };\n\n  AbstractKeybindingService.prototype.softDispatch = function (e, target) {\n    var keybinding = this.resolveKeyboardEvent(e);\n\n    if (keybinding.isChord()) {\n      console.warn('Unexpected keyboard event mapped to a chord');\n      return null;\n    }\n\n    var firstPart = keybinding.getDispatchParts()[0];\n\n    if (firstPart === null) {\n      // cannot be dispatched, probably only modifier keys\n      return null;\n    }\n\n    var contextValue = this._contextKeyService.getContext(target);\n\n    var currentChord = this._currentChord ? this._currentChord.keypress : null;\n    return this._getResolver().resolve(contextValue, currentChord, firstPart);\n  };\n\n  AbstractKeybindingService.prototype._enterChordMode = function (firstPart, keypressLabel) {\n    var _this = this;\n\n    this._currentChord = {\n      keypress: firstPart,\n      label: keypressLabel\n    };\n    this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n    var chordEnterTime = Date.now();\n\n    this._currentChordChecker.cancelAndSet(function () {\n      if (!_this._documentHasFocus()) {\n        // Focus has been lost => leave chord mode\n        _this._leaveChordMode();\n\n        return;\n      }\n\n      if (Date.now() - chordEnterTime > 5000) {\n        // 5 seconds elapsed => leave chord mode\n        _this._leaveChordMode();\n      }\n    }, 500);\n  };\n\n  AbstractKeybindingService.prototype._leaveChordMode = function () {\n    if (this._currentChordStatusMessage) {\n      this._currentChordStatusMessage.dispose();\n\n      this._currentChordStatusMessage = null;\n    }\n\n    this._currentChordChecker.cancel();\n\n    this._currentChord = null;\n  };\n\n  AbstractKeybindingService.prototype._dispatch = function (e, target) {\n    return this._doDispatch(this.resolveKeyboardEvent(e), target);\n  };\n\n  AbstractKeybindingService.prototype._doDispatch = function (keybinding, target) {\n    var _this = this;\n\n    var shouldPreventDefault = false;\n\n    if (keybinding.isChord()) {\n      console.warn('Unexpected keyboard event mapped to a chord');\n      return false;\n    }\n\n    var firstPart = keybinding.getDispatchParts()[0];\n\n    if (firstPart === null) {\n      // cannot be dispatched, probably only modifier keys\n      return shouldPreventDefault;\n    }\n\n    var contextValue = this._contextKeyService.getContext(target);\n\n    var currentChord = this._currentChord ? this._currentChord.keypress : null;\n    var keypressLabel = keybinding.getLabel();\n\n    var resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);\n\n    if (resolveResult && resolveResult.enterChord) {\n      shouldPreventDefault = true;\n\n      this._enterChordMode(firstPart, keypressLabel);\n\n      return shouldPreventDefault;\n    }\n\n    if (this._currentChord) {\n      if (!resolveResult || !resolveResult.commandId) {\n        this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", this._currentChord.label, keypressLabel), {\n          hideAfter: 10 * 1000\n          /* 10s */\n\n        });\n\n        shouldPreventDefault = true;\n      }\n    }\n\n    this._leaveChordMode();\n\n    if (resolveResult && resolveResult.commandId) {\n      if (!resolveResult.bubble) {\n        shouldPreventDefault = true;\n      }\n\n      if (typeof resolveResult.commandArgs === 'undefined') {\n        this._commandService.executeCommand(resolveResult.commandId).then(undefined, function (err) {\n          return _this._notificationService.warn(err);\n        });\n      } else {\n        this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, function (err) {\n          return _this._notificationService.warn(err);\n        });\n      }\n\n      this._telemetryService.publicLog2('workbenchActionExecuted', {\n        id: resolveResult.commandId,\n        from: 'keybinding'\n      });\n    }\n\n    return shouldPreventDefault;\n  };\n\n  AbstractKeybindingService.prototype.mightProducePrintableCharacter = function (event) {\n    if (event.ctrlKey || event.metaKey) {\n      // ignore ctrl/cmd-combination but not shift/alt-combinatios\n      return false;\n    } // weak check for certain ranges. this is properly implemented in a subclass\n    // with access to the KeyboardMapperFactory.\n\n\n    if (event.keyCode >= 31\n    /* KEY_A */\n    && event.keyCode <= 56\n    /* KEY_Z */\n    || event.keyCode >= 21\n    /* KEY_0 */\n    && event.keyCode <= 30\n    /* KEY_9 */\n    ) {\n      return true;\n    }\n\n    return false;\n  };\n\n  return AbstractKeybindingService;\n}(Disposable);\n\nexport { AbstractKeybindingService };","map":null,"metadata":{},"sourceType":"module"}