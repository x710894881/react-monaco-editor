{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\n\nvar LineCommentCommand =\n/** @class */\nfunction () {\n  function LineCommentCommand(selection, tabSize, type) {\n    this._selection = selection;\n    this._selectionId = null;\n    this._tabSize = tabSize;\n    this._type = type;\n    this._deltaColumn = 0;\n    this._moveEndPositionDown = false;\n  }\n  /**\n   * Do an initial pass over the lines and gather info about the line comment string.\n   * Returns null if any of the lines doesn't support a line comment string.\n   */\n\n\n  LineCommentCommand._gatherPreflightCommentStrings = function (model, startLineNumber, endLineNumber) {\n    model.tokenizeIfCheap(startLineNumber);\n    var languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n    var config = LanguageConfigurationRegistry.getComments(languageId);\n    var commentStr = config ? config.lineCommentToken : null;\n\n    if (!commentStr) {\n      // Mode does not support line comments\n      return null;\n    }\n\n    var lines = [];\n\n    for (var i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n      lines[i] = {\n        ignore: false,\n        commentStr: commentStr,\n        commentStrOffset: 0,\n        commentStrLength: commentStr.length\n      };\n    }\n\n    return lines;\n  };\n  /**\n   * Analyze lines and decide which lines are relevant and what the toggle should do.\n   * Also, build up several offsets and lengths useful in the generation of editor operations.\n   */\n\n\n  LineCommentCommand._analyzeLines = function (type, model, lines, startLineNumber) {\n    var onlyWhitespaceLines = true;\n    var shouldRemoveComments;\n\n    if (type === 0\n    /* Toggle */\n    ) {\n        shouldRemoveComments = true;\n      } else if (type === 1\n    /* ForceAdd */\n    ) {\n        shouldRemoveComments = false;\n      } else {\n      shouldRemoveComments = true;\n    }\n\n    for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\n      var lineData = lines[i];\n      var lineNumber = startLineNumber + i;\n      var lineContent = model.getLineContent(lineNumber);\n      var lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n\n      if (lineContentStartOffset === -1) {\n        // Empty or whitespace only line\n        if (type === 0\n        /* Toggle */\n        ) {\n            lineData.ignore = true;\n          } else if (type === 1\n        /* ForceAdd */\n        ) {\n            lineData.ignore = true;\n          } else {\n          lineData.ignore = true;\n        }\n\n        lineData.commentStrOffset = lineContent.length;\n        continue;\n      }\n\n      onlyWhitespaceLines = false;\n      lineData.ignore = false;\n      lineData.commentStrOffset = lineContentStartOffset;\n\n      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n        if (type === 0\n        /* Toggle */\n        ) {\n            // Every line so far has been a line comment, but this one is not\n            shouldRemoveComments = false;\n          } else if (type === 1\n        /* ForceAdd */\n        ) {// Will not happen\n          } else {\n          lineData.ignore = true;\n        }\n      }\n\n      if (shouldRemoveComments) {\n        var commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n\n        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32\n        /* Space */\n        ) {\n            lineData.commentStrLength += 1;\n          }\n      }\n    }\n\n    if (type === 0\n    /* Toggle */\n    && onlyWhitespaceLines) {\n      // For only whitespace lines, we insert comments\n      shouldRemoveComments = false; // Also, no longer ignore them\n\n      for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\n        lines[i].ignore = false;\n      }\n    }\n\n    return {\n      supported: true,\n      shouldRemoveComments: shouldRemoveComments,\n      lines: lines\n    };\n  };\n  /**\n   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n   */\n\n\n  LineCommentCommand._gatherPreflightData = function (type, model, startLineNumber, endLineNumber) {\n    var lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);\n\n    if (lines === null) {\n      return {\n        supported: false\n      };\n    }\n\n    return LineCommentCommand._analyzeLines(type, model, lines, startLineNumber);\n  };\n  /**\n   * Given a successful analysis, execute either insert line comments, either remove line comments\n   */\n\n\n  LineCommentCommand.prototype._executeLineComments = function (model, builder, data, s) {\n    var ops;\n\n    if (data.shouldRemoveComments) {\n      ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n    } else {\n      LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n\n      ops = LineCommentCommand._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n    }\n\n    var cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n\n    for (var i = 0, len = ops.length; i < len; i++) {\n      builder.addEditOperation(ops[i].range, ops[i].text);\n\n      if (ops[i].range.isEmpty() && ops[i].range.getStartPosition().equals(cursorPosition)) {\n        var lineContent = model.getLineContent(cursorPosition.lineNumber);\n\n        if (lineContent.length + 1 === cursorPosition.column) {\n          this._deltaColumn = (ops[i].text || '').length;\n        }\n      }\n    }\n\n    this._selectionId = builder.trackSelection(s);\n  };\n\n  LineCommentCommand.prototype._attemptRemoveBlockComment = function (model, s, startToken, endToken) {\n    var startLineNumber = s.startLineNumber;\n    var endLineNumber = s.endLineNumber;\n    var startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n    var startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n    var endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n\n    if (startTokenIndex !== -1 && endTokenIndex === -1) {\n      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      endLineNumber = startLineNumber;\n    }\n\n    if (startTokenIndex === -1 && endTokenIndex !== -1) {\n      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n      startLineNumber = endLineNumber;\n    }\n\n    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n\n      if (startTokenIndex !== -1) {\n        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      }\n    } // We have to adjust to possible inner white space.\n    // For Space after startToken, add Space to startToken - range math will work out.\n\n\n    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32\n    /* Space */\n    ) {\n        startToken += ' ';\n      } // For Space before endToken, add Space before endToken and shift index one left.\n\n\n    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32\n    /* Space */\n    ) {\n        endToken = ' ' + endToken;\n        endTokenIndex -= 1;\n      }\n\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n    }\n\n    return null;\n  };\n  /**\n   * Given an unsuccessful analysis, delegate to the block comment command\n   */\n\n\n  LineCommentCommand.prototype._executeBlockComment = function (model, builder, s) {\n    model.tokenizeIfCheap(s.startLineNumber);\n    var languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n    var config = LanguageConfigurationRegistry.getComments(languageId);\n\n    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n      // Mode does not support block comments\n      return;\n    }\n\n    var startToken = config.blockCommentStartToken;\n    var endToken = config.blockCommentEndToken;\n\n    var ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n\n    if (!ops) {\n      if (s.isEmpty()) {\n        var lineContent = model.getLineContent(s.startLineNumber);\n        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\n        if (firstNonWhitespaceIndex === -1) {\n          // Line is empty or contains only whitespace\n          firstNonWhitespaceIndex = lineContent.length;\n        }\n\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken);\n      } else {\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken);\n      }\n\n      if (ops.length === 1) {\n        // Leave cursor after token and Space\n        this._deltaColumn = startToken.length + 1;\n      }\n    }\n\n    this._selectionId = builder.trackSelection(s);\n\n    for (var _i = 0, ops_1 = ops; _i < ops_1.length; _i++) {\n      var op = ops_1[_i];\n      builder.addEditOperation(op.range, op.text);\n    }\n  };\n\n  LineCommentCommand.prototype.getEditOperations = function (model, builder) {\n    var s = this._selection;\n    this._moveEndPositionDown = false;\n\n    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n      this._moveEndPositionDown = true;\n      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n    }\n\n    var data = LineCommentCommand._gatherPreflightData(this._type, model, s.startLineNumber, s.endLineNumber);\n\n    if (data.supported) {\n      return this._executeLineComments(model, builder, data, s);\n    }\n\n    return this._executeBlockComment(model, builder, s);\n  };\n\n  LineCommentCommand.prototype.computeCursorState = function (model, helper) {\n    var result = helper.getTrackedSelection(this._selectionId);\n\n    if (this._moveEndPositionDown) {\n      result = result.setEndPosition(result.endLineNumber + 1, 1);\n    }\n\n    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n  };\n  /**\n   * Generate edit operations in the remove line comment case\n   */\n\n\n  LineCommentCommand._createRemoveLineCommentsOperations = function (lines, startLineNumber) {\n    var res = [];\n\n    for (var i = 0, len = lines.length; i < len; i++) {\n      var lineData = lines[i];\n\n      if (lineData.ignore) {\n        continue;\n      }\n\n      res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n    }\n\n    return res;\n  };\n  /**\n   * Generate edit operations in the add line comment case\n   */\n\n\n  LineCommentCommand._createAddLineCommentsOperations = function (lines, startLineNumber) {\n    var res = [];\n\n    for (var i = 0, len = lines.length; i < len; i++) {\n      var lineData = lines[i];\n\n      if (lineData.ignore) {\n        continue;\n      }\n\n      res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + ' '));\n    }\n\n    return res;\n  }; // TODO@Alex -> duplicated in characterHardWrappingLineMapper\n\n\n  LineCommentCommand.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {\n    if (isTab) {\n      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);\n    }\n\n    return currentVisibleColumn + columnSize;\n  };\n  /**\n   * Adjust insertion points to have them vertically aligned in the add line comment case\n   */\n\n\n  LineCommentCommand._normalizeInsertionPoint = function (model, lines, startLineNumber, tabSize) {\n    var minVisibleColumn = Number.MAX_VALUE;\n    var j;\n    var lenJ;\n\n    for (var i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n\n      var lineContent = model.getLineContent(startLineNumber + i);\n      var currentVisibleColumn = 0;\n\n      for (var j_1 = 0, lenJ_1 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j_1 < lenJ_1; j_1++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j_1) === 9\n        /* Tab */\n        , 1);\n      }\n\n      if (currentVisibleColumn < minVisibleColumn) {\n        minVisibleColumn = currentVisibleColumn;\n      }\n    }\n\n    minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n\n    for (var i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n\n      var lineContent = model.getLineContent(startLineNumber + i);\n      var currentVisibleColumn = 0;\n\n      for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9\n        /* Tab */\n        , 1);\n      }\n\n      if (currentVisibleColumn > minVisibleColumn) {\n        lines[i].commentStrOffset = j - 1;\n      } else {\n        lines[i].commentStrOffset = j;\n      }\n    }\n  };\n\n  return LineCommentCommand;\n}();\n\nexport { LineCommentCommand };","map":null,"metadata":{},"sourceType":"module"}