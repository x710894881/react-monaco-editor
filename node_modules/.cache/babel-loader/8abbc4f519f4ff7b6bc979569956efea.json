{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../controller/cursorCommon.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nvar repeatCache = Object.create(null);\nexport function cachedStringRepeat(str, count) {\n  if (!repeatCache[str]) {\n    repeatCache[str] = ['', str];\n  }\n\n  var cache = repeatCache[str];\n\n  for (var i = cache.length; i <= count; i++) {\n    cache[i] = cache[i - 1] + str;\n  }\n\n  return cache[count];\n}\n\nvar ShiftCommand =\n/** @class */\nfunction () {\n  function ShiftCommand(range, opts) {\n    this._opts = opts;\n    this._selection = range;\n    this._selectionId = null;\n    this._useLastEditRangeForCursorEndPosition = false;\n    this._selectionStartColumnStaysPut = false;\n  }\n\n  ShiftCommand.unshiftIndent = function (line, column, tabSize, indentSize, insertSpaces) {\n    // Determine the visible column where the content starts\n    var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n\n    if (insertSpaces) {\n      var indent = cachedStringRepeat(' ', indentSize);\n      var desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n      var indentCount = desiredTabStop / indentSize; // will be an integer\n\n      return cachedStringRepeat(indent, indentCount);\n    } else {\n      var indent = '\\t';\n      var desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n      var indentCount = desiredTabStop / tabSize; // will be an integer\n\n      return cachedStringRepeat(indent, indentCount);\n    }\n  };\n\n  ShiftCommand.shiftIndent = function (line, column, tabSize, indentSize, insertSpaces) {\n    // Determine the visible column where the content starts\n    var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n\n    if (insertSpaces) {\n      var indent = cachedStringRepeat(' ', indentSize);\n      var desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n      var indentCount = desiredTabStop / indentSize; // will be an integer\n\n      return cachedStringRepeat(indent, indentCount);\n    } else {\n      var indent = '\\t';\n      var desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n      var indentCount = desiredTabStop / tabSize; // will be an integer\n\n      return cachedStringRepeat(indent, indentCount);\n    }\n  };\n\n  ShiftCommand.prototype._addEditOperation = function (builder, range, text) {\n    if (this._useLastEditRangeForCursorEndPosition) {\n      builder.addTrackedEditOperation(range, text);\n    } else {\n      builder.addEditOperation(range, text);\n    }\n  };\n\n  ShiftCommand.prototype.getEditOperations = function (model, builder) {\n    var startLine = this._selection.startLineNumber;\n    var endLine = this._selection.endLineNumber;\n\n    if (this._selection.endColumn === 1 && startLine !== endLine) {\n      endLine = endLine - 1;\n    }\n\n    var _a = this._opts,\n        tabSize = _a.tabSize,\n        indentSize = _a.indentSize,\n        insertSpaces = _a.insertSpaces;\n    var shouldIndentEmptyLines = startLine === endLine; // if indenting or outdenting on a whitespace only line\n\n    if (this._selection.isEmpty()) {\n      if (/^\\s*$/.test(model.getLineContent(startLine))) {\n        this._useLastEditRangeForCursorEndPosition = true;\n      }\n    }\n\n    if (this._opts.useTabStops) {\n      // keep track of previous line's \"miss-alignment\"\n      var previousLineExtraSpaces = 0,\n          extraSpaces = 0;\n\n      for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n        extraSpaces = 0;\n        var lineText = model.getLineContent(lineNumber);\n        var indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n\n        if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n          // empty line or line with no leading whitespace => nothing to do\n          continue;\n        }\n\n        if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n          // do not indent empty lines => nothing to do\n          continue;\n        }\n\n        if (indentationEndIndex === -1) {\n          // the entire line is whitespace\n          indentationEndIndex = lineText.length;\n        }\n\n        if (lineNumber > 1) {\n          var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n\n          if (contentStartVisibleColumn % indentSize !== 0) {\n            // The current line is \"miss-aligned\", so let's see if this is expected...\n            // This can only happen when it has trailing commas in the indent\n            if (model.isCheapToTokenize(lineNumber - 1)) {\n              var enterAction = LanguageConfigurationRegistry.getRawEnterActionAtPosition(model, lineNumber - 1, model.getLineMaxColumn(lineNumber - 1));\n\n              if (enterAction) {\n                extraSpaces = previousLineExtraSpaces;\n\n                if (enterAction.appendText) {\n                  for (var j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                    if (enterAction.appendText.charCodeAt(j) === 32\n                    /* Space */\n                    ) {\n                        extraSpaces++;\n                      } else {\n                      break;\n                    }\n                  }\n                }\n\n                if (enterAction.removeText) {\n                  extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                } // Act as if `prefixSpaces` is not part of the indentation\n\n\n                for (var j = 0; j < extraSpaces; j++) {\n                  if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32\n                  /* Space */\n                  ) {\n                      break;\n                    }\n\n                  indentationEndIndex--;\n                }\n              }\n            }\n          }\n        }\n\n        if (this._opts.isUnshift && indentationEndIndex === 0) {\n          // line with no leading whitespace => nothing to do\n          continue;\n        }\n\n        var desiredIndent = void 0;\n\n        if (this._opts.isUnshift) {\n          desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n        } else {\n          desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n        }\n\n        this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n\n        if (lineNumber === startLine) {\n          // Force the startColumn to stay put because we're inserting after it\n          this._selectionStartColumnStaysPut = this._selection.startColumn <= indentationEndIndex + 1;\n        }\n      }\n    } else {\n      var oneIndent = insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t';\n\n      for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n        var lineText = model.getLineContent(lineNumber);\n        var indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n\n        if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n          // empty line or line with no leading whitespace => nothing to do\n          continue;\n        }\n\n        if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n          // do not indent empty lines => nothing to do\n          continue;\n        }\n\n        if (indentationEndIndex === -1) {\n          // the entire line is whitespace\n          indentationEndIndex = lineText.length;\n        }\n\n        if (this._opts.isUnshift && indentationEndIndex === 0) {\n          // line with no leading whitespace => nothing to do\n          continue;\n        }\n\n        if (this._opts.isUnshift) {\n          indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n\n          for (var i = 0; i < indentationEndIndex; i++) {\n            var chr = lineText.charCodeAt(i);\n\n            if (chr === 9\n            /* Tab */\n            ) {\n                indentationEndIndex = i + 1;\n                break;\n              }\n          }\n\n          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n        } else {\n          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n\n          if (lineNumber === startLine) {\n            // Force the startColumn to stay put because we're inserting after it\n            this._selectionStartColumnStaysPut = this._selection.startColumn === 1;\n          }\n        }\n      }\n    }\n\n    this._selectionId = builder.trackSelection(this._selection);\n  };\n\n  ShiftCommand.prototype.computeCursorState = function (model, helper) {\n    if (this._useLastEditRangeForCursorEndPosition) {\n      var lastOp = helper.getInverseEditOperations()[0];\n      return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n    }\n\n    var result = helper.getTrackedSelection(this._selectionId);\n\n    if (this._selectionStartColumnStaysPut) {\n      // The selection start should not move\n      var initialStartColumn = this._selection.startColumn;\n      var resultStartColumn = result.startColumn;\n\n      if (resultStartColumn <= initialStartColumn) {\n        return result;\n      }\n\n      if (result.getDirection() === 0\n      /* LTR */\n      ) {\n          return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n        }\n\n      return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n    }\n\n    return result;\n  };\n\n  return ShiftCommand;\n}();\n\nexport { ShiftCommand };","map":null,"metadata":{},"sourceType":"module"}