{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport function startsWith(haystack, needle) {\n  if (haystack.length < needle.length) {\n    return false;\n  }\n\n  for (var i = 0; i < needle.length; i++) {\n    if (haystack[i] !== needle[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Determines if haystack ends with needle.\n */\n\nexport function endsWith(haystack, needle) {\n  var diff = haystack.length - needle.length;\n\n  if (diff > 0) {\n    return haystack.lastIndexOf(needle) === diff;\n  } else if (diff === 0) {\n    return haystack === needle;\n  } else {\n    return false;\n  }\n}\n/**\n * Computes the difference score for two strings. More similar strings have a higher score.\n * We use largest common subsequence dynamic programming approach but penalize in the end for length differences.\n * Strings that have a large length difference will get a bad default score 0.\n * Complexity - both time and space O(first.length * second.length)\n * Dynamic programming LCS computation http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n *\n * @param first a string\n * @param second a string\n */\n\nexport function difference(first, second, maxLenDelta) {\n  if (maxLenDelta === void 0) {\n    maxLenDelta = 4;\n  }\n\n  var lengthDifference = Math.abs(first.length - second.length); // We only compute score if length of the currentWord and length of entry.name are similar.\n\n  if (lengthDifference > maxLenDelta) {\n    return 0;\n  } // Initialize LCS (largest common subsequence) matrix.\n\n\n  var LCS = [];\n  var zeroArray = [];\n  var i, j;\n\n  for (i = 0; i < second.length + 1; ++i) {\n    zeroArray.push(0);\n  }\n\n  for (i = 0; i < first.length + 1; ++i) {\n    LCS.push(zeroArray);\n  }\n\n  for (i = 1; i < first.length + 1; ++i) {\n    for (j = 1; j < second.length + 1; ++j) {\n      if (first[i - 1] === second[j - 1]) {\n        LCS[i][j] = LCS[i - 1][j - 1] + 1;\n      } else {\n        LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);\n      }\n    }\n  }\n\n  return LCS[first.length][second.length] - Math.sqrt(lengthDifference);\n}\n/**\n * Limit of string length.\n */\n\nexport function getLimitedString(str, ellipsis) {\n  if (ellipsis === void 0) {\n    ellipsis = true;\n  }\n\n  if (!str) {\n    return '';\n  }\n\n  if (str.length < 140) {\n    return str;\n  }\n\n  return str.slice(0, 140) + (ellipsis ? '\\u2026' : '');\n}","map":null,"metadata":{},"sourceType":"module"}