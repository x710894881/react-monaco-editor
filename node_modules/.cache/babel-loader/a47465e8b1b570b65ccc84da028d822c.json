{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nexport function values(forEachable) {\n  var result = [];\n  forEachable.forEach(function (value) {\n    return result.push(value);\n  });\n  return result;\n}\nexport function keys(map) {\n  var result = [];\n  map.forEach(function (value, key) {\n    return result.push(key);\n  });\n  return result;\n}\n\nvar StringIterator =\n/** @class */\nfunction () {\n  function StringIterator() {\n    this._value = '';\n    this._pos = 0;\n  }\n\n  StringIterator.prototype.reset = function (key) {\n    this._value = key;\n    this._pos = 0;\n    return this;\n  };\n\n  StringIterator.prototype.next = function () {\n    this._pos += 1;\n    return this;\n  };\n\n  StringIterator.prototype.hasNext = function () {\n    return this._pos < this._value.length - 1;\n  };\n\n  StringIterator.prototype.cmp = function (a) {\n    var aCode = a.charCodeAt(0);\n\n    var thisCode = this._value.charCodeAt(this._pos);\n\n    return aCode - thisCode;\n  };\n\n  StringIterator.prototype.value = function () {\n    return this._value[this._pos];\n  };\n\n  return StringIterator;\n}();\n\nexport { StringIterator };\n\nvar PathIterator =\n/** @class */\nfunction () {\n  function PathIterator() {}\n\n  PathIterator.prototype.reset = function (key) {\n    this._value = key.replace(/\\\\$|\\/$/, '');\n    this._from = 0;\n    this._to = 0;\n    return this.next();\n  };\n\n  PathIterator.prototype.hasNext = function () {\n    return this._to < this._value.length;\n  };\n\n  PathIterator.prototype.next = function () {\n    // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n    this._from = this._to;\n    var justSeps = true;\n\n    for (; this._to < this._value.length; this._to++) {\n      var ch = this._value.charCodeAt(this._to);\n\n      if (ch === 47\n      /* Slash */\n      || ch === 92\n      /* Backslash */\n      ) {\n          if (justSeps) {\n            this._from++;\n          } else {\n            break;\n          }\n        } else {\n        justSeps = false;\n      }\n    }\n\n    return this;\n  };\n\n  PathIterator.prototype.cmp = function (a) {\n    var aPos = 0;\n    var aLen = a.length;\n    var thisPos = this._from;\n\n    while (aPos < aLen && thisPos < this._to) {\n      var cmp = a.charCodeAt(aPos) - this._value.charCodeAt(thisPos);\n\n      if (cmp !== 0) {\n        return cmp;\n      }\n\n      aPos += 1;\n      thisPos += 1;\n    }\n\n    if (aLen === this._to - this._from) {\n      return 0;\n    } else if (aPos < aLen) {\n      return -1;\n    } else {\n      return 1;\n    }\n  };\n\n  PathIterator.prototype.value = function () {\n    return this._value.substring(this._from, this._to);\n  };\n\n  return PathIterator;\n}();\n\nexport { PathIterator };\n\nvar TernarySearchTreeNode =\n/** @class */\nfunction () {\n  function TernarySearchTreeNode() {}\n\n  return TernarySearchTreeNode;\n}();\n\nvar TernarySearchTree =\n/** @class */\nfunction () {\n  function TernarySearchTree(segments) {\n    this._iter = segments;\n  }\n\n  TernarySearchTree.forPaths = function () {\n    return new TernarySearchTree(new PathIterator());\n  };\n\n  TernarySearchTree.forStrings = function () {\n    return new TernarySearchTree(new StringIterator());\n  };\n\n  TernarySearchTree.prototype.clear = function () {\n    this._root = undefined;\n  };\n\n  TernarySearchTree.prototype.set = function (key, element) {\n    var iter = this._iter.reset(key);\n\n    var node;\n\n    if (!this._root) {\n      this._root = new TernarySearchTreeNode();\n      this._root.segment = iter.value();\n    }\n\n    node = this._root;\n\n    while (true) {\n      var val = iter.cmp(node.segment);\n\n      if (val > 0) {\n        // left\n        if (!node.left) {\n          node.left = new TernarySearchTreeNode();\n          node.left.segment = iter.value();\n        }\n\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        if (!node.right) {\n          node.right = new TernarySearchTreeNode();\n          node.right.segment = iter.value();\n        }\n\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n\n        if (!node.mid) {\n          node.mid = new TernarySearchTreeNode();\n          node.mid.segment = iter.value();\n        }\n\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n\n    var oldElement = node.value;\n    node.value = element;\n    node.key = key;\n    return oldElement;\n  };\n\n  TernarySearchTree.prototype.get = function (key) {\n    var iter = this._iter.reset(key);\n\n    var node = this._root;\n\n    while (node) {\n      var val = iter.cmp(node.segment);\n\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n\n    return node ? node.value : undefined;\n  };\n\n  TernarySearchTree.prototype.findSubstr = function (key) {\n    var iter = this._iter.reset(key);\n\n    var node = this._root;\n    var candidate = undefined;\n\n    while (node) {\n      var val = iter.cmp(node.segment);\n\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        candidate = node.value || candidate;\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n\n    return node && node.value || candidate;\n  };\n\n  TernarySearchTree.prototype.forEach = function (callback) {\n    this._forEach(this._root, callback);\n  };\n\n  TernarySearchTree.prototype._forEach = function (node, callback) {\n    if (node) {\n      // left\n      this._forEach(node.left, callback); // node\n\n\n      if (node.value) {\n        // callback(node.value, this._iter.join(parts));\n        callback(node.value, node.key);\n      } // mid\n\n\n      this._forEach(node.mid, callback); // right\n\n\n      this._forEach(node.right, callback);\n    }\n  };\n\n  return TernarySearchTree;\n}();\n\nexport { TernarySearchTree };\n\nvar ResourceMap =\n/** @class */\nfunction () {\n  function ResourceMap() {\n    this.map = new Map();\n    this.ignoreCase = false; // in the future this should be an uri-comparator\n  }\n\n  ResourceMap.prototype.set = function (resource, value) {\n    this.map.set(this.toKey(resource), value);\n  };\n\n  ResourceMap.prototype.get = function (resource) {\n    return this.map.get(this.toKey(resource));\n  };\n\n  ResourceMap.prototype.toKey = function (resource) {\n    var key = resource.toString();\n\n    if (this.ignoreCase) {\n      key = key.toLowerCase();\n    }\n\n    return key;\n  };\n\n  return ResourceMap;\n}();\n\nexport { ResourceMap };\n\nvar LinkedMap =\n/** @class */\nfunction () {\n  function LinkedMap() {\n    this._map = new Map();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n  }\n\n  LinkedMap.prototype.clear = function () {\n    this._map.clear();\n\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n  };\n\n  Object.defineProperty(LinkedMap.prototype, \"size\", {\n    get: function () {\n      return this._size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  LinkedMap.prototype.get = function (key, touch) {\n    if (touch === void 0) {\n      touch = 0\n      /* None */\n      ;\n    }\n\n    var item = this._map.get(key);\n\n    if (!item) {\n      return undefined;\n    }\n\n    if (touch !== 0\n    /* None */\n    ) {\n        this.touch(item, touch);\n      }\n\n    return item.value;\n  };\n\n  LinkedMap.prototype.set = function (key, value, touch) {\n    if (touch === void 0) {\n      touch = 0\n      /* None */\n      ;\n    }\n\n    var item = this._map.get(key);\n\n    if (item) {\n      item.value = value;\n\n      if (touch !== 0\n      /* None */\n      ) {\n          this.touch(item, touch);\n        }\n    } else {\n      item = {\n        key: key,\n        value: value,\n        next: undefined,\n        previous: undefined\n      };\n\n      switch (touch) {\n        case 0\n        /* None */\n        :\n          this.addItemLast(item);\n          break;\n\n        case 1\n        /* AsOld */\n        :\n          this.addItemFirst(item);\n          break;\n\n        case 2\n        /* AsNew */\n        :\n          this.addItemLast(item);\n          break;\n\n        default:\n          this.addItemLast(item);\n          break;\n      }\n\n      this._map.set(key, item);\n\n      this._size++;\n    }\n  };\n\n  LinkedMap.prototype.delete = function (key) {\n    return !!this.remove(key);\n  };\n\n  LinkedMap.prototype.remove = function (key) {\n    var item = this._map.get(key);\n\n    if (!item) {\n      return undefined;\n    }\n\n    this._map.delete(key);\n\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  };\n\n  LinkedMap.prototype.forEach = function (callbackfn, thisArg) {\n    var current = this._head;\n\n    while (current) {\n      if (thisArg) {\n        callbackfn.bind(thisArg)(current.value, current.key, this);\n      } else {\n        callbackfn(current.value, current.key, this);\n      }\n\n      current = current.next;\n    }\n  };\n  /* VS Code / Monaco editor runs on es5 which has no Symbol.iterator\n  keys(): IterableIterator<K> {\n      const current = this._head;\n      const iterator: IterableIterator<K> = {\n          [Symbol.iterator]() {\n              return iterator;\n          },\n          next():IteratorResult<K> {\n              if (current) {\n                  const result = { value: current.key, done: false };\n                  current = current.next;\n                  return result;\n              } else {\n                  return { value: undefined, done: true };\n              }\n          }\n      };\n      return iterator;\n  }\n   values(): IterableIterator<V> {\n      const current = this._head;\n      const iterator: IterableIterator<V> = {\n          [Symbol.iterator]() {\n              return iterator;\n          },\n          next():IteratorResult<V> {\n              if (current) {\n                  const result = { value: current.value, done: false };\n                  current = current.next;\n                  return result;\n              } else {\n                  return { value: undefined, done: true };\n              }\n          }\n      };\n      return iterator;\n  }\n  */\n\n\n  LinkedMap.prototype.trimOld = function (newSize) {\n    if (newSize >= this.size) {\n      return;\n    }\n\n    if (newSize === 0) {\n      this.clear();\n      return;\n    }\n\n    var current = this._head;\n    var currentSize = this.size;\n\n    while (current && currentSize > newSize) {\n      this._map.delete(current.key);\n\n      current = current.next;\n      currentSize--;\n    }\n\n    this._head = current;\n    this._size = currentSize;\n\n    if (current) {\n      current.previous = undefined;\n    }\n  };\n\n  LinkedMap.prototype.addItemFirst = function (item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._tail = item;\n    } else if (!this._head) {\n      throw new Error('Invalid list');\n    } else {\n      item.next = this._head;\n      this._head.previous = item;\n    }\n\n    this._head = item;\n  };\n\n  LinkedMap.prototype.addItemLast = function (item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._head = item;\n    } else if (!this._tail) {\n      throw new Error('Invalid list');\n    } else {\n      item.previous = this._tail;\n      this._tail.next = item;\n    }\n\n    this._tail = item;\n  };\n\n  LinkedMap.prototype.removeItem = function (item) {\n    if (item === this._head && item === this._tail) {\n      this._head = undefined;\n      this._tail = undefined;\n    } else if (item === this._head) {\n      // This can only happend if size === 1 which is handle\n      // by the case above.\n      if (!item.next) {\n        throw new Error('Invalid list');\n      }\n\n      item.next.previous = undefined;\n      this._head = item.next;\n    } else if (item === this._tail) {\n      // This can only happend if size === 1 which is handle\n      // by the case above.\n      if (!item.previous) {\n        throw new Error('Invalid list');\n      }\n\n      item.previous.next = undefined;\n      this._tail = item.previous;\n    } else {\n      var next = item.next;\n      var previous = item.previous;\n\n      if (!next || !previous) {\n        throw new Error('Invalid list');\n      }\n\n      next.previous = previous;\n      previous.next = next;\n    }\n\n    item.next = undefined;\n    item.previous = undefined;\n  };\n\n  LinkedMap.prototype.touch = function (item, touch) {\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n\n    if (touch !== 1\n    /* AsOld */\n    && touch !== 2\n    /* AsNew */\n    ) {\n        return;\n      }\n\n    if (touch === 1\n    /* AsOld */\n    ) {\n        if (item === this._head) {\n          return;\n        }\n\n        var next = item.next;\n        var previous = item.previous; // Unlink the item\n\n        if (item === this._tail) {\n          // previous must be defined since item was not head but is tail\n          // So there are more than on item in the map\n          previous.next = undefined;\n          this._tail = previous;\n        } else {\n          // Both next and previous are not undefined since item was neither head nor tail.\n          next.previous = previous;\n          previous.next = next;\n        } // Insert the node at head\n\n\n        item.previous = undefined;\n        item.next = this._head;\n        this._head.previous = item;\n        this._head = item;\n      } else if (touch === 2\n    /* AsNew */\n    ) {\n        if (item === this._tail) {\n          return;\n        }\n\n        var next = item.next;\n        var previous = item.previous; // Unlink the item.\n\n        if (item === this._head) {\n          // next must be defined since item was not tail but is head\n          // So there are more than on item in the map\n          next.previous = undefined;\n          this._head = next;\n        } else {\n          // Both next and previous are not undefined since item was neither head nor tail.\n          next.previous = previous;\n          previous.next = next;\n        }\n\n        item.next = undefined;\n        item.previous = this._tail;\n        this._tail.next = item;\n        this._tail = item;\n      }\n  };\n\n  LinkedMap.prototype.toJSON = function () {\n    var data = [];\n    this.forEach(function (value, key) {\n      data.push([key, value]);\n    });\n    return data;\n  };\n\n  return LinkedMap;\n}();\n\nexport { LinkedMap };\n\nvar LRUCache =\n/** @class */\nfunction (_super) {\n  __extends(LRUCache, _super);\n\n  function LRUCache(limit, ratio) {\n    if (ratio === void 0) {\n      ratio = 1;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this._limit = limit;\n    _this._ratio = Math.min(Math.max(0, ratio), 1);\n    return _this;\n  }\n\n  LRUCache.prototype.get = function (key) {\n    return _super.prototype.get.call(this, key, 2\n    /* AsNew */\n    );\n  };\n\n  LRUCache.prototype.peek = function (key) {\n    return _super.prototype.get.call(this, key, 0\n    /* None */\n    );\n  };\n\n  LRUCache.prototype.set = function (key, value) {\n    _super.prototype.set.call(this, key, value, 2\n    /* AsNew */\n    );\n\n    this.checkTrim();\n  };\n\n  LRUCache.prototype.checkTrim = function () {\n    if (this.size > this._limit) {\n      this.trimOld(Math.round(this._limit * this._ratio));\n    }\n  };\n\n  return LRUCache;\n}(LinkedMap);\n\nexport { LRUCache };","map":null,"metadata":{},"sourceType":"module"}