{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range, Position } from '../../vscode-languageserver-types/main.js';\nimport { html_beautify } from '../beautify/beautify-html.js';\nimport { repeat } from '../utils/strings.js';\nexport function format(document, range, options) {\n  var value = document.getText();\n  var includesEnd = true;\n  var initialIndentLevel = 0;\n  var tabSize = options.tabSize || 4;\n\n  if (range) {\n    var startOffset = document.offsetAt(range.start); // include all leading whitespace iff at the beginning of the line\n\n    var extendedStart = startOffset;\n\n    while (extendedStart > 0 && isWhitespace(value, extendedStart - 1)) {\n      extendedStart--;\n    }\n\n    if (extendedStart === 0 || isEOL(value, extendedStart - 1)) {\n      startOffset = extendedStart;\n    } else {\n      // else keep at least one whitespace\n      if (extendedStart < startOffset) {\n        startOffset = extendedStart + 1;\n      }\n    } // include all following whitespace until the end of the line\n\n\n    var endOffset = document.offsetAt(range.end);\n    var extendedEnd = endOffset;\n\n    while (extendedEnd < value.length && isWhitespace(value, extendedEnd)) {\n      extendedEnd++;\n    }\n\n    if (extendedEnd === value.length || isEOL(value, extendedEnd)) {\n      endOffset = extendedEnd;\n    }\n\n    range = Range.create(document.positionAt(startOffset), document.positionAt(endOffset)); // Do not modify if substring starts in inside an element\n    // Ending inside an element is fine as it doesn't cause formatting errors\n\n    var firstHalf = value.substring(0, startOffset);\n\n    if (new RegExp(/.*[<][^>]*$/).test(firstHalf)) {\n      //return without modification\n      value = value.substring(startOffset, endOffset);\n      return [{\n        range: range,\n        newText: value\n      }];\n    }\n\n    includesEnd = endOffset === value.length;\n    value = value.substring(startOffset, endOffset);\n\n    if (startOffset !== 0) {\n      var startOfLineOffset = document.offsetAt(Position.create(range.start.line, 0));\n      initialIndentLevel = computeIndentLevel(document.getText(), startOfLineOffset, options);\n    }\n  } else {\n    range = Range.create(Position.create(0, 0), document.positionAt(value.length));\n  }\n\n  var htmlOptions = {\n    indent_size: tabSize,\n    indent_char: options.insertSpaces ? ' ' : '\\t',\n    wrap_line_length: getFormatOption(options, 'wrapLineLength', 120),\n    unformatted: getTagsFormatOption(options, 'unformatted', void 0),\n    content_unformatted: getTagsFormatOption(options, 'contentUnformatted', void 0),\n    indent_inner_html: getFormatOption(options, 'indentInnerHtml', false),\n    preserve_newlines: getFormatOption(options, 'preserveNewLines', true),\n    max_preserve_newlines: getFormatOption(options, 'maxPreserveNewLines', 32786),\n    indent_handlebars: getFormatOption(options, 'indentHandlebars', false),\n    end_with_newline: includesEnd && getFormatOption(options, 'endWithNewline', false),\n    extra_liners: getTagsFormatOption(options, 'extraLiners', void 0),\n    wrap_attributes: getFormatOption(options, 'wrapAttributes', 'auto'),\n    wrap_attributes_indent_size: getFormatOption(options, 'wrapAttributesIndentSize', void 0),\n    eol: '\\n'\n  };\n  var result = html_beautify(trimLeft(value), htmlOptions);\n\n  if (initialIndentLevel > 0) {\n    var indent = options.insertSpaces ? repeat(' ', tabSize * initialIndentLevel) : repeat('\\t', initialIndentLevel);\n    result = result.split('\\n').join('\\n' + indent);\n\n    if (range.start.character === 0) {\n      result = indent + result; // keep the indent\n    }\n  }\n\n  return [{\n    range: range,\n    newText: result\n  }];\n}\n\nfunction trimLeft(str) {\n  return str.replace(/^\\s+/, '');\n}\n\nfunction getFormatOption(options, key, dflt) {\n  if (options && options.hasOwnProperty(key)) {\n    var value = options[key];\n\n    if (value !== null) {\n      return value;\n    }\n  }\n\n  return dflt;\n}\n\nfunction getTagsFormatOption(options, key, dflt) {\n  var list = getFormatOption(options, key, null);\n\n  if (typeof list === 'string') {\n    if (list.length > 0) {\n      return list.split(',').map(function (t) {\n        return t.trim().toLowerCase();\n      });\n    }\n\n    return [];\n  }\n\n  return dflt;\n}\n\nfunction computeIndentLevel(content, offset, options) {\n  var i = offset;\n  var nChars = 0;\n  var tabSize = options.tabSize || 4;\n\n  while (i < content.length) {\n    var ch = content.charAt(i);\n\n    if (ch === ' ') {\n      nChars++;\n    } else if (ch === '\\t') {\n      nChars += tabSize;\n    } else {\n      break;\n    }\n\n    i++;\n  }\n\n  return Math.floor(nChars / tabSize);\n}\n\nfunction getEOL(document) {\n  var text = document.getText();\n\n  if (document.lineCount > 1) {\n    var to = document.offsetAt(Position.create(1, 0));\n    var from = to;\n\n    while (from > 0 && isEOL(text, from - 1)) {\n      from--;\n    }\n\n    return text.substr(from, to - from);\n  }\n\n  return '\\n';\n}\n\nfunction isEOL(text, offset) {\n  return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n\nfunction isWhitespace(text, offset) {\n  return ' \\t'.indexOf(text.charAt(offset)) !== -1;\n}","map":null,"metadata":{},"sourceType":"module"}