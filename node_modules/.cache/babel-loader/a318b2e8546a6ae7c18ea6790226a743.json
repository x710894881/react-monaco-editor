{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as dom from '../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { PointerHandler } from '../controller/pointerHandler.js';\nimport { TextAreaHandler } from '../controller/textAreaHandler.js';\nimport { ViewController } from './viewController.js';\nimport { ContentViewOverlays, MarginViewOverlays } from './viewOverlays.js';\nimport { PartFingerprints } from './viewPart.js';\nimport { ViewContentWidgets } from '../viewParts/contentWidgets/contentWidgets.js';\nimport { CurrentLineHighlightOverlay } from '../viewParts/currentLineHighlight/currentLineHighlight.js';\nimport { CurrentLineMarginHighlightOverlay } from '../viewParts/currentLineMarginHighlight/currentLineMarginHighlight.js';\nimport { DecorationsOverlay } from '../viewParts/decorations/decorations.js';\nimport { EditorScrollbar } from '../viewParts/editorScrollbar/editorScrollbar.js';\nimport { GlyphMarginOverlay } from '../viewParts/glyphMargin/glyphMargin.js';\nimport { IndentGuidesOverlay } from '../viewParts/indentGuides/indentGuides.js';\nimport { LineNumbersOverlay } from '../viewParts/lineNumbers/lineNumbers.js';\nimport { ViewLines } from '../viewParts/lines/viewLines.js';\nimport { LinesDecorationsOverlay } from '../viewParts/linesDecorations/linesDecorations.js';\nimport { Margin } from '../viewParts/margin/margin.js';\nimport { MarginViewLineDecorationsOverlay } from '../viewParts/marginDecorations/marginDecorations.js';\nimport { Minimap } from '../viewParts/minimap/minimap.js';\nimport { ViewOverlayWidgets } from '../viewParts/overlayWidgets/overlayWidgets.js';\nimport { DecorationsOverviewRuler } from '../viewParts/overviewRuler/decorationsOverviewRuler.js';\nimport { OverviewRuler } from '../viewParts/overviewRuler/overviewRuler.js';\nimport { Rulers } from '../viewParts/rulers/rulers.js';\nimport { ScrollDecorationViewPart } from '../viewParts/scrollDecoration/scrollDecoration.js';\nimport { SelectionsOverlay } from '../viewParts/selections/selections.js';\nimport { ViewCursors } from '../viewParts/viewCursors/viewCursors.js';\nimport { ViewZones } from '../viewParts/viewZones/viewZones.js';\nimport { Position } from '../../common/core/position.js';\nimport { RenderingContext } from '../../common/view/renderingContext.js';\nimport { ViewContext } from '../../common/view/viewContext.js';\nimport { ViewEventDispatcher } from '../../common/view/viewEventDispatcher.js';\nimport * as viewEvents from '../../common/view/viewEvents.js';\nimport { ViewportData } from '../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewEventHandler } from '../../common/viewModel/viewEventHandler.js';\nimport { getThemeTypeSelector } from '../../../platform/theme/common/themeService.js';\n\nvar invalidFunc = function () {\n  throw new Error(\"Invalid change accessor\");\n};\n\nvar View =\n/** @class */\nfunction (_super) {\n  __extends(View, _super);\n\n  function View(commandDelegate, configuration, themeService, model, cursor, outgoingEvents) {\n    var _this = _super.call(this) || this;\n\n    _this._cursor = cursor;\n    _this._renderAnimationFrame = null;\n    _this.outgoingEvents = outgoingEvents;\n    var viewController = new ViewController(configuration, model, _this.outgoingEvents, commandDelegate); // The event dispatcher will always go through _renderOnce before dispatching any events\n\n    _this.eventDispatcher = new ViewEventDispatcher(function (callback) {\n      return _this._renderOnce(callback);\n    }); // Ensure the view is the first event handler in order to update the layout\n\n    _this.eventDispatcher.addEventHandler(_this); // The view context is passed on to most classes (basically to reduce param. counts in ctors)\n\n\n    _this._context = new ViewContext(configuration, themeService.getTheme(), model, _this.eventDispatcher);\n\n    _this._register(themeService.onThemeChange(function (theme) {\n      _this._context.theme = theme;\n\n      _this.eventDispatcher.emit(new viewEvents.ViewThemeChangedEvent());\n\n      _this.render(true, false);\n    }));\n\n    _this.viewParts = []; // Keyboard handler\n\n    _this._textAreaHandler = new TextAreaHandler(_this._context, viewController, _this.createTextAreaHandlerHelper());\n\n    _this.viewParts.push(_this._textAreaHandler); // These two dom nodes must be constructed up front, since references are needed in the layout provider (scrolling & co.)\n\n\n    _this.linesContent = createFastDomNode(document.createElement('div'));\n\n    _this.linesContent.setClassName('lines-content' + ' monaco-editor-background');\n\n    _this.linesContent.setPosition('absolute');\n\n    _this.domNode = createFastDomNode(document.createElement('div'));\n\n    _this.domNode.setClassName(_this.getEditorClassName());\n\n    _this.overflowGuardContainer = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(_this.overflowGuardContainer, 3\n    /* OverflowGuard */\n    );\n\n    _this.overflowGuardContainer.setClassName('overflow-guard');\n\n    _this._scrollbar = new EditorScrollbar(_this._context, _this.linesContent, _this.domNode, _this.overflowGuardContainer);\n\n    _this.viewParts.push(_this._scrollbar); // View Lines\n\n\n    _this.viewLines = new ViewLines(_this._context, _this.linesContent); // View Zones\n\n    _this.viewZones = new ViewZones(_this._context);\n\n    _this.viewParts.push(_this.viewZones); // Decorations overview ruler\n\n\n    var decorationsOverviewRuler = new DecorationsOverviewRuler(_this._context);\n\n    _this.viewParts.push(decorationsOverviewRuler);\n\n    var scrollDecoration = new ScrollDecorationViewPart(_this._context);\n\n    _this.viewParts.push(scrollDecoration);\n\n    var contentViewOverlays = new ContentViewOverlays(_this._context);\n\n    _this.viewParts.push(contentViewOverlays);\n\n    contentViewOverlays.addDynamicOverlay(new CurrentLineHighlightOverlay(_this._context));\n    contentViewOverlays.addDynamicOverlay(new SelectionsOverlay(_this._context));\n    contentViewOverlays.addDynamicOverlay(new IndentGuidesOverlay(_this._context));\n    contentViewOverlays.addDynamicOverlay(new DecorationsOverlay(_this._context));\n    var marginViewOverlays = new MarginViewOverlays(_this._context);\n\n    _this.viewParts.push(marginViewOverlays);\n\n    marginViewOverlays.addDynamicOverlay(new CurrentLineMarginHighlightOverlay(_this._context));\n    marginViewOverlays.addDynamicOverlay(new GlyphMarginOverlay(_this._context));\n    marginViewOverlays.addDynamicOverlay(new MarginViewLineDecorationsOverlay(_this._context));\n    marginViewOverlays.addDynamicOverlay(new LinesDecorationsOverlay(_this._context));\n    marginViewOverlays.addDynamicOverlay(new LineNumbersOverlay(_this._context));\n    var margin = new Margin(_this._context);\n    margin.getDomNode().appendChild(_this.viewZones.marginDomNode);\n    margin.getDomNode().appendChild(marginViewOverlays.getDomNode());\n\n    _this.viewParts.push(margin); // Content widgets\n\n\n    _this.contentWidgets = new ViewContentWidgets(_this._context, _this.domNode);\n\n    _this.viewParts.push(_this.contentWidgets);\n\n    _this.viewCursors = new ViewCursors(_this._context);\n\n    _this.viewParts.push(_this.viewCursors); // Overlay widgets\n\n\n    _this.overlayWidgets = new ViewOverlayWidgets(_this._context);\n\n    _this.viewParts.push(_this.overlayWidgets);\n\n    var rulers = new Rulers(_this._context);\n\n    _this.viewParts.push(rulers);\n\n    var minimap = new Minimap(_this._context);\n\n    _this.viewParts.push(minimap); // -------------- Wire dom nodes up\n\n\n    if (decorationsOverviewRuler) {\n      var overviewRulerData = _this._scrollbar.getOverviewRulerLayoutInfo();\n\n      overviewRulerData.parent.insertBefore(decorationsOverviewRuler.getDomNode(), overviewRulerData.insertBefore);\n    }\n\n    _this.linesContent.appendChild(contentViewOverlays.getDomNode());\n\n    _this.linesContent.appendChild(rulers.domNode);\n\n    _this.linesContent.appendChild(_this.viewZones.domNode);\n\n    _this.linesContent.appendChild(_this.viewLines.getDomNode());\n\n    _this.linesContent.appendChild(_this.contentWidgets.domNode);\n\n    _this.linesContent.appendChild(_this.viewCursors.getDomNode());\n\n    _this.overflowGuardContainer.appendChild(margin.getDomNode());\n\n    _this.overflowGuardContainer.appendChild(_this._scrollbar.getDomNode());\n\n    _this.overflowGuardContainer.appendChild(scrollDecoration.getDomNode());\n\n    _this.overflowGuardContainer.appendChild(_this._textAreaHandler.textArea);\n\n    _this.overflowGuardContainer.appendChild(_this._textAreaHandler.textAreaCover);\n\n    _this.overflowGuardContainer.appendChild(_this.overlayWidgets.getDomNode());\n\n    _this.overflowGuardContainer.appendChild(minimap.getDomNode());\n\n    _this.domNode.appendChild(_this.overflowGuardContainer);\n\n    _this.domNode.appendChild(_this.contentWidgets.overflowingContentWidgetsDomNode);\n\n    _this._setLayout(); // Pointer handler\n\n\n    _this.pointerHandler = _this._register(new PointerHandler(_this._context, viewController, _this.createPointerHandlerHelper()));\n\n    _this._register(model.addEventListener(function (events) {\n      _this.eventDispatcher.emitMany(events);\n    }));\n\n    _this._register(_this._cursor.addEventListener(function (events) {\n      _this.eventDispatcher.emitMany(events);\n    }));\n\n    return _this;\n  }\n\n  View.prototype._flushAccumulatedAndRenderNow = function () {\n    this._renderNow();\n  };\n\n  View.prototype.createPointerHandlerHelper = function () {\n    var _this = this;\n\n    return {\n      viewDomNode: this.domNode.domNode,\n      linesContentDomNode: this.linesContent.domNode,\n      focusTextArea: function () {\n        _this.focus();\n      },\n      getLastViewCursorsRenderData: function () {\n        return _this.viewCursors.getLastRenderData() || [];\n      },\n      shouldSuppressMouseDownOnViewZone: function (viewZoneId) {\n        return _this.viewZones.shouldSuppressMouseDownOnViewZone(viewZoneId);\n      },\n      shouldSuppressMouseDownOnWidget: function (widgetId) {\n        return _this.contentWidgets.shouldSuppressMouseDownOnWidget(widgetId);\n      },\n      getPositionFromDOMInfo: function (spanNode, offset) {\n        _this._flushAccumulatedAndRenderNow();\n\n        return _this.viewLines.getPositionFromDOMInfo(spanNode, offset);\n      },\n      visibleRangeForPosition2: function (lineNumber, column) {\n        _this._flushAccumulatedAndRenderNow();\n\n        return _this.viewLines.visibleRangeForPosition(new Position(lineNumber, column));\n      },\n      getLineWidth: function (lineNumber) {\n        _this._flushAccumulatedAndRenderNow();\n\n        return _this.viewLines.getLineWidth(lineNumber);\n      }\n    };\n  };\n\n  View.prototype.createTextAreaHandlerHelper = function () {\n    var _this = this;\n\n    return {\n      visibleRangeForPositionRelativeToEditor: function (lineNumber, column) {\n        _this._flushAccumulatedAndRenderNow();\n\n        return _this.viewLines.visibleRangeForPosition(new Position(lineNumber, column));\n      }\n    };\n  };\n\n  View.prototype._setLayout = function () {\n    var layoutInfo = this._context.configuration.editor.layoutInfo;\n    this.domNode.setWidth(layoutInfo.width);\n    this.domNode.setHeight(layoutInfo.height);\n    this.overflowGuardContainer.setWidth(layoutInfo.width);\n    this.overflowGuardContainer.setHeight(layoutInfo.height);\n    this.linesContent.setWidth(1000000);\n    this.linesContent.setHeight(1000000);\n  };\n\n  View.prototype.getEditorClassName = function () {\n    var focused = this._textAreaHandler.isFocused() ? ' focused' : '';\n    return this._context.configuration.editor.editorClassName + ' ' + getThemeTypeSelector(this._context.theme.type) + focused;\n  }; // --- begin event handlers\n\n\n  View.prototype.onConfigurationChanged = function (e) {\n    if (e.editorClassName) {\n      this.domNode.setClassName(this.getEditorClassName());\n    }\n\n    if (e.layoutInfo) {\n      this._setLayout();\n    }\n\n    return false;\n  };\n\n  View.prototype.onFocusChanged = function (e) {\n    this.domNode.setClassName(this.getEditorClassName());\n\n    this._context.model.setHasFocus(e.isFocused);\n\n    if (e.isFocused) {\n      this.outgoingEvents.emitViewFocusGained();\n    } else {\n      this.outgoingEvents.emitViewFocusLost();\n    }\n\n    return false;\n  };\n\n  View.prototype.onScrollChanged = function (e) {\n    this.outgoingEvents.emitScrollChanged(e);\n    return false;\n  };\n\n  View.prototype.onThemeChanged = function (e) {\n    this.domNode.setClassName(this.getEditorClassName());\n    return false;\n  }; // --- end event handlers\n\n\n  View.prototype.dispose = function () {\n    if (this._renderAnimationFrame !== null) {\n      this._renderAnimationFrame.dispose();\n\n      this._renderAnimationFrame = null;\n    }\n\n    this.eventDispatcher.removeEventHandler(this);\n    this.outgoingEvents.dispose();\n    this.viewLines.dispose(); // Destroy view parts\n\n    for (var i = 0, len = this.viewParts.length; i < len; i++) {\n      this.viewParts[i].dispose();\n    }\n\n    this.viewParts = [];\n\n    _super.prototype.dispose.call(this);\n  };\n\n  View.prototype._renderOnce = function (callback) {\n    var r = safeInvokeNoArg(callback);\n\n    this._scheduleRender();\n\n    return r;\n  };\n\n  View.prototype._scheduleRender = function () {\n    if (this._renderAnimationFrame === null) {\n      this._renderAnimationFrame = dom.runAtThisOrScheduleAtNextAnimationFrame(this._onRenderScheduled.bind(this), 100);\n    }\n  };\n\n  View.prototype._onRenderScheduled = function () {\n    this._renderAnimationFrame = null;\n\n    this._flushAccumulatedAndRenderNow();\n  };\n\n  View.prototype._renderNow = function () {\n    var _this = this;\n\n    safeInvokeNoArg(function () {\n      return _this._actualRender();\n    });\n  };\n\n  View.prototype._getViewPartsToRender = function () {\n    var result = [],\n        resultLen = 0;\n\n    for (var i = 0, len = this.viewParts.length; i < len; i++) {\n      var viewPart = this.viewParts[i];\n\n      if (viewPart.shouldRender()) {\n        result[resultLen++] = viewPart;\n      }\n    }\n\n    return result;\n  };\n\n  View.prototype._actualRender = function () {\n    if (!dom.isInDOM(this.domNode.domNode)) {\n      return;\n    }\n\n    var viewPartsToRender = this._getViewPartsToRender();\n\n    if (!this.viewLines.shouldRender() && viewPartsToRender.length === 0) {\n      // Nothing to render\n      return;\n    }\n\n    var partialViewportData = this._context.viewLayout.getLinesViewportData();\n\n    this._context.model.setViewport(partialViewportData.startLineNumber, partialViewportData.endLineNumber, partialViewportData.centeredLineNumber);\n\n    var viewportData = new ViewportData(this._cursor.getViewSelections(), partialViewportData, this._context.viewLayout.getWhitespaceViewportData(), this._context.model);\n\n    if (this.contentWidgets.shouldRender()) {\n      // Give the content widgets a chance to set their max width before a possible synchronous layout\n      this.contentWidgets.onBeforeRender(viewportData);\n    }\n\n    if (this.viewLines.shouldRender()) {\n      this.viewLines.renderText(viewportData);\n      this.viewLines.onDidRender(); // Rendering of viewLines might cause scroll events to occur, so collect view parts to render again\n\n      viewPartsToRender = this._getViewPartsToRender();\n    }\n\n    var renderingContext = new RenderingContext(this._context.viewLayout, viewportData, this.viewLines); // Render the rest of the parts\n\n    for (var i = 0, len = viewPartsToRender.length; i < len; i++) {\n      var viewPart = viewPartsToRender[i];\n      viewPart.prepareRender(renderingContext);\n    }\n\n    for (var i = 0, len = viewPartsToRender.length; i < len; i++) {\n      var viewPart = viewPartsToRender[i];\n      viewPart.render(renderingContext);\n      viewPart.onDidRender();\n    }\n  }; // --- BEGIN CodeEditor helpers\n\n\n  View.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {\n    this._scrollbar.delegateVerticalScrollbarMouseDown(browserEvent);\n  };\n\n  View.prototype.restoreState = function (scrollPosition) {\n    this._context.viewLayout.setScrollPositionNow({\n      scrollTop: scrollPosition.scrollTop\n    });\n\n    this._context.model.tokenizeViewport();\n\n    this._renderNow();\n\n    this.viewLines.updateLineWidths();\n\n    this._context.viewLayout.setScrollPositionNow({\n      scrollLeft: scrollPosition.scrollLeft\n    });\n  };\n\n  View.prototype.getOffsetForColumn = function (modelLineNumber, modelColumn) {\n    var modelPosition = this._context.model.validateModelPosition({\n      lineNumber: modelLineNumber,\n      column: modelColumn\n    });\n\n    var viewPosition = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n\n    this._flushAccumulatedAndRenderNow();\n\n    var visibleRange = this.viewLines.visibleRangeForPosition(new Position(viewPosition.lineNumber, viewPosition.column));\n\n    if (!visibleRange) {\n      return -1;\n    }\n\n    return visibleRange.left;\n  };\n\n  View.prototype.getTargetAtClientPoint = function (clientX, clientY) {\n    return this.pointerHandler.getTargetAtClientPoint(clientX, clientY);\n  };\n\n  View.prototype.createOverviewRuler = function (cssClassName) {\n    return new OverviewRuler(this._context, cssClassName);\n  };\n\n  View.prototype.change = function (callback) {\n    var _this = this;\n\n    var zonesHaveChanged = false;\n\n    this._renderOnce(function () {\n      var changeAccessor = {\n        addZone: function (zone) {\n          zonesHaveChanged = true;\n          return _this.viewZones.addZone(zone);\n        },\n        removeZone: function (id) {\n          if (!id) {\n            return;\n          }\n\n          zonesHaveChanged = _this.viewZones.removeZone(id) || zonesHaveChanged;\n        },\n        layoutZone: function (id) {\n          if (!id) {\n            return;\n          }\n\n          zonesHaveChanged = _this.viewZones.layoutZone(id) || zonesHaveChanged;\n        }\n      };\n      safeInvoke1Arg(callback, changeAccessor); // Invalidate changeAccessor\n\n      changeAccessor.addZone = invalidFunc;\n      changeAccessor.removeZone = invalidFunc;\n      changeAccessor.layoutZone = invalidFunc;\n\n      if (zonesHaveChanged) {\n        _this._context.viewLayout.onHeightMaybeChanged();\n\n        _this._context.privateViewEventBus.emit(new viewEvents.ViewZonesChangedEvent());\n      }\n    });\n\n    return zonesHaveChanged;\n  };\n\n  View.prototype.render = function (now, everything) {\n    if (everything) {\n      // Force everything to render...\n      this.viewLines.forceShouldRender();\n\n      for (var i = 0, len = this.viewParts.length; i < len; i++) {\n        var viewPart = this.viewParts[i];\n        viewPart.forceShouldRender();\n      }\n    }\n\n    if (now) {\n      this._flushAccumulatedAndRenderNow();\n    } else {\n      this._scheduleRender();\n    }\n  };\n\n  View.prototype.focus = function () {\n    this._textAreaHandler.focusTextArea();\n  };\n\n  View.prototype.isFocused = function () {\n    return this._textAreaHandler.isFocused();\n  };\n\n  View.prototype.addContentWidget = function (widgetData) {\n    this.contentWidgets.addWidget(widgetData.widget);\n    this.layoutContentWidget(widgetData);\n\n    this._scheduleRender();\n  };\n\n  View.prototype.layoutContentWidget = function (widgetData) {\n    var newPosition = widgetData.position ? widgetData.position.position : null;\n    var newRange = widgetData.position ? widgetData.position.range || null : null;\n    var newPreference = widgetData.position ? widgetData.position.preference : null;\n    this.contentWidgets.setWidgetPosition(widgetData.widget, newPosition, newRange, newPreference);\n\n    this._scheduleRender();\n  };\n\n  View.prototype.removeContentWidget = function (widgetData) {\n    this.contentWidgets.removeWidget(widgetData.widget);\n\n    this._scheduleRender();\n  };\n\n  View.prototype.addOverlayWidget = function (widgetData) {\n    this.overlayWidgets.addWidget(widgetData.widget);\n    this.layoutOverlayWidget(widgetData);\n\n    this._scheduleRender();\n  };\n\n  View.prototype.layoutOverlayWidget = function (widgetData) {\n    var newPreference = widgetData.position ? widgetData.position.preference : null;\n    var shouldRender = this.overlayWidgets.setWidgetPosition(widgetData.widget, newPreference);\n\n    if (shouldRender) {\n      this._scheduleRender();\n    }\n  };\n\n  View.prototype.removeOverlayWidget = function (widgetData) {\n    this.overlayWidgets.removeWidget(widgetData.widget);\n\n    this._scheduleRender();\n  };\n\n  return View;\n}(ViewEventHandler);\n\nexport { View };\n\nfunction safeInvokeNoArg(func) {\n  try {\n    return func();\n  } catch (e) {\n    onUnexpectedError(e);\n  }\n}\n\nfunction safeInvoke1Arg(func, arg1) {\n  try {\n    return func(arg1);\n  } catch (e) {\n    onUnexpectedError(e);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}