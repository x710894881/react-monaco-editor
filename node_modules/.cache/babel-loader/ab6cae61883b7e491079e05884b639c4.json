{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport './menu.css';\nimport * as nls from '../../../../nls.js';\nimport * as strings from '../../../common/strings.js';\nimport { Action } from '../../../common/actions.js';\nimport { ActionBar, Separator, ActionViewItem, BaseActionViewItem } from '../actionbar/actionbar.js';\nimport { addClass, EventType, EventHelper, removeTabIndexAndUpdateFocus, isAncestor, hasClass, addDisposableListener, removeClass, append, $, addClasses, removeClasses } from '../../dom.js';\nimport { StandardKeyboardEvent } from '../../keyboardEvent.js';\nimport { RunOnceScheduler } from '../../../common/async.js';\nimport { DisposableStore } from '../../../common/lifecycle.js';\nimport { DomScrollableElement } from '../scrollbar/scrollableElement.js';\nimport { Emitter } from '../../../common/event.js';\nimport { isLinux, isMacintosh } from '../../../common/platform.js';\nexport var MENU_MNEMONIC_REGEX = /\\(&([^\\s&])\\)|(^|[^&])&([^\\s&])/;\nexport var MENU_ESCAPED_MNEMONIC_REGEX = /(&amp;)?(&amp;)([^\\s&])/g;\n\nvar SubmenuAction =\n/** @class */\nfunction (_super) {\n  __extends(SubmenuAction, _super);\n\n  function SubmenuAction(label, entries, cssClass) {\n    var _this = _super.call(this, !!cssClass ? cssClass : 'submenu', label, '', true) || this;\n\n    _this.entries = entries;\n    return _this;\n  }\n\n  return SubmenuAction;\n}(Action);\n\nexport { SubmenuAction };\n\nvar Menu =\n/** @class */\nfunction (_super) {\n  __extends(Menu, _super);\n\n  function Menu(container, actions, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = this;\n\n    addClass(container, 'monaco-menu-container');\n    container.setAttribute('role', 'presentation');\n    var menuElement = document.createElement('div');\n    addClass(menuElement, 'monaco-menu');\n    menuElement.setAttribute('role', 'presentation');\n    _this = _super.call(this, menuElement, {\n      orientation: 2\n      /* VERTICAL */\n      ,\n      actionViewItemProvider: function (action) {\n        return _this.doGetActionViewItem(action, options, parentData);\n      },\n      context: options.context,\n      actionRunner: options.actionRunner,\n      ariaLabel: options.ariaLabel,\n      triggerKeys: {\n        keys: [3\n        /* Enter */\n        ].concat(isMacintosh ? [10\n        /* Space */\n        ] : []),\n        keyDown: true\n      }\n    }) || this;\n    _this.menuElement = menuElement;\n    _this._onScroll = _this._register(new Emitter());\n\n    _this.actionsList.setAttribute('role', 'menu');\n\n    _this.actionsList.tabIndex = 0;\n    _this.menuDisposables = _this._register(new DisposableStore());\n    addDisposableListener(menuElement, EventType.KEY_DOWN, function (e) {\n      var event = new StandardKeyboardEvent(e); // Stop tab navigation of menus\n\n      if (event.equals(2\n      /* Tab */\n      )) {\n        e.preventDefault();\n      }\n    });\n\n    if (options.enableMnemonics) {\n      _this.menuDisposables.add(addDisposableListener(menuElement, EventType.KEY_DOWN, function (e) {\n        var key = e.key.toLocaleLowerCase();\n\n        if (_this.mnemonics.has(key)) {\n          EventHelper.stop(e, true);\n\n          var actions_1 = _this.mnemonics.get(key);\n\n          if (actions_1.length === 1) {\n            if (actions_1[0] instanceof SubmenuMenuActionViewItem) {\n              _this.focusItemByElement(actions_1[0].container);\n            }\n\n            actions_1[0].onClick(e);\n          }\n\n          if (actions_1.length > 1) {\n            var action = actions_1.shift();\n\n            if (action) {\n              _this.focusItemByElement(action.container);\n\n              actions_1.push(action);\n            }\n\n            _this.mnemonics.set(key, actions_1);\n          }\n        }\n      }));\n    }\n\n    if (isLinux) {\n      _this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, function (e) {\n        var event = new StandardKeyboardEvent(e);\n\n        if (event.equals(14\n        /* Home */\n        ) || event.equals(11\n        /* PageUp */\n        )) {\n          _this.focusedItem = _this.viewItems.length - 1;\n\n          _this.focusNext();\n\n          EventHelper.stop(e, true);\n        } else if (event.equals(13\n        /* End */\n        ) || event.equals(12\n        /* PageDown */\n        )) {\n          _this.focusedItem = 0;\n\n          _this.focusPrevious();\n\n          EventHelper.stop(e, true);\n        }\n      }));\n    }\n\n    _this._register(addDisposableListener(_this.domNode, EventType.MOUSE_OUT, function (e) {\n      var relatedTarget = e.relatedTarget;\n\n      if (!isAncestor(relatedTarget, _this.domNode)) {\n        _this.focusedItem = undefined;\n        _this.scrollTopHold = _this.menuElement.scrollTop;\n\n        _this.updateFocus();\n\n        e.stopPropagation();\n      }\n    }));\n\n    _this._register(addDisposableListener(_this.domNode, EventType.MOUSE_UP, function (e) {\n      // Absorb clicks in menu dead space https://github.com/Microsoft/vscode/issues/63575\n      EventHelper.stop(e, true);\n    }));\n\n    _this._register(addDisposableListener(_this.actionsList, EventType.MOUSE_OVER, function (e) {\n      var target = e.target;\n\n      if (!target || !isAncestor(target, _this.actionsList) || target === _this.actionsList) {\n        return;\n      }\n\n      while (target.parentElement !== _this.actionsList && target.parentElement !== null) {\n        target = target.parentElement;\n      }\n\n      if (hasClass(target, 'action-item')) {\n        var lastFocusedItem = _this.focusedItem;\n        _this.scrollTopHold = _this.menuElement.scrollTop;\n\n        _this.setFocusedItem(target);\n\n        if (lastFocusedItem !== _this.focusedItem) {\n          _this.updateFocus();\n        }\n      }\n    }));\n\n    var parentData = {\n      parent: _this\n    };\n    _this.mnemonics = new Map();\n\n    _this.push(actions, {\n      icon: true,\n      label: true,\n      isMenu: true\n    }); // Scroll Logic\n\n\n    _this.scrollableElement = _this._register(new DomScrollableElement(menuElement, {\n      alwaysConsumeMouseWheel: true,\n      horizontal: 2\n      /* Hidden */\n      ,\n      vertical: 3\n      /* Visible */\n      ,\n      verticalScrollbarSize: 7,\n      handleMouseWheel: true,\n      useShadows: true\n    }));\n\n    var scrollElement = _this.scrollableElement.getDomNode();\n\n    scrollElement.style.position = null;\n    menuElement.style.maxHeight = Math.max(10, window.innerHeight - container.getBoundingClientRect().top - 30) + \"px\";\n\n    _this.menuDisposables.add(_this.scrollableElement.onScroll(function () {\n      _this._onScroll.fire();\n    }, _this));\n\n    _this._register(addDisposableListener(_this.menuElement, EventType.SCROLL, function (e) {\n      if (_this.scrollTopHold !== undefined) {\n        _this.menuElement.scrollTop = _this.scrollTopHold;\n        _this.scrollTopHold = undefined;\n      }\n\n      _this.scrollableElement.scanDomNode();\n    }));\n\n    container.appendChild(_this.scrollableElement.getDomNode());\n\n    _this.scrollableElement.scanDomNode();\n\n    _this.viewItems.filter(function (item) {\n      return !(item instanceof MenuSeparatorActionViewItem);\n    }).forEach(function (item, index, array) {\n      item.updatePositionInSet(index + 1, array.length);\n    });\n\n    return _this;\n  }\n\n  Menu.prototype.style = function (style) {\n    var container = this.getContainer();\n    var fgColor = style.foregroundColor ? \"\" + style.foregroundColor : null;\n    var bgColor = style.backgroundColor ? \"\" + style.backgroundColor : null;\n    var border = style.borderColor ? \"2px solid \" + style.borderColor : null;\n    var shadow = style.shadowColor ? \"0 2px 4px \" + style.shadowColor : null;\n    container.style.border = border;\n    this.domNode.style.color = fgColor;\n    this.domNode.style.backgroundColor = bgColor;\n    container.style.boxShadow = shadow;\n\n    if (this.viewItems) {\n      this.viewItems.forEach(function (item) {\n        if (item instanceof BaseMenuActionViewItem || item instanceof MenuSeparatorActionViewItem) {\n          item.style(style);\n        }\n      });\n    }\n  };\n\n  Menu.prototype.getContainer = function () {\n    return this.scrollableElement.getDomNode();\n  };\n\n  Object.defineProperty(Menu.prototype, \"onScroll\", {\n    get: function () {\n      return this._onScroll.event;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Menu.prototype, \"scrollOffset\", {\n    get: function () {\n      return this.menuElement.scrollTop;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Menu.prototype.focusItemByElement = function (element) {\n    var lastFocusedItem = this.focusedItem;\n    this.setFocusedItem(element);\n\n    if (lastFocusedItem !== this.focusedItem) {\n      this.updateFocus();\n    }\n  };\n\n  Menu.prototype.setFocusedItem = function (element) {\n    for (var i = 0; i < this.actionsList.children.length; i++) {\n      var elem = this.actionsList.children[i];\n\n      if (element === elem) {\n        this.focusedItem = i;\n        break;\n      }\n    }\n  };\n\n  Menu.prototype.doGetActionViewItem = function (action, options, parentData) {\n    if (action instanceof Separator) {\n      return new MenuSeparatorActionViewItem(options.context, action, {\n        icon: true\n      });\n    } else if (action instanceof SubmenuAction) {\n      var menuActionViewItem = new SubmenuMenuActionViewItem(action, action.entries, parentData, options);\n\n      if (options.enableMnemonics) {\n        var mnemonic = menuActionViewItem.getMnemonic();\n\n        if (mnemonic && menuActionViewItem.isEnabled()) {\n          var actionViewItems = [];\n\n          if (this.mnemonics.has(mnemonic)) {\n            actionViewItems = this.mnemonics.get(mnemonic);\n          }\n\n          actionViewItems.push(menuActionViewItem);\n          this.mnemonics.set(mnemonic, actionViewItems);\n        }\n      }\n\n      return menuActionViewItem;\n    } else {\n      var menuItemOptions = {\n        enableMnemonics: options.enableMnemonics\n      };\n\n      if (options.getKeyBinding) {\n        var keybinding = options.getKeyBinding(action);\n\n        if (keybinding) {\n          var keybindingLabel = keybinding.getLabel();\n\n          if (keybindingLabel) {\n            menuItemOptions.keybinding = keybindingLabel;\n          }\n        }\n      }\n\n      var menuActionViewItem = new BaseMenuActionViewItem(options.context, action, menuItemOptions);\n\n      if (options.enableMnemonics) {\n        var mnemonic = menuActionViewItem.getMnemonic();\n\n        if (mnemonic && menuActionViewItem.isEnabled()) {\n          var actionViewItems = [];\n\n          if (this.mnemonics.has(mnemonic)) {\n            actionViewItems = this.mnemonics.get(mnemonic);\n          }\n\n          actionViewItems.push(menuActionViewItem);\n          this.mnemonics.set(mnemonic, actionViewItems);\n        }\n      }\n\n      return menuActionViewItem;\n    }\n  };\n\n  return Menu;\n}(ActionBar);\n\nexport { Menu };\n\nvar BaseMenuActionViewItem =\n/** @class */\nfunction (_super) {\n  __extends(BaseMenuActionViewItem, _super);\n\n  function BaseMenuActionViewItem(ctx, action, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = this;\n\n    options.isMenu = true;\n    _this = _super.call(this, action, action, options) || this;\n    _this.options = options;\n    _this.options.icon = options.icon !== undefined ? options.icon : false;\n    _this.options.label = options.label !== undefined ? options.label : true;\n    _this.cssClass = ''; // Set mnemonic\n\n    if (_this.options.label && options.enableMnemonics) {\n      var label = _this.getAction().label;\n\n      if (label) {\n        var matches = MENU_MNEMONIC_REGEX.exec(label);\n\n        if (matches) {\n          _this.mnemonic = (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase();\n        }\n      }\n    } // Add mouse up listener later to avoid accidental clicks\n\n\n    _this.runOnceToEnableMouseUp = new RunOnceScheduler(function () {\n      if (!_this.element) {\n        return;\n      }\n\n      _this._register(addDisposableListener(_this.element, EventType.MOUSE_UP, function (e) {\n        EventHelper.stop(e, true);\n\n        _this.onClick(e);\n      }));\n    }, 50);\n\n    _this._register(_this.runOnceToEnableMouseUp);\n\n    return _this;\n  }\n\n  BaseMenuActionViewItem.prototype.render = function (container) {\n    _super.prototype.render.call(this, container);\n\n    if (!this.element) {\n      return;\n    }\n\n    this.container = container;\n    this.item = append(this.element, $('a.action-menu-item'));\n\n    if (this._action.id === Separator.ID) {\n      // A separator is a presentation item\n      this.item.setAttribute('role', 'presentation');\n    } else {\n      this.item.setAttribute('role', 'menuitem');\n\n      if (this.mnemonic) {\n        this.item.setAttribute('aria-keyshortcuts', \"\" + this.mnemonic);\n      }\n    }\n\n    this.check = append(this.item, $('span.menu-item-check'));\n    this.check.setAttribute('role', 'none');\n    this.label = append(this.item, $('span.action-label'));\n\n    if (this.options.label && this.options.keybinding) {\n      append(this.item, $('span.keybinding')).textContent = this.options.keybinding;\n    } // Adds mouse up listener to actually run the action\n\n\n    this.runOnceToEnableMouseUp.schedule();\n    this.updateClass();\n    this.updateLabel();\n    this.updateTooltip();\n    this.updateEnabled();\n    this.updateChecked();\n  };\n\n  BaseMenuActionViewItem.prototype.blur = function () {\n    _super.prototype.blur.call(this);\n\n    this.applyStyle();\n  };\n\n  BaseMenuActionViewItem.prototype.focus = function () {\n    _super.prototype.focus.call(this);\n\n    this.item.focus();\n    this.applyStyle();\n  };\n\n  BaseMenuActionViewItem.prototype.updatePositionInSet = function (pos, setSize) {\n    this.item.setAttribute('aria-posinset', \"\" + pos);\n    this.item.setAttribute('aria-setsize', \"\" + setSize);\n  };\n\n  BaseMenuActionViewItem.prototype.updateLabel = function () {\n    if (this.options.label) {\n      var label = this.getAction().label;\n\n      if (label) {\n        var cleanLabel = cleanMnemonic(label);\n\n        if (!this.options.enableMnemonics) {\n          label = cleanLabel;\n        }\n\n        this.label.setAttribute('aria-label', cleanLabel.replace(/&&/g, '&'));\n        var matches = MENU_MNEMONIC_REGEX.exec(label);\n\n        if (matches) {\n          label = strings.escape(label); // This is global, reset it\n\n          MENU_ESCAPED_MNEMONIC_REGEX.lastIndex = 0;\n          var escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label); // We can't use negative lookbehind so if we match our negative and skip\n\n          while (escMatch && escMatch[1]) {\n            escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);\n          }\n\n          if (escMatch) {\n            label = label.substr(0, escMatch.index) + \"<u aria-hidden=\\\"true\\\">\" + escMatch[3] + \"</u>\" + label.substr(escMatch.index + escMatch[0].length);\n          }\n\n          label = label.replace(/&amp;&amp;/g, '&amp;');\n          this.item.setAttribute('aria-keyshortcuts', (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase());\n        } else {\n          label = label.replace(/&&/g, '&');\n        }\n      }\n\n      this.label.innerHTML = label.trim();\n    }\n  };\n\n  BaseMenuActionViewItem.prototype.updateTooltip = function () {\n    var title = null;\n\n    if (this.getAction().tooltip) {\n      title = this.getAction().tooltip;\n    } else if (!this.options.label && this.getAction().label && this.options.icon) {\n      title = this.getAction().label;\n\n      if (this.options.keybinding) {\n        title = nls.localize({\n          key: 'titleLabel',\n          comment: ['action title', 'action keybinding']\n        }, \"{0} ({1})\", title, this.options.keybinding);\n      }\n    }\n\n    if (title) {\n      this.item.title = title;\n    }\n  };\n\n  BaseMenuActionViewItem.prototype.updateClass = function () {\n    if (this.cssClass) {\n      removeClasses(this.item, this.cssClass);\n    }\n\n    if (this.options.icon) {\n      this.cssClass = this.getAction().class || '';\n      addClass(this.label, 'icon');\n\n      if (this.cssClass) {\n        addClasses(this.label, this.cssClass);\n      }\n\n      this.updateEnabled();\n    } else {\n      removeClass(this.label, 'icon');\n    }\n  };\n\n  BaseMenuActionViewItem.prototype.updateEnabled = function () {\n    if (this.getAction().enabled) {\n      if (this.element) {\n        removeClass(this.element, 'disabled');\n      }\n\n      removeClass(this.item, 'disabled');\n      this.item.tabIndex = 0;\n    } else {\n      if (this.element) {\n        addClass(this.element, 'disabled');\n      }\n\n      addClass(this.item, 'disabled');\n      removeTabIndexAndUpdateFocus(this.item);\n    }\n  };\n\n  BaseMenuActionViewItem.prototype.updateChecked = function () {\n    if (this.getAction().checked) {\n      addClass(this.item, 'checked');\n      this.item.setAttribute('role', 'menuitemcheckbox');\n      this.item.setAttribute('aria-checked', 'true');\n    } else {\n      removeClass(this.item, 'checked');\n      this.item.setAttribute('role', 'menuitem');\n      this.item.setAttribute('aria-checked', 'false');\n    }\n  };\n\n  BaseMenuActionViewItem.prototype.getMnemonic = function () {\n    return this.mnemonic;\n  };\n\n  BaseMenuActionViewItem.prototype.applyStyle = function () {\n    if (!this.menuStyle) {\n      return;\n    }\n\n    var isSelected = this.element && hasClass(this.element, 'focused');\n    var fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;\n    var bgColor = isSelected && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : this.menuStyle.backgroundColor;\n    var border = isSelected && this.menuStyle.selectionBorderColor ? \"thin solid \" + this.menuStyle.selectionBorderColor : null;\n    this.item.style.color = fgColor ? \"\" + fgColor : null;\n    this.check.style.backgroundColor = fgColor ? \"\" + fgColor : null;\n    this.item.style.backgroundColor = bgColor ? \"\" + bgColor : null;\n    this.container.style.border = border;\n  };\n\n  BaseMenuActionViewItem.prototype.style = function (style) {\n    this.menuStyle = style;\n    this.applyStyle();\n  };\n\n  return BaseMenuActionViewItem;\n}(BaseActionViewItem);\n\nvar SubmenuMenuActionViewItem =\n/** @class */\nfunction (_super) {\n  __extends(SubmenuMenuActionViewItem, _super);\n\n  function SubmenuMenuActionViewItem(action, submenuActions, parentData, submenuOptions) {\n    var _this = _super.call(this, action, action, submenuOptions) || this;\n\n    _this.submenuActions = submenuActions;\n    _this.parentData = parentData;\n    _this.submenuOptions = submenuOptions;\n    _this.submenuDisposables = _this._register(new DisposableStore());\n    _this.showScheduler = new RunOnceScheduler(function () {\n      if (_this.mouseOver) {\n        _this.cleanupExistingSubmenu(false);\n\n        _this.createSubmenu(false);\n      }\n    }, 250);\n    _this.hideScheduler = new RunOnceScheduler(function () {\n      if (_this.element && !isAncestor(document.activeElement, _this.element) && _this.parentData.submenu === _this.mysubmenu) {\n        _this.parentData.parent.focus(false);\n\n        _this.cleanupExistingSubmenu(true);\n      }\n    }, 750);\n    return _this;\n  }\n\n  SubmenuMenuActionViewItem.prototype.render = function (container) {\n    var _this = this;\n\n    _super.prototype.render.call(this, container);\n\n    if (!this.element) {\n      return;\n    }\n\n    addClass(this.item, 'monaco-submenu-item');\n    this.item.setAttribute('aria-haspopup', 'true');\n    this.submenuIndicator = append(this.item, $('span.submenu-indicator'));\n    this.submenuIndicator.setAttribute('aria-hidden', 'true');\n\n    this._register(addDisposableListener(this.element, EventType.KEY_UP, function (e) {\n      var event = new StandardKeyboardEvent(e);\n\n      if (event.equals(17\n      /* RightArrow */\n      ) || event.equals(3\n      /* Enter */\n      )) {\n        EventHelper.stop(e, true);\n\n        _this.createSubmenu(true);\n      }\n    }));\n\n    this._register(addDisposableListener(this.element, EventType.KEY_DOWN, function (e) {\n      var event = new StandardKeyboardEvent(e);\n\n      if (document.activeElement === _this.item) {\n        if (event.equals(17\n        /* RightArrow */\n        ) || event.equals(3\n        /* Enter */\n        )) {\n          EventHelper.stop(e, true);\n        }\n      }\n    }));\n\n    this._register(addDisposableListener(this.element, EventType.MOUSE_OVER, function (e) {\n      if (!_this.mouseOver) {\n        _this.mouseOver = true;\n\n        _this.showScheduler.schedule();\n      }\n    }));\n\n    this._register(addDisposableListener(this.element, EventType.MOUSE_LEAVE, function (e) {\n      _this.mouseOver = false;\n    }));\n\n    this._register(addDisposableListener(this.element, EventType.FOCUS_OUT, function (e) {\n      if (_this.element && !isAncestor(document.activeElement, _this.element)) {\n        _this.hideScheduler.schedule();\n      }\n    }));\n\n    this._register(this.parentData.parent.onScroll(function () {\n      _this.parentData.parent.focus(false);\n\n      _this.cleanupExistingSubmenu(false);\n    }));\n  };\n\n  SubmenuMenuActionViewItem.prototype.onClick = function (e) {\n    // stop clicking from trying to run an action\n    EventHelper.stop(e, true);\n    this.cleanupExistingSubmenu(false);\n    this.createSubmenu(false);\n  };\n\n  SubmenuMenuActionViewItem.prototype.cleanupExistingSubmenu = function (force) {\n    if (this.parentData.submenu && (force || this.parentData.submenu !== this.mysubmenu)) {\n      this.parentData.submenu.dispose();\n      this.parentData.submenu = undefined;\n\n      if (this.submenuContainer) {\n        this.submenuDisposables.clear();\n        this.submenuContainer = undefined;\n      }\n    }\n  };\n\n  SubmenuMenuActionViewItem.prototype.createSubmenu = function (selectFirstItem) {\n    var _this = this;\n\n    if (selectFirstItem === void 0) {\n      selectFirstItem = true;\n    }\n\n    if (!this.element) {\n      return;\n    }\n\n    if (!this.parentData.submenu) {\n      this.submenuContainer = append(this.element, $('div.monaco-submenu'));\n      addClasses(this.submenuContainer, 'menubar-menu-items-holder', 'context-view');\n      this.parentData.submenu = new Menu(this.submenuContainer, this.submenuActions, this.submenuOptions);\n\n      if (this.menuStyle) {\n        this.parentData.submenu.style(this.menuStyle);\n      }\n\n      var boundingRect = this.element.getBoundingClientRect();\n      var childBoundingRect = this.submenuContainer.getBoundingClientRect();\n      var computedStyles = getComputedStyle(this.parentData.parent.domNode);\n      var paddingTop = parseFloat(computedStyles.paddingTop || '0') || 0;\n\n      if (window.innerWidth <= boundingRect.right + childBoundingRect.width) {\n        this.submenuContainer.style.left = '10px';\n        this.submenuContainer.style.top = this.element.offsetTop - this.parentData.parent.scrollOffset + boundingRect.height + \"px\";\n      } else {\n        this.submenuContainer.style.left = this.element.offsetWidth + \"px\";\n        this.submenuContainer.style.top = this.element.offsetTop - this.parentData.parent.scrollOffset - paddingTop + \"px\";\n      }\n\n      this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_UP, function (e) {\n        var event = new StandardKeyboardEvent(e);\n\n        if (event.equals(15\n        /* LeftArrow */\n        )) {\n          EventHelper.stop(e, true);\n\n          _this.parentData.parent.focus();\n\n          if (_this.parentData.submenu) {\n            _this.parentData.submenu.dispose();\n\n            _this.parentData.submenu = undefined;\n          }\n\n          _this.submenuDisposables.clear();\n\n          _this.submenuContainer = undefined;\n        }\n      }));\n      this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_DOWN, function (e) {\n        var event = new StandardKeyboardEvent(e);\n\n        if (event.equals(15\n        /* LeftArrow */\n        )) {\n          EventHelper.stop(e, true);\n        }\n      }));\n      this.submenuDisposables.add(this.parentData.submenu.onDidCancel(function () {\n        _this.parentData.parent.focus();\n\n        if (_this.parentData.submenu) {\n          _this.parentData.submenu.dispose();\n\n          _this.parentData.submenu = undefined;\n        }\n\n        _this.submenuDisposables.clear();\n\n        _this.submenuContainer = undefined;\n      }));\n      this.parentData.submenu.focus(selectFirstItem);\n      this.mysubmenu = this.parentData.submenu;\n    } else {\n      this.parentData.submenu.focus(false);\n    }\n  };\n\n  SubmenuMenuActionViewItem.prototype.applyStyle = function () {\n    _super.prototype.applyStyle.call(this);\n\n    if (!this.menuStyle) {\n      return;\n    }\n\n    var isSelected = this.element && hasClass(this.element, 'focused');\n    var fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;\n    this.submenuIndicator.style.backgroundColor = fgColor ? \"\" + fgColor : null;\n\n    if (this.parentData.submenu) {\n      this.parentData.submenu.style(this.menuStyle);\n    }\n  };\n\n  SubmenuMenuActionViewItem.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.hideScheduler.dispose();\n\n    if (this.mysubmenu) {\n      this.mysubmenu.dispose();\n      this.mysubmenu = null;\n    }\n\n    if (this.submenuContainer) {\n      this.submenuContainer = undefined;\n    }\n  };\n\n  return SubmenuMenuActionViewItem;\n}(BaseMenuActionViewItem);\n\nvar MenuSeparatorActionViewItem =\n/** @class */\nfunction (_super) {\n  __extends(MenuSeparatorActionViewItem, _super);\n\n  function MenuSeparatorActionViewItem() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  MenuSeparatorActionViewItem.prototype.style = function (style) {\n    this.label.style.borderBottomColor = style.separatorColor ? \"\" + style.separatorColor : null;\n  };\n\n  return MenuSeparatorActionViewItem;\n}(ActionViewItem);\n\nexport function cleanMnemonic(label) {\n  var regex = MENU_MNEMONIC_REGEX;\n  var matches = regex.exec(label);\n\n  if (!matches) {\n    return label;\n  }\n\n  var mnemonicInText = !matches[1];\n  return label.replace(regex, mnemonicInText ? '$2$3' : '').trim();\n}","map":null,"metadata":{},"sourceType":"module"}