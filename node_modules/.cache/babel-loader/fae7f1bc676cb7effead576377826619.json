{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../config/editorOptions.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport * as model from '../model.js';\nimport { EditStack } from './editStack.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, getNodeIsInOverviewRuler, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { InternalModelContentChangeEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from './textModelEvents.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TextModelTokenization } from './textModelTokens.js';\nimport { getWordAtText } from './wordHelper.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nimport { NULL_LANGUAGE_IDENTIFIER } from '../modes/nullMode.js';\nimport { ignoreBracketsInToken } from '../modes/supports.js';\nimport { BracketsUtils } from '../modes/supports/richEditBrackets.js';\nimport { withUndefinedAsNull } from '../../../base/common/types.js';\nimport { TokensStore, countEOL } from './tokensStore.js';\nimport { Color } from '../../../base/common/color.js';\n\nfunction createTextBufferBuilder() {\n  return new PieceTreeTextBufferBuilder();\n}\n\nexport function createTextBufferFactory(text) {\n  var builder = createTextBufferBuilder();\n  builder.acceptChunk(text);\n  return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n  var factory = typeof value === 'string' ? createTextBufferFactory(value) : value;\n  return factory.create(defaultEOL);\n}\nvar MODEL_ID = 0;\nvar LIMIT_FIND_COUNT = 999;\nexport var LONG_LINE_BOUNDARY = 10000;\n\nvar invalidFunc = function () {\n  throw new Error(\"Invalid change accessor\");\n};\n\nvar TextModel =\n/** @class */\nfunction (_super) {\n  __extends(TextModel, _super); //#endregion\n\n\n  function TextModel(source, creationOptions, languageIdentifier, associatedResource) {\n    if (associatedResource === void 0) {\n      associatedResource = null;\n    }\n\n    var _this = _super.call(this) || this; //#region Events\n\n\n    _this._onWillDispose = _this._register(new Emitter());\n    _this.onWillDispose = _this._onWillDispose.event;\n    _this._onDidChangeDecorations = _this._register(new DidChangeDecorationsEmitter());\n    _this.onDidChangeDecorations = _this._onDidChangeDecorations.event;\n    _this._onDidChangeLanguage = _this._register(new Emitter());\n    _this.onDidChangeLanguage = _this._onDidChangeLanguage.event;\n    _this._onDidChangeLanguageConfiguration = _this._register(new Emitter());\n    _this.onDidChangeLanguageConfiguration = _this._onDidChangeLanguageConfiguration.event;\n    _this._onDidChangeTokens = _this._register(new Emitter());\n    _this.onDidChangeTokens = _this._onDidChangeTokens.event;\n    _this._onDidChangeOptions = _this._register(new Emitter());\n    _this.onDidChangeOptions = _this._onDidChangeOptions.event;\n    _this._onDidChangeAttached = _this._register(new Emitter());\n    _this.onDidChangeAttached = _this._onDidChangeAttached.event;\n    _this._eventEmitter = _this._register(new DidChangeContentEmitter()); // Generate a new unique model id\n\n    MODEL_ID++;\n    _this.id = '$model' + MODEL_ID;\n    _this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n\n    if (typeof associatedResource === 'undefined' || associatedResource === null) {\n      _this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n    } else {\n      _this._associatedResource = associatedResource;\n    }\n\n    _this._attachedEditorCount = 0;\n    _this._buffer = createTextBuffer(source, creationOptions.defaultEOL);\n    _this._options = TextModel.resolveOptions(_this._buffer, creationOptions);\n\n    var bufferLineCount = _this._buffer.getLineCount();\n\n    var bufferTextLength = _this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, _this._buffer.getLineLength(bufferLineCount) + 1), 0\n    /* TextDefined */\n    ); // !!! Make a decision in the ctor and permanently respect this decision !!!\n    // If a model is too large at construction time, it will never get tokenized,\n    // under no circumstances.\n\n\n    if (creationOptions.largeFileOptimizations) {\n      _this._isTooLargeForTokenization = bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD || bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD;\n    } else {\n      _this._isTooLargeForTokenization = false;\n    }\n\n    _this._isTooLargeForSyncing = bufferTextLength > TextModel.MODEL_SYNC_LIMIT;\n    _this._versionId = 1;\n    _this._alternativeVersionId = 1;\n    _this._isDisposed = false;\n    _this._isDisposing = false;\n    _this._languageIdentifier = languageIdentifier || NULL_LANGUAGE_IDENTIFIER;\n    _this._languageRegistryListener = LanguageConfigurationRegistry.onDidChange(function (e) {\n      if (e.languageIdentifier.id === _this._languageIdentifier.id) {\n        _this._onDidChangeLanguageConfiguration.fire({});\n      }\n    });\n    _this._instanceId = strings.singleLetterHash(MODEL_ID);\n    _this._lastDecorationId = 0;\n    _this._decorations = Object.create(null);\n    _this._decorationsTree = new DecorationsTrees();\n    _this._commandManager = new EditStack(_this);\n    _this._isUndoing = false;\n    _this._isRedoing = false;\n    _this._trimAutoWhitespaceLines = null;\n    _this._tokens = new TokensStore();\n    _this._tokenization = new TextModelTokenization(_this);\n    return _this;\n  }\n\n  TextModel.createFromString = function (text, options, languageIdentifier, uri) {\n    if (options === void 0) {\n      options = TextModel.DEFAULT_CREATION_OPTIONS;\n    }\n\n    if (languageIdentifier === void 0) {\n      languageIdentifier = null;\n    }\n\n    if (uri === void 0) {\n      uri = null;\n    }\n\n    return new TextModel(text, options, languageIdentifier, uri);\n  };\n\n  TextModel.resolveOptions = function (textBuffer, options) {\n    if (options.detectIndentation) {\n      var guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n      return new model.TextModelResolvedOptions({\n        tabSize: guessedIndentation.tabSize,\n        indentSize: guessedIndentation.tabSize,\n        insertSpaces: guessedIndentation.insertSpaces,\n        trimAutoWhitespace: options.trimAutoWhitespace,\n        defaultEOL: options.defaultEOL\n      });\n    }\n\n    return new model.TextModelResolvedOptions({\n      tabSize: options.tabSize,\n      indentSize: options.indentSize,\n      insertSpaces: options.insertSpaces,\n      trimAutoWhitespace: options.trimAutoWhitespace,\n      defaultEOL: options.defaultEOL\n    });\n  };\n\n  TextModel.prototype.onDidChangeRawContentFast = function (listener) {\n    return this._eventEmitter.fastEvent(function (e) {\n      return listener(e.rawContentChangedEvent);\n    });\n  };\n\n  TextModel.prototype.onDidChangeRawContent = function (listener) {\n    return this._eventEmitter.slowEvent(function (e) {\n      return listener(e.rawContentChangedEvent);\n    });\n  };\n\n  TextModel.prototype.onDidChangeContentFast = function (listener) {\n    return this._eventEmitter.fastEvent(function (e) {\n      return listener(e.contentChangedEvent);\n    });\n  };\n\n  TextModel.prototype.onDidChangeContent = function (listener) {\n    return this._eventEmitter.slowEvent(function (e) {\n      return listener(e.contentChangedEvent);\n    });\n  };\n\n  TextModel.prototype.dispose = function () {\n    this._isDisposing = true;\n\n    this._onWillDispose.fire();\n\n    this._languageRegistryListener.dispose();\n\n    this._tokenization.dispose();\n\n    this._isDisposed = true;\n\n    _super.prototype.dispose.call(this);\n\n    this._isDisposing = false;\n  };\n\n  TextModel.prototype._assertNotDisposed = function () {\n    if (this._isDisposed) {\n      throw new Error('Model is disposed!');\n    }\n  };\n\n  TextModel.prototype._emitContentChangedEvent = function (rawChange, change) {\n    if (this._isDisposing) {\n      // Do not confuse listeners by emitting any event after disposing\n      return;\n    }\n\n    this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n  };\n\n  TextModel.prototype.setValue = function (value) {\n    this._assertNotDisposed();\n\n    if (value === null) {\n      // There's nothing to do\n      return;\n    }\n\n    var textBuffer = createTextBuffer(value, this._options.defaultEOL);\n    this.setValueFromTextBuffer(textBuffer);\n  };\n\n  TextModel.prototype._createContentChanged2 = function (range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n    return {\n      changes: [{\n        range: range,\n        rangeOffset: rangeOffset,\n        rangeLength: rangeLength,\n        text: text\n      }],\n      eol: this._buffer.getEOL(),\n      versionId: this.getVersionId(),\n      isUndoing: isUndoing,\n      isRedoing: isRedoing,\n      isFlush: isFlush\n    };\n  };\n\n  TextModel.prototype.setValueFromTextBuffer = function (textBuffer) {\n    this._assertNotDisposed();\n\n    if (textBuffer === null) {\n      // There's nothing to do\n      return;\n    }\n\n    var oldFullModelRange = this.getFullModelRange();\n    var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    var endLineNumber = this.getLineCount();\n    var endColumn = this.getLineMaxColumn(endLineNumber);\n    this._buffer = textBuffer;\n\n    this._increaseVersionId(); // Flush all tokens\n\n\n    this._tokens.flush(); // Destroy all my decorations\n\n\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees(); // Destroy my edit history and settings\n\n    this._commandManager = new EditStack(this);\n    this._trimAutoWhitespaceLines = null;\n\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawFlush()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n  };\n\n  TextModel.prototype.setEOL = function (eol) {\n    this._assertNotDisposed();\n\n    var newEOL = eol === 1\n    /* CRLF */\n    ? '\\r\\n' : '\\n';\n\n    if (this._buffer.getEOL() === newEOL) {\n      // Nothing to do\n      return;\n    }\n\n    var oldFullModelRange = this.getFullModelRange();\n    var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    var endLineNumber = this.getLineCount();\n    var endColumn = this.getLineMaxColumn(endLineNumber);\n\n    this._onBeforeEOLChange();\n\n    this._buffer.setEOL(newEOL);\n\n    this._increaseVersionId();\n\n    this._onAfterEOLChange();\n\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawEOLChanged()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n  };\n\n  TextModel.prototype._onBeforeEOLChange = function () {\n    // Ensure all decorations get their `range` set.\n    var versionId = this.getVersionId();\n\n    var allDecorations = this._decorationsTree.search(0, false, false, versionId);\n\n    this._ensureNodesHaveRanges(allDecorations);\n  };\n\n  TextModel.prototype._onAfterEOLChange = function () {\n    // Transform back `range` to offsets\n    var versionId = this.getVersionId();\n\n    var allDecorations = this._decorationsTree.collectNodesPostOrder();\n\n    for (var i = 0, len = allDecorations.length; i < len; i++) {\n      var node = allDecorations[i];\n      var delta = node.cachedAbsoluteStart - node.start;\n\n      var startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);\n\n      var endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);\n\n      node.cachedAbsoluteStart = startOffset;\n      node.cachedAbsoluteEnd = endOffset;\n      node.cachedVersionId = versionId;\n      node.start = startOffset - delta;\n      node.end = endOffset - delta;\n      recomputeMaxEnd(node);\n    }\n  };\n\n  TextModel.prototype.onBeforeAttached = function () {\n    this._attachedEditorCount++;\n\n    if (this._attachedEditorCount === 1) {\n      this._onDidChangeAttached.fire(undefined);\n    }\n  };\n\n  TextModel.prototype.onBeforeDetached = function () {\n    this._attachedEditorCount--;\n\n    if (this._attachedEditorCount === 0) {\n      this._onDidChangeAttached.fire(undefined);\n    }\n  };\n\n  TextModel.prototype.isAttachedToEditor = function () {\n    return this._attachedEditorCount > 0;\n  };\n\n  TextModel.prototype.getAttachedEditorCount = function () {\n    return this._attachedEditorCount;\n  };\n\n  TextModel.prototype.isTooLargeForSyncing = function () {\n    return this._isTooLargeForSyncing;\n  };\n\n  TextModel.prototype.isTooLargeForTokenization = function () {\n    return this._isTooLargeForTokenization;\n  };\n\n  TextModel.prototype.isDisposed = function () {\n    return this._isDisposed;\n  };\n\n  TextModel.prototype.isDominatedByLongLines = function () {\n    this._assertNotDisposed();\n\n    if (this.isTooLargeForTokenization()) {\n      // Cannot word wrap huge files anyways, so it doesn't really matter\n      return false;\n    }\n\n    var smallLineCharCount = 0;\n    var longLineCharCount = 0;\n\n    var lineCount = this._buffer.getLineCount();\n\n    for (var lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n      var lineLength = this._buffer.getLineLength(lineNumber);\n\n      if (lineLength >= LONG_LINE_BOUNDARY) {\n        longLineCharCount += lineLength;\n      } else {\n        smallLineCharCount += lineLength;\n      }\n    }\n\n    return longLineCharCount > smallLineCharCount;\n  };\n\n  Object.defineProperty(TextModel.prototype, \"uri\", {\n    get: function () {\n      return this._associatedResource;\n    },\n    enumerable: true,\n    configurable: true\n  }); //#region Options\n\n  TextModel.prototype.getOptions = function () {\n    this._assertNotDisposed();\n\n    return this._options;\n  };\n\n  TextModel.prototype.getFormattingOptions = function () {\n    return {\n      tabSize: this._options.indentSize,\n      insertSpaces: this._options.insertSpaces\n    };\n  };\n\n  TextModel.prototype.updateOptions = function (_newOpts) {\n    this._assertNotDisposed();\n\n    var tabSize = typeof _newOpts.tabSize !== 'undefined' ? _newOpts.tabSize : this._options.tabSize;\n    var indentSize = typeof _newOpts.indentSize !== 'undefined' ? _newOpts.indentSize : this._options.indentSize;\n    var insertSpaces = typeof _newOpts.insertSpaces !== 'undefined' ? _newOpts.insertSpaces : this._options.insertSpaces;\n    var trimAutoWhitespace = typeof _newOpts.trimAutoWhitespace !== 'undefined' ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n    var newOpts = new model.TextModelResolvedOptions({\n      tabSize: tabSize,\n      indentSize: indentSize,\n      insertSpaces: insertSpaces,\n      defaultEOL: this._options.defaultEOL,\n      trimAutoWhitespace: trimAutoWhitespace\n    });\n\n    if (this._options.equals(newOpts)) {\n      return;\n    }\n\n    var e = this._options.createChangeEvent(newOpts);\n\n    this._options = newOpts;\n\n    this._onDidChangeOptions.fire(e);\n  };\n\n  TextModel.prototype.detectIndentation = function (defaultInsertSpaces, defaultTabSize) {\n    this._assertNotDisposed();\n\n    var guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n    this.updateOptions({\n      insertSpaces: guessedIndentation.insertSpaces,\n      tabSize: guessedIndentation.tabSize,\n      indentSize: guessedIndentation.tabSize\n    });\n  };\n\n  TextModel._normalizeIndentationFromWhitespace = function (str, indentSize, insertSpaces) {\n    var spacesCnt = 0;\n\n    for (var i = 0; i < str.length; i++) {\n      if (str.charAt(i) === '\\t') {\n        spacesCnt += indentSize;\n      } else {\n        spacesCnt++;\n      }\n    }\n\n    var result = '';\n\n    if (!insertSpaces) {\n      var tabsCnt = Math.floor(spacesCnt / indentSize);\n      spacesCnt = spacesCnt % indentSize;\n\n      for (var i = 0; i < tabsCnt; i++) {\n        result += '\\t';\n      }\n    }\n\n    for (var i = 0; i < spacesCnt; i++) {\n      result += ' ';\n    }\n\n    return result;\n  };\n\n  TextModel.normalizeIndentation = function (str, indentSize, insertSpaces) {\n    var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n\n    if (firstNonWhitespaceIndex === -1) {\n      firstNonWhitespaceIndex = str.length;\n    }\n\n    return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n  };\n\n  TextModel.prototype.normalizeIndentation = function (str) {\n    this._assertNotDisposed();\n\n    return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n  }; //#endregion\n  //#region Reading\n\n\n  TextModel.prototype.getVersionId = function () {\n    this._assertNotDisposed();\n\n    return this._versionId;\n  };\n\n  TextModel.prototype.mightContainRTL = function () {\n    return this._buffer.mightContainRTL();\n  };\n\n  TextModel.prototype.mightContainNonBasicASCII = function () {\n    return this._buffer.mightContainNonBasicASCII();\n  };\n\n  TextModel.prototype.getAlternativeVersionId = function () {\n    this._assertNotDisposed();\n\n    return this._alternativeVersionId;\n  };\n\n  TextModel.prototype.getOffsetAt = function (rawPosition) {\n    this._assertNotDisposed();\n\n    var position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, false);\n\n    return this._buffer.getOffsetAt(position.lineNumber, position.column);\n  };\n\n  TextModel.prototype.getPositionAt = function (rawOffset) {\n    this._assertNotDisposed();\n\n    var offset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));\n    return this._buffer.getPositionAt(offset);\n  };\n\n  TextModel.prototype._increaseVersionId = function () {\n    this._versionId = this._versionId + 1;\n    this._alternativeVersionId = this._versionId;\n  };\n\n  TextModel.prototype._overwriteAlternativeVersionId = function (newAlternativeVersionId) {\n    this._alternativeVersionId = newAlternativeVersionId;\n  };\n\n  TextModel.prototype.getValue = function (eol, preserveBOM) {\n    if (preserveBOM === void 0) {\n      preserveBOM = false;\n    }\n\n    this._assertNotDisposed();\n\n    var fullModelRange = this.getFullModelRange();\n    var fullModelValue = this.getValueInRange(fullModelRange, eol);\n\n    if (preserveBOM) {\n      return this._buffer.getBOM() + fullModelValue;\n    }\n\n    return fullModelValue;\n  };\n\n  TextModel.prototype.getValueLength = function (eol, preserveBOM) {\n    if (preserveBOM === void 0) {\n      preserveBOM = false;\n    }\n\n    this._assertNotDisposed();\n\n    var fullModelRange = this.getFullModelRange();\n    var fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n\n    if (preserveBOM) {\n      return this._buffer.getBOM().length + fullModelValue;\n    }\n\n    return fullModelValue;\n  };\n\n  TextModel.prototype.getValueInRange = function (rawRange, eol) {\n    if (eol === void 0) {\n      eol = 0\n      /* TextDefined */\n      ;\n    }\n\n    this._assertNotDisposed();\n\n    return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n  };\n\n  TextModel.prototype.getValueLengthInRange = function (rawRange, eol) {\n    if (eol === void 0) {\n      eol = 0\n      /* TextDefined */\n      ;\n    }\n\n    this._assertNotDisposed();\n\n    return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n  };\n\n  TextModel.prototype.getLineCount = function () {\n    this._assertNotDisposed();\n\n    return this._buffer.getLineCount();\n  };\n\n  TextModel.prototype.getLineContent = function (lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineContent(lineNumber);\n  };\n\n  TextModel.prototype.getLineLength = function (lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineLength(lineNumber);\n  };\n\n  TextModel.prototype.getLinesContent = function () {\n    this._assertNotDisposed();\n\n    return this._buffer.getLinesContent();\n  };\n\n  TextModel.prototype.getEOL = function () {\n    this._assertNotDisposed();\n\n    return this._buffer.getEOL();\n  };\n\n  TextModel.prototype.getLineMinColumn = function (lineNumber) {\n    this._assertNotDisposed();\n\n    return 1;\n  };\n\n  TextModel.prototype.getLineMaxColumn = function (lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineLength(lineNumber) + 1;\n  };\n\n  TextModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n  };\n\n  TextModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {\n    this._assertNotDisposed();\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n  };\n  /**\n   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n   * Will try to not allocate if possible.\n   */\n\n\n  TextModel.prototype._validateRangeRelaxedNoAllocations = function (range) {\n    var linesCount = this._buffer.getLineCount();\n\n    var initialStartLineNumber = range.startLineNumber;\n    var initialStartColumn = range.startColumn;\n    var startLineNumber;\n    var startColumn;\n\n    if (initialStartLineNumber < 1) {\n      startLineNumber = 1;\n      startColumn = 1;\n    } else if (initialStartLineNumber > linesCount) {\n      startLineNumber = linesCount;\n      startColumn = this.getLineMaxColumn(startLineNumber);\n    } else {\n      startLineNumber = initialStartLineNumber | 0;\n\n      if (initialStartColumn <= 1) {\n        startColumn = 1;\n      } else {\n        var maxColumn = this.getLineMaxColumn(startLineNumber);\n\n        if (initialStartColumn >= maxColumn) {\n          startColumn = maxColumn;\n        } else {\n          startColumn = initialStartColumn | 0;\n        }\n      }\n    }\n\n    var initialEndLineNumber = range.endLineNumber;\n    var initialEndColumn = range.endColumn;\n    var endLineNumber;\n    var endColumn;\n\n    if (initialEndLineNumber < 1) {\n      endLineNumber = 1;\n      endColumn = 1;\n    } else if (initialEndLineNumber > linesCount) {\n      endLineNumber = linesCount;\n      endColumn = this.getLineMaxColumn(endLineNumber);\n    } else {\n      endLineNumber = initialEndLineNumber | 0;\n\n      if (initialEndColumn <= 1) {\n        endColumn = 1;\n      } else {\n        var maxColumn = this.getLineMaxColumn(endLineNumber);\n\n        if (initialEndColumn >= maxColumn) {\n          endColumn = maxColumn;\n        } else {\n          endColumn = initialEndColumn | 0;\n        }\n      }\n    }\n\n    if (initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && initialEndLineNumber === endLineNumber && initialEndColumn === endColumn && range instanceof Range && !(range instanceof Selection)) {\n      return range;\n    }\n\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  };\n  /**\n   * @param strict Do NOT allow a position inside a high-low surrogate pair\n   */\n\n\n  TextModel.prototype._isValidPosition = function (lineNumber, column, strict) {\n    if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n      return false;\n    }\n\n    if (isNaN(lineNumber) || isNaN(column)) {\n      return false;\n    }\n\n    if (lineNumber < 1 || column < 1) {\n      return false;\n    }\n\n    if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n      return false;\n    }\n\n    var lineCount = this._buffer.getLineCount();\n\n    if (lineNumber > lineCount) {\n      return false;\n    }\n\n    var maxColumn = this.getLineMaxColumn(lineNumber);\n\n    if (column > maxColumn) {\n      return false;\n    }\n\n    if (strict) {\n      if (column > 1) {\n        var charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\n        if (strings.isHighSurrogate(charCodeBefore)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\n   * @param strict Do NOT allow a position inside a high-low surrogate pair\n   */\n\n\n  TextModel.prototype._validatePosition = function (_lineNumber, _column, strict) {\n    var lineNumber = Math.floor(typeof _lineNumber === 'number' && !isNaN(_lineNumber) ? _lineNumber : 1);\n    var column = Math.floor(typeof _column === 'number' && !isNaN(_column) ? _column : 1);\n\n    var lineCount = this._buffer.getLineCount();\n\n    if (lineNumber < 1) {\n      return new Position(1, 1);\n    }\n\n    if (lineNumber > lineCount) {\n      return new Position(lineCount, this.getLineMaxColumn(lineCount));\n    }\n\n    if (column <= 1) {\n      return new Position(lineNumber, 1);\n    }\n\n    var maxColumn = this.getLineMaxColumn(lineNumber);\n\n    if (column >= maxColumn) {\n      return new Position(lineNumber, maxColumn);\n    }\n\n    if (strict) {\n      // If the position would end up in the middle of a high-low surrogate pair,\n      // we move it to before the pair\n      // !!At this point, column > 1\n      var charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return new Position(lineNumber, column - 1);\n      }\n    }\n\n    return new Position(lineNumber, column);\n  };\n\n  TextModel.prototype.validatePosition = function (position) {\n    this._assertNotDisposed(); // Avoid object allocation and cover most likely case\n\n\n    if (position instanceof Position) {\n      if (this._isValidPosition(position.lineNumber, position.column, true)) {\n        return position;\n      }\n    }\n\n    return this._validatePosition(position.lineNumber, position.column, true);\n  };\n  /**\n   * @param strict Do NOT allow a range to have its boundaries inside a high-low surrogate pair\n   */\n\n\n  TextModel.prototype._isValidRange = function (range, strict) {\n    var startLineNumber = range.startLineNumber;\n    var startColumn = range.startColumn;\n    var endLineNumber = range.endLineNumber;\n    var endColumn = range.endColumn;\n\n    if (!this._isValidPosition(startLineNumber, startColumn, false)) {\n      return false;\n    }\n\n    if (!this._isValidPosition(endLineNumber, endColumn, false)) {\n      return false;\n    }\n\n    if (strict) {\n      var charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      var charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return true;\n  };\n\n  TextModel.prototype.validateRange = function (_range) {\n    this._assertNotDisposed(); // Avoid object allocation and cover most likely case\n\n\n    if (_range instanceof Range && !(_range instanceof Selection)) {\n      if (this._isValidRange(_range, true)) {\n        return _range;\n      }\n    }\n\n    var start = this._validatePosition(_range.startLineNumber, _range.startColumn, false);\n\n    var end = this._validatePosition(_range.endLineNumber, _range.endColumn, false);\n\n    var startLineNumber = start.lineNumber;\n    var startColumn = start.column;\n    var endLineNumber = end.lineNumber;\n    var endColumn = end.column;\n    var charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n    var charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n    var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n    var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n    if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n      return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n\n    if (startLineNumber === endLineNumber && startColumn === endColumn) {\n      // do not expand a collapsed range, simply move it to a valid location\n      return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n    }\n\n    if (startInsideSurrogatePair && endInsideSurrogatePair) {\n      // expand range at both ends\n      return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n    }\n\n    if (startInsideSurrogatePair) {\n      // only expand range at the start\n      return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n    } // only expand range at the end\n\n\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n  };\n\n  TextModel.prototype.modifyPosition = function (rawPosition, offset) {\n    this._assertNotDisposed();\n\n    var candidate = this.getOffsetAt(rawPosition) + offset;\n    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n  };\n\n  TextModel.prototype.getFullModelRange = function () {\n    this._assertNotDisposed();\n\n    var lineCount = this.getLineCount();\n    return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n  };\n\n  TextModel.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\n    return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  };\n\n  TextModel.prototype.findMatches = function (searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount) {\n    if (limitResultCount === void 0) {\n      limitResultCount = LIMIT_FIND_COUNT;\n    }\n\n    this._assertNotDisposed();\n\n    var searchRange;\n\n    if (Range.isIRange(rawSearchScope)) {\n      searchRange = this.validateRange(rawSearchScope);\n    } else {\n      searchRange = this.getFullModelRange();\n    }\n\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      // not regex, not multi line\n      var searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      var searchData = searchParams.parseSearchRequest();\n\n      if (!searchData) {\n        return [];\n      }\n\n      return this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n\n    return TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n  };\n\n  TextModel.prototype.findNextMatch = function (searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n\n    var searchStart = this.validatePosition(rawSearchStart);\n\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      var searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      var searchData = searchParams.parseSearchRequest();\n\n      if (!searchData) {\n        return null;\n      }\n\n      var lineCount = this.getLineCount();\n      var searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n      var ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\n      if (ret.length > 0) {\n        return ret[0];\n      }\n\n      searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n      ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n\n      if (ret.length > 0) {\n        return ret[0];\n      }\n\n      return null;\n    }\n\n    return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  };\n\n  TextModel.prototype.findPreviousMatch = function (searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n\n    var searchStart = this.validatePosition(rawSearchStart);\n    return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }; //#endregion\n  //#region Editing\n\n\n  TextModel.prototype.pushStackElement = function () {\n    this._commandManager.pushStackElement();\n  };\n\n  TextModel.prototype.pushEOL = function (eol) {\n    var currentEOL = this.getEOL() === '\\n' ? 0\n    /* LF */\n    : 1\n    /* CRLF */\n    ;\n\n    if (currentEOL === eol) {\n      return;\n    }\n\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      this._commandManager.pushEOL(eol);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  };\n\n  TextModel.prototype.pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      return this._pushEditOperations(beforeCursorState, editOperations, cursorStateComputer);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  };\n\n  TextModel.prototype._pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {\n    var _this = this;\n\n    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n      // Go through each saved line number and insert a trim whitespace edit\n      // if it is safe to do so (no conflicts with other edits).\n      var incomingEdits = editOperations.map(function (op) {\n        return {\n          range: _this.validateRange(op.range),\n          text: op.text\n        };\n      }); // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n      // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n\n      var editsAreNearCursors = true;\n\n      for (var i = 0, len = beforeCursorState.length; i < len; i++) {\n        var sel = beforeCursorState[i];\n        var foundEditNearSel = false;\n\n        for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n          var editRange = incomingEdits[j].range;\n          var selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n          var selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n\n          if (!selIsAbove && !selIsBelow) {\n            foundEditNearSel = true;\n            break;\n          }\n        }\n\n        if (!foundEditNearSel) {\n          editsAreNearCursors = false;\n          break;\n        }\n      }\n\n      if (editsAreNearCursors) {\n        for (var i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n          var trimLineNumber = this._trimAutoWhitespaceLines[i];\n          var maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n          var allowTrimLine = true;\n\n          for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            var editRange = incomingEdits[j].range;\n            var editText = incomingEdits[j].text;\n\n            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n              // `trimLine` is completely outside this edit\n              continue;\n            } // At this point:\n            //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n\n\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n              // This edit inserts a new line (and maybe other text) after `trimLine`\n              continue;\n            }\n\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1 && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n              // This edit inserts a new line (and maybe other text) before `trimLine`\n              continue;\n            } // Looks like we can't trim this line as it would interfere with an incoming edit\n\n\n            allowTrimLine = false;\n            break;\n          }\n\n          if (allowTrimLine) {\n            editOperations.push({\n              range: new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn),\n              text: null\n            });\n          }\n        }\n      }\n\n      this._trimAutoWhitespaceLines = null;\n    }\n\n    return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n  };\n\n  TextModel.prototype.applyEdits = function (rawOperations) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      return this._applyEdits(rawOperations);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  };\n\n  TextModel.prototype._applyEdits = function (rawOperations) {\n    for (var i = 0, len = rawOperations.length; i < len; i++) {\n      rawOperations[i].range = this.validateRange(rawOperations[i].range);\n    }\n\n    var oldLineCount = this._buffer.getLineCount();\n\n    var result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace);\n\n    var newLineCount = this._buffer.getLineCount();\n\n    var contentChanges = result.changes;\n    this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n\n    if (contentChanges.length !== 0) {\n      var rawContentChanges = [];\n      var lineCount = oldLineCount;\n\n      for (var i = 0, len = contentChanges.length; i < len; i++) {\n        var change = contentChanges[i];\n\n        var _a = countEOL(change.text),\n            eolCount = _a[0],\n            firstLineLength = _a[1];\n\n        this._tokens.acceptEdit(change.range, eolCount, firstLineLength);\n\n        this._onDidChangeDecorations.fire();\n\n        this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n\n        var startLineNumber = change.range.startLineNumber;\n        var endLineNumber = change.range.endLineNumber;\n        var deletingLinesCnt = endLineNumber - startLineNumber;\n        var insertingLinesCnt = eolCount;\n        var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n        var changeLineCountDelta = insertingLinesCnt - deletingLinesCnt;\n\n        for (var j = editingLinesCnt; j >= 0; j--) {\n          var editLineNumber = startLineNumber + j;\n          var currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;\n          rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));\n        }\n\n        if (editingLinesCnt < deletingLinesCnt) {\n          // Must delete some lines\n          var spliceStartLineNumber = startLineNumber + editingLinesCnt;\n          rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n        }\n\n        if (editingLinesCnt < insertingLinesCnt) {\n          // Must insert some lines\n          var spliceLineNumber = startLineNumber + editingLinesCnt;\n          var cnt = insertingLinesCnt - editingLinesCnt;\n          var fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n          var newLines = [];\n\n          for (var i_1 = 0; i_1 < cnt; i_1++) {\n            var lineNumber = fromLineNumber + i_1;\n            newLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);\n          }\n\n          rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));\n        }\n\n        lineCount += changeLineCountDelta;\n      }\n\n      this._increaseVersionId();\n\n      this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n        changes: contentChanges,\n        eol: this._buffer.getEOL(),\n        versionId: this.getVersionId(),\n        isUndoing: this._isUndoing,\n        isRedoing: this._isRedoing,\n        isFlush: false\n      });\n    }\n\n    return result.reverseEdits;\n  };\n\n  TextModel.prototype._undo = function () {\n    this._isUndoing = true;\n\n    var r = this._commandManager.undo();\n\n    this._isUndoing = false;\n\n    if (!r) {\n      return null;\n    }\n\n    this._overwriteAlternativeVersionId(r.recordedVersionId);\n\n    return r.selections;\n  };\n\n  TextModel.prototype.undo = function () {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      return this._undo();\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  };\n\n  TextModel.prototype.canUndo = function () {\n    return this._commandManager.canUndo();\n  };\n\n  TextModel.prototype._redo = function () {\n    this._isRedoing = true;\n\n    var r = this._commandManager.redo();\n\n    this._isRedoing = false;\n\n    if (!r) {\n      return null;\n    }\n\n    this._overwriteAlternativeVersionId(r.recordedVersionId);\n\n    return r.selections;\n  };\n\n  TextModel.prototype.redo = function () {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._eventEmitter.beginDeferredEmit();\n\n      return this._redo();\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  };\n\n  TextModel.prototype.canRedo = function () {\n    return this._commandManager.canRedo();\n  }; //#endregion\n  //#region Decorations\n\n\n  TextModel.prototype.changeDecorations = function (callback, ownerId) {\n    if (ownerId === void 0) {\n      ownerId = 0;\n    }\n\n    this._assertNotDisposed();\n\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      return this._changeDecorations(ownerId, callback);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  };\n\n  TextModel.prototype._changeDecorations = function (ownerId, callback) {\n    var _this = this;\n\n    var changeAccessor = {\n      addDecoration: function (range, options) {\n        _this._onDidChangeDecorations.fire();\n\n        return _this._deltaDecorationsImpl(ownerId, [], [{\n          range: range,\n          options: options\n        }])[0];\n      },\n      changeDecoration: function (id, newRange) {\n        _this._onDidChangeDecorations.fire();\n\n        _this._changeDecorationImpl(id, newRange);\n      },\n      changeDecorationOptions: function (id, options) {\n        _this._onDidChangeDecorations.fire();\n\n        _this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n      },\n      removeDecoration: function (id) {\n        _this._onDidChangeDecorations.fire();\n\n        _this._deltaDecorationsImpl(ownerId, [id], []);\n      },\n      deltaDecorations: function (oldDecorations, newDecorations) {\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n          // nothing to do\n          return [];\n        }\n\n        _this._onDidChangeDecorations.fire();\n\n        return _this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n      }\n    };\n    var result = null;\n\n    try {\n      result = callback(changeAccessor);\n    } catch (e) {\n      onUnexpectedError(e);\n    } // Invalidate change accessor\n\n\n    changeAccessor.addDecoration = invalidFunc;\n    changeAccessor.changeDecoration = invalidFunc;\n    changeAccessor.changeDecorationOptions = invalidFunc;\n    changeAccessor.removeDecoration = invalidFunc;\n    changeAccessor.deltaDecorations = invalidFunc;\n    return result;\n  };\n\n  TextModel.prototype.deltaDecorations = function (oldDecorations, newDecorations, ownerId) {\n    if (ownerId === void 0) {\n      ownerId = 0;\n    }\n\n    this._assertNotDisposed();\n\n    if (!oldDecorations) {\n      oldDecorations = [];\n    }\n\n    if (oldDecorations.length === 0 && newDecorations.length === 0) {\n      // nothing to do\n      return [];\n    }\n\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n\n      this._onDidChangeDecorations.fire();\n\n      return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  };\n\n  TextModel.prototype._getTrackedRange = function (id) {\n    return this.getDecorationRange(id);\n  };\n\n  TextModel.prototype._setTrackedRange = function (id, newRange, newStickiness) {\n    var node = id ? this._decorations[id] : null;\n\n    if (!node) {\n      if (!newRange) {\n        // node doesn't exist, the request is to delete => nothing to do\n        return null;\n      } // node doesn't exist, the request is to set => add the tracked range\n\n\n      return this._deltaDecorationsImpl(0, [], [{\n        range: newRange,\n        options: TRACKED_RANGE_OPTIONS[newStickiness]\n      }])[0];\n    }\n\n    if (!newRange) {\n      // node exists, the request is to delete => delete node\n      this._decorationsTree.delete(node);\n\n      delete this._decorations[node.id];\n      return null;\n    } // node exists, the request is to set => change the tracked range and its options\n\n\n    var range = this._validateRangeRelaxedNoAllocations(newRange);\n\n    var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n    var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n    this._decorationsTree.delete(node);\n\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n\n    this._decorationsTree.insert(node);\n\n    return node.id;\n  };\n\n  TextModel.prototype.removeAllDecorationsWithOwnerId = function (ownerId) {\n    if (this._isDisposed) {\n      return;\n    }\n\n    var nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      var node = nodes[i];\n\n      this._decorationsTree.delete(node);\n\n      delete this._decorations[node.id];\n    }\n  };\n\n  TextModel.prototype.getDecorationOptions = function (decorationId) {\n    var node = this._decorations[decorationId];\n\n    if (!node) {\n      return null;\n    }\n\n    return node.options;\n  };\n\n  TextModel.prototype.getDecorationRange = function (decorationId) {\n    var node = this._decorations[decorationId];\n\n    if (!node) {\n      return null;\n    }\n\n    var versionId = this.getVersionId();\n\n    if (node.cachedVersionId !== versionId) {\n      this._decorationsTree.resolveNode(node, versionId);\n    }\n\n    if (node.range === null) {\n      node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n    }\n\n    return node.range;\n  };\n\n  TextModel.prototype.getLineDecorations = function (lineNumber, ownerId, filterOutValidation) {\n    if (ownerId === void 0) {\n      ownerId = 0;\n    }\n\n    if (filterOutValidation === void 0) {\n      filterOutValidation = false;\n    }\n\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      return [];\n    }\n\n    return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n  };\n\n  TextModel.prototype.getLinesDecorations = function (_startLineNumber, _endLineNumber, ownerId, filterOutValidation) {\n    if (ownerId === void 0) {\n      ownerId = 0;\n    }\n\n    if (filterOutValidation === void 0) {\n      filterOutValidation = false;\n    }\n\n    var lineCount = this.getLineCount();\n    var startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n    var endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n    var endColumn = this.getLineMaxColumn(endLineNumber);\n    return this._getDecorationsInRange(new Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);\n  };\n\n  TextModel.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {\n    if (ownerId === void 0) {\n      ownerId = 0;\n    }\n\n    if (filterOutValidation === void 0) {\n      filterOutValidation = false;\n    }\n\n    var validatedRange = this.validateRange(range);\n    return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n  };\n\n  TextModel.prototype.getOverviewRulerDecorations = function (ownerId, filterOutValidation) {\n    if (ownerId === void 0) {\n      ownerId = 0;\n    }\n\n    if (filterOutValidation === void 0) {\n      filterOutValidation = false;\n    }\n\n    var versionId = this.getVersionId();\n\n    var result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);\n\n    return this._ensureNodesHaveRanges(result);\n  };\n\n  TextModel.prototype.getAllDecorations = function (ownerId, filterOutValidation) {\n    if (ownerId === void 0) {\n      ownerId = 0;\n    }\n\n    if (filterOutValidation === void 0) {\n      filterOutValidation = false;\n    }\n\n    var versionId = this.getVersionId();\n\n    var result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);\n\n    return this._ensureNodesHaveRanges(result);\n  };\n\n  TextModel.prototype._getDecorationsInRange = function (filterRange, filterOwnerId, filterOutValidation) {\n    var startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n\n    var endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n\n    var versionId = this.getVersionId();\n\n    var result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);\n\n    return this._ensureNodesHaveRanges(result);\n  };\n\n  TextModel.prototype._ensureNodesHaveRanges = function (nodes) {\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      var node = nodes[i];\n\n      if (node.range === null) {\n        node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n      }\n    }\n\n    return nodes;\n  };\n\n  TextModel.prototype._getRangeAt = function (start, end) {\n    return this._buffer.getRangeAt(start, end - start);\n  };\n\n  TextModel.prototype._changeDecorationImpl = function (decorationId, _range) {\n    var node = this._decorations[decorationId];\n\n    if (!node) {\n      return;\n    }\n\n    var range = this._validateRangeRelaxedNoAllocations(_range);\n\n    var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n    var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n    this._decorationsTree.delete(node);\n\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n\n    this._decorationsTree.insert(node);\n  };\n\n  TextModel.prototype._changeDecorationOptionsImpl = function (decorationId, options) {\n    var node = this._decorations[decorationId];\n\n    if (!node) {\n      return;\n    }\n\n    var nodeWasInOverviewRuler = node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n    var nodeIsInOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n\n    if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n      // Delete + Insert due to an overview ruler status change\n      this._decorationsTree.delete(node);\n\n      node.setOptions(options);\n\n      this._decorationsTree.insert(node);\n    } else {\n      node.setOptions(options);\n    }\n  };\n\n  TextModel.prototype._deltaDecorationsImpl = function (ownerId, oldDecorationsIds, newDecorations) {\n    var versionId = this.getVersionId();\n    var oldDecorationsLen = oldDecorationsIds.length;\n    var oldDecorationIndex = 0;\n    var newDecorationsLen = newDecorations.length;\n    var newDecorationIndex = 0;\n    var result = new Array(newDecorationsLen);\n\n    while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n      var node = null;\n\n      if (oldDecorationIndex < oldDecorationsLen) {\n        // (1) get ourselves an old node\n        do {\n          node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n        } while (!node && oldDecorationIndex < oldDecorationsLen); // (2) remove the node from the tree (if it exists)\n\n\n        if (node) {\n          this._decorationsTree.delete(node);\n        }\n      }\n\n      if (newDecorationIndex < newDecorationsLen) {\n        // (3) create a new node if necessary\n        if (!node) {\n          var internalDecorationId = ++this._lastDecorationId;\n          var decorationId = this._instanceId + \";\" + internalDecorationId;\n          node = new IntervalNode(decorationId, 0, 0);\n          this._decorations[decorationId] = node;\n        } // (4) initialize node\n\n\n        var newDecoration = newDecorations[newDecorationIndex];\n\n        var range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n\n        var options = _normalizeOptions(newDecoration.options);\n\n        var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n        var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n        node.ownerId = ownerId;\n        node.reset(versionId, startOffset, endOffset, range);\n        node.setOptions(options);\n\n        this._decorationsTree.insert(node);\n\n        result[newDecorationIndex] = node.id;\n        newDecorationIndex++;\n      } else {\n        if (node) {\n          delete this._decorations[node.id];\n        }\n      }\n    }\n\n    return result;\n  }; //#endregion\n  //#region Tokenization\n\n\n  TextModel.prototype.setLineTokens = function (lineNumber, tokens) {\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), tokens);\n  };\n\n  TextModel.prototype.setTokens = function (tokens) {\n    if (tokens.length === 0) {\n      return;\n    }\n\n    var ranges = [];\n\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      var element = tokens[i];\n      ranges.push({\n        fromLineNumber: element.startLineNumber,\n        toLineNumber: element.startLineNumber + element.tokens.length - 1\n      });\n\n      for (var j = 0, lenJ = element.tokens.length; j < lenJ; j++) {\n        this.setLineTokens(element.startLineNumber + j, element.tokens[j]);\n      }\n    }\n\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: false,\n      ranges: ranges\n    });\n  };\n\n  TextModel.prototype.tokenizeViewport = function (startLineNumber, endLineNumber) {\n    startLineNumber = Math.max(1, startLineNumber);\n    endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);\n\n    this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\n  };\n\n  TextModel.prototype.clearTokens = function () {\n    this._tokens.flush();\n\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: true,\n      ranges: [{\n        fromLineNumber: 1,\n        toLineNumber: this._buffer.getLineCount()\n      }]\n    });\n  };\n\n  TextModel.prototype._emitModelTokensChangedEvent = function (e) {\n    if (!this._isDisposing) {\n      this._onDidChangeTokens.fire(e);\n    }\n  };\n\n  TextModel.prototype.resetTokenization = function () {\n    this._tokenization.reset();\n  };\n\n  TextModel.prototype.forceTokenization = function (lineNumber) {\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    this._tokenization.forceTokenization(lineNumber);\n  };\n\n  TextModel.prototype.isCheapToTokenize = function (lineNumber) {\n    return this._tokenization.isCheapToTokenize(lineNumber);\n  };\n\n  TextModel.prototype.tokenizeIfCheap = function (lineNumber) {\n    if (this.isCheapToTokenize(lineNumber)) {\n      this.forceTokenization(lineNumber);\n    }\n  };\n\n  TextModel.prototype.getLineTokens = function (lineNumber) {\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    return this._getLineTokens(lineNumber);\n  };\n\n  TextModel.prototype._getLineTokens = function (lineNumber) {\n    var lineText = this.getLineContent(lineNumber);\n    return this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);\n  };\n\n  TextModel.prototype.getLanguageIdentifier = function () {\n    return this._languageIdentifier;\n  };\n\n  TextModel.prototype.getModeId = function () {\n    return this._languageIdentifier.language;\n  };\n\n  TextModel.prototype.setMode = function (languageIdentifier) {\n    if (this._languageIdentifier.id === languageIdentifier.id) {\n      // There's nothing to do\n      return;\n    }\n\n    var e = {\n      oldLanguage: this._languageIdentifier.language,\n      newLanguage: languageIdentifier.language\n    };\n    this._languageIdentifier = languageIdentifier;\n\n    this._onDidChangeLanguage.fire(e);\n\n    this._onDidChangeLanguageConfiguration.fire({});\n  };\n\n  TextModel.prototype.getLanguageIdAtPosition = function (lineNumber, column) {\n    var position = this.validatePosition(new Position(lineNumber, column));\n    var lineTokens = this.getLineTokens(position.lineNumber);\n    return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n  }; // Having tokens allows implementing additional helper methods\n\n\n  TextModel.prototype.getWordAtPosition = function (_position) {\n    this._assertNotDisposed();\n\n    var position = this.validatePosition(_position);\n    var lineContent = this.getLineContent(position.lineNumber);\n\n    var lineTokens = this._getLineTokens(position.lineNumber);\n\n    var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1); // (1). First try checking right biased word\n\n    var _a = TextModel._findLanguageBoundaries(lineTokens, tokenIndex),\n        rbStartOffset = _a[0],\n        rbEndOffset = _a[1];\n\n    var rightBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset); // Make sure the result touches the original passed in position\n\n    if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n      return rightBiasedWord;\n    } // (2). Else, if we were at a language boundary, check the left biased word\n\n\n    if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n      // edge case, where `position` sits between two tokens belonging to two different languages\n      var _b = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1),\n          lbStartOffset = _b[0],\n          lbEndOffset = _b[1];\n\n      var leftBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset); // Make sure the result touches the original passed in position\n\n      if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n        return leftBiasedWord;\n      }\n    }\n\n    return null;\n  };\n\n  TextModel._findLanguageBoundaries = function (lineTokens, tokenIndex) {\n    var languageId = lineTokens.getLanguageId(tokenIndex); // go left until a different language is hit\n\n    var startOffset = 0;\n\n    for (var i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n      startOffset = lineTokens.getStartOffset(i);\n    } // go right until a different language is hit\n\n\n    var endOffset = lineTokens.getLineContent().length;\n\n    for (var i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n      endOffset = lineTokens.getEndOffset(i);\n    }\n\n    return [startOffset, endOffset];\n  };\n\n  TextModel.prototype.getWordUntilPosition = function (position) {\n    var wordAtPosition = this.getWordAtPosition(position);\n\n    if (!wordAtPosition) {\n      return {\n        word: '',\n        startColumn: position.column,\n        endColumn: position.column\n      };\n    }\n\n    return {\n      word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n      startColumn: wordAtPosition.startColumn,\n      endColumn: position.column\n    };\n  };\n\n  TextModel.prototype.findMatchingBracketUp = function (_bracket, _position) {\n    var bracket = _bracket.toLowerCase();\n\n    var position = this.validatePosition(_position);\n\n    var lineTokens = this._getLineTokens(position.lineNumber);\n\n    var languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    var bracketsSupport = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n\n    if (!bracketsSupport) {\n      return null;\n    }\n\n    var data = bracketsSupport.textIsBracket[bracket];\n\n    if (!data) {\n      return null;\n    }\n\n    return this._findMatchingBracketUp(data, position);\n  };\n\n  TextModel.prototype.matchBracket = function (position) {\n    return this._matchBracket(this.validatePosition(position));\n  };\n\n  TextModel.prototype._matchBracket = function (position) {\n    var lineNumber = position.lineNumber;\n\n    var lineTokens = this._getLineTokens(lineNumber);\n\n    var lineText = this._buffer.getLineContent(lineNumber);\n\n    var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\n    if (tokenIndex < 0) {\n      return null;\n    }\n\n    var currentModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex)); // check that the token is not to be ignored\n\n    if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n      // limit search to not go before `maxBracketLength`\n      var searchStartOffset = Math.max(lineTokens.getStartOffset(tokenIndex), position.column - 1 - currentModeBrackets.maxBracketLength); // limit search to not go after `maxBracketLength`\n\n      var searchEndOffset = Math.min(lineTokens.getEndOffset(tokenIndex), position.column - 1 + currentModeBrackets.maxBracketLength); // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n      // `bestResult` will contain the most right-side result\n\n      var bestResult = null;\n\n      while (true) {\n        var foundBracket = BracketsUtils.findNextBracketInToken(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n        if (!foundBracket) {\n          // there are no more brackets in this text\n          break;\n        } // check that we didn't hit a bracket too far away from position\n\n\n        if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n          var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);\n          foundBracketText = foundBracketText.toLowerCase();\n\n          var r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]); // check that we can actually match this bracket\n\n\n          if (r) {\n            bestResult = r;\n          }\n        }\n\n        searchStartOffset = foundBracket.endColumn - 1;\n      }\n\n      if (bestResult) {\n        return bestResult;\n      }\n    } // If position is in between two tokens, try also looking in the previous token\n\n\n    if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n      var searchEndOffset = lineTokens.getStartOffset(tokenIndex);\n      tokenIndex--;\n      var prevModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex)); // check that previous token is not to be ignored\n\n      if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n        // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`\n        var searchStartOffset = Math.max(lineTokens.getStartOffset(tokenIndex), position.column - 1 - prevModeBrackets.maxBracketLength);\n        var foundBracket = BracketsUtils.findPrevBracketInToken(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset); // check that we didn't hit a bracket too far away from position\n\n        if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n          var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);\n          foundBracketText = foundBracketText.toLowerCase();\n\n          var r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText]); // check that we can actually match this bracket\n\n\n          if (r) {\n            return r;\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  TextModel.prototype._matchFoundBracket = function (foundBracket, data, isOpen) {\n    if (!data) {\n      return null;\n    }\n\n    if (isOpen) {\n      var matched = this._findMatchingBracketDown(data, foundBracket.getEndPosition());\n\n      if (matched) {\n        return [foundBracket, matched];\n      }\n    } else {\n      var matched = this._findMatchingBracketUp(data, foundBracket.getStartPosition());\n\n      if (matched) {\n        return [foundBracket, matched];\n      }\n    }\n\n    return null;\n  };\n\n  TextModel.prototype._findMatchingBracketUp = function (bracket, position) {\n    // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n    var languageId = bracket.languageIdentifier.id;\n    var reversedBracketRegex = bracket.reversedRegex;\n    var count = -1;\n\n    for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n      var lineTokens = this._getLineTokens(lineNumber);\n\n      var tokenCount = lineTokens.getCount();\n\n      var lineText = this._buffer.getLineContent(lineNumber);\n\n      var tokenIndex = tokenCount - 1;\n      var searchStopOffset = -1;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStopOffset = position.column - 1;\n      }\n\n      for (; tokenIndex >= 0; tokenIndex--) {\n        var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        var tokenType = lineTokens.getStandardTokenType(tokenIndex);\n        var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n        var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n\n        if (searchStopOffset === -1) {\n          searchStopOffset = tokenEndOffset;\n        }\n\n        if (tokenLanguageId === languageId && !ignoreBracketsInToken(tokenType)) {\n          while (true) {\n            var r = BracketsUtils.findPrevBracketInToken(reversedBracketRegex, lineNumber, lineText, tokenStartOffset, searchStopOffset);\n\n            if (!r) {\n              break;\n            }\n\n            var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);\n            hitText = hitText.toLowerCase();\n\n            if (hitText === bracket.open) {\n              count++;\n            } else if (hitText === bracket.close) {\n              count--;\n            }\n\n            if (count === 0) {\n              return r;\n            }\n\n            searchStopOffset = r.startColumn - 1;\n          }\n        }\n\n        searchStopOffset = -1;\n      }\n    }\n\n    return null;\n  };\n\n  TextModel.prototype._findMatchingBracketDown = function (bracket, position) {\n    // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n    var languageId = bracket.languageIdentifier.id;\n    var bracketRegex = bracket.forwardRegex;\n    var count = 1;\n\n    for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n      var lineTokens = this._getLineTokens(lineNumber);\n\n      var tokenCount = lineTokens.getCount();\n\n      var lineText = this._buffer.getLineContent(lineNumber);\n\n      var tokenIndex = 0;\n      var searchStartOffset = 0;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n      }\n\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        var tokenType = lineTokens.getStandardTokenType(tokenIndex);\n        var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n        var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n\n        if (searchStartOffset === 0) {\n          searchStartOffset = tokenStartOffset;\n        }\n\n        if (tokenLanguageId === languageId && !ignoreBracketsInToken(tokenType)) {\n          while (true) {\n            var r = BracketsUtils.findNextBracketInToken(bracketRegex, lineNumber, lineText, searchStartOffset, tokenEndOffset);\n\n            if (!r) {\n              break;\n            }\n\n            var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);\n            hitText = hitText.toLowerCase();\n\n            if (hitText === bracket.open) {\n              count++;\n            } else if (hitText === bracket.close) {\n              count--;\n            }\n\n            if (count === 0) {\n              return r;\n            }\n\n            searchStartOffset = r.endColumn - 1;\n          }\n        }\n\n        searchStartOffset = 0;\n      }\n    }\n\n    return null;\n  };\n\n  TextModel.prototype.findPrevBracket = function (_position) {\n    var position = this.validatePosition(_position);\n    var languageId = -1;\n    var modeBrackets = null;\n\n    for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n      var lineTokens = this._getLineTokens(lineNumber);\n\n      var tokenCount = lineTokens.getCount();\n\n      var lineText = this._buffer.getLineContent(lineNumber);\n\n      var tokenIndex = tokenCount - 1;\n      var searchStopOffset = -1;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStopOffset = position.column - 1;\n      }\n\n      for (; tokenIndex >= 0; tokenIndex--) {\n        var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        var tokenType = lineTokens.getStandardTokenType(tokenIndex);\n        var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n        var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n\n        if (searchStopOffset === -1) {\n          searchStopOffset = tokenEndOffset;\n        }\n\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n        }\n\n        if (modeBrackets && !ignoreBracketsInToken(tokenType)) {\n          var r = BracketsUtils.findPrevBracketInToken(modeBrackets.reversedRegex, lineNumber, lineText, tokenStartOffset, searchStopOffset);\n\n          if (r) {\n            return this._toFoundBracket(modeBrackets, r);\n          }\n        }\n\n        searchStopOffset = -1;\n      }\n    }\n\n    return null;\n  };\n\n  TextModel.prototype.findNextBracket = function (_position) {\n    var position = this.validatePosition(_position);\n    var languageId = -1;\n    var modeBrackets = null;\n\n    for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n      var lineTokens = this._getLineTokens(lineNumber);\n\n      var tokenCount = lineTokens.getCount();\n\n      var lineText = this._buffer.getLineContent(lineNumber);\n\n      var tokenIndex = 0;\n      var searchStartOffset = 0;\n\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n      }\n\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        var tokenType = lineTokens.getStandardTokenType(tokenIndex);\n        var tokenStartOffset = lineTokens.getStartOffset(tokenIndex);\n        var tokenEndOffset = lineTokens.getEndOffset(tokenIndex);\n\n        if (searchStartOffset === 0) {\n          searchStartOffset = tokenStartOffset;\n        }\n\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n        }\n\n        if (modeBrackets && !ignoreBracketsInToken(tokenType)) {\n          var r = BracketsUtils.findNextBracketInToken(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, tokenEndOffset);\n\n          if (r) {\n            return this._toFoundBracket(modeBrackets, r);\n          }\n        }\n\n        searchStartOffset = 0;\n      }\n    }\n\n    return null;\n  };\n\n  TextModel.prototype._toFoundBracket = function (modeBrackets, r) {\n    if (!r) {\n      return null;\n    }\n\n    var text = this.getValueInRange(r);\n    text = text.toLowerCase();\n    var data = modeBrackets.textIsBracket[text];\n\n    if (!data) {\n      return null;\n    }\n\n    return {\n      range: r,\n      open: data.open,\n      close: data.close,\n      isOpen: modeBrackets.textIsOpenBracket[text]\n    };\n  };\n  /**\n   * Returns:\n   *  - -1 => the line consists of whitespace\n   *  - otherwise => the indent level is returned value\n   */\n\n\n  TextModel.computeIndentLevel = function (line, tabSize) {\n    var indent = 0;\n    var i = 0;\n    var len = line.length;\n\n    while (i < len) {\n      var chCode = line.charCodeAt(i);\n\n      if (chCode === 32\n      /* Space */\n      ) {\n          indent++;\n        } else if (chCode === 9\n      /* Tab */\n      ) {\n          indent = indent - indent % tabSize + tabSize;\n        } else {\n        break;\n      }\n\n      i++;\n    }\n\n    if (i === len) {\n      return -1; // line only consists of whitespace\n    }\n\n    return indent;\n  };\n\n  TextModel.prototype._computeIndentLevel = function (lineIndex) {\n    return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);\n  };\n\n  TextModel.prototype.getActiveIndentGuide = function (lineNumber, minLineNumber, maxLineNumber) {\n    var _this = this;\n\n    this._assertNotDisposed();\n\n    var lineCount = this.getLineCount();\n\n    if (lineNumber < 1 || lineNumber > lineCount) {\n      throw new Error('Illegal value for lineNumber');\n    }\n\n    var foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n    var offSide = Boolean(foldingRules && foldingRules.offSide);\n    var up_aboveContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    var up_aboveContentLineIndent = -1;\n    var up_belowContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    var up_belowContentLineIndent = -1;\n\n    var up_resolveIndents = function (lineNumber) {\n      if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\n        up_aboveContentLineIndex = -1;\n        up_aboveContentLineIndent = -1; // must find previous line with content\n\n        for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          var indent_1 = _this._computeIndentLevel(lineIndex);\n\n          if (indent_1 >= 0) {\n            up_aboveContentLineIndex = lineIndex;\n            up_aboveContentLineIndent = indent_1;\n            break;\n          }\n        }\n      }\n\n      if (up_belowContentLineIndex === -2) {\n        up_belowContentLineIndex = -1;\n        up_belowContentLineIndent = -1; // must find next line with content\n\n        for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          var indent_2 = _this._computeIndentLevel(lineIndex);\n\n          if (indent_2 >= 0) {\n            up_belowContentLineIndex = lineIndex;\n            up_belowContentLineIndent = indent_2;\n            break;\n          }\n        }\n      }\n    };\n\n    var down_aboveContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    var down_aboveContentLineIndent = -1;\n    var down_belowContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    var down_belowContentLineIndent = -1;\n\n    var down_resolveIndents = function (lineNumber) {\n      if (down_aboveContentLineIndex === -2) {\n        down_aboveContentLineIndex = -1;\n        down_aboveContentLineIndent = -1; // must find previous line with content\n\n        for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          var indent_3 = _this._computeIndentLevel(lineIndex);\n\n          if (indent_3 >= 0) {\n            down_aboveContentLineIndex = lineIndex;\n            down_aboveContentLineIndent = indent_3;\n            break;\n          }\n        }\n      }\n\n      if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\n        down_belowContentLineIndex = -1;\n        down_belowContentLineIndent = -1; // must find next line with content\n\n        for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          var indent_4 = _this._computeIndentLevel(lineIndex);\n\n          if (indent_4 >= 0) {\n            down_belowContentLineIndex = lineIndex;\n            down_belowContentLineIndent = indent_4;\n            break;\n          }\n        }\n      }\n    };\n\n    var startLineNumber = 0;\n    var goUp = true;\n    var endLineNumber = 0;\n    var goDown = true;\n    var indent = 0;\n\n    for (var distance = 0; goUp || goDown; distance++) {\n      var upLineNumber = lineNumber - distance;\n      var downLineNumber = lineNumber + distance;\n\n      if (distance !== 0 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n        goUp = false;\n      }\n\n      if (distance !== 0 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n        goDown = false;\n      }\n\n      if (distance > 50000) {\n        // stop processing\n        goUp = false;\n        goDown = false;\n      }\n\n      if (goUp) {\n        // compute indent level going up\n        var upLineIndentLevel = void 0;\n\n        var currentIndent = this._computeIndentLevel(upLineNumber - 1);\n\n        if (currentIndent >= 0) {\n          // This line has content (besides whitespace)\n          // Use the line's indent\n          up_belowContentLineIndex = upLineNumber - 1;\n          up_belowContentLineIndent = currentIndent;\n          upLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n        } else {\n          up_resolveIndents(upLineNumber);\n          upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n        }\n\n        if (distance === 0) {\n          // This is the initial line number\n          startLineNumber = upLineNumber;\n          endLineNumber = downLineNumber;\n          indent = upLineIndentLevel;\n\n          if (indent === 0) {\n            // No need to continue\n            return {\n              startLineNumber: startLineNumber,\n              endLineNumber: endLineNumber,\n              indent: indent\n            };\n          }\n\n          continue;\n        }\n\n        if (upLineIndentLevel >= indent) {\n          startLineNumber = upLineNumber;\n        } else {\n          goUp = false;\n        }\n      }\n\n      if (goDown) {\n        // compute indent level going down\n        var downLineIndentLevel = void 0;\n\n        var currentIndent = this._computeIndentLevel(downLineNumber - 1);\n\n        if (currentIndent >= 0) {\n          // This line has content (besides whitespace)\n          // Use the line's indent\n          down_aboveContentLineIndex = downLineNumber - 1;\n          down_aboveContentLineIndent = currentIndent;\n          downLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n        } else {\n          down_resolveIndents(downLineNumber);\n          downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n        }\n\n        if (downLineIndentLevel >= indent) {\n          endLineNumber = downLineNumber;\n        } else {\n          goDown = false;\n        }\n      }\n    }\n\n    return {\n      startLineNumber: startLineNumber,\n      endLineNumber: endLineNumber,\n      indent: indent\n    };\n  };\n\n  TextModel.prototype.getLinesIndentGuides = function (startLineNumber, endLineNumber) {\n    this._assertNotDisposed();\n\n    var lineCount = this.getLineCount();\n\n    if (startLineNumber < 1 || startLineNumber > lineCount) {\n      throw new Error('Illegal value for startLineNumber');\n    }\n\n    if (endLineNumber < 1 || endLineNumber > lineCount) {\n      throw new Error('Illegal value for endLineNumber');\n    }\n\n    var foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n    var offSide = Boolean(foldingRules && foldingRules.offSide);\n    var result = new Array(endLineNumber - startLineNumber + 1);\n    var aboveContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    var aboveContentLineIndent = -1;\n    var belowContentLineIndex = -2;\n    /* -2 is a marker for not having computed it */\n\n    var belowContentLineIndent = -1;\n\n    for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      var resultIndex = lineNumber - startLineNumber;\n\n      var currentIndent = this._computeIndentLevel(lineNumber - 1);\n\n      if (currentIndent >= 0) {\n        // This line has content (besides whitespace)\n        // Use the line's indent\n        aboveContentLineIndex = lineNumber - 1;\n        aboveContentLineIndent = currentIndent;\n        result[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);\n        continue;\n      }\n\n      if (aboveContentLineIndex === -2) {\n        aboveContentLineIndex = -1;\n        aboveContentLineIndent = -1; // must find previous line with content\n\n        for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          var indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            aboveContentLineIndex = lineIndex;\n            aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n\n      if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n        belowContentLineIndex = -1;\n        belowContentLineIndent = -1; // must find next line with content\n\n        for (var lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          var indent = this._computeIndentLevel(lineIndex);\n\n          if (indent >= 0) {\n            belowContentLineIndex = lineIndex;\n            belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n\n      result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n    }\n\n    return result;\n  };\n\n  TextModel.prototype._getIndentLevelForWhitespaceLine = function (offSide, aboveContentLineIndent, belowContentLineIndent) {\n    if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n      // At the top or bottom of the file\n      return 0;\n    } else if (aboveContentLineIndent < belowContentLineIndent) {\n      // we are inside the region above\n      return 1 + Math.floor(aboveContentLineIndent / this._options.indentSize);\n    } else if (aboveContentLineIndent === belowContentLineIndent) {\n      // we are in between two regions\n      return Math.ceil(belowContentLineIndent / this._options.indentSize);\n    } else {\n      if (offSide) {\n        // same level as region below\n        return Math.ceil(belowContentLineIndent / this._options.indentSize);\n      } else {\n        // we are inside the region that ends below\n        return 1 + Math.floor(belowContentLineIndent / this._options.indentSize);\n      }\n    }\n  };\n\n  TextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\n\n  TextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\n\n  TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\n\n  TextModel.DEFAULT_CREATION_OPTIONS = {\n    isForSimpleWidget: false,\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n    detectIndentation: false,\n    defaultEOL: 1\n    /* LF */\n    ,\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations\n  };\n  return TextModel;\n}(Disposable);\n\nexport { TextModel }; //#region Decorations\n\nvar DecorationsTrees =\n/** @class */\nfunction () {\n  function DecorationsTrees() {\n    this._decorationsTree0 = new IntervalTree();\n    this._decorationsTree1 = new IntervalTree();\n  }\n\n  DecorationsTrees.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n    var r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\n    var r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\n    return r0.concat(r1);\n  };\n\n  DecorationsTrees.prototype.search = function (filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n    if (overviewRulerOnly) {\n      return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n    } else {\n      var r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\n      var r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\n      return r0.concat(r1);\n    }\n  };\n\n  DecorationsTrees.prototype.collectNodesFromOwner = function (ownerId) {\n    var r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n\n    var r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n\n    return r0.concat(r1);\n  };\n\n  DecorationsTrees.prototype.collectNodesPostOrder = function () {\n    var r0 = this._decorationsTree0.collectNodesPostOrder();\n\n    var r1 = this._decorationsTree1.collectNodesPostOrder();\n\n    return r0.concat(r1);\n  };\n\n  DecorationsTrees.prototype.insert = function (node) {\n    if (getNodeIsInOverviewRuler(node)) {\n      this._decorationsTree1.insert(node);\n    } else {\n      this._decorationsTree0.insert(node);\n    }\n  };\n\n  DecorationsTrees.prototype.delete = function (node) {\n    if (getNodeIsInOverviewRuler(node)) {\n      this._decorationsTree1.delete(node);\n    } else {\n      this._decorationsTree0.delete(node);\n    }\n  };\n\n  DecorationsTrees.prototype.resolveNode = function (node, cachedVersionId) {\n    if (getNodeIsInOverviewRuler(node)) {\n      this._decorationsTree1.resolveNode(node, cachedVersionId);\n    } else {\n      this._decorationsTree0.resolveNode(node, cachedVersionId);\n    }\n  };\n\n  DecorationsTrees.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {\n    this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\n    this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n  };\n\n  return DecorationsTrees;\n}();\n\nfunction cleanClassName(className) {\n  return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\n\nvar DecorationOptions =\n/** @class */\nfunction () {\n  function DecorationOptions(options) {\n    this.color = options.color || strings.empty;\n    this.darkColor = options.darkColor || strings.empty;\n  }\n\n  return DecorationOptions;\n}();\n\nvar ModelDecorationOverviewRulerOptions =\n/** @class */\nfunction (_super) {\n  __extends(ModelDecorationOverviewRulerOptions, _super);\n\n  function ModelDecorationOverviewRulerOptions(options) {\n    var _this = _super.call(this, options) || this;\n\n    _this._resolvedColor = null;\n    _this.position = typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center;\n    return _this;\n  }\n\n  ModelDecorationOverviewRulerOptions.prototype.getColor = function (theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n\n    return this._resolvedColor;\n  };\n\n  ModelDecorationOverviewRulerOptions.prototype.invalidateCachedColor = function () {\n    this._resolvedColor = null;\n  };\n\n  ModelDecorationOverviewRulerOptions.prototype._resolveColor = function (color, theme) {\n    if (typeof color === 'string') {\n      return color;\n    }\n\n    var c = color ? theme.getColor(color.id) : null;\n\n    if (!c) {\n      return strings.empty;\n    }\n\n    return c.toString();\n  };\n\n  return ModelDecorationOverviewRulerOptions;\n}(DecorationOptions);\n\nexport { ModelDecorationOverviewRulerOptions };\n\nvar ModelDecorationMinimapOptions =\n/** @class */\nfunction (_super) {\n  __extends(ModelDecorationMinimapOptions, _super);\n\n  function ModelDecorationMinimapOptions(options) {\n    var _this = _super.call(this, options) || this;\n\n    _this.position = options.position;\n    return _this;\n  }\n\n  ModelDecorationMinimapOptions.prototype.getColor = function (theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n\n    return this._resolvedColor;\n  };\n\n  ModelDecorationMinimapOptions.prototype.invalidateCachedColor = function () {\n    this._resolvedColor = undefined;\n  };\n\n  ModelDecorationMinimapOptions.prototype._resolveColor = function (color, theme) {\n    if (typeof color === 'string') {\n      return Color.fromHex(color);\n    }\n\n    return theme.getColor(color.id);\n  };\n\n  return ModelDecorationMinimapOptions;\n}(DecorationOptions);\n\nexport { ModelDecorationMinimapOptions };\n\nvar ModelDecorationOptions =\n/** @class */\nfunction () {\n  function ModelDecorationOptions(options) {\n    this.stickiness = options.stickiness || 0\n    /* AlwaysGrowsWhenTypingAtEdges */\n    ;\n    this.zIndex = options.zIndex || 0;\n    this.className = options.className ? cleanClassName(options.className) : null;\n    this.hoverMessage = withUndefinedAsNull(options.hoverMessage);\n    this.glyphMarginHoverMessage = withUndefinedAsNull(options.glyphMarginHoverMessage);\n    this.isWholeLine = options.isWholeLine || false;\n    this.showIfCollapsed = options.showIfCollapsed || false;\n    this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n    this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n    this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n    this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n    this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n    this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n    this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n    this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n  }\n\n  ModelDecorationOptions.register = function (options) {\n    return new ModelDecorationOptions(options);\n  };\n\n  ModelDecorationOptions.createDynamic = function (options) {\n    return new ModelDecorationOptions(options);\n  };\n\n  return ModelDecorationOptions;\n}();\n\nexport { ModelDecorationOptions };\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});\n/**\n * The order carefully matches the values of the enum.\n */\n\nvar TRACKED_RANGE_OPTIONS = [ModelDecorationOptions.register({\n  stickiness: 0\n  /* AlwaysGrowsWhenTypingAtEdges */\n\n}), ModelDecorationOptions.register({\n  stickiness: 1\n  /* NeverGrowsWhenTypingAtEdges */\n\n}), ModelDecorationOptions.register({\n  stickiness: 2\n  /* GrowsOnlyWhenTypingBefore */\n\n}), ModelDecorationOptions.register({\n  stickiness: 3\n  /* GrowsOnlyWhenTypingAfter */\n\n})];\n\nfunction _normalizeOptions(options) {\n  if (options instanceof ModelDecorationOptions) {\n    return options;\n  }\n\n  return ModelDecorationOptions.createDynamic(options);\n}\n\nvar DidChangeDecorationsEmitter =\n/** @class */\nfunction (_super) {\n  __extends(DidChangeDecorationsEmitter, _super);\n\n  function DidChangeDecorationsEmitter() {\n    var _this = _super.call(this) || this;\n\n    _this._actual = _this._register(new Emitter());\n    _this.event = _this._actual.event;\n    _this._deferredCnt = 0;\n    _this._shouldFire = false;\n    return _this;\n  }\n\n  DidChangeDecorationsEmitter.prototype.beginDeferredEmit = function () {\n    this._deferredCnt++;\n  };\n\n  DidChangeDecorationsEmitter.prototype.endDeferredEmit = function () {\n    this._deferredCnt--;\n\n    if (this._deferredCnt === 0) {\n      if (this._shouldFire) {\n        this._shouldFire = false;\n\n        this._actual.fire({});\n      }\n    }\n  };\n\n  DidChangeDecorationsEmitter.prototype.fire = function () {\n    this._shouldFire = true;\n  };\n\n  return DidChangeDecorationsEmitter;\n}(Disposable);\n\nexport { DidChangeDecorationsEmitter }; //#endregion\n\nvar DidChangeContentEmitter =\n/** @class */\nfunction (_super) {\n  __extends(DidChangeContentEmitter, _super);\n\n  function DidChangeContentEmitter() {\n    var _this = _super.call(this) || this;\n    /**\n     * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n     */\n\n\n    _this._fastEmitter = _this._register(new Emitter());\n    _this.fastEvent = _this._fastEmitter.event;\n    _this._slowEmitter = _this._register(new Emitter());\n    _this.slowEvent = _this._slowEmitter.event;\n    _this._deferredCnt = 0;\n    _this._deferredEvent = null;\n    return _this;\n  }\n\n  DidChangeContentEmitter.prototype.beginDeferredEmit = function () {\n    this._deferredCnt++;\n  };\n\n  DidChangeContentEmitter.prototype.endDeferredEmit = function () {\n    this._deferredCnt--;\n\n    if (this._deferredCnt === 0) {\n      if (this._deferredEvent !== null) {\n        var e = this._deferredEvent;\n        this._deferredEvent = null;\n\n        this._fastEmitter.fire(e);\n\n        this._slowEmitter.fire(e);\n      }\n    }\n  };\n\n  DidChangeContentEmitter.prototype.fire = function (e) {\n    if (this._deferredCnt > 0) {\n      if (this._deferredEvent) {\n        this._deferredEvent = this._deferredEvent.merge(e);\n      } else {\n        this._deferredEvent = e;\n      }\n\n      return;\n    }\n\n    this._fastEmitter.fire(e);\n\n    this._slowEmitter.fire(e);\n  };\n\n  return DidChangeContentEmitter;\n}(Disposable);\n\nexport { DidChangeContentEmitter };","map":null,"metadata":{},"sourceType":"module"}