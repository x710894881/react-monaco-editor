{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { MAX_LINE_NUMBER, FoldingRegions } from './foldingRanges.js';\nvar MAX_FOLDING_REGIONS = 5000;\nvar foldingContext = {};\nexport var ID_SYNTAX_PROVIDER = 'syntax';\n\nvar SyntaxRangeProvider =\n/** @class */\nfunction () {\n  function SyntaxRangeProvider(editorModel, providers, limit) {\n    if (limit === void 0) {\n      limit = MAX_FOLDING_REGIONS;\n    }\n\n    this.editorModel = editorModel;\n    this.providers = providers;\n    this.limit = limit;\n    this.id = ID_SYNTAX_PROVIDER;\n  }\n\n  SyntaxRangeProvider.prototype.compute = function (cancellationToken) {\n    var _this = this;\n\n    return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(function (ranges) {\n      if (ranges) {\n        var res = sanitizeRanges(ranges, _this.limit);\n        return res;\n      }\n\n      return null;\n    });\n  };\n\n  SyntaxRangeProvider.prototype.dispose = function () {};\n\n  return SyntaxRangeProvider;\n}();\n\nexport { SyntaxRangeProvider };\n\nfunction collectSyntaxRanges(providers, model, cancellationToken) {\n  var rangeData = null;\n  var promises = providers.map(function (provider, i) {\n    return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(function (ranges) {\n      if (cancellationToken.isCancellationRequested) {\n        return;\n      }\n\n      if (Array.isArray(ranges)) {\n        if (!Array.isArray(rangeData)) {\n          rangeData = [];\n        }\n\n        var nLines = model.getLineCount();\n\n        for (var _i = 0, ranges_1 = ranges; _i < ranges_1.length; _i++) {\n          var r = ranges_1[_i];\n\n          if (r.start > 0 && r.end > r.start && r.end <= nLines) {\n            rangeData.push({\n              start: r.start,\n              end: r.end,\n              rank: i,\n              kind: r.kind\n            });\n          }\n        }\n      }\n    }, onUnexpectedExternalError);\n  });\n  return Promise.all(promises).then(function (_) {\n    return rangeData;\n  });\n}\n\nvar RangesCollector =\n/** @class */\nfunction () {\n  function RangesCollector(foldingRangesLimit) {\n    this._startIndexes = [];\n    this._endIndexes = [];\n    this._nestingLevels = [];\n    this._nestingLevelCounts = [];\n    this._types = [];\n    this._length = 0;\n    this._foldingRangesLimit = foldingRangesLimit;\n  }\n\n  RangesCollector.prototype.add = function (startLineNumber, endLineNumber, type, nestingLevel) {\n    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n      return;\n    }\n\n    var index = this._length;\n    this._startIndexes[index] = startLineNumber;\n    this._endIndexes[index] = endLineNumber;\n    this._nestingLevels[index] = nestingLevel;\n    this._types[index] = type;\n    this._length++;\n\n    if (nestingLevel < 30) {\n      this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\n    }\n  };\n\n  RangesCollector.prototype.toIndentRanges = function () {\n    if (this._length <= this._foldingRangesLimit) {\n      var startIndexes = new Uint32Array(this._length);\n      var endIndexes = new Uint32Array(this._length);\n\n      for (var i = 0; i < this._length; i++) {\n        startIndexes[i] = this._startIndexes[i];\n        endIndexes[i] = this._endIndexes[i];\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes, this._types);\n    } else {\n      var entries = 0;\n      var maxLevel = this._nestingLevelCounts.length;\n\n      for (var i = 0; i < this._nestingLevelCounts.length; i++) {\n        var n = this._nestingLevelCounts[i];\n\n        if (n) {\n          if (n + entries > this._foldingRangesLimit) {\n            maxLevel = i;\n            break;\n          }\n\n          entries += n;\n        }\n      }\n\n      var startIndexes = new Uint32Array(this._foldingRangesLimit);\n      var endIndexes = new Uint32Array(this._foldingRangesLimit);\n      var types = [];\n\n      for (var i = 0, k = 0; i < this._length; i++) {\n        var level = this._nestingLevels[i];\n\n        if (level < maxLevel || level === maxLevel && entries++ < this._foldingRangesLimit) {\n          startIndexes[k] = this._startIndexes[i];\n          endIndexes[k] = this._endIndexes[i];\n          types[k] = this._types[i];\n          k++;\n        }\n      }\n\n      return new FoldingRegions(startIndexes, endIndexes, types);\n    }\n  };\n\n  return RangesCollector;\n}();\n\nexport { RangesCollector };\nexport function sanitizeRanges(rangeData, limit) {\n  var sorted = rangeData.sort(function (d1, d2) {\n    var diff = d1.start - d2.start;\n\n    if (diff === 0) {\n      diff = d1.rank - d2.rank;\n    }\n\n    return diff;\n  });\n  var collector = new RangesCollector(limit);\n  var top = undefined;\n  var previous = [];\n\n  for (var _i = 0, sorted_1 = sorted; _i < sorted_1.length; _i++) {\n    var entry = sorted_1[_i];\n\n    if (!top) {\n      top = entry;\n      collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n    } else {\n      if (entry.start > top.start) {\n        if (entry.end <= top.end) {\n          previous.push(top);\n          top = entry;\n          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        } else {\n          if (entry.start > top.end) {\n            do {\n              top = previous.pop();\n            } while (top && entry.start > top.end);\n\n            if (top) {\n              previous.push(top);\n            }\n\n            top = entry;\n          }\n\n          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        }\n      }\n    }\n  }\n\n  return collector.toIndentRanges();\n}","map":null,"metadata":{},"sourceType":"module"}