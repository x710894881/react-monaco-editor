{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { ComposedTreeDelegate } from './abstractTree.js';\nimport { ObjectTree } from './objectTree.js';\nimport { dispose } from '../../../common/lifecycle.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { timeout, createCancelablePromise } from '../../../common/async.js';\nimport { Iterator } from '../../../common/iterator.js';\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { isPromiseCanceledError, onUnexpectedError } from '../../../common/errors.js';\nimport { toggleClass } from '../../dom.js';\nimport { values } from '../../../common/map.js';\n\nfunction createAsyncDataTreeNode(props) {\n  return __assign({}, props, {\n    children: [],\n    loading: false,\n    stale: true,\n    slow: false,\n    collapsedByDefault: undefined\n  });\n}\n\nfunction isAncestor(ancestor, descendant) {\n  if (!descendant.parent) {\n    return false;\n  } else if (descendant.parent === ancestor) {\n    return true;\n  } else {\n    return isAncestor(ancestor, descendant.parent);\n  }\n}\n\nfunction intersects(node, other) {\n  return node === other || isAncestor(node, other) || isAncestor(other, node);\n}\n\nvar AsyncDataTreeNodeWrapper =\n/** @class */\nfunction () {\n  function AsyncDataTreeNodeWrapper(node) {\n    this.node = node;\n  }\n\n  Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"element\", {\n    get: function () {\n      return this.node.element.element;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"parent\", {\n    get: function () {\n      return this.node.parent && new AsyncDataTreeNodeWrapper(this.node.parent);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"children\", {\n    get: function () {\n      return this.node.children.map(function (node) {\n        return new AsyncDataTreeNodeWrapper(node);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"depth\", {\n    get: function () {\n      return this.node.depth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"visibleChildrenCount\", {\n    get: function () {\n      return this.node.visibleChildrenCount;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"visibleChildIndex\", {\n    get: function () {\n      return this.node.visibleChildIndex;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"collapsible\", {\n    get: function () {\n      return this.node.collapsible;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"collapsed\", {\n    get: function () {\n      return this.node.collapsed;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"visible\", {\n    get: function () {\n      return this.node.visible;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"filterData\", {\n    get: function () {\n      return this.node.filterData;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return AsyncDataTreeNodeWrapper;\n}();\n\nvar DataTreeRenderer =\n/** @class */\nfunction () {\n  function DataTreeRenderer(renderer, onDidChangeTwistieState) {\n    this.renderer = renderer;\n    this.onDidChangeTwistieState = onDidChangeTwistieState;\n    this.renderedNodes = new Map();\n    this.disposables = [];\n    this.templateId = renderer.templateId;\n  }\n\n  DataTreeRenderer.prototype.renderTemplate = function (container) {\n    var templateData = this.renderer.renderTemplate(container);\n    return {\n      templateData: templateData\n    };\n  };\n\n  DataTreeRenderer.prototype.renderElement = function (node, index, templateData, height) {\n    this.renderer.renderElement(new AsyncDataTreeNodeWrapper(node), index, templateData.templateData, height);\n  };\n\n  DataTreeRenderer.prototype.renderTwistie = function (element, twistieElement) {\n    toggleClass(twistieElement, 'loading', element.slow);\n    return false;\n  };\n\n  DataTreeRenderer.prototype.disposeElement = function (node, index, templateData, height) {\n    if (this.renderer.disposeElement) {\n      this.renderer.disposeElement(new AsyncDataTreeNodeWrapper(node), index, templateData.templateData, height);\n    }\n  };\n\n  DataTreeRenderer.prototype.disposeTemplate = function (templateData) {\n    this.renderer.disposeTemplate(templateData.templateData);\n  };\n\n  DataTreeRenderer.prototype.dispose = function () {\n    this.renderedNodes.clear();\n    this.disposables = dispose(this.disposables);\n  };\n\n  return DataTreeRenderer;\n}();\n\nfunction asTreeEvent(e) {\n  return {\n    browserEvent: e.browserEvent,\n    elements: e.elements.map(function (e) {\n      return e.element;\n    })\n  };\n}\n\nexport var ChildrenResolutionReason;\n\n(function (ChildrenResolutionReason) {\n  ChildrenResolutionReason[ChildrenResolutionReason[\"Refresh\"] = 0] = \"Refresh\";\n  ChildrenResolutionReason[ChildrenResolutionReason[\"Expand\"] = 1] = \"Expand\";\n})(ChildrenResolutionReason || (ChildrenResolutionReason = {}));\n\nfunction asAsyncDataTreeDragAndDropData(data) {\n  if (data instanceof ElementsDragAndDropData) {\n    var nodes = data.elements;\n    return new ElementsDragAndDropData(nodes.map(function (node) {\n      return node.element;\n    }));\n  }\n\n  return data;\n}\n\nvar AsyncDataTreeNodeListDragAndDrop =\n/** @class */\nfunction () {\n  function AsyncDataTreeNodeListDragAndDrop(dnd) {\n    this.dnd = dnd;\n  }\n\n  AsyncDataTreeNodeListDragAndDrop.prototype.getDragURI = function (node) {\n    return this.dnd.getDragURI(node.element);\n  };\n\n  AsyncDataTreeNodeListDragAndDrop.prototype.getDragLabel = function (nodes) {\n    if (this.dnd.getDragLabel) {\n      return this.dnd.getDragLabel(nodes.map(function (node) {\n        return node.element;\n      }));\n    }\n\n    return undefined;\n  };\n\n  AsyncDataTreeNodeListDragAndDrop.prototype.onDragStart = function (data, originalEvent) {\n    if (this.dnd.onDragStart) {\n      this.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);\n    }\n  };\n\n  AsyncDataTreeNodeListDragAndDrop.prototype.onDragOver = function (data, targetNode, targetIndex, originalEvent, raw) {\n    if (raw === void 0) {\n      raw = true;\n    }\n\n    return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n  };\n\n  AsyncDataTreeNodeListDragAndDrop.prototype.drop = function (data, targetNode, targetIndex, originalEvent) {\n    this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n  };\n\n  return AsyncDataTreeNodeListDragAndDrop;\n}();\n\nfunction asObjectTreeOptions(options) {\n  return options && __assign({}, options, {\n    collapseByDefault: true,\n    identityProvider: options.identityProvider && {\n      getId: function (el) {\n        return options.identityProvider.getId(el.element);\n      }\n    },\n    dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),\n    multipleSelectionController: options.multipleSelectionController && {\n      isSelectionSingleChangeEvent: function (e) {\n        return options.multipleSelectionController.isSelectionSingleChangeEvent(__assign({}, e, {\n          element: e.element\n        }));\n      },\n      isSelectionRangeChangeEvent: function (e) {\n        return options.multipleSelectionController.isSelectionRangeChangeEvent(__assign({}, e, {\n          element: e.element\n        }));\n      }\n    },\n    accessibilityProvider: options.accessibilityProvider && {\n      getAriaLabel: function (e) {\n        return options.accessibilityProvider.getAriaLabel(e.element);\n      }\n    },\n    filter: options.filter && {\n      filter: function (e, parentVisibility) {\n        return options.filter.filter(e.element, parentVisibility);\n      }\n    },\n    keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && __assign({}, options.keyboardNavigationLabelProvider, {\n      getKeyboardNavigationLabel: function (e) {\n        return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);\n      }\n    }),\n    sorter: undefined,\n    expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : function (e) {\n      return options.expandOnlyOnTwistieClick(e.element);\n    },\n    ariaProvider: undefined,\n    additionalScrollHeight: options.additionalScrollHeight\n  });\n}\n\nfunction asTreeElement(node, viewStateContext) {\n  var collapsed;\n\n  if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n    collapsed = false;\n  } else {\n    collapsed = node.collapsedByDefault;\n  }\n\n  node.collapsedByDefault = undefined;\n  return {\n    element: node,\n    children: node.hasChildren ? Iterator.map(Iterator.fromArray(node.children), function (child) {\n      return asTreeElement(child, viewStateContext);\n    }) : [],\n    collapsible: node.hasChildren,\n    collapsed: collapsed\n  };\n}\n\nfunction dfs(node, fn) {\n  fn(node);\n  node.children.forEach(function (child) {\n    return dfs(child, fn);\n  });\n}\n\nvar AsyncDataTree =\n/** @class */\nfunction () {\n  function AsyncDataTree(container, delegate, renderers, dataSource, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.dataSource = dataSource;\n    this.nodes = new Map();\n    this.subTreeRefreshPromises = new Map();\n    this.refreshPromises = new Map();\n    this._onDidRender = new Emitter();\n    this._onDidChangeNodeSlowState = new Emitter();\n    this.disposables = [];\n    this.identityProvider = options.identityProvider;\n    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n    this.sorter = options.sorter;\n    this.collapseByDefault = options.collapseByDefault;\n    var objectTreeDelegate = new ComposedTreeDelegate(delegate);\n    var objectTreeRenderers = renderers.map(function (r) {\n      return new DataTreeRenderer(r, _this._onDidChangeNodeSlowState.event);\n    });\n    var objectTreeOptions = asObjectTreeOptions(options) || {};\n    this.tree = new ObjectTree(container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n    this.root = createAsyncDataTreeNode({\n      element: undefined,\n      parent: null,\n      hasChildren: true\n    });\n\n    if (this.identityProvider) {\n      this.root = __assign({}, this.root, {\n        id: null\n      });\n    }\n\n    this.nodes.set(null, this.root);\n    this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n  }\n\n  Object.defineProperty(AsyncDataTree.prototype, \"onDidChangeFocus\", {\n    get: function () {\n      return Event.map(this.tree.onDidChangeFocus, asTreeEvent);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTree.prototype, \"onDidChangeSelection\", {\n    get: function () {\n      return Event.map(this.tree.onDidChangeSelection, asTreeEvent);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTree.prototype, \"onDidOpen\", {\n    get: function () {\n      return Event.map(this.tree.onDidOpen, asTreeEvent);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTree.prototype, \"onDidFocus\", {\n    get: function () {\n      return this.tree.onDidFocus;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AsyncDataTree.prototype, \"onDidDispose\", {\n    get: function () {\n      return this.tree.onDidDispose;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AsyncDataTree.prototype.updateOptions = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.tree.updateOptions(options);\n  }; // Widget\n\n\n  AsyncDataTree.prototype.getHTMLElement = function () {\n    return this.tree.getHTMLElement();\n  };\n\n  Object.defineProperty(AsyncDataTree.prototype, \"scrollTop\", {\n    get: function () {\n      return this.tree.scrollTop;\n    },\n    set: function (scrollTop) {\n      this.tree.scrollTop = scrollTop;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AsyncDataTree.prototype.domFocus = function () {\n    this.tree.domFocus();\n  };\n\n  AsyncDataTree.prototype.layout = function (height, width) {\n    this.tree.layout(height, width);\n  };\n\n  AsyncDataTree.prototype.style = function (styles) {\n    this.tree.style(styles);\n  }; // Model\n\n\n  AsyncDataTree.prototype.getInput = function () {\n    return this.root.element;\n  };\n\n  AsyncDataTree.prototype.setInput = function (input, viewState) {\n    return __awaiter(this, void 0, void 0, function () {\n      var viewStateContext;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.refreshPromises.forEach(function (promise) {\n              return promise.cancel();\n            });\n            this.refreshPromises.clear();\n            this.root.element = input;\n            viewStateContext = viewState && {\n              viewState: viewState,\n              focus: [],\n              selection: []\n            };\n            return [4\n            /*yield*/\n            , this.updateChildren(input, true, viewStateContext)];\n\n          case 1:\n            _a.sent();\n\n            if (viewStateContext) {\n              this.tree.setFocus(viewStateContext.focus);\n              this.tree.setSelection(viewStateContext.selection);\n            }\n\n            if (viewState && typeof viewState.scrollTop === 'number') {\n              this.scrollTop = viewState.scrollTop;\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AsyncDataTree.prototype.updateChildren = function (element, recursive, viewStateContext) {\n    if (element === void 0) {\n      element = this.root.element;\n    }\n\n    if (recursive === void 0) {\n      recursive = true;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (typeof this.root.element === 'undefined') {\n              throw new Error('Tree input not set');\n            }\n\n            if (!this.root.loading) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.subTreeRefreshPromises.get(this.root)];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , Event.toPromise(this._onDidRender.event)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [4\n            /*yield*/\n            , this.refreshAndRenderNode(this.getDataNode(element), recursive, ChildrenResolutionReason.Refresh, viewStateContext)];\n\n          case 4:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // View\n\n\n  AsyncDataTree.prototype.rerender = function (element) {\n    if (element === undefined || element === this.root.element) {\n      this.tree.rerender();\n      return;\n    }\n\n    var node = this.getDataNode(element);\n    this.tree.rerender(node);\n  };\n\n  AsyncDataTree.prototype.collapse = function (element, recursive) {\n    if (recursive === void 0) {\n      recursive = false;\n    }\n\n    var node = this.getDataNode(element);\n    return this.tree.collapse(node === this.root ? null : node, recursive);\n  };\n\n  AsyncDataTree.prototype.expand = function (element, recursive) {\n    if (recursive === void 0) {\n      recursive = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var node, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (typeof this.root.element === 'undefined') {\n              throw new Error('Tree input not set');\n            }\n\n            if (!this.root.loading) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.subTreeRefreshPromises.get(this.root)];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , Event.toPromise(this._onDidRender.event)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            node = this.getDataNode(element);\n\n            if (node !== this.root && !node.loading && !this.tree.isCollapsed(node)) {\n              return [2\n              /*return*/\n              , false];\n            }\n\n            result = this.tree.expand(node === this.root ? null : node, recursive);\n            if (!node.loading) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this.subTreeRefreshPromises.get(node)];\n\n          case 4:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , Event.toPromise(this._onDidRender.event)];\n\n          case 5:\n            _a.sent();\n\n            _a.label = 6;\n\n          case 6:\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n\n  AsyncDataTree.prototype.setSelection = function (elements, browserEvent) {\n    var _this = this;\n\n    var nodes = elements.map(function (e) {\n      return _this.getDataNode(e);\n    });\n    this.tree.setSelection(nodes, browserEvent);\n  };\n\n  AsyncDataTree.prototype.getSelection = function () {\n    var nodes = this.tree.getSelection();\n    return nodes.map(function (n) {\n      return n.element;\n    });\n  };\n\n  AsyncDataTree.prototype.setFocus = function (elements, browserEvent) {\n    var _this = this;\n\n    var nodes = elements.map(function (e) {\n      return _this.getDataNode(e);\n    });\n    this.tree.setFocus(nodes, browserEvent);\n  };\n\n  AsyncDataTree.prototype.getFocus = function () {\n    var nodes = this.tree.getFocus();\n    return nodes.map(function (n) {\n      return n.element;\n    });\n  };\n\n  AsyncDataTree.prototype.reveal = function (element, relativeTop) {\n    this.tree.reveal(this.getDataNode(element), relativeTop);\n  }; // Implementation\n\n\n  AsyncDataTree.prototype.getDataNode = function (element) {\n    var node = this.nodes.get(element === this.root.element ? null : element);\n\n    if (!node) {\n      throw new Error(\"Data tree node not found: \" + element);\n    }\n\n    return node;\n  };\n\n  AsyncDataTree.prototype.refreshAndRenderNode = function (node, recursive, reason, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var treeNode, visibleChildren;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.refreshNode(node, recursive, viewStateContext)];\n\n          case 1:\n            _a.sent();\n\n            this.render(node, viewStateContext);\n            if (!(node !== this.root && this.autoExpandSingleChildren && reason === ChildrenResolutionReason.Expand)) return [3\n            /*break*/\n            , 3];\n            treeNode = this.tree.getNode(node);\n            visibleChildren = treeNode.children.filter(function (node) {\n              return node.visible;\n            });\n            if (!(visibleChildren.length === 1)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.tree.expand(visibleChildren[0].element, false)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AsyncDataTree.prototype.refreshNode = function (node, recursive, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var result;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.subTreeRefreshPromises.forEach(function (refreshPromise, refreshNode) {\n              if (!result && intersects(refreshNode, node)) {\n                result = refreshPromise.then(function () {\n                  return _this.refreshNode(node, recursive, viewStateContext);\n                });\n              }\n            });\n\n            if (result) {\n              return [2\n              /*return*/\n              , result];\n            }\n\n            result = this.doRefreshSubTree(node, recursive, viewStateContext);\n            this.subTreeRefreshPromises.set(node, result);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1,, 3, 4]);\n\n            return [4\n            /*yield*/\n            , result];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            this.subTreeRefreshPromises.delete(node);\n            return [7\n            /*endfinally*/\n            ];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AsyncDataTree.prototype.doRefreshSubTree = function (node, recursive, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var childrenToRefresh;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            node.loading = true;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1,, 4, 5]);\n\n            return [4\n            /*yield*/\n            , this.doRefreshNode(node, recursive, viewStateContext)];\n\n          case 2:\n            childrenToRefresh = _a.sent();\n            node.stale = false;\n            return [4\n            /*yield*/\n            , Promise.all(childrenToRefresh.map(function (child) {\n              return _this.doRefreshSubTree(child, recursive, viewStateContext);\n            }))];\n\n          case 3:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            node.loading = false;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AsyncDataTree.prototype.doRefreshNode = function (node, recursive, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var childrenPromise, slowTimeout_1, children, err_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            node.hasChildren = !!this.dataSource.hasChildren(node.element);\n\n            if (!node.hasChildren) {\n              childrenPromise = Promise.resolve([]);\n            } else {\n              slowTimeout_1 = timeout(800);\n              slowTimeout_1.then(function () {\n                node.slow = true;\n\n                _this._onDidChangeNodeSlowState.fire(node);\n              }, function (_) {\n                return null;\n              });\n              childrenPromise = this.doGetChildren(node).finally(function () {\n                return slowTimeout_1.cancel();\n              });\n            }\n\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3, 4, 5]);\n\n            return [4\n            /*yield*/\n            , childrenPromise];\n\n          case 2:\n            children = _a.sent();\n            return [2\n            /*return*/\n            , this.setChildren(node, children, recursive, viewStateContext)];\n\n          case 3:\n            err_1 = _a.sent();\n\n            if (node !== this.root) {\n              this.tree.collapse(node === this.root ? null : node);\n            }\n\n            if (isPromiseCanceledError(err_1)) {\n              return [2\n              /*return*/\n              , []];\n            }\n\n            throw err_1;\n\n          case 4:\n            if (node.slow) {\n              node.slow = false;\n\n              this._onDidChangeNodeSlowState.fire(node);\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AsyncDataTree.prototype.doGetChildren = function (node) {\n    var _this = this;\n\n    var result = this.refreshPromises.get(node);\n\n    if (result) {\n      return result;\n    }\n\n    result = createCancelablePromise(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var children;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.dataSource.getChildren(node.element)];\n\n            case 1:\n              children = _a.sent();\n\n              if (this.sorter) {\n                children.sort(this.sorter.compare.bind(this.sorter));\n              }\n\n              return [2\n              /*return*/\n              , children];\n          }\n        });\n      });\n    });\n    this.refreshPromises.set(node, result);\n    return result.finally(function () {\n      return _this.refreshPromises.delete(node);\n    });\n  };\n\n  AsyncDataTree.prototype._onDidChangeCollapseState = function (_a) {\n    var node = _a.node,\n        deep = _a.deep;\n\n    if (!node.collapsed && node.element.stale) {\n      if (deep) {\n        this.collapse(node.element.element);\n      } else {\n        this.refreshAndRenderNode(node.element, false, ChildrenResolutionReason.Expand).catch(onUnexpectedError);\n      }\n    }\n  };\n\n  AsyncDataTree.prototype.setChildren = function (node, childrenElements, recursive, viewStateContext) {\n    var _a;\n\n    var _this = this; // perf: if the node was and still is a leaf, avoid all this hassle\n\n\n    if (node.children.length === 0 && childrenElements.length === 0) {\n      return [];\n    }\n\n    var nodesToForget = new Map();\n    var childrenTreeNodesById = new Map();\n\n    for (var _i = 0, _b = node.children; _i < _b.length; _i++) {\n      var child = _b[_i];\n      nodesToForget.set(child.element, child);\n\n      if (this.identityProvider) {\n        childrenTreeNodesById.set(child.id, this.tree.getNode(child));\n      }\n    }\n\n    var childrenToRefresh = [];\n    var children = childrenElements.map(function (element) {\n      var hasChildren = !!_this.dataSource.hasChildren(element);\n\n      if (!_this.identityProvider) {\n        var asyncDataTreeNode = createAsyncDataTreeNode({\n          element: element,\n          parent: node,\n          hasChildren: hasChildren\n        });\n\n        if (hasChildren && _this.collapseByDefault && !_this.collapseByDefault(element)) {\n          asyncDataTreeNode.collapsedByDefault = false;\n          childrenToRefresh.push(asyncDataTreeNode);\n        }\n\n        return asyncDataTreeNode;\n      }\n\n      var id = _this.identityProvider.getId(element).toString();\n\n      var childNode = childrenTreeNodesById.get(id);\n\n      if (childNode) {\n        var asyncDataTreeNode = childNode.element;\n        nodesToForget.delete(asyncDataTreeNode.element);\n\n        _this.nodes.delete(asyncDataTreeNode.element);\n\n        _this.nodes.set(element, asyncDataTreeNode);\n\n        asyncDataTreeNode.element = element;\n        asyncDataTreeNode.hasChildren = hasChildren;\n\n        if (recursive) {\n          if (childNode.collapsed) {\n            dfs(asyncDataTreeNode, function (node) {\n              return node.stale = true;\n            });\n          } else {\n            childrenToRefresh.push(asyncDataTreeNode);\n          }\n        } else if (hasChildren && _this.collapseByDefault && !_this.collapseByDefault(element)) {\n          asyncDataTreeNode.collapsedByDefault = false;\n          childrenToRefresh.push(asyncDataTreeNode);\n        }\n\n        return asyncDataTreeNode;\n      }\n\n      var childAsyncDataTreeNode = createAsyncDataTreeNode({\n        element: element,\n        parent: node,\n        id: id,\n        hasChildren: hasChildren\n      });\n\n      if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n        viewStateContext.focus.push(childAsyncDataTreeNode);\n      }\n\n      if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n        viewStateContext.selection.push(childAsyncDataTreeNode);\n      }\n\n      if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n        childrenToRefresh.push(childAsyncDataTreeNode);\n      } else if (hasChildren && _this.collapseByDefault && !_this.collapseByDefault(element)) {\n        childAsyncDataTreeNode.collapsedByDefault = false;\n        childrenToRefresh.push(childAsyncDataTreeNode);\n      }\n\n      return childAsyncDataTreeNode;\n    });\n\n    for (var _c = 0, _d = values(nodesToForget); _c < _d.length; _c++) {\n      var node_1 = _d[_c];\n      dfs(node_1, function (node) {\n        return _this.nodes.delete(node.element);\n      });\n    }\n\n    for (var _e = 0, children_1 = children; _e < children_1.length; _e++) {\n      var child = children_1[_e];\n      this.nodes.set(child.element, child);\n    }\n\n    (_a = node.children).splice.apply(_a, [0, node.children.length].concat(children));\n\n    return childrenToRefresh;\n  };\n\n  AsyncDataTree.prototype.render = function (node, viewStateContext) {\n    var children = node.children.map(function (c) {\n      return asTreeElement(c, viewStateContext);\n    });\n    this.tree.setChildren(node === this.root ? null : node, children);\n\n    this._onDidRender.fire();\n  };\n\n  AsyncDataTree.prototype.dispose = function () {\n    dispose(this.disposables);\n  };\n\n  return AsyncDataTree;\n}();\n\nexport { AsyncDataTree };","map":null,"metadata":{},"sourceType":"module"}