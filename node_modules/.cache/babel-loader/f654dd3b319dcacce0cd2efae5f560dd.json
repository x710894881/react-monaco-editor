{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { TokenType, Scanner } from './cssScanner.js';\nimport * as nodes from './cssNodes.js';\nimport { ParseError } from './cssErrors.js';\nimport * as languageFacts from '../languageFacts/facts.js'; /// <summary>\n/// A parser for the css core specification. See for reference:\n/// https://www.w3.org/TR/CSS21/grammar.html\n/// http://www.w3.org/TR/CSS21/syndata.html#tokenization\n/// </summary>\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(scnr) {\n    if (scnr === void 0) {\n      scnr = new Scanner();\n    }\n\n    this.keyframeRegex = /^@(\\-(webkit|ms|moz|o)\\-)?keyframes$/i;\n    this.scanner = scnr;\n    this.token = null;\n    this.prevToken = null;\n  }\n\n  Parser.prototype.peekIdent = function (text) {\n    return TokenType.Ident === this.token.type && text.length === this.token.text.length && text === this.token.text.toLowerCase();\n  };\n\n  Parser.prototype.peekKeyword = function (text) {\n    return TokenType.AtKeyword === this.token.type && text.length === this.token.text.length && text === this.token.text.toLowerCase();\n  };\n\n  Parser.prototype.peekDelim = function (text) {\n    return TokenType.Delim === this.token.type && text === this.token.text;\n  };\n\n  Parser.prototype.peek = function (type) {\n    return type === this.token.type;\n  };\n\n  Parser.prototype.peekRegExp = function (type, regEx) {\n    if (type !== this.token.type) {\n      return false;\n    }\n\n    return regEx.test(this.token.text);\n  };\n\n  Parser.prototype.hasWhitespace = function () {\n    return this.prevToken && this.prevToken.offset + this.prevToken.len !== this.token.offset;\n  };\n\n  Parser.prototype.consumeToken = function () {\n    this.prevToken = this.token;\n    this.token = this.scanner.scan();\n  };\n\n  Parser.prototype.mark = function () {\n    return {\n      prev: this.prevToken,\n      curr: this.token,\n      pos: this.scanner.pos()\n    };\n  };\n\n  Parser.prototype.restoreAtMark = function (mark) {\n    this.prevToken = mark.prev;\n    this.token = mark.curr;\n    this.scanner.goBackTo(mark.pos);\n  };\n\n  Parser.prototype.try = function (func) {\n    var pos = this.mark();\n    var node = func();\n\n    if (!node) {\n      this.restoreAtMark(pos);\n      return null;\n    }\n\n    return node;\n  };\n\n  Parser.prototype.acceptOneKeyword = function (keywords) {\n    if (TokenType.AtKeyword === this.token.type) {\n      for (var _i = 0, keywords_1 = keywords; _i < keywords_1.length; _i++) {\n        var keyword = keywords_1[_i];\n\n        if (keyword.length === this.token.text.length && keyword === this.token.text.toLowerCase()) {\n          this.consumeToken();\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Parser.prototype.accept = function (type) {\n    if (type === this.token.type) {\n      this.consumeToken();\n      return true;\n    }\n\n    return false;\n  };\n\n  Parser.prototype.acceptIdent = function (text) {\n    if (this.peekIdent(text)) {\n      this.consumeToken();\n      return true;\n    }\n\n    return false;\n  };\n\n  Parser.prototype.acceptKeyword = function (text) {\n    if (this.peekKeyword(text)) {\n      this.consumeToken();\n      return true;\n    }\n\n    return false;\n  };\n\n  Parser.prototype.acceptDelim = function (text) {\n    if (this.peekDelim(text)) {\n      this.consumeToken();\n      return true;\n    }\n\n    return false;\n  };\n\n  Parser.prototype.acceptUnquotedString = function () {\n    var pos = this.scanner.pos();\n    this.scanner.goBackTo(this.token.offset);\n    var unquoted = this.scanner.scanUnquotedString();\n\n    if (unquoted) {\n      this.token = unquoted;\n      this.consumeToken();\n      return true;\n    }\n\n    this.scanner.goBackTo(pos);\n    return false;\n  };\n\n  Parser.prototype.resync = function (resyncTokens, resyncStopTokens) {\n    while (true) {\n      if (resyncTokens && resyncTokens.indexOf(this.token.type) !== -1) {\n        this.consumeToken();\n        return true;\n      } else if (resyncStopTokens && resyncStopTokens.indexOf(this.token.type) !== -1) {\n        return true;\n      } else {\n        if (this.token.type === TokenType.EOF) {\n          return false;\n        }\n\n        this.token = this.scanner.scan();\n      }\n    }\n  };\n\n  Parser.prototype.createNode = function (nodeType) {\n    return new nodes.Node(this.token.offset, this.token.len, nodeType);\n  };\n\n  Parser.prototype.create = function (ctor) {\n    return new ctor(this.token.offset, this.token.len);\n  };\n\n  Parser.prototype.finish = function (node, error, resyncTokens, resyncStopTokens) {\n    // parseNumeric misuses error for boolean flagging (however the real error mustn't be a false)\n    // + nodelist offsets mustn't be modified, because there is a offset hack in rulesets for smartselection\n    if (!(node instanceof nodes.Nodelist)) {\n      if (error) {\n        this.markError(node, error, resyncTokens, resyncStopTokens);\n      } // set the node end position\n\n\n      if (this.prevToken !== null) {\n        // length with more elements belonging together\n        var prevEnd = this.prevToken.offset + this.prevToken.len;\n        node.length = prevEnd > node.offset ? prevEnd - node.offset : 0; // offset is taken from current token, end from previous: Use 0 for empty nodes\n      }\n    }\n\n    return node;\n  };\n\n  Parser.prototype.markError = function (node, error, resyncTokens, resyncStopTokens) {\n    if (this.token !== this.lastErrorToken) {\n      // do not report twice on the same token\n      node.addIssue(new nodes.Marker(node, error, nodes.Level.Error, null, this.token.offset, this.token.len));\n      this.lastErrorToken = this.token;\n    }\n\n    if (resyncTokens || resyncStopTokens) {\n      this.resync(resyncTokens, resyncStopTokens);\n    }\n  };\n\n  Parser.prototype.parseStylesheet = function (textDocument) {\n    var versionId = textDocument.version;\n\n    var textProvider = function (offset, length) {\n      if (textDocument.version !== versionId) {\n        throw new Error('Underlying model has changed, AST is no longer valid');\n      }\n\n      return textDocument.getText().substr(offset, length);\n    };\n\n    return this.internalParse(textDocument.getText(), this._parseStylesheet, textProvider);\n  };\n\n  Parser.prototype.internalParse = function (input, parseFunc, textProvider) {\n    this.scanner.setSource(input);\n    this.token = this.scanner.scan();\n    var node = parseFunc.bind(this)();\n\n    if (node) {\n      if (textProvider) {\n        node.textProvider = textProvider;\n      } else {\n        node.textProvider = function (offset, length) {\n          return input.substr(offset, length);\n        };\n      }\n    }\n\n    return node;\n  };\n\n  Parser.prototype._parseStylesheet = function () {\n    var node = this.create(nodes.Stylesheet);\n    node.addChild(this._parseCharset());\n    var inRecovery = false;\n\n    do {\n      var hasMatch = false;\n\n      do {\n        hasMatch = false;\n\n        var statement = this._parseStylesheetStatement();\n\n        if (statement) {\n          node.addChild(statement);\n          hasMatch = true;\n          inRecovery = false;\n\n          if (!this.peek(TokenType.EOF) && this._needsSemicolonAfter(statement) && !this.accept(TokenType.SemiColon)) {\n            this.markError(node, ParseError.SemiColonExpected);\n          }\n        }\n\n        while (this.accept(TokenType.SemiColon) || this.accept(TokenType.CDO) || this.accept(TokenType.CDC)) {\n          // accept empty statements\n          hasMatch = true;\n          inRecovery = false;\n        }\n      } while (hasMatch);\n\n      if (this.peek(TokenType.EOF)) {\n        break;\n      }\n\n      if (!inRecovery) {\n        if (this.peek(TokenType.AtKeyword)) {\n          this.markError(node, ParseError.UnknownAtRule);\n        } else {\n          this.markError(node, ParseError.RuleOrSelectorExpected);\n        }\n\n        inRecovery = true;\n      }\n\n      this.consumeToken();\n    } while (!this.peek(TokenType.EOF));\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseStylesheetStatement = function (isNested) {\n    if (isNested === void 0) {\n      isNested = false;\n    }\n\n    if (this.peek(TokenType.AtKeyword)) {\n      return this._parseStylesheetAtStatement(isNested);\n    }\n\n    return this._parseRuleset(isNested);\n  };\n\n  Parser.prototype._parseStylesheetAtStatement = function (isNested) {\n    if (isNested === void 0) {\n      isNested = false;\n    }\n\n    return this._parseImport() || this._parseMedia(isNested) || this._parsePage() || this._parseFontFace() || this._parseKeyframe() || this._parseSupports(isNested) || this._parseViewPort() || this._parseNamespace() || this._parseDocument() || this._parseUnknownAtRule();\n  };\n\n  Parser.prototype._tryParseRuleset = function (isNested) {\n    var mark = this.mark();\n\n    if (this._parseSelector(isNested)) {\n      while (this.accept(TokenType.Comma) && this._parseSelector(isNested)) {// loop\n      }\n\n      if (this.accept(TokenType.CurlyL)) {\n        this.restoreAtMark(mark);\n        return this._parseRuleset(isNested);\n      }\n    }\n\n    this.restoreAtMark(mark);\n    return null;\n  };\n\n  Parser.prototype._parseRuleset = function (isNested) {\n    if (isNested === void 0) {\n      isNested = false;\n    }\n\n    var node = this.create(nodes.RuleSet);\n    var selectors = node.getSelectors();\n\n    if (!selectors.addChild(this._parseSelector(isNested))) {\n      return null;\n    }\n\n    while (this.accept(TokenType.Comma)) {\n      if (!selectors.addChild(this._parseSelector(isNested))) {\n        return this.finish(node, ParseError.SelectorExpected);\n      }\n    }\n\n    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));\n  };\n\n  Parser.prototype._parseRuleSetDeclaration = function () {\n    // https://www.w3.org/TR/css-syntax-3/#consume-a-list-of-declarations0\n    return this._parseAtApply() || this._tryParseCustomPropertyDeclaration() || this._parseDeclaration() || this._parseUnknownAtRule();\n  };\n  /**\n   * Parses declarations like:\n   *   @apply --my-theme;\n   *\n   * Follows https://tabatkins.github.io/specs/css-apply-rule/#using\n   */\n\n\n  Parser.prototype._parseAtApply = function () {\n    if (!this.peekKeyword('@apply')) {\n      return null;\n    }\n\n    var node = this.create(nodes.AtApplyRule);\n    this.consumeToken();\n\n    if (!node.setIdentifier(this._parseIdent([nodes.ReferenceType.Variable]))) {\n      return this.finish(node, ParseError.IdentifierExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._needsSemicolonAfter = function (node) {\n    switch (node.type) {\n      case nodes.NodeType.Keyframe:\n      case nodes.NodeType.ViewPort:\n      case nodes.NodeType.Media:\n      case nodes.NodeType.Ruleset:\n      case nodes.NodeType.Namespace:\n      case nodes.NodeType.If:\n      case nodes.NodeType.For:\n      case nodes.NodeType.Each:\n      case nodes.NodeType.While:\n      case nodes.NodeType.MixinDeclaration:\n      case nodes.NodeType.FunctionDeclaration:\n        return false;\n\n      case nodes.NodeType.ExtendsReference:\n      case nodes.NodeType.MixinContent:\n      case nodes.NodeType.ReturnStatement:\n      case nodes.NodeType.MediaQuery:\n      case nodes.NodeType.Debug:\n      case nodes.NodeType.Import:\n      case nodes.NodeType.AtApplyRule:\n      case nodes.NodeType.CustomPropertyDeclaration:\n        return true;\n\n      case nodes.NodeType.VariableDeclaration:\n        return node.needsSemicolon;\n\n      case nodes.NodeType.MixinReference:\n        return !node.getContent();\n\n      case nodes.NodeType.Declaration:\n        return !node.getNestedProperties();\n    }\n\n    return false;\n  };\n\n  Parser.prototype._parseDeclarations = function (parseDeclaration) {\n    var node = this.create(nodes.Declarations);\n\n    if (!this.accept(TokenType.CurlyL)) {\n      return null;\n    }\n\n    var decl = parseDeclaration();\n\n    while (node.addChild(decl)) {\n      if (this.peek(TokenType.CurlyR)) {\n        break;\n      }\n\n      if (this._needsSemicolonAfter(decl) && !this.accept(TokenType.SemiColon)) {\n        return this.finish(node, ParseError.SemiColonExpected, [TokenType.SemiColon, TokenType.CurlyR]);\n      }\n\n      while (this.accept(TokenType.SemiColon)) {// accept empty statements\n      }\n\n      decl = parseDeclaration();\n    }\n\n    if (!this.accept(TokenType.CurlyR)) {\n      return this.finish(node, ParseError.RightCurlyExpected, [TokenType.CurlyR, TokenType.SemiColon]);\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseBody = function (node, parseDeclaration) {\n    if (!node.setDeclarations(this._parseDeclarations(parseDeclaration))) {\n      return this.finish(node, ParseError.LeftCurlyExpected, [TokenType.CurlyR, TokenType.SemiColon]);\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseSelector = function (isNested) {\n    var node = this.create(nodes.Selector);\n    var hasContent = false;\n\n    if (isNested) {\n      // nested selectors can start with a combinator\n      hasContent = node.addChild(this._parseCombinator());\n    }\n\n    while (node.addChild(this._parseSimpleSelector())) {\n      hasContent = true;\n      node.addChild(this._parseCombinator()); // optional\n    }\n\n    return hasContent ? this.finish(node) : null;\n  };\n\n  Parser.prototype._parseDeclaration = function (resyncStopTokens) {\n    var node = this.create(nodes.Declaration);\n\n    if (!node.setProperty(this._parseProperty())) {\n      return null;\n    }\n\n    if (!this.accept(TokenType.Colon)) {\n      return this.finish(node, ParseError.ColonExpected, [TokenType.Colon], resyncStopTokens);\n    }\n\n    node.colonPosition = this.prevToken.offset;\n\n    if (!node.setValue(this._parseExpr())) {\n      return this.finish(node, ParseError.PropertyValueExpected);\n    }\n\n    node.addChild(this._parsePrio());\n\n    if (this.peek(TokenType.SemiColon)) {\n      node.semicolonPosition = this.token.offset; // not part of the declaration, but useful information for code assist\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._tryParseCustomPropertyDeclaration = function () {\n    if (!this.peekRegExp(TokenType.Ident, /^--/)) {\n      return null;\n    }\n\n    var node = this.create(nodes.CustomPropertyDeclaration);\n\n    if (!node.setProperty(this._parseProperty())) {\n      return null;\n    }\n\n    if (!this.accept(TokenType.Colon)) {\n      return this.finish(node, ParseError.ColonExpected, [TokenType.Colon]);\n    }\n\n    node.colonPosition = this.prevToken.offset;\n    var mark = this.mark();\n\n    if (this.peek(TokenType.CurlyL)) {\n      // try to parse it as nested declaration\n      var propertySet = this.create(nodes.CustomPropertySet);\n\n      var declarations = this._parseDeclarations(this._parseRuleSetDeclaration.bind(this));\n\n      if (propertySet.setDeclarations(declarations) && !declarations.isErroneous(true)) {\n        propertySet.addChild(this._parsePrio());\n\n        if (this.peek(TokenType.SemiColon)) {\n          this.finish(propertySet);\n          node.setPropertySet(propertySet);\n          node.semicolonPosition = this.token.offset; // not part of the declaration, but useful information for code assist\n\n          return this.finish(node);\n        }\n      }\n\n      this.restoreAtMark(mark);\n    } // try tp parse as expression\n\n\n    var expression = this._parseExpr();\n\n    if (expression && !expression.isErroneous(true)) {\n      this._parsePrio();\n\n      if (this.peek(TokenType.SemiColon)) {\n        node.setValue(expression);\n        node.semicolonPosition = this.token.offset; // not part of the declaration, but useful information for code assist\n\n        return this.finish(node);\n      }\n    }\n\n    this.restoreAtMark(mark);\n    node.addChild(this._parseCustomPropertyValue());\n    node.addChild(this._parsePrio());\n\n    if (this.token.offset === node.colonPosition + 1) {\n      return this.finish(node, ParseError.PropertyValueExpected);\n    }\n\n    return this.finish(node);\n  };\n  /**\n   * Parse custom property values.\n   *\n   * Based on https://www.w3.org/TR/css-variables/#syntax\n   *\n   * This code is somewhat unusual, as the allowed syntax is incredibly broad,\n   * parsing almost any sequence of tokens, save for a small set of exceptions.\n   * Unbalanced delimitors, invalid tokens, and declaration\n   * terminators like semicolons and !important directives (when not inside\n   * of delimitors).\n   */\n\n\n  Parser.prototype._parseCustomPropertyValue = function () {\n    var node = this.create(nodes.Node);\n\n    var isTopLevel = function () {\n      return curlyDepth === 0 && parensDepth === 0 && bracketsDepth === 0;\n    };\n\n    var curlyDepth = 0;\n    var parensDepth = 0;\n    var bracketsDepth = 0;\n\n    done: while (true) {\n      switch (this.token.type) {\n        case TokenType.SemiColon:\n          // A semicolon only ends things if we're not inside a delimitor.\n          if (isTopLevel()) {\n            break done;\n          }\n\n          break;\n\n        case TokenType.Exclamation:\n          // An exclamation ends the value if we're not inside delims.\n          if (isTopLevel()) {\n            break done;\n          }\n\n          break;\n\n        case TokenType.CurlyL:\n          curlyDepth++;\n          break;\n\n        case TokenType.CurlyR:\n          curlyDepth--;\n\n          if (curlyDepth < 0) {\n            // The property value has been terminated without a semicolon, and\n            // this is the last declaration in the ruleset.\n            if (parensDepth === 0 && bracketsDepth === 0) {\n              break done;\n            }\n\n            return this.finish(node, ParseError.LeftCurlyExpected);\n          }\n\n          break;\n\n        case TokenType.ParenthesisL:\n          parensDepth++;\n          break;\n\n        case TokenType.ParenthesisR:\n          parensDepth--;\n\n          if (parensDepth < 0) {\n            return this.finish(node, ParseError.LeftParenthesisExpected);\n          }\n\n          break;\n\n        case TokenType.BracketL:\n          bracketsDepth++;\n          break;\n\n        case TokenType.BracketR:\n          bracketsDepth--;\n\n          if (bracketsDepth < 0) {\n            return this.finish(node, ParseError.LeftSquareBracketExpected);\n          }\n\n          break;\n\n        case TokenType.BadString:\n          // fall through\n          break done;\n\n        case TokenType.EOF:\n          // We shouldn't have reached the end of input, something is\n          // unterminated.\n          var error = ParseError.RightCurlyExpected;\n\n          if (bracketsDepth > 0) {\n            error = ParseError.RightSquareBracketExpected;\n          } else if (parensDepth > 0) {\n            error = ParseError.RightParenthesisExpected;\n          }\n\n          return this.finish(node, error);\n      }\n\n      this.consumeToken();\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._tryToParseDeclaration = function () {\n    var mark = this.mark();\n\n    if (this._parseProperty() && this.accept(TokenType.Colon)) {\n      // looks like a declaration, go ahead\n      this.restoreAtMark(mark);\n      return this._parseDeclaration();\n    }\n\n    this.restoreAtMark(mark);\n    return null;\n  };\n\n  Parser.prototype._parseProperty = function () {\n    var node = this.create(nodes.Property);\n    var mark = this.mark();\n\n    if (this.acceptDelim('*') || this.acceptDelim('_')) {\n      // support for  IE 5.x, 6 and 7 star hack: see http://en.wikipedia.org/wiki/CSS_filter#Star_hack\n      if (this.hasWhitespace()) {\n        this.restoreAtMark(mark);\n        return null;\n      }\n    }\n\n    if (node.setIdentifier(this._parsePropertyIdentifier())) {\n      return this.finish(node);\n    }\n\n    return null;\n  };\n\n  Parser.prototype._parsePropertyIdentifier = function () {\n    return this._parseIdent();\n  };\n\n  Parser.prototype._parseCharset = function () {\n    if (!this.peek(TokenType.Charset)) {\n      return null;\n    }\n\n    var node = this.create(nodes.Node);\n    this.consumeToken(); // charset\n\n    if (!this.accept(TokenType.String)) {\n      return this.finish(node, ParseError.IdentifierExpected);\n    }\n\n    if (!this.accept(TokenType.SemiColon)) {\n      return this.finish(node, ParseError.SemiColonExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseImport = function () {\n    if (!this.peekKeyword('@import')) {\n      return null;\n    }\n\n    var node = this.create(nodes.Import);\n    this.consumeToken(); // @import\n\n    if (!node.addChild(this._parseURILiteral()) && !node.addChild(this._parseStringLiteral())) {\n      return this.finish(node, ParseError.URIOrStringExpected);\n    }\n\n    if (!this.peek(TokenType.SemiColon) && !this.peek(TokenType.EOF)) {\n      node.setMedialist(this._parseMediaQueryList());\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseNamespace = function () {\n    // http://www.w3.org/TR/css3-namespace/\n    // namespace  : NAMESPACE_SYM S* [IDENT S*]? [STRING|URI] S* ';' S*\n    if (!this.peekKeyword('@namespace')) {\n      return null;\n    }\n\n    var node = this.create(nodes.Namespace);\n    this.consumeToken(); // @namespace\n\n    if (!node.addChild(this._parseURILiteral())) {\n      // url literal also starts with ident\n      node.addChild(this._parseIdent()); // optional prefix\n\n      if (!node.addChild(this._parseURILiteral()) && !node.addChild(this._parseStringLiteral())) {\n        return this.finish(node, ParseError.URIExpected, [TokenType.SemiColon]);\n      }\n    }\n\n    if (!this.accept(TokenType.SemiColon)) {\n      return this.finish(node, ParseError.SemiColonExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseFontFace = function () {\n    if (!this.peekKeyword('@font-face')) {\n      return null;\n    }\n\n    var node = this.create(nodes.FontFace);\n    this.consumeToken(); // @font-face\n\n    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));\n  };\n\n  Parser.prototype._parseViewPort = function () {\n    if (!this.peekKeyword('@-ms-viewport') && !this.peekKeyword('@-o-viewport') && !this.peekKeyword('@viewport')) {\n      return null;\n    }\n\n    var node = this.create(nodes.ViewPort);\n    this.consumeToken(); // @-ms-viewport\n\n    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));\n  };\n\n  Parser.prototype._parseKeyframe = function () {\n    if (!this.peekRegExp(TokenType.AtKeyword, this.keyframeRegex)) {\n      return null;\n    }\n\n    var node = this.create(nodes.Keyframe);\n    var atNode = this.create(nodes.Node);\n    this.consumeToken(); // atkeyword\n\n    node.setKeyword(this.finish(atNode));\n\n    if (atNode.getText() === '@-ms-keyframes') {\n      // -ms-keyframes never existed\n      this.markError(atNode, ParseError.UnknownKeyword);\n    }\n\n    if (!node.setIdentifier(this._parseKeyframeIdent())) {\n      return this.finish(node, ParseError.IdentifierExpected, [TokenType.CurlyR]);\n    }\n\n    return this._parseBody(node, this._parseKeyframeSelector.bind(this));\n  };\n\n  Parser.prototype._parseKeyframeIdent = function () {\n    return this._parseIdent([nodes.ReferenceType.Keyframe]);\n  };\n\n  Parser.prototype._parseKeyframeSelector = function () {\n    var node = this.create(nodes.KeyframeSelector);\n\n    if (!node.addChild(this._parseIdent()) && !this.accept(TokenType.Percentage)) {\n      return null;\n    }\n\n    while (this.accept(TokenType.Comma)) {\n      if (!node.addChild(this._parseIdent()) && !this.accept(TokenType.Percentage)) {\n        return this.finish(node, ParseError.PercentageExpected);\n      }\n    }\n\n    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));\n  };\n\n  Parser.prototype._tryParseKeyframeSelector = function () {\n    var node = this.create(nodes.KeyframeSelector);\n    var pos = this.mark();\n\n    if (!node.addChild(this._parseIdent()) && !this.accept(TokenType.Percentage)) {\n      return null;\n    }\n\n    while (this.accept(TokenType.Comma)) {\n      if (!node.addChild(this._parseIdent()) && !this.accept(TokenType.Percentage)) {\n        this.restoreAtMark(pos);\n        return null;\n      }\n    }\n\n    if (!this.peek(TokenType.CurlyL)) {\n      this.restoreAtMark(pos);\n      return null;\n    }\n\n    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));\n  };\n\n  Parser.prototype._parseSupports = function (isNested) {\n    if (isNested === void 0) {\n      isNested = false;\n    } // SUPPORTS_SYM S* supports_condition '{' S* ruleset* '}' S*\n\n\n    if (!this.peekKeyword('@supports')) {\n      return null;\n    }\n\n    var node = this.create(nodes.Supports);\n    this.consumeToken(); // @supports\n\n    node.addChild(this._parseSupportsCondition());\n    return this._parseBody(node, this._parseSupportsDeclaration.bind(this, isNested));\n  };\n\n  Parser.prototype._parseSupportsDeclaration = function (isNested) {\n    if (isNested === void 0) {\n      isNested = false;\n    }\n\n    if (isNested) {\n      // if nested, the body can contain rulesets, but also declarations\n      return this._tryParseRuleset(true) || this._tryToParseDeclaration() || this._parseStylesheetStatement(true);\n    }\n\n    return this._parseStylesheetStatement(false);\n  };\n\n  Parser.prototype._parseSupportsCondition = function () {\n    // supports_condition : supports_negation | supports_conjunction | supports_disjunction | supports_condition_in_parens ;\n    // supports_condition_in_parens: ( '(' S* supports_condition S* ')' ) | supports_declaration_condition | general_enclosed ;\n    // supports_negation: NOT S+ supports_condition_in_parens ;\n    // supports_conjunction: supports_condition_in_parens ( S+ AND S+ supports_condition_in_parens )+;\n    // supports_disjunction: supports_condition_in_parens ( S+ OR S+ supports_condition_in_parens )+;\n    // supports_declaration_condition: '(' S* declaration ')';\n    // general_enclosed: ( FUNCTION | '(' ) ( any | unused )* ')' ;\n    var node = this.create(nodes.SupportsCondition);\n\n    if (this.acceptIdent('not')) {\n      node.addChild(this._parseSupportsConditionInParens());\n    } else {\n      node.addChild(this._parseSupportsConditionInParens());\n\n      if (this.peekRegExp(TokenType.Ident, /^(and|or)$/i)) {\n        var text = this.token.text.toLowerCase();\n\n        while (this.acceptIdent(text)) {\n          node.addChild(this._parseSupportsConditionInParens());\n        }\n      }\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseSupportsConditionInParens = function () {\n    var node = this.create(nodes.SupportsCondition);\n\n    if (this.accept(TokenType.ParenthesisL)) {\n      node.lParent = this.prevToken.offset;\n\n      if (!node.addChild(this._tryToParseDeclaration())) {\n        if (!this._parseSupportsCondition()) {\n          return this.finish(node, ParseError.ConditionExpected);\n        }\n      }\n\n      if (!this.accept(TokenType.ParenthesisR)) {\n        return this.finish(node, ParseError.RightParenthesisExpected, [TokenType.ParenthesisR], []);\n      }\n\n      node.rParent = this.prevToken.offset;\n      return this.finish(node);\n    } else if (this.peek(TokenType.Ident)) {\n      var pos = this.mark();\n      this.consumeToken();\n\n      if (!this.hasWhitespace() && this.accept(TokenType.ParenthesisL)) {\n        var openParentCount = 1;\n\n        while (this.token.type !== TokenType.EOF && openParentCount !== 0) {\n          if (this.token.type === TokenType.ParenthesisL) {\n            openParentCount++;\n          } else if (this.token.type === TokenType.ParenthesisR) {\n            openParentCount--;\n          }\n\n          this.consumeToken();\n        }\n\n        return this.finish(node);\n      } else {\n        this.restoreAtMark(pos);\n      }\n    }\n\n    return this.finish(node, ParseError.LeftParenthesisExpected, [], [TokenType.ParenthesisL]);\n  };\n\n  Parser.prototype._parseMediaDeclaration = function (isNested) {\n    if (isNested === void 0) {\n      isNested = false;\n    }\n\n    if (isNested) {\n      // if nested, the body can contain rulesets, but also declarations\n      return this._tryParseRuleset(true) || this._tryToParseDeclaration() || this._parseStylesheetStatement(true);\n    }\n\n    return this._parseStylesheetStatement(false);\n  };\n\n  Parser.prototype._parseMedia = function (isNested) {\n    if (isNested === void 0) {\n      isNested = false;\n    } // MEDIA_SYM S* media_query_list '{' S* ruleset* '}' S*\n    // media_query_list : S* [media_query [ ',' S* media_query ]* ]?\n\n\n    if (!this.peekKeyword('@media')) {\n      return null;\n    }\n\n    var node = this.create(nodes.Media);\n    this.consumeToken(); // @media\n\n    if (!node.addChild(this._parseMediaQueryList())) {\n      return this.finish(node, ParseError.MediaQueryExpected);\n    }\n\n    return this._parseBody(node, this._parseMediaDeclaration.bind(this, isNested));\n  };\n\n  Parser.prototype._parseMediaQueryList = function () {\n    var node = this.create(nodes.Medialist);\n\n    if (!node.addChild(this._parseMediaQuery([TokenType.CurlyL]))) {\n      return this.finish(node, ParseError.MediaQueryExpected);\n    }\n\n    while (this.accept(TokenType.Comma)) {\n      if (!node.addChild(this._parseMediaQuery([TokenType.CurlyL]))) {\n        return this.finish(node, ParseError.MediaQueryExpected);\n      }\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseMediaQuery = function (resyncStopToken) {\n    // http://www.w3.org/TR/css3-mediaqueries/\n    // media_query : [ONLY | NOT]? S* IDENT S* [ AND S* expression ]* | expression [ AND S* expression ]*\n    // expression : '(' S* IDENT S* [ ':' S* expr ]? ')' S*\n    var node = this.create(nodes.MediaQuery);\n    var parseExpression = true;\n    var hasContent = false;\n\n    if (!this.peek(TokenType.ParenthesisL)) {\n      if (this.acceptIdent('only') || this.acceptIdent('not')) {// optional\n      }\n\n      if (!node.addChild(this._parseIdent())) {\n        return null;\n      }\n\n      hasContent = true;\n      parseExpression = this.acceptIdent('and');\n    }\n\n    while (parseExpression) {\n      if (!this.accept(TokenType.ParenthesisL)) {\n        if (hasContent) {\n          return this.finish(node, ParseError.LeftParenthesisExpected, [], resyncStopToken);\n        }\n\n        return null;\n      }\n\n      if (!node.addChild(this._parseMediaFeatureName())) {\n        return this.finish(node, ParseError.IdentifierExpected, [], resyncStopToken);\n      }\n\n      if (this.accept(TokenType.Colon)) {\n        if (!node.addChild(this._parseExpr())) {\n          return this.finish(node, ParseError.TermExpected, [], resyncStopToken);\n        }\n      }\n\n      if (!this.accept(TokenType.ParenthesisR)) {\n        return this.finish(node, ParseError.RightParenthesisExpected, [], resyncStopToken);\n      }\n\n      parseExpression = this.acceptIdent('and');\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseMediaFeatureName = function () {\n    return this._parseIdent();\n  };\n\n  Parser.prototype._parseMedium = function () {\n    var node = this.create(nodes.Node);\n\n    if (node.addChild(this._parseIdent())) {\n      return this.finish(node);\n    } else {\n      return null;\n    }\n  };\n\n  Parser.prototype._parsePageDeclaration = function () {\n    return this._parsePageMarginBox() || this._parseRuleSetDeclaration();\n  };\n\n  Parser.prototype._parsePage = function () {\n    // http://www.w3.org/TR/css3-page/\n    // page_rule : PAGE_SYM S* page_selector_list '{' S* page_body '}' S*\n    // page_body :  /* Can be empty */ declaration? [ ';' S* page_body ]? | page_margin_box page_body\n    if (!this.peekKeyword('@page')) {\n      return null;\n    }\n\n    var node = this.create(nodes.Page);\n    this.consumeToken();\n\n    if (node.addChild(this._parsePageSelector())) {\n      while (this.accept(TokenType.Comma)) {\n        if (!node.addChild(this._parsePageSelector())) {\n          return this.finish(node, ParseError.IdentifierExpected);\n        }\n      }\n    }\n\n    return this._parseBody(node, this._parsePageDeclaration.bind(this));\n  };\n\n  Parser.prototype._parsePageMarginBox = function () {\n    // page_margin_box :  margin_sym S* '{' S* declaration? [ ';' S* declaration? ]* '}' S*\n    if (!this.peek(TokenType.AtKeyword)) {\n      return null;\n    }\n\n    var node = this.create(nodes.PageBoxMarginBox);\n\n    if (!this.acceptOneKeyword(languageFacts.pageBoxDirectives)) {\n      this.markError(node, ParseError.UnknownAtRule, [], [TokenType.CurlyL]);\n    }\n\n    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));\n  };\n\n  Parser.prototype._parsePageSelector = function () {\n    // page_selector : pseudo_page+ | IDENT pseudo_page*\n    // pseudo_page :  ':' [ \"left\" | \"right\" | \"first\" | \"blank\" ];\n    if (!this.peek(TokenType.Ident) && !this.peek(TokenType.Colon)) {\n      return null;\n    }\n\n    var node = this.create(nodes.Node);\n    node.addChild(this._parseIdent()); // optional ident\n\n    if (this.accept(TokenType.Colon)) {\n      if (!node.addChild(this._parseIdent())) {\n        // optional ident\n        return this.finish(node, ParseError.IdentifierExpected);\n      }\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseDocument = function () {\n    // -moz-document is experimental but has been pushed to css4\n    if (!this.peekKeyword('@-moz-document')) {\n      return null;\n    }\n\n    var node = this.create(nodes.Document);\n    this.consumeToken(); // @-moz-document\n\n    this.resync([], [TokenType.CurlyL]); // ignore all the rules\n\n    return this._parseBody(node, this._parseStylesheetStatement.bind(this));\n  }; // https://www.w3.org/TR/css-syntax-3/#consume-an-at-rule\n\n\n  Parser.prototype._parseUnknownAtRule = function () {\n    if (!this.peek(TokenType.AtKeyword)) {\n      return null;\n    }\n\n    var node = this.create(nodes.UnknownAtRule);\n    node.addChild(this._parseUnknownAtRuleName());\n\n    var isTopLevel = function () {\n      return curlyDepth === 0 && parensDepth === 0 && bracketsDepth === 0;\n    };\n\n    var curlyLCount = 0;\n    var curlyDepth = 0;\n    var parensDepth = 0;\n    var bracketsDepth = 0;\n\n    done: while (true) {\n      switch (this.token.type) {\n        case TokenType.SemiColon:\n          if (isTopLevel()) {\n            break done;\n          }\n\n          break;\n\n        case TokenType.EOF:\n          if (curlyDepth > 0) {\n            return this.finish(node, ParseError.RightCurlyExpected);\n          } else if (bracketsDepth > 0) {\n            return this.finish(node, ParseError.RightSquareBracketExpected);\n          } else if (parensDepth > 0) {\n            return this.finish(node, ParseError.RightParenthesisExpected);\n          } else {\n            return this.finish(node);\n          }\n\n        case TokenType.CurlyL:\n          curlyLCount++;\n          curlyDepth++;\n          break;\n\n        case TokenType.CurlyR:\n          curlyDepth--; // End of at-rule, consume CurlyR and return node\n\n          if (curlyLCount > 0 && curlyDepth === 0) {\n            this.consumeToken();\n\n            if (bracketsDepth > 0) {\n              return this.finish(node, ParseError.RightSquareBracketExpected);\n            } else if (parensDepth > 0) {\n              return this.finish(node, ParseError.RightParenthesisExpected);\n            }\n\n            break done;\n          }\n\n          if (curlyDepth < 0) {\n            // The property value has been terminated without a semicolon, and\n            // this is the last declaration in the ruleset.\n            if (parensDepth === 0 && bracketsDepth === 0) {\n              break done;\n            }\n\n            return this.finish(node, ParseError.LeftCurlyExpected);\n          }\n\n          break;\n\n        case TokenType.ParenthesisL:\n          parensDepth++;\n          break;\n\n        case TokenType.ParenthesisR:\n          parensDepth--;\n\n          if (parensDepth < 0) {\n            return this.finish(node, ParseError.LeftParenthesisExpected);\n          }\n\n          break;\n\n        case TokenType.BracketL:\n          bracketsDepth++;\n          break;\n\n        case TokenType.BracketR:\n          bracketsDepth--;\n\n          if (bracketsDepth < 0) {\n            return this.finish(node, ParseError.LeftSquareBracketExpected);\n          }\n\n          break;\n      }\n\n      this.consumeToken();\n    }\n\n    return node;\n  };\n\n  Parser.prototype._parseUnknownAtRuleName = function () {\n    var node = this.create(nodes.Node);\n\n    if (this.accept(TokenType.AtKeyword)) {\n      return this.finish(node);\n    }\n\n    return node;\n  };\n\n  Parser.prototype._parseOperator = function () {\n    // these are operators for binary expressions\n    if (this.peekDelim('/') || this.peekDelim('*') || this.peekDelim('+') || this.peekDelim('-') || this.peek(TokenType.Dashmatch) || this.peek(TokenType.Includes) || this.peek(TokenType.SubstringOperator) || this.peek(TokenType.PrefixOperator) || this.peek(TokenType.SuffixOperator) || this.peekDelim('=')) {\n      // doesn't stick to the standard here\n      var node = this.createNode(nodes.NodeType.Operator);\n      this.consumeToken();\n      return this.finish(node);\n    } else {\n      return null;\n    }\n  };\n\n  Parser.prototype._parseUnaryOperator = function () {\n    if (!this.peekDelim('+') && !this.peekDelim('-')) {\n      return null;\n    }\n\n    var node = this.create(nodes.Node);\n    this.consumeToken();\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseCombinator = function () {\n    if (this.peekDelim('>')) {\n      var node = this.create(nodes.Node);\n      this.consumeToken();\n      var mark = this.mark();\n\n      if (!this.hasWhitespace() && this.acceptDelim('>')) {\n        if (!this.hasWhitespace() && this.acceptDelim('>')) {\n          node.type = nodes.NodeType.SelectorCombinatorShadowPiercingDescendant;\n          return this.finish(node);\n        }\n\n        this.restoreAtMark(mark);\n      }\n\n      node.type = nodes.NodeType.SelectorCombinatorParent;\n      return this.finish(node);\n    } else if (this.peekDelim('+')) {\n      var node = this.create(nodes.Node);\n      this.consumeToken();\n      node.type = nodes.NodeType.SelectorCombinatorSibling;\n      return this.finish(node);\n    } else if (this.peekDelim('~')) {\n      var node = this.create(nodes.Node);\n      this.consumeToken();\n      node.type = nodes.NodeType.SelectorCombinatorAllSiblings;\n      return this.finish(node);\n    } else if (this.peekDelim('/')) {\n      var node = this.create(nodes.Node);\n      this.consumeToken();\n      var mark = this.mark();\n\n      if (!this.hasWhitespace() && this.acceptIdent('deep') && !this.hasWhitespace() && this.acceptDelim('/')) {\n        node.type = nodes.NodeType.SelectorCombinatorShadowPiercingDescendant;\n        return this.finish(node);\n      }\n\n      this.restoreAtMark(mark);\n    } else {\n      return null;\n    }\n  };\n\n  Parser.prototype._parseSimpleSelector = function () {\n    // simple_selector\n    //  : element_name [ HASH | class | attrib | pseudo ]* | [ HASH | class | attrib | pseudo ]+ ;\n    var node = this.create(nodes.SimpleSelector);\n    var c = 0;\n\n    if (node.addChild(this._parseElementName())) {\n      c++;\n    }\n\n    while ((c === 0 || !this.hasWhitespace()) && node.addChild(this._parseSimpleSelectorBody())) {\n      c++;\n    }\n\n    return c > 0 ? this.finish(node) : null;\n  };\n\n  Parser.prototype._parseSimpleSelectorBody = function () {\n    return this._parsePseudo() || this._parseHash() || this._parseClass() || this._parseAttrib();\n  };\n\n  Parser.prototype._parseSelectorIdent = function () {\n    return this._parseIdent();\n  };\n\n  Parser.prototype._parseHash = function () {\n    if (!this.peek(TokenType.Hash) && !this.peekDelim('#')) {\n      return null;\n    }\n\n    var node = this.createNode(nodes.NodeType.IdentifierSelector);\n\n    if (this.acceptDelim('#')) {\n      if (this.hasWhitespace() || !node.addChild(this._parseSelectorIdent())) {\n        return this.finish(node, ParseError.IdentifierExpected);\n      }\n    } else {\n      this.consumeToken(); // TokenType.Hash\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseClass = function () {\n    // class: '.' IDENT ;\n    if (!this.peekDelim('.')) {\n      return null;\n    }\n\n    var node = this.createNode(nodes.NodeType.ClassSelector);\n    this.consumeToken(); // '.'\n\n    if (this.hasWhitespace() || !node.addChild(this._parseSelectorIdent())) {\n      return this.finish(node, ParseError.IdentifierExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseElementName = function () {\n    // element_name: (ns? '|')? IDENT | '*';\n    var pos = this.mark();\n    var node = this.createNode(nodes.NodeType.ElementNameSelector);\n    node.addChild(this._parseNamespacePrefix());\n\n    if (!node.addChild(this._parseSelectorIdent()) && !this.acceptDelim('*')) {\n      this.restoreAtMark(pos);\n      return null;\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseNamespacePrefix = function () {\n    var pos = this.mark();\n    var node = this.createNode(nodes.NodeType.NamespacePrefix);\n\n    if (!node.addChild(this._parseIdent()) && !this.acceptDelim('*')) {// ns is optional\n    }\n\n    if (!this.acceptDelim('|')) {\n      this.restoreAtMark(pos);\n      return null;\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseAttrib = function () {\n    // attrib : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*   [ IDENT | STRING ] S* ]? ']'\n    if (!this.peek(TokenType.BracketL)) {\n      return null;\n    }\n\n    var node = this.create(nodes.AttributeSelector);\n    this.consumeToken(); // BracketL\n    // Optional attrib namespace\n\n    node.setNamespacePrefix(this._parseNamespacePrefix());\n\n    if (!node.setIdentifier(this._parseIdent())) {\n      return this.finish(node, ParseError.IdentifierExpected);\n    }\n\n    if (node.setOperator(this._parseOperator())) {\n      node.setValue(this._parseBinaryExpr());\n      this.acceptIdent('i'); // case insensitive matching\n    }\n\n    if (!this.accept(TokenType.BracketR)) {\n      return this.finish(node, ParseError.RightSquareBracketExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parsePseudo = function () {\n    var _this = this; // pseudo: ':' [ IDENT | FUNCTION S* [IDENT S*]? ')' ]\n\n\n    var node = this._tryParsePseudoIdentifier();\n\n    if (node) {\n      if (!this.hasWhitespace() && this.accept(TokenType.ParenthesisL)) {\n        var tryAsSelector = function () {\n          var selectors = _this.create(nodes.Node);\n\n          if (!selectors.addChild(_this._parseSelector(false))) {\n            return null;\n          }\n\n          while (_this.accept(TokenType.Comma) && selectors.addChild(_this._parseSelector(false))) {// loop\n          }\n\n          if (_this.peek(TokenType.ParenthesisR)) {\n            return _this.finish(selectors);\n          }\n        };\n\n        node.addChild(this.try(tryAsSelector) || this._parseBinaryExpr());\n\n        if (!this.accept(TokenType.ParenthesisR)) {\n          return this.finish(node, ParseError.RightParenthesisExpected);\n        }\n      }\n\n      return this.finish(node);\n    }\n\n    return null;\n  };\n\n  Parser.prototype._tryParsePseudoIdentifier = function () {\n    if (!this.peek(TokenType.Colon)) {\n      return null;\n    }\n\n    var pos = this.mark();\n    var node = this.createNode(nodes.NodeType.PseudoSelector);\n    this.consumeToken(); // Colon\n\n    if (this.hasWhitespace()) {\n      this.restoreAtMark(pos);\n      return null;\n    } // optional, support ::\n\n\n    if (this.accept(TokenType.Colon) && this.hasWhitespace()) {\n      this.markError(node, ParseError.IdentifierExpected);\n    }\n\n    if (!node.addChild(this._parseIdent())) {\n      this.markError(node, ParseError.IdentifierExpected);\n    }\n\n    return node;\n  };\n\n  Parser.prototype._tryParsePrio = function () {\n    var mark = this.mark();\n\n    var prio = this._parsePrio();\n\n    if (prio) {\n      return prio;\n    }\n\n    this.restoreAtMark(mark);\n    return null;\n  };\n\n  Parser.prototype._parsePrio = function () {\n    if (!this.peek(TokenType.Exclamation)) {\n      return null;\n    }\n\n    var node = this.createNode(nodes.NodeType.Prio);\n\n    if (this.accept(TokenType.Exclamation) && this.acceptIdent('important')) {\n      return this.finish(node);\n    }\n\n    return null;\n  };\n\n  Parser.prototype._parseExpr = function (stopOnComma) {\n    if (stopOnComma === void 0) {\n      stopOnComma = false;\n    }\n\n    var node = this.create(nodes.Expression);\n\n    if (!node.addChild(this._parseBinaryExpr())) {\n      return null;\n    }\n\n    while (true) {\n      if (this.peek(TokenType.Comma)) {\n        // optional\n        if (stopOnComma) {\n          return this.finish(node);\n        }\n\n        this.consumeToken();\n      }\n\n      if (!node.addChild(this._parseBinaryExpr())) {\n        break;\n      }\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseNamedLine = function () {\n    // https://www.w3.org/TR/css-grid-1/#named-lines\n    if (!this.peek(TokenType.BracketL)) {\n      return null;\n    }\n\n    var node = this.createNode(nodes.NodeType.GridLine);\n    this.consumeToken();\n\n    while (node.addChild(this._parseIdent())) {// repeat\n    }\n\n    if (!this.accept(TokenType.BracketR)) {\n      return this.finish(node, ParseError.RightSquareBracketExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseBinaryExpr = function (preparsedLeft, preparsedOper) {\n    var node = this.create(nodes.BinaryExpression);\n\n    if (!node.setLeft(preparsedLeft || this._parseTerm())) {\n      return null;\n    }\n\n    if (!node.setOperator(preparsedOper || this._parseOperator())) {\n      return this.finish(node);\n    }\n\n    if (!node.setRight(this._parseTerm())) {\n      return this.finish(node, ParseError.TermExpected);\n    } // things needed for multiple binary expressions\n\n\n    node = this.finish(node);\n\n    var operator = this._parseOperator();\n\n    if (operator) {\n      node = this._parseBinaryExpr(node, operator);\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseTerm = function () {\n    var node = this.create(nodes.Term);\n    node.setOperator(this._parseUnaryOperator()); // optional\n\n    if (node.setExpression(this._parseURILiteral()) || // url before function\n    node.setExpression(this._parseFunction()) || // function before ident\n    node.setExpression(this._parseIdent()) || node.setExpression(this._parseStringLiteral()) || node.setExpression(this._parseNumeric()) || node.setExpression(this._parseHexColor()) || node.setExpression(this._parseOperation()) || node.setExpression(this._parseNamedLine())) {\n      return this.finish(node);\n    }\n\n    return null;\n  };\n\n  Parser.prototype._parseOperation = function () {\n    if (!this.peek(TokenType.ParenthesisL)) {\n      return null;\n    }\n\n    var node = this.create(nodes.Node);\n    this.consumeToken(); // ParenthesisL\n\n    node.addChild(this._parseExpr());\n\n    if (!this.accept(TokenType.ParenthesisR)) {\n      return this.finish(node, ParseError.RightParenthesisExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseNumeric = function () {\n    if (this.peek(TokenType.Num) || this.peek(TokenType.Percentage) || this.peek(TokenType.Resolution) || this.peek(TokenType.Length) || this.peek(TokenType.EMS) || this.peek(TokenType.EXS) || this.peek(TokenType.Angle) || this.peek(TokenType.Time) || this.peek(TokenType.Dimension) || this.peek(TokenType.Freq)) {\n      var node = this.create(nodes.NumericValue);\n      this.consumeToken();\n      return this.finish(node);\n    }\n\n    return null;\n  };\n\n  Parser.prototype._parseStringLiteral = function () {\n    if (!this.peek(TokenType.String) && !this.peek(TokenType.BadString)) {\n      return null;\n    }\n\n    var node = this.createNode(nodes.NodeType.StringLiteral);\n    this.consumeToken();\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseURILiteral = function () {\n    if (!this.peekRegExp(TokenType.Ident, /^url(-prefix)?$/i)) {\n      return null;\n    }\n\n    var pos = this.mark();\n    var node = this.createNode(nodes.NodeType.URILiteral);\n    this.accept(TokenType.Ident);\n\n    if (this.hasWhitespace() || !this.peek(TokenType.ParenthesisL)) {\n      this.restoreAtMark(pos);\n      return null;\n    }\n\n    this.scanner.inURL = true;\n    this.consumeToken(); // consume ()\n\n    node.addChild(this._parseURLArgument()); // argument is optional\n\n    this.scanner.inURL = false;\n\n    if (!this.accept(TokenType.ParenthesisR)) {\n      return this.finish(node, ParseError.RightParenthesisExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseURLArgument = function () {\n    var node = this.create(nodes.Node);\n\n    if (!this.accept(TokenType.String) && !this.accept(TokenType.BadString) && !this.acceptUnquotedString()) {\n      return null;\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseIdent = function (referenceTypes) {\n    if (!this.peek(TokenType.Ident)) {\n      return null;\n    }\n\n    var node = this.create(nodes.Identifier);\n\n    if (referenceTypes) {\n      node.referenceTypes = referenceTypes;\n    }\n\n    node.isCustomProperty = this.peekRegExp(TokenType.Ident, /^--/);\n    this.consumeToken();\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseFunction = function () {\n    var pos = this.mark();\n    var node = this.create(nodes.Function);\n\n    if (!node.setIdentifier(this._parseFunctionIdentifier())) {\n      return null;\n    }\n\n    if (this.hasWhitespace() || !this.accept(TokenType.ParenthesisL)) {\n      this.restoreAtMark(pos);\n      return null;\n    }\n\n    if (node.getArguments().addChild(this._parseFunctionArgument())) {\n      while (this.accept(TokenType.Comma)) {\n        if (this.peek(TokenType.ParenthesisR)) {\n          break;\n        }\n\n        if (!node.getArguments().addChild(this._parseFunctionArgument())) {\n          this.markError(node, ParseError.ExpressionExpected);\n        }\n      }\n    }\n\n    if (!this.accept(TokenType.ParenthesisR)) {\n      return this.finish(node, ParseError.RightParenthesisExpected);\n    }\n\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseFunctionIdentifier = function () {\n    if (!this.peek(TokenType.Ident)) {\n      return null;\n    }\n\n    var node = this.create(nodes.Identifier);\n    node.referenceTypes = [nodes.ReferenceType.Function];\n\n    if (this.acceptIdent('progid')) {\n      // support for IE7 specific filters: 'progid:DXImageTransform.Microsoft.MotionBlur(strength=13, direction=310)'\n      if (this.accept(TokenType.Colon)) {\n        while (this.accept(TokenType.Ident) && this.acceptDelim('.')) {// loop\n        }\n      }\n\n      return this.finish(node);\n    }\n\n    this.consumeToken();\n    return this.finish(node);\n  };\n\n  Parser.prototype._parseFunctionArgument = function () {\n    var node = this.create(nodes.FunctionArgument);\n\n    if (node.setValue(this._parseExpr(true))) {\n      return this.finish(node);\n    }\n\n    return null;\n  };\n\n  Parser.prototype._parseHexColor = function () {\n    if (this.peekRegExp(TokenType.Hash, /^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{4}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/g)) {\n      var node = this.create(nodes.HexColorValue);\n      this.consumeToken();\n      return this.finish(node);\n    } else {\n      return null;\n    }\n  };\n\n  return Parser;\n}();\n\nexport { Parser };","map":null,"metadata":{},"sourceType":"module"}