{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n\nvar LineDecoration =\n/** @class */\nfunction () {\n  function LineDecoration(startColumn, endColumn, className, type) {\n    this.startColumn = startColumn;\n    this.endColumn = endColumn;\n    this.className = className;\n    this.type = type;\n  }\n\n  LineDecoration._equals = function (a, b) {\n    return a.startColumn === b.startColumn && a.endColumn === b.endColumn && a.className === b.className && a.type === b.type;\n  };\n\n  LineDecoration.equalsArr = function (a, b) {\n    var aLen = a.length;\n    var bLen = b.length;\n\n    if (aLen !== bLen) {\n      return false;\n    }\n\n    for (var i = 0; i < aLen; i++) {\n      if (!LineDecoration._equals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  LineDecoration.filter = function (lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n    if (lineDecorations.length === 0) {\n      return [];\n    }\n\n    var result = [],\n        resultLen = 0;\n\n    for (var i = 0, len = lineDecorations.length; i < len; i++) {\n      var d = lineDecorations[i];\n      var range = d.range;\n\n      if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n        // Ignore decorations that sit outside this line\n        continue;\n      }\n\n      if (range.isEmpty() && (d.type === 0\n      /* Regular */\n      || d.type === 3\n      /* RegularAffectingLetterSpacing */\n      )) {\n        // Ignore empty range decorations\n        continue;\n      }\n\n      var startColumn = range.startLineNumber === lineNumber ? range.startColumn : minLineColumn;\n      var endColumn = range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn;\n      result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n    }\n\n    return result;\n  };\n\n  LineDecoration.compare = function (a, b) {\n    if (a.startColumn === b.startColumn) {\n      if (a.endColumn === b.endColumn) {\n        if (a.className < b.className) {\n          return -1;\n        }\n\n        if (a.className > b.className) {\n          return 1;\n        }\n\n        return 0;\n      }\n\n      return a.endColumn - b.endColumn;\n    }\n\n    return a.startColumn - b.startColumn;\n  };\n\n  return LineDecoration;\n}();\n\nexport { LineDecoration };\n\nvar DecorationSegment =\n/** @class */\nfunction () {\n  function DecorationSegment(startOffset, endOffset, className) {\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    this.className = className;\n  }\n\n  return DecorationSegment;\n}();\n\nexport { DecorationSegment };\n\nvar Stack =\n/** @class */\nfunction () {\n  function Stack() {\n    this.stopOffsets = [];\n    this.classNames = [];\n    this.count = 0;\n  }\n\n  Stack.prototype.consumeLowerThan = function (maxStopOffset, nextStartOffset, result) {\n    while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n      var i = 0; // Take all equal stopping offsets\n\n      while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n        i++;\n      } // Basically we are consuming the first i + 1 elements of the stack\n\n\n      result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' ')));\n      nextStartOffset = this.stopOffsets[i] + 1; // Consume them\n\n      this.stopOffsets.splice(0, i + 1);\n      this.classNames.splice(0, i + 1);\n      this.count -= i + 1;\n    }\n\n    if (this.count > 0 && nextStartOffset < maxStopOffset) {\n      result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' ')));\n      nextStartOffset = maxStopOffset;\n    }\n\n    return nextStartOffset;\n  };\n\n  Stack.prototype.insert = function (stopOffset, className) {\n    if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n      // Insert at the end\n      this.stopOffsets.push(stopOffset);\n      this.classNames.push(className);\n    } else {\n      // Find the insertion position for `stopOffset`\n      for (var i = 0; i < this.count; i++) {\n        if (this.stopOffsets[i] >= stopOffset) {\n          this.stopOffsets.splice(i, 0, stopOffset);\n          this.classNames.splice(i, 0, className);\n          break;\n        }\n      }\n    }\n\n    this.count++;\n    return;\n  };\n\n  return Stack;\n}();\n\nvar LineDecorationsNormalizer =\n/** @class */\nfunction () {\n  function LineDecorationsNormalizer() {}\n  /**\n   * Normalize line decorations. Overlapping decorations will generate multiple segments\n   */\n\n\n  LineDecorationsNormalizer.normalize = function (lineContent, lineDecorations) {\n    if (lineDecorations.length === 0) {\n      return [];\n    }\n\n    var result = [];\n    var stack = new Stack();\n    var nextStartOffset = 0;\n\n    for (var i = 0, len = lineDecorations.length; i < len; i++) {\n      var d = lineDecorations[i];\n      var startColumn = d.startColumn;\n      var endColumn = d.endColumn;\n      var className = d.className; // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n\n      if (startColumn > 1) {\n        var charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n\n        if (strings.isHighSurrogate(charCodeBefore)) {\n          startColumn--;\n        }\n      }\n\n      if (endColumn > 1) {\n        var charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n\n        if (strings.isHighSurrogate(charCodeBefore)) {\n          endColumn--;\n        }\n      }\n\n      var currentStartOffset = startColumn - 1;\n      var currentEndOffset = endColumn - 2;\n      nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n\n      if (stack.count === 0) {\n        nextStartOffset = currentStartOffset;\n      }\n\n      stack.insert(currentEndOffset, className);\n    }\n\n    stack.consumeLowerThan(1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    , nextStartOffset, result);\n    return result;\n  };\n\n  return LineDecorationsNormalizer;\n}();\n\nexport { LineDecorationsNormalizer };","map":null,"metadata":{},"sourceType":"module"}