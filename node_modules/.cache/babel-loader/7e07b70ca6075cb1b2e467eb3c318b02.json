{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict'; // Allow for running under nodejs/requirejs in tests\n\nvar _monaco = typeof monaco === 'undefined' ? self.monaco : monaco;\n\nvar EMPTY_ELEMENTS = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'];\nexport var conf = {\n  wordPattern: /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\$\\^\\&\\*\\(\\)\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\s]+)/g,\n  comments: {\n    blockComment: ['<!--', '-->']\n  },\n  brackets: [['<!--', '-->'], ['<', '>'], ['{', '}'], ['(', ')']],\n  autoClosingPairs: [{\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: '\\'',\n    close: '\\''\n  }],\n  surroundingPairs: [{\n    open: '\"',\n    close: '\"'\n  }, {\n    open: '\\'',\n    close: '\\''\n  }, {\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: '<',\n    close: '>'\n  }],\n  onEnterRules: [{\n    beforeText: new RegExp(\"<(?!(?:\" + EMPTY_ELEMENTS.join('|') + \"))([_:\\\\w][_:\\\\w-.\\\\d]*)([^/>]*(?!/)>)[^<]*$\", 'i'),\n    afterText: /^<\\/([_:\\w][_:\\w-.\\d]*)\\s*>$/i,\n    action: {\n      indentAction: _monaco.languages.IndentAction.IndentOutdent\n    }\n  }, {\n    beforeText: new RegExp(\"<(?!(?:\" + EMPTY_ELEMENTS.join('|') + \"))(\\\\w[\\\\w\\\\d]*)([^/>]*(?!/)>)[^<]*$\", 'i'),\n    action: {\n      indentAction: _monaco.languages.IndentAction.Indent\n    }\n  }],\n  folding: {\n    markers: {\n      start: new RegExp(\"^\\\\s*<!--\\\\s*#region\\\\b.*-->\"),\n      end: new RegExp(\"^\\\\s*<!--\\\\s*#endregion\\\\b.*-->\")\n    }\n  }\n};\nexport var language = {\n  defaultToken: '',\n  tokenPostfix: '.html',\n  ignoreCase: true,\n  // The main tokenizer for our languages\n  tokenizer: {\n    root: [[/<!DOCTYPE/, 'metatag', '@doctype'], [/<!--/, 'comment', '@comment'], [/(<)((?:[\\w\\-]+:)?[\\w\\-]+)(\\s*)(\\/>)/, ['delimiter', 'tag', '', 'delimiter']], [/(<)(script)/, ['delimiter', {\n      token: 'tag',\n      next: '@script'\n    }]], [/(<)(style)/, ['delimiter', {\n      token: 'tag',\n      next: '@style'\n    }]], [/(<)((?:[\\w\\-]+:)?[\\w\\-]+)/, ['delimiter', {\n      token: 'tag',\n      next: '@otherTag'\n    }]], [/(<\\/)((?:[\\w\\-]+:)?[\\w\\-]+)/, ['delimiter', {\n      token: 'tag',\n      next: '@otherTag'\n    }]], [/</, 'delimiter'], [/[^<]+/]],\n    doctype: [[/[^>]+/, 'metatag.content'], [/>/, 'metatag', '@pop']],\n    comment: [[/-->/, 'comment', '@pop'], [/[^-]+/, 'comment.content'], [/./, 'comment.content']],\n    otherTag: [[/\\/?>/, 'delimiter', '@pop'], [/\"([^\"]*)\"/, 'attribute.value'], [/'([^']*)'/, 'attribute.value'], [/[\\w\\-]+/, 'attribute.name'], [/=/, 'delimiter'], [/[ \\t\\r\\n]+/]],\n    // -- BEGIN <script> tags handling\n    // After <script\n    script: [[/type/, 'attribute.name', '@scriptAfterType'], [/\"([^\"]*)\"/, 'attribute.value'], [/'([^']*)'/, 'attribute.value'], [/[\\w\\-]+/, 'attribute.name'], [/=/, 'delimiter'], [/>/, {\n      token: 'delimiter',\n      next: '@scriptEmbedded',\n      nextEmbedded: 'text/javascript'\n    }], [/[ \\t\\r\\n]+/], [/(<\\/)(script\\s*)(>)/, ['delimiter', 'tag', {\n      token: 'delimiter',\n      next: '@pop'\n    }]]],\n    // After <script ... type\n    scriptAfterType: [[/=/, 'delimiter', '@scriptAfterTypeEquals'], [/>/, {\n      token: 'delimiter',\n      next: '@scriptEmbedded',\n      nextEmbedded: 'text/javascript'\n    }], [/[ \\t\\r\\n]+/], [/<\\/script\\s*>/, {\n      token: '@rematch',\n      next: '@pop'\n    }]],\n    // After <script ... type =\n    scriptAfterTypeEquals: [[/\"([^\"]*)\"/, {\n      token: 'attribute.value',\n      switchTo: '@scriptWithCustomType.$1'\n    }], [/'([^']*)'/, {\n      token: 'attribute.value',\n      switchTo: '@scriptWithCustomType.$1'\n    }], [/>/, {\n      token: 'delimiter',\n      next: '@scriptEmbedded',\n      nextEmbedded: 'text/javascript'\n    }], [/[ \\t\\r\\n]+/], [/<\\/script\\s*>/, {\n      token: '@rematch',\n      next: '@pop'\n    }]],\n    // After <script ... type = $S2\n    scriptWithCustomType: [[/>/, {\n      token: 'delimiter',\n      next: '@scriptEmbedded.$S2',\n      nextEmbedded: '$S2'\n    }], [/\"([^\"]*)\"/, 'attribute.value'], [/'([^']*)'/, 'attribute.value'], [/[\\w\\-]+/, 'attribute.name'], [/=/, 'delimiter'], [/[ \\t\\r\\n]+/], [/<\\/script\\s*>/, {\n      token: '@rematch',\n      next: '@pop'\n    }]],\n    scriptEmbedded: [[/<\\/script/, {\n      token: '@rematch',\n      next: '@pop',\n      nextEmbedded: '@pop'\n    }], [/[^<]+/, '']],\n    // -- END <script> tags handling\n    // -- BEGIN <style> tags handling\n    // After <style\n    style: [[/type/, 'attribute.name', '@styleAfterType'], [/\"([^\"]*)\"/, 'attribute.value'], [/'([^']*)'/, 'attribute.value'], [/[\\w\\-]+/, 'attribute.name'], [/=/, 'delimiter'], [/>/, {\n      token: 'delimiter',\n      next: '@styleEmbedded',\n      nextEmbedded: 'text/css'\n    }], [/[ \\t\\r\\n]+/], [/(<\\/)(style\\s*)(>)/, ['delimiter', 'tag', {\n      token: 'delimiter',\n      next: '@pop'\n    }]]],\n    // After <style ... type\n    styleAfterType: [[/=/, 'delimiter', '@styleAfterTypeEquals'], [/>/, {\n      token: 'delimiter',\n      next: '@styleEmbedded',\n      nextEmbedded: 'text/css'\n    }], [/[ \\t\\r\\n]+/], [/<\\/style\\s*>/, {\n      token: '@rematch',\n      next: '@pop'\n    }]],\n    // After <style ... type =\n    styleAfterTypeEquals: [[/\"([^\"]*)\"/, {\n      token: 'attribute.value',\n      switchTo: '@styleWithCustomType.$1'\n    }], [/'([^']*)'/, {\n      token: 'attribute.value',\n      switchTo: '@styleWithCustomType.$1'\n    }], [/>/, {\n      token: 'delimiter',\n      next: '@styleEmbedded',\n      nextEmbedded: 'text/css'\n    }], [/[ \\t\\r\\n]+/], [/<\\/style\\s*>/, {\n      token: '@rematch',\n      next: '@pop'\n    }]],\n    // After <style ... type = $S2\n    styleWithCustomType: [[/>/, {\n      token: 'delimiter',\n      next: '@styleEmbedded.$S2',\n      nextEmbedded: '$S2'\n    }], [/\"([^\"]*)\"/, 'attribute.value'], [/'([^']*)'/, 'attribute.value'], [/[\\w\\-]+/, 'attribute.name'], [/=/, 'delimiter'], [/[ \\t\\r\\n]+/], [/<\\/style\\s*>/, {\n      token: '@rematch',\n      next: '@pop'\n    }]],\n    styleEmbedded: [[/<\\/style/, {\n      token: '@rematch',\n      next: '@pop',\n      nextEmbedded: '@pop'\n    }], [/[^<]+/, '']]\n  }\n};","map":null,"metadata":{},"sourceType":"module"}