{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport * as viewEvents from '../view/viewEvents.js';\nimport { PrefixSumComputerWithCache } from './prefixSumComputer.js';\nimport { ViewLineData } from './viewModel.js';\n\nvar OutputPosition =\n/** @class */\nfunction () {\n  function OutputPosition(outputLineIndex, outputOffset) {\n    this.outputLineIndex = outputLineIndex;\n    this.outputOffset = outputOffset;\n  }\n\n  return OutputPosition;\n}();\n\nexport { OutputPosition };\n\nvar CoordinatesConverter =\n/** @class */\nfunction () {\n  function CoordinatesConverter(lines) {\n    this._lines = lines;\n  } // View -> Model conversion and related methods\n\n\n  CoordinatesConverter.prototype.convertViewPositionToModelPosition = function (viewPosition) {\n    return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n  };\n\n  CoordinatesConverter.prototype.convertViewRangeToModelRange = function (viewRange) {\n    var start = this._lines.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n\n    var end = this._lines.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  };\n\n  CoordinatesConverter.prototype.validateViewPosition = function (viewPosition, expectedModelPosition) {\n    return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n  };\n\n  CoordinatesConverter.prototype.validateViewRange = function (viewRange, expectedModelRange) {\n    var validViewStart = this._lines.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n\n    var validViewEnd = this._lines.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n\n    return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n  }; // Model -> View conversion and related methods\n\n\n  CoordinatesConverter.prototype.convertModelPositionToViewPosition = function (modelPosition) {\n    return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);\n  };\n\n  CoordinatesConverter.prototype.convertModelRangeToViewRange = function (modelRange) {\n    var start = this._lines.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);\n\n    var end = this._lines.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);\n\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  };\n\n  CoordinatesConverter.prototype.modelPositionIsVisible = function (modelPosition) {\n    return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n  };\n\n  return CoordinatesConverter;\n}();\n\nexport { CoordinatesConverter };\n\nvar SplitLinesCollection =\n/** @class */\nfunction () {\n  function SplitLinesCollection(model, linePositionMapperFactory, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent) {\n    this.model = model;\n    this._validModelVersionId = -1;\n    this.tabSize = tabSize;\n    this.wrappingColumn = wrappingColumn;\n    this.columnsForFullWidthChar = columnsForFullWidthChar;\n    this.wrappingIndent = wrappingIndent;\n    this.linePositionMapperFactory = linePositionMapperFactory;\n\n    this._constructLines(true);\n  }\n\n  SplitLinesCollection.prototype.dispose = function () {\n    this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);\n  };\n\n  SplitLinesCollection.prototype.createCoordinatesConverter = function () {\n    return new CoordinatesConverter(this);\n  };\n\n  SplitLinesCollection.prototype._ensureValidState = function () {\n    var modelVersion = this.model.getVersionId();\n\n    if (modelVersion !== this._validModelVersionId) {\n      // This is pretty bad, it means we lost track of the model...\n      throw new Error(\"ViewModel is out of sync with Model!\");\n    }\n\n    if (this.lines.length !== this.model.getLineCount()) {\n      // This is pretty bad, it means we lost track of the model...\n      this._constructLines(false);\n    }\n  };\n\n  SplitLinesCollection.prototype._constructLines = function (resetHiddenAreas) {\n    var _this = this;\n\n    this.lines = [];\n\n    if (resetHiddenAreas) {\n      this.hiddenAreasIds = [];\n    }\n\n    var linesContent = this.model.getLinesContent();\n    var lineCount = linesContent.length;\n    var values = new Uint32Array(lineCount);\n    var hiddenAreas = this.hiddenAreasIds.map(function (areaId) {\n      return _this.model.getDecorationRange(areaId);\n    }).sort(Range.compareRangesUsingStarts);\n    var hiddenAreaStart = 1,\n        hiddenAreaEnd = 0;\n    var hiddenAreaIdx = -1;\n    var nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n\n    for (var i = 0; i < lineCount; i++) {\n      var lineNumber = i + 1;\n\n      if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n        hiddenAreaIdx++;\n        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n      }\n\n      var isInHiddenArea = lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd;\n      var line = createSplitLine(this.linePositionMapperFactory, linesContent[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);\n      values[i] = line.getViewLineCount();\n      this.lines[i] = line;\n    }\n\n    this._validModelVersionId = this.model.getVersionId();\n    this.prefixSumComputer = new PrefixSumComputerWithCache(values);\n  };\n\n  SplitLinesCollection.prototype.getHiddenAreas = function () {\n    var _this = this;\n\n    return this.hiddenAreasIds.map(function (decId) {\n      return _this.model.getDecorationRange(decId);\n    });\n  };\n\n  SplitLinesCollection.prototype._reduceRanges = function (_ranges) {\n    var _this = this;\n\n    if (_ranges.length === 0) {\n      return [];\n    }\n\n    var ranges = _ranges.map(function (r) {\n      return _this.model.validateRange(r);\n    }).sort(Range.compareRangesUsingStarts);\n\n    var result = [];\n    var currentRangeStart = ranges[0].startLineNumber;\n    var currentRangeEnd = ranges[0].endLineNumber;\n\n    for (var i = 1, len = ranges.length; i < len; i++) {\n      var range = ranges[i];\n\n      if (range.startLineNumber > currentRangeEnd + 1) {\n        result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n        currentRangeStart = range.startLineNumber;\n        currentRangeEnd = range.endLineNumber;\n      } else if (range.endLineNumber > currentRangeEnd) {\n        currentRangeEnd = range.endLineNumber;\n      }\n    }\n\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n  };\n\n  SplitLinesCollection.prototype.setHiddenAreas = function (_ranges) {\n    var _this = this;\n\n    var newRanges = this._reduceRanges(_ranges); // BEGIN TODO@Martin: Please stop calling this method on each model change!\n\n\n    var oldRanges = this.hiddenAreasIds.map(function (areaId) {\n      return _this.model.getDecorationRange(areaId);\n    }).sort(Range.compareRangesUsingStarts);\n\n    if (newRanges.length === oldRanges.length) {\n      var hasDifference = false;\n\n      for (var i = 0; i < newRanges.length; i++) {\n        if (!newRanges[i].equalsRange(oldRanges[i])) {\n          hasDifference = true;\n          break;\n        }\n      }\n\n      if (!hasDifference) {\n        return false;\n      }\n    } // END TODO@Martin: Please stop calling this method on each model change!\n\n\n    var newDecorations = [];\n\n    for (var _i = 0, newRanges_1 = newRanges; _i < newRanges_1.length; _i++) {\n      var newRange = newRanges_1[_i];\n      newDecorations.push({\n        range: newRange,\n        options: ModelDecorationOptions.EMPTY\n      });\n    }\n\n    this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);\n    var hiddenAreas = newRanges;\n    var hiddenAreaStart = 1,\n        hiddenAreaEnd = 0;\n    var hiddenAreaIdx = -1;\n    var nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.lines.length + 2;\n    var hasVisibleLine = false;\n\n    for (var i = 0; i < this.lines.length; i++) {\n      var lineNumber = i + 1;\n\n      if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n        hiddenAreaIdx++;\n        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.lines.length + 2;\n      }\n\n      var lineChanged = false;\n\n      if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n        // Line should be hidden\n        if (this.lines[i].isVisible()) {\n          this.lines[i] = this.lines[i].setVisible(false);\n          lineChanged = true;\n        }\n      } else {\n        hasVisibleLine = true; // Line should be visible\n\n        if (!this.lines[i].isVisible()) {\n          this.lines[i] = this.lines[i].setVisible(true);\n          lineChanged = true;\n        }\n      }\n\n      if (lineChanged) {\n        var newOutputLineCount = this.lines[i].getViewLineCount();\n        this.prefixSumComputer.changeValue(i, newOutputLineCount);\n      }\n    }\n\n    if (!hasVisibleLine) {\n      // Cannot have everything be hidden => reveal everything!\n      this.setHiddenAreas([]);\n    }\n\n    return true;\n  };\n\n  SplitLinesCollection.prototype.modelPositionIsVisible = function (modelLineNumber, _modelColumn) {\n    if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n      // invalid arguments\n      return false;\n    }\n\n    return this.lines[modelLineNumber - 1].isVisible();\n  };\n\n  SplitLinesCollection.prototype.setTabSize = function (newTabSize) {\n    if (this.tabSize === newTabSize) {\n      return false;\n    }\n\n    this.tabSize = newTabSize;\n\n    this._constructLines(false);\n\n    return true;\n  };\n\n  SplitLinesCollection.prototype.setWrappingSettings = function (wrappingIndent, wrappingColumn, columnsForFullWidthChar) {\n    if (this.wrappingIndent === wrappingIndent && this.wrappingColumn === wrappingColumn && this.columnsForFullWidthChar === columnsForFullWidthChar) {\n      return false;\n    }\n\n    this.wrappingIndent = wrappingIndent;\n    this.wrappingColumn = wrappingColumn;\n    this.columnsForFullWidthChar = columnsForFullWidthChar;\n\n    this._constructLines(false);\n\n    return true;\n  };\n\n  SplitLinesCollection.prototype.onModelFlushed = function () {\n    this._constructLines(true);\n  };\n\n  SplitLinesCollection.prototype.onModelLinesDeleted = function (versionId, fromLineNumber, toLineNumber) {\n    if (versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return null;\n    }\n\n    var outputFromLineNumber = fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1;\n    var outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);\n    this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n    this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n    return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n  };\n\n  SplitLinesCollection.prototype.onModelLinesInserted = function (versionId, fromLineNumber, _toLineNumber, text) {\n    if (versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return null;\n    }\n\n    var hiddenAreas = this.getHiddenAreas();\n    var isInHiddenArea = false;\n    var testPosition = new Position(fromLineNumber, 1);\n\n    for (var _i = 0, hiddenAreas_1 = hiddenAreas; _i < hiddenAreas_1.length; _i++) {\n      var hiddenArea = hiddenAreas_1[_i];\n\n      if (hiddenArea.containsPosition(testPosition)) {\n        isInHiddenArea = true;\n        break;\n      }\n    }\n\n    var outputFromLineNumber = fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1;\n    var totalOutputLineCount = 0;\n    var insertLines = [];\n    var insertPrefixSumValues = new Uint32Array(text.length);\n\n    for (var i = 0, len = text.length; i < len; i++) {\n      var line = createSplitLine(this.linePositionMapperFactory, text[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);\n      insertLines.push(line);\n      var outputLineCount = line.getViewLineCount();\n      totalOutputLineCount += outputLineCount;\n      insertPrefixSumValues[i] = outputLineCount;\n    } // TODO@Alex: use arrays.arrayInsert\n\n\n    this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));\n    this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n    return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n  };\n\n  SplitLinesCollection.prototype.onModelLineChanged = function (versionId, lineNumber, newText) {\n    if (versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return [false, null, null, null];\n    }\n\n    var lineIndex = lineNumber - 1;\n    var oldOutputLineCount = this.lines[lineIndex].getViewLineCount();\n    var isVisible = this.lines[lineIndex].isVisible();\n    var line = createSplitLine(this.linePositionMapperFactory, newText, this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, isVisible);\n    this.lines[lineIndex] = line;\n    var newOutputLineCount = this.lines[lineIndex].getViewLineCount();\n    var lineMappingChanged = false;\n    var changeFrom = 0;\n    var changeTo = -1;\n    var insertFrom = 0;\n    var insertTo = -1;\n    var deleteFrom = 0;\n    var deleteTo = -1;\n\n    if (oldOutputLineCount > newOutputLineCount) {\n      changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;\n      changeTo = changeFrom + newOutputLineCount - 1;\n      deleteFrom = changeTo + 1;\n      deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n      lineMappingChanged = true;\n    } else if (oldOutputLineCount < newOutputLineCount) {\n      changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;\n      changeTo = changeFrom + oldOutputLineCount - 1;\n      insertFrom = changeTo + 1;\n      insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n      lineMappingChanged = true;\n    } else {\n      changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;\n      changeTo = changeFrom + newOutputLineCount - 1;\n    }\n\n    this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);\n    var viewLinesChangedEvent = changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null;\n    var viewLinesInsertedEvent = insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null;\n    var viewLinesDeletedEvent = deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null;\n    return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n  };\n\n  SplitLinesCollection.prototype.acceptVersionId = function (versionId) {\n    this._validModelVersionId = versionId;\n\n    if (this.lines.length === 1 && !this.lines[0].isVisible()) {\n      // At least one line must be visible => reset hidden areas\n      this.setHiddenAreas([]);\n    }\n  };\n\n  SplitLinesCollection.prototype.getViewLineCount = function () {\n    this._ensureValidState();\n\n    return this.prefixSumComputer.getTotalValue();\n  };\n\n  SplitLinesCollection.prototype._toValidViewLineNumber = function (viewLineNumber) {\n    if (viewLineNumber < 1) {\n      return 1;\n    }\n\n    var viewLineCount = this.getViewLineCount();\n\n    if (viewLineNumber > viewLineCount) {\n      return viewLineCount;\n    }\n\n    return viewLineNumber;\n  };\n  /**\n   * Gives a hint that a lot of requests are about to come in for these line numbers.\n   */\n\n\n  SplitLinesCollection.prototype.warmUpLookupCache = function (viewStartLineNumber, viewEndLineNumber) {\n    this.prefixSumComputer.warmUpCache(viewStartLineNumber - 1, viewEndLineNumber - 1);\n  };\n\n  SplitLinesCollection.prototype.getActiveIndentGuide = function (viewLineNumber, minLineNumber, maxLineNumber) {\n    this._ensureValidState();\n\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    minLineNumber = this._toValidViewLineNumber(minLineNumber);\n    maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n    var modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n    var modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n    var modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n    var result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n    var viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n    var viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n    return {\n      startLineNumber: viewStartPosition.lineNumber,\n      endLineNumber: viewEndPosition.lineNumber,\n      indent: result.indent\n    };\n  };\n\n  SplitLinesCollection.prototype.getViewLinesIndentGuides = function (viewStartLineNumber, viewEndLineNumber) {\n    this._ensureValidState();\n\n    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n    var modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n    var modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n    var result = [];\n    var resultRepeatCount = [];\n    var resultRepeatOption = [];\n    var modelStartLineIndex = modelStart.lineNumber - 1;\n    var modelEndLineIndex = modelEnd.lineNumber - 1;\n    var reqStart = null;\n\n    for (var modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n      var line = this.lines[modelLineIndex];\n\n      if (line.isVisible()) {\n        var viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n        var viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n        var count = viewLineEndIndex - viewLineStartIndex + 1;\n        var option = 0\n        /* BlockNone */\n        ;\n\n        if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n          // wrapped lines should block indent guides\n          option = viewLineStartIndex === 0 ? 1\n          /* BlockSubsequent */\n          : 2\n          /* BlockAll */\n          ;\n        }\n\n        resultRepeatCount.push(count);\n        resultRepeatOption.push(option); // merge into previous request\n\n        if (reqStart === null) {\n          reqStart = new Position(modelLineIndex + 1, 0);\n        }\n      } else {\n        // hit invisible line => flush request\n        if (reqStart !== null) {\n          result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n          reqStart = null;\n        }\n      }\n    }\n\n    if (reqStart !== null) {\n      result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n      reqStart = null;\n    }\n\n    var viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n    var viewIndents = new Array(viewLineCount);\n    var currIndex = 0;\n\n    for (var i = 0, len = result.length; i < len; i++) {\n      var value = result[i];\n      var count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n      var option = resultRepeatOption[i];\n      var blockAtIndex = void 0;\n\n      if (option === 2\n      /* BlockAll */\n      ) {\n          blockAtIndex = 0;\n        } else if (option === 1\n      /* BlockSubsequent */\n      ) {\n          blockAtIndex = 1;\n        } else {\n        blockAtIndex = count;\n      }\n\n      for (var j = 0; j < count; j++) {\n        if (j === blockAtIndex) {\n          value = 0;\n        }\n\n        viewIndents[currIndex++] = value;\n      }\n    }\n\n    return viewIndents;\n  };\n\n  SplitLinesCollection.prototype.getViewLineContent = function (viewLineNumber) {\n    this._ensureValidState();\n\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    var lineIndex = r.index;\n    var remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);\n  };\n\n  SplitLinesCollection.prototype.getViewLineLength = function (viewLineNumber) {\n    this._ensureValidState();\n\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    var lineIndex = r.index;\n    var remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);\n  };\n\n  SplitLinesCollection.prototype.getViewLineMinColumn = function (viewLineNumber) {\n    this._ensureValidState();\n\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    var lineIndex = r.index;\n    var remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n  };\n\n  SplitLinesCollection.prototype.getViewLineMaxColumn = function (viewLineNumber) {\n    this._ensureValidState();\n\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    var lineIndex = r.index;\n    var remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n  };\n\n  SplitLinesCollection.prototype.getViewLineData = function (viewLineNumber) {\n    this._ensureValidState();\n\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    var lineIndex = r.index;\n    var remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);\n  };\n\n  SplitLinesCollection.prototype.getViewLinesData = function (viewStartLineNumber, viewEndLineNumber, needed) {\n    this._ensureValidState();\n\n    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n    var start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);\n    var viewLineNumber = viewStartLineNumber;\n    var startModelLineIndex = start.index;\n    var startRemainder = start.remainder;\n    var result = [];\n\n    for (var modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n      var line = this.lines[modelLineIndex];\n\n      if (!line.isVisible()) {\n        continue;\n      }\n\n      var fromViewLineIndex = modelLineIndex === startModelLineIndex ? startRemainder : 0;\n      var remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n      var lastLine = false;\n\n      if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n        lastLine = true;\n        remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n      }\n\n      var toViewLineIndex = fromViewLineIndex + remainingViewLineCount;\n      line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);\n      viewLineNumber += remainingViewLineCount;\n\n      if (lastLine) {\n        break;\n      }\n    }\n\n    return result;\n  };\n\n  SplitLinesCollection.prototype.validateViewPosition = function (viewLineNumber, viewColumn, expectedModelPosition) {\n    this._ensureValidState();\n\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    var lineIndex = r.index;\n    var remainder = r.remainder;\n    var line = this.lines[lineIndex];\n    var minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n    var maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n\n    if (viewColumn < minColumn) {\n      viewColumn = minColumn;\n    }\n\n    if (viewColumn > maxColumn) {\n      viewColumn = maxColumn;\n    }\n\n    var computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n    var computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n\n    if (computedModelPosition.equals(expectedModelPosition)) {\n      return new Position(viewLineNumber, viewColumn);\n    }\n\n    return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n  };\n\n  SplitLinesCollection.prototype.convertViewPositionToModelPosition = function (viewLineNumber, viewColumn) {\n    this._ensureValidState();\n\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    var lineIndex = r.index;\n    var remainder = r.remainder;\n    var inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn); // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n\n    return this.model.validatePosition(new Position(lineIndex + 1, inputColumn));\n  };\n\n  SplitLinesCollection.prototype.convertModelPositionToViewPosition = function (_modelLineNumber, _modelColumn) {\n    this._ensureValidState();\n\n    var validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n    var inputLineNumber = validPosition.lineNumber;\n    var inputColumn = validPosition.column;\n    var lineIndex = inputLineNumber - 1,\n        lineIndexChanged = false;\n\n    while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n      lineIndex--;\n      lineIndexChanged = true;\n    }\n\n    if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n      // Could not reach a real line\n      // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n      return new Position(1, 1);\n    }\n\n    var deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n    var r;\n\n    if (lineIndexChanged) {\n      r = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    } else {\n      r = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn);\n    } // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n\n\n    return r;\n  };\n\n  SplitLinesCollection.prototype._getViewLineNumberForModelPosition = function (inputLineNumber, inputColumn) {\n    var lineIndex = inputLineNumber - 1;\n\n    if (this.lines[lineIndex].isVisible()) {\n      // this model line is visible\n      var deltaLineNumber_1 = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n      return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber_1, inputColumn);\n    } // this model line is not visible\n\n\n    while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n      lineIndex--;\n    }\n\n    if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n      // Could not reach a real line\n      return 1;\n    }\n\n    var deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n    return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n  };\n\n  SplitLinesCollection.prototype.getAllOverviewRulerDecorations = function (ownerId, filterOutValidation, theme) {\n    var decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n    var result = new OverviewRulerDecorations();\n\n    for (var _i = 0, decorations_1 = decorations; _i < decorations_1.length; _i++) {\n      var decoration = decorations_1[_i];\n      var opts = decoration.options.overviewRuler;\n      var lane = opts ? opts.position : 0;\n\n      if (lane === 0) {\n        continue;\n      }\n\n      var color = opts.getColor(theme);\n\n      var viewStartLineNumber = this._getViewLineNumberForModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n\n      var viewEndLineNumber = this._getViewLineNumberForModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n\n      result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n    }\n\n    return result.result;\n  };\n\n  SplitLinesCollection.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {\n    var modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n    var modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n\n    if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n      // most likely there are no hidden lines => fast path\n      // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n      return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n    }\n\n    var result = [];\n    var modelStartLineIndex = modelStart.lineNumber - 1;\n    var modelEndLineIndex = modelEnd.lineNumber - 1;\n    var reqStart = null;\n\n    for (var modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n      var line = this.lines[modelLineIndex];\n\n      if (line.isVisible()) {\n        // merge into previous request\n        if (reqStart === null) {\n          reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n        }\n      } else {\n        // hit invisible line => flush request\n        if (reqStart !== null) {\n          var maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n          result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n          reqStart = null;\n        }\n      }\n    }\n\n    if (reqStart !== null) {\n      result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n      reqStart = null;\n    }\n\n    result.sort(function (a, b) {\n      var res = Range.compareRangesUsingStarts(a.range, b.range);\n\n      if (res === 0) {\n        if (a.id < b.id) {\n          return -1;\n        }\n\n        if (a.id > b.id) {\n          return 1;\n        }\n\n        return 0;\n      }\n\n      return res;\n    }); // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n\n    var finalResult = [],\n        finalResultLen = 0;\n    var prevDecId = null;\n\n    for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {\n      var dec = result_1[_i];\n      var decId = dec.id;\n\n      if (prevDecId === decId) {\n        // skip\n        continue;\n      }\n\n      prevDecId = decId;\n      finalResult[finalResultLen++] = dec;\n    }\n\n    return finalResult;\n  };\n\n  return SplitLinesCollection;\n}();\n\nexport { SplitLinesCollection };\n\nvar VisibleIdentitySplitLine =\n/** @class */\nfunction () {\n  function VisibleIdentitySplitLine() {}\n\n  VisibleIdentitySplitLine.prototype.isVisible = function () {\n    return true;\n  };\n\n  VisibleIdentitySplitLine.prototype.setVisible = function (isVisible) {\n    if (isVisible) {\n      return this;\n    }\n\n    return InvisibleIdentitySplitLine.INSTANCE;\n  };\n\n  VisibleIdentitySplitLine.prototype.getViewLineCount = function () {\n    return 1;\n  };\n\n  VisibleIdentitySplitLine.prototype.getViewLineContent = function (model, modelLineNumber, _outputLineIndex) {\n    return model.getLineContent(modelLineNumber);\n  };\n\n  VisibleIdentitySplitLine.prototype.getViewLineLength = function (model, modelLineNumber, _outputLineIndex) {\n    return model.getLineLength(modelLineNumber);\n  };\n\n  VisibleIdentitySplitLine.prototype.getViewLineMinColumn = function (model, modelLineNumber, _outputLineIndex) {\n    return model.getLineMinColumn(modelLineNumber);\n  };\n\n  VisibleIdentitySplitLine.prototype.getViewLineMaxColumn = function (model, modelLineNumber, _outputLineIndex) {\n    return model.getLineMaxColumn(modelLineNumber);\n  };\n\n  VisibleIdentitySplitLine.prototype.getViewLineData = function (model, modelLineNumber, _outputLineIndex) {\n    var lineTokens = model.getLineTokens(modelLineNumber);\n    var lineContent = lineTokens.getLineContent();\n    return new ViewLineData(lineContent, false, 1, lineContent.length + 1, lineTokens.inflate());\n  };\n\n  VisibleIdentitySplitLine.prototype.getViewLinesData = function (model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n    if (!needed[globalStartIndex]) {\n      result[globalStartIndex] = null;\n      return;\n    }\n\n    result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n  };\n\n  VisibleIdentitySplitLine.prototype.getModelColumnOfViewPosition = function (_outputLineIndex, outputColumn) {\n    return outputColumn;\n  };\n\n  VisibleIdentitySplitLine.prototype.getViewPositionOfModelPosition = function (deltaLineNumber, inputColumn) {\n    return new Position(deltaLineNumber, inputColumn);\n  };\n\n  VisibleIdentitySplitLine.prototype.getViewLineNumberOfModelPosition = function (deltaLineNumber, _inputColumn) {\n    return deltaLineNumber;\n  };\n\n  VisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();\n  return VisibleIdentitySplitLine;\n}();\n\nvar InvisibleIdentitySplitLine =\n/** @class */\nfunction () {\n  function InvisibleIdentitySplitLine() {}\n\n  InvisibleIdentitySplitLine.prototype.isVisible = function () {\n    return false;\n  };\n\n  InvisibleIdentitySplitLine.prototype.setVisible = function (isVisible) {\n    if (!isVisible) {\n      return this;\n    }\n\n    return VisibleIdentitySplitLine.INSTANCE;\n  };\n\n  InvisibleIdentitySplitLine.prototype.getViewLineCount = function () {\n    return 0;\n  };\n\n  InvisibleIdentitySplitLine.prototype.getViewLineContent = function (_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  };\n\n  InvisibleIdentitySplitLine.prototype.getViewLineLength = function (_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  };\n\n  InvisibleIdentitySplitLine.prototype.getViewLineMinColumn = function (_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  };\n\n  InvisibleIdentitySplitLine.prototype.getViewLineMaxColumn = function (_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  };\n\n  InvisibleIdentitySplitLine.prototype.getViewLineData = function (_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  };\n\n  InvisibleIdentitySplitLine.prototype.getViewLinesData = function (_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n    throw new Error('Not supported');\n  };\n\n  InvisibleIdentitySplitLine.prototype.getModelColumnOfViewPosition = function (_outputLineIndex, _outputColumn) {\n    throw new Error('Not supported');\n  };\n\n  InvisibleIdentitySplitLine.prototype.getViewPositionOfModelPosition = function (_deltaLineNumber, _inputColumn) {\n    throw new Error('Not supported');\n  };\n\n  InvisibleIdentitySplitLine.prototype.getViewLineNumberOfModelPosition = function (_deltaLineNumber, _inputColumn) {\n    throw new Error('Not supported');\n  };\n\n  InvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();\n  return InvisibleIdentitySplitLine;\n}();\n\nvar SplitLine =\n/** @class */\nfunction () {\n  function SplitLine(positionMapper, isVisible) {\n    this.positionMapper = positionMapper;\n    this.wrappedIndent = this.positionMapper.getWrappedLinesIndent();\n    this.wrappedIndentLength = this.wrappedIndent.length;\n    this.outputLineCount = this.positionMapper.getOutputLineCount();\n    this._isVisible = isVisible;\n  }\n\n  SplitLine.prototype.isVisible = function () {\n    return this._isVisible;\n  };\n\n  SplitLine.prototype.setVisible = function (isVisible) {\n    this._isVisible = isVisible;\n    return this;\n  };\n\n  SplitLine.prototype.getViewLineCount = function () {\n    if (!this._isVisible) {\n      return 0;\n    }\n\n    return this.outputLineCount;\n  };\n\n  SplitLine.prototype.getInputStartOffsetOfOutputLineIndex = function (outputLineIndex) {\n    return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, 0);\n  };\n\n  SplitLine.prototype.getInputEndOffsetOfOutputLineIndex = function (model, modelLineNumber, outputLineIndex) {\n    if (outputLineIndex + 1 === this.outputLineCount) {\n      return model.getLineMaxColumn(modelLineNumber) - 1;\n    }\n\n    return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex + 1, 0);\n  };\n\n  SplitLine.prototype.getViewLineContent = function (model, modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n    var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n    var r = model.getValueInRange({\n      startLineNumber: modelLineNumber,\n      startColumn: startOffset + 1,\n      endLineNumber: modelLineNumber,\n      endColumn: endOffset + 1\n    });\n\n    if (outputLineIndex > 0) {\n      r = this.wrappedIndent + r;\n    }\n\n    return r;\n  };\n\n  SplitLine.prototype.getViewLineLength = function (model, modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n    var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n    var r = endOffset - startOffset;\n\n    if (outputLineIndex > 0) {\n      r = this.wrappedIndent.length + r;\n    }\n\n    return r;\n  };\n\n  SplitLine.prototype.getViewLineMinColumn = function (_model, _modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    if (outputLineIndex > 0) {\n      return this.wrappedIndentLength + 1;\n    }\n\n    return 1;\n  };\n\n  SplitLine.prototype.getViewLineMaxColumn = function (model, modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    return this.getViewLineContent(model, modelLineNumber, outputLineIndex).length + 1;\n  };\n\n  SplitLine.prototype.getViewLineData = function (model, modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n    var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n    var lineContent = model.getValueInRange({\n      startLineNumber: modelLineNumber,\n      startColumn: startOffset + 1,\n      endLineNumber: modelLineNumber,\n      endColumn: endOffset + 1\n    });\n\n    if (outputLineIndex > 0) {\n      lineContent = this.wrappedIndent + lineContent;\n    }\n\n    var minColumn = outputLineIndex > 0 ? this.wrappedIndentLength + 1 : 1;\n    var maxColumn = lineContent.length + 1;\n    var continuesWithWrappedLine = outputLineIndex + 1 < this.getViewLineCount();\n    var deltaStartIndex = 0;\n\n    if (outputLineIndex > 0) {\n      deltaStartIndex = this.wrappedIndentLength;\n    }\n\n    var lineTokens = model.getLineTokens(modelLineNumber);\n    return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex));\n  };\n\n  SplitLine.prototype.getViewLinesData = function (model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    for (var outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {\n      var globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;\n\n      if (!needed[globalIndex]) {\n        result[globalIndex] = null;\n        continue;\n      }\n\n      result[globalIndex] = this.getViewLineData(model, modelLineNumber, outputLineIndex);\n    }\n  };\n\n  SplitLine.prototype.getModelColumnOfViewPosition = function (outputLineIndex, outputColumn) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    var adjustedColumn = outputColumn - 1;\n\n    if (outputLineIndex > 0) {\n      if (adjustedColumn < this.wrappedIndentLength) {\n        adjustedColumn = 0;\n      } else {\n        adjustedColumn -= this.wrappedIndentLength;\n      }\n    }\n\n    return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, adjustedColumn) + 1;\n  };\n\n  SplitLine.prototype.getViewPositionOfModelPosition = function (deltaLineNumber, inputColumn) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    var r = this.positionMapper.getOutputPositionOfInputOffset(inputColumn - 1);\n    var outputLineIndex = r.outputLineIndex;\n    var outputColumn = r.outputOffset + 1;\n\n    if (outputLineIndex > 0) {\n      outputColumn += this.wrappedIndentLength;\n    } //\t\tconsole.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);\n\n\n    return new Position(deltaLineNumber + outputLineIndex, outputColumn);\n  };\n\n  SplitLine.prototype.getViewLineNumberOfModelPosition = function (deltaLineNumber, inputColumn) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n\n    var r = this.positionMapper.getOutputPositionOfInputOffset(inputColumn - 1);\n    return deltaLineNumber + r.outputLineIndex;\n  };\n\n  return SplitLine;\n}();\n\nexport { SplitLine };\n\nfunction createSplitLine(linePositionMapperFactory, text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, isVisible) {\n  var positionMapper = linePositionMapperFactory.createLineMapping(text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n\n  if (positionMapper === null) {\n    // No mapping needed\n    if (isVisible) {\n      return VisibleIdentitySplitLine.INSTANCE;\n    }\n\n    return InvisibleIdentitySplitLine.INSTANCE;\n  } else {\n    return new SplitLine(positionMapper, isVisible);\n  }\n}\n\nvar IdentityCoordinatesConverter =\n/** @class */\nfunction () {\n  function IdentityCoordinatesConverter(lines) {\n    this._lines = lines;\n  }\n\n  IdentityCoordinatesConverter.prototype._validPosition = function (pos) {\n    return this._lines.model.validatePosition(pos);\n  };\n\n  IdentityCoordinatesConverter.prototype._validRange = function (range) {\n    return this._lines.model.validateRange(range);\n  }; // View -> Model conversion and related methods\n\n\n  IdentityCoordinatesConverter.prototype.convertViewPositionToModelPosition = function (viewPosition) {\n    return this._validPosition(viewPosition);\n  };\n\n  IdentityCoordinatesConverter.prototype.convertViewRangeToModelRange = function (viewRange) {\n    return this._validRange(viewRange);\n  };\n\n  IdentityCoordinatesConverter.prototype.validateViewPosition = function (_viewPosition, expectedModelPosition) {\n    return this._validPosition(expectedModelPosition);\n  };\n\n  IdentityCoordinatesConverter.prototype.validateViewRange = function (_viewRange, expectedModelRange) {\n    return this._validRange(expectedModelRange);\n  }; // Model -> View conversion and related methods\n\n\n  IdentityCoordinatesConverter.prototype.convertModelPositionToViewPosition = function (modelPosition) {\n    return this._validPosition(modelPosition);\n  };\n\n  IdentityCoordinatesConverter.prototype.convertModelRangeToViewRange = function (modelRange) {\n    return this._validRange(modelRange);\n  };\n\n  IdentityCoordinatesConverter.prototype.modelPositionIsVisible = function (modelPosition) {\n    var lineCount = this._lines.model.getLineCount();\n\n    if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n      // invalid arguments\n      return false;\n    }\n\n    return true;\n  };\n\n  return IdentityCoordinatesConverter;\n}();\n\nexport { IdentityCoordinatesConverter };\n\nvar IdentityLinesCollection =\n/** @class */\nfunction () {\n  function IdentityLinesCollection(model) {\n    this.model = model;\n  }\n\n  IdentityLinesCollection.prototype.dispose = function () {};\n\n  IdentityLinesCollection.prototype.createCoordinatesConverter = function () {\n    return new IdentityCoordinatesConverter(this);\n  };\n\n  IdentityLinesCollection.prototype.getHiddenAreas = function () {\n    return [];\n  };\n\n  IdentityLinesCollection.prototype.setHiddenAreas = function (_ranges) {\n    return false;\n  };\n\n  IdentityLinesCollection.prototype.setTabSize = function (_newTabSize) {\n    return false;\n  };\n\n  IdentityLinesCollection.prototype.setWrappingSettings = function (_wrappingIndent, _wrappingColumn, _columnsForFullWidthChar) {\n    return false;\n  };\n\n  IdentityLinesCollection.prototype.onModelFlushed = function () {};\n\n  IdentityLinesCollection.prototype.onModelLinesDeleted = function (_versionId, fromLineNumber, toLineNumber) {\n    return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n  };\n\n  IdentityLinesCollection.prototype.onModelLinesInserted = function (_versionId, fromLineNumber, toLineNumber, _text) {\n    return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n  };\n\n  IdentityLinesCollection.prototype.onModelLineChanged = function (_versionId, lineNumber, _newText) {\n    return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n  };\n\n  IdentityLinesCollection.prototype.acceptVersionId = function (_versionId) {};\n\n  IdentityLinesCollection.prototype.getViewLineCount = function () {\n    return this.model.getLineCount();\n  };\n\n  IdentityLinesCollection.prototype.warmUpLookupCache = function (_viewStartLineNumber, _viewEndLineNumber) {};\n\n  IdentityLinesCollection.prototype.getActiveIndentGuide = function (viewLineNumber, _minLineNumber, _maxLineNumber) {\n    return {\n      startLineNumber: viewLineNumber,\n      endLineNumber: viewLineNumber,\n      indent: 0\n    };\n  };\n\n  IdentityLinesCollection.prototype.getViewLinesIndentGuides = function (viewStartLineNumber, viewEndLineNumber) {\n    var viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n    var result = new Array(viewLineCount);\n\n    for (var i = 0; i < viewLineCount; i++) {\n      result[i] = 0;\n    }\n\n    return result;\n  };\n\n  IdentityLinesCollection.prototype.getViewLineContent = function (viewLineNumber) {\n    return this.model.getLineContent(viewLineNumber);\n  };\n\n  IdentityLinesCollection.prototype.getViewLineLength = function (viewLineNumber) {\n    return this.model.getLineLength(viewLineNumber);\n  };\n\n  IdentityLinesCollection.prototype.getViewLineMinColumn = function (viewLineNumber) {\n    return this.model.getLineMinColumn(viewLineNumber);\n  };\n\n  IdentityLinesCollection.prototype.getViewLineMaxColumn = function (viewLineNumber) {\n    return this.model.getLineMaxColumn(viewLineNumber);\n  };\n\n  IdentityLinesCollection.prototype.getViewLineData = function (viewLineNumber) {\n    var lineTokens = this.model.getLineTokens(viewLineNumber);\n    var lineContent = lineTokens.getLineContent();\n    return new ViewLineData(lineContent, false, 1, lineContent.length + 1, lineTokens.inflate());\n  };\n\n  IdentityLinesCollection.prototype.getViewLinesData = function (viewStartLineNumber, viewEndLineNumber, needed) {\n    var lineCount = this.model.getLineCount();\n    viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n    viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n    var result = [];\n\n    for (var lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n      var idx = lineNumber - viewStartLineNumber;\n\n      if (!needed[idx]) {\n        result[idx] = null;\n      }\n\n      result[idx] = this.getViewLineData(lineNumber);\n    }\n\n    return result;\n  };\n\n  IdentityLinesCollection.prototype.getAllOverviewRulerDecorations = function (ownerId, filterOutValidation, theme) {\n    var decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n    var result = new OverviewRulerDecorations();\n\n    for (var _i = 0, decorations_2 = decorations; _i < decorations_2.length; _i++) {\n      var decoration = decorations_2[_i];\n      var opts = decoration.options.overviewRuler;\n      var lane = opts ? opts.position : 0;\n\n      if (lane === 0) {\n        continue;\n      }\n\n      var color = opts.getColor(theme);\n      var viewStartLineNumber = decoration.range.startLineNumber;\n      var viewEndLineNumber = decoration.range.endLineNumber;\n      result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n    }\n\n    return result.result;\n  };\n\n  IdentityLinesCollection.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {\n    return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n  };\n\n  return IdentityLinesCollection;\n}();\n\nexport { IdentityLinesCollection };\n\nvar OverviewRulerDecorations =\n/** @class */\nfunction () {\n  function OverviewRulerDecorations() {\n    this.result = Object.create(null);\n  }\n\n  OverviewRulerDecorations.prototype.accept = function (color, startLineNumber, endLineNumber, lane) {\n    var prev = this.result[color];\n\n    if (prev) {\n      var prevLane = prev[prev.length - 3];\n      var prevEndLineNumber = prev[prev.length - 1];\n\n      if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n        // merge into prev\n        if (endLineNumber > prevEndLineNumber) {\n          prev[prev.length - 1] = endLineNumber;\n        }\n\n        return;\n      } // push\n\n\n      prev.push(lane, startLineNumber, endLineNumber);\n    } else {\n      this.result[color] = [lane, startLineNumber, endLineNumber];\n    }\n  };\n\n  return OverviewRulerDecorations;\n}();","map":null,"metadata":{},"sourceType":"module"}