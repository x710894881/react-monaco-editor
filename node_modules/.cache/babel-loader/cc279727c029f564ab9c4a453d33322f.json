{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as nodes from './cssNodes.js';\nimport { findFirst } from '../utils/arrays.js';\n\nvar Scope =\n/** @class */\nfunction () {\n  function Scope(offset, length) {\n    this.offset = offset;\n    this.length = length;\n    this.symbols = [];\n    this.parent = null;\n    this.children = [];\n  }\n\n  Scope.prototype.addChild = function (scope) {\n    this.children.push(scope);\n    scope.setParent(this);\n  };\n\n  Scope.prototype.setParent = function (scope) {\n    this.parent = scope;\n  };\n\n  Scope.prototype.findScope = function (offset, length) {\n    if (length === void 0) {\n      length = 0;\n    }\n\n    if (this.offset <= offset && this.offset + this.length > offset + length || this.offset === offset && this.length === length) {\n      return this.findInScope(offset, length);\n    }\n\n    return null;\n  };\n\n  Scope.prototype.findInScope = function (offset, length) {\n    if (length === void 0) {\n      length = 0;\n    } // find the first scope child that has an offset larger than offset + length\n\n\n    var end = offset + length;\n    var idx = findFirst(this.children, function (s) {\n      return s.offset > end;\n    });\n\n    if (idx === 0) {\n      // all scopes have offsets larger than our end\n      return this;\n    }\n\n    var res = this.children[idx - 1];\n\n    if (res.offset <= offset && res.offset + res.length >= offset + length) {\n      return res.findInScope(offset, length);\n    }\n\n    return this;\n  };\n\n  Scope.prototype.addSymbol = function (symbol) {\n    this.symbols.push(symbol);\n  };\n\n  Scope.prototype.getSymbol = function (name, type) {\n    for (var index = 0; index < this.symbols.length; index++) {\n      var symbol = this.symbols[index];\n\n      if (symbol.name === name && symbol.type === type) {\n        return symbol;\n      }\n    }\n\n    return null;\n  };\n\n  Scope.prototype.getSymbols = function () {\n    return this.symbols;\n  };\n\n  return Scope;\n}();\n\nexport { Scope };\n\nvar GlobalScope =\n/** @class */\nfunction (_super) {\n  __extends(GlobalScope, _super);\n\n  function GlobalScope() {\n    return _super.call(this, 0, Number.MAX_VALUE) || this;\n  }\n\n  return GlobalScope;\n}(Scope);\n\nexport { GlobalScope };\n\nvar Symbol =\n/** @class */\nfunction () {\n  function Symbol(name, value, node, type) {\n    this.name = name;\n    this.value = value;\n    this.node = node;\n    this.type = type;\n  }\n\n  return Symbol;\n}();\n\nexport { Symbol };\n\nvar ScopeBuilder =\n/** @class */\nfunction () {\n  function ScopeBuilder(scope) {\n    this.scope = scope;\n  }\n\n  ScopeBuilder.prototype.addSymbol = function (node, name, value, type) {\n    if (node.offset !== -1) {\n      var current = this.scope.findScope(node.offset, node.length);\n\n      if (current) {\n        current.addSymbol(new Symbol(name, value, node, type));\n      }\n    }\n  };\n\n  ScopeBuilder.prototype.addScope = function (node) {\n    if (node.offset !== -1) {\n      var current = this.scope.findScope(node.offset, node.length);\n\n      if (current && (current.offset !== node.offset || current.length !== node.length)) {\n        // scope already known?\n        var newScope = new Scope(node.offset, node.length);\n        current.addChild(newScope);\n        return newScope;\n      }\n\n      return current;\n    }\n\n    return null;\n  };\n\n  ScopeBuilder.prototype.addSymbolToChildScope = function (scopeNode, node, name, value, type) {\n    if (scopeNode && scopeNode.offset !== -1) {\n      var current = this.addScope(scopeNode); // create the scope or gets the existing one\n\n      if (current) {\n        current.addSymbol(new Symbol(name, value, node, type));\n      }\n    }\n  };\n\n  ScopeBuilder.prototype.visitNode = function (node) {\n    switch (node.type) {\n      case nodes.NodeType.Keyframe:\n        this.addSymbol(node, node.getName(), void 0, nodes.ReferenceType.Keyframe);\n        return true;\n\n      case nodes.NodeType.CustomPropertyDeclaration:\n        return this.visitCustomPropertyDeclarationNode(node);\n\n      case nodes.NodeType.VariableDeclaration:\n        return this.visitVariableDeclarationNode(node);\n\n      case nodes.NodeType.Ruleset:\n        return this.visitRuleSet(node);\n\n      case nodes.NodeType.MixinDeclaration:\n        this.addSymbol(node, node.getName(), void 0, nodes.ReferenceType.Mixin);\n        return true;\n\n      case nodes.NodeType.FunctionDeclaration:\n        this.addSymbol(node, node.getName(), void 0, nodes.ReferenceType.Function);\n        return true;\n\n      case nodes.NodeType.FunctionParameter:\n        {\n          return this.visitFunctionParameterNode(node);\n        }\n\n      case nodes.NodeType.Declarations:\n        this.addScope(node);\n        return true;\n\n      case nodes.NodeType.For:\n        var forNode = node;\n        var scopeNode = forNode.getDeclarations();\n\n        if (scopeNode) {\n          this.addSymbolToChildScope(scopeNode, forNode.variable, forNode.variable.getName(), void 0, nodes.ReferenceType.Variable);\n        }\n\n        return true;\n\n      case nodes.NodeType.Each:\n        {\n          var eachNode = node;\n          var scopeNode_1 = eachNode.getDeclarations();\n\n          if (scopeNode_1) {\n            var variables = eachNode.getVariables().getChildren();\n\n            for (var _i = 0, variables_1 = variables; _i < variables_1.length; _i++) {\n              var variable = variables_1[_i];\n              this.addSymbolToChildScope(scopeNode_1, variable, variable.getName(), void 0, nodes.ReferenceType.Variable);\n            }\n          }\n\n          return true;\n        }\n    }\n\n    return true;\n  };\n\n  ScopeBuilder.prototype.visitRuleSet = function (node) {\n    var current = this.scope.findScope(node.offset, node.length);\n\n    if (current) {\n      for (var _i = 0, _a = node.getSelectors().getChildren(); _i < _a.length; _i++) {\n        var child = _a[_i];\n\n        if (child instanceof nodes.Selector) {\n          if (child.getChildren().length === 1) {\n            // only selectors with a single element can be extended\n            current.addSymbol(new Symbol(child.getChild(0).getText(), void 0, child, nodes.ReferenceType.Rule));\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  ScopeBuilder.prototype.visitVariableDeclarationNode = function (node) {\n    var value = node.getValue() ? node.getValue().getText() : void 0;\n    this.addSymbol(node, node.getName(), value, nodes.ReferenceType.Variable);\n    return true;\n  };\n\n  ScopeBuilder.prototype.visitFunctionParameterNode = function (node) {\n    // parameters are part of the body scope\n    var scopeNode = node.getParent().getDeclarations();\n\n    if (scopeNode) {\n      var valueNode = node.getDefaultValue();\n      var value = valueNode ? valueNode.getText() : void 0;\n      this.addSymbolToChildScope(scopeNode, node, node.getName(), value, nodes.ReferenceType.Variable);\n    }\n\n    return true;\n  };\n\n  ScopeBuilder.prototype.visitCustomPropertyDeclarationNode = function (node) {\n    var value = node.getValue() ? node.getValue().getText() : '';\n    this.addCSSVariable(node.getProperty(), node.getProperty().getName(), value, nodes.ReferenceType.Variable);\n    return true;\n  };\n\n  ScopeBuilder.prototype.addCSSVariable = function (node, name, value, type) {\n    if (node.offset !== -1) {\n      this.scope.addSymbol(new Symbol(name, value, node, type));\n    }\n  };\n\n  return ScopeBuilder;\n}();\n\nexport { ScopeBuilder };\n\nvar Symbols =\n/** @class */\nfunction () {\n  function Symbols(node) {\n    this.global = new GlobalScope();\n    node.acceptVisitor(new ScopeBuilder(this.global));\n  }\n\n  Symbols.prototype.findSymbolsAtOffset = function (offset, referenceType) {\n    var scope = this.global.findScope(offset, 0);\n    var result = [];\n    var names = {};\n\n    while (scope) {\n      var symbols = scope.getSymbols();\n\n      for (var i = 0; i < symbols.length; i++) {\n        var symbol = symbols[i];\n\n        if (symbol.type === referenceType && !names[symbol.name]) {\n          result.push(symbol);\n          names[symbol.name] = true;\n        }\n      }\n\n      scope = scope.parent;\n    }\n\n    return result;\n  };\n\n  Symbols.prototype.internalFindSymbol = function (node, referenceTypes) {\n    var scopeNode = node;\n\n    if (node.parent instanceof nodes.FunctionParameter && node.parent.getParent() instanceof nodes.BodyDeclaration) {\n      scopeNode = node.parent.getParent().getDeclarations();\n    }\n\n    if (node.parent instanceof nodes.FunctionArgument && node.parent.getParent() instanceof nodes.Function) {\n      var funcId = node.parent.getParent().getIdentifier();\n\n      if (funcId) {\n        var functionSymbol = this.internalFindSymbol(funcId, [nodes.ReferenceType.Function]);\n\n        if (functionSymbol) {\n          scopeNode = functionSymbol.node.getDeclarations();\n        }\n      }\n    }\n\n    if (!scopeNode) {\n      return null;\n    }\n\n    var name = node.getText();\n    var scope = this.global.findScope(scopeNode.offset, scopeNode.length);\n\n    while (scope) {\n      for (var index = 0; index < referenceTypes.length; index++) {\n        var type = referenceTypes[index];\n        var symbol = scope.getSymbol(name, type);\n\n        if (symbol) {\n          return symbol;\n        }\n      }\n\n      scope = scope.parent;\n    }\n\n    return null;\n  };\n\n  Symbols.prototype.evaluateReferenceTypes = function (node) {\n    if (node instanceof nodes.Identifier) {\n      var referenceTypes = node.referenceTypes;\n\n      if (referenceTypes) {\n        return referenceTypes;\n      } else {\n        if (node.isCustomProperty) {\n          return [nodes.ReferenceType.Variable];\n        } // are a reference to a keyframe?\n\n\n        var decl = nodes.getParentDeclaration(node);\n\n        if (decl) {\n          var propertyName = decl.getNonPrefixedPropertyName();\n\n          if ((propertyName === 'animation' || propertyName === 'animation-name') && decl.getValue() && decl.getValue().offset === node.offset) {\n            return [nodes.ReferenceType.Keyframe];\n          }\n        }\n      }\n    } else if (node instanceof nodes.Variable) {\n      return [nodes.ReferenceType.Variable];\n    }\n\n    var selector = node.findAParent(nodes.NodeType.Selector, nodes.NodeType.ExtendsReference);\n\n    if (selector) {\n      return [nodes.ReferenceType.Rule];\n    }\n\n    return null;\n  };\n\n  Symbols.prototype.findSymbolFromNode = function (node) {\n    if (!node) {\n      return null;\n    }\n\n    while (node.type === nodes.NodeType.Interpolation) {\n      node = node.getParent();\n    }\n\n    var referenceTypes = this.evaluateReferenceTypes(node);\n\n    if (referenceTypes) {\n      return this.internalFindSymbol(node, referenceTypes);\n    }\n\n    return null;\n  };\n\n  Symbols.prototype.matchesSymbol = function (node, symbol) {\n    if (!node) {\n      return false;\n    }\n\n    while (node.type === nodes.NodeType.Interpolation) {\n      node = node.getParent();\n    }\n\n    if (symbol.name.length !== node.length || symbol.name !== node.getText()) {\n      return false;\n    }\n\n    var referenceTypes = this.evaluateReferenceTypes(node);\n\n    if (!referenceTypes || referenceTypes.indexOf(symbol.type) === -1) {\n      return false;\n    }\n\n    var nodeSymbol = this.internalFindSymbol(node, referenceTypes);\n    return nodeSymbol === symbol;\n  };\n\n  Symbols.prototype.findSymbol = function (name, type, offset) {\n    var scope = this.global.findScope(offset);\n\n    while (scope) {\n      var symbol = scope.getSymbol(name, type);\n\n      if (symbol) {\n        return symbol;\n      }\n\n      scope = scope.parent;\n    }\n\n    return null;\n  };\n\n  return Symbols;\n}();\n\nexport { Symbols };","map":null,"metadata":{},"sourceType":"module"}