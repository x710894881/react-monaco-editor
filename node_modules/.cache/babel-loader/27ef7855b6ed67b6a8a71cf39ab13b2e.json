{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { CursorColumns, EditOperationResult, isQuote } from './cursorCommon.js';\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { IndentAction } from '../modes/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\n\nvar TypeOperations =\n/** @class */\nfunction () {\n  function TypeOperations() {}\n\n  TypeOperations.indent = function (config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ShiftCommand(selections[i], {\n        isUnshift: false,\n        tabSize: config.tabSize,\n        indentSize: config.indentSize,\n        insertSpaces: config.insertSpaces,\n        useTabStops: config.useTabStops\n      });\n    }\n\n    return commands;\n  };\n\n  TypeOperations.outdent = function (config, model, selections) {\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ShiftCommand(selections[i], {\n        isUnshift: true,\n        tabSize: config.tabSize,\n        indentSize: config.indentSize,\n        insertSpaces: config.insertSpaces,\n        useTabStops: config.useTabStops\n      });\n    }\n\n    return commands;\n  };\n\n  TypeOperations.shiftIndent = function (config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n  };\n\n  TypeOperations.unshiftIndent = function (config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n  };\n\n  TypeOperations._distributedPaste = function (config, model, selections, text) {\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], text[i]);\n    }\n\n    return new EditOperationResult(0\n    /* Other */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  };\n\n  TypeOperations._simplePaste = function (config, model, selections, text, pasteOnNewLine) {\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n      var position = selection.getPosition();\n\n      if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n        pasteOnNewLine = false;\n      }\n\n      if (pasteOnNewLine && selection.startLineNumber !== selection.endLineNumber) {\n        pasteOnNewLine = false;\n      }\n\n      if (pasteOnNewLine && selection.startColumn === model.getLineMinColumn(selection.startLineNumber) && selection.endColumn === model.getLineMaxColumn(selection.startLineNumber)) {\n        pasteOnNewLine = false;\n      }\n\n      if (pasteOnNewLine) {\n        // Paste entire line at the beginning of line\n        var typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n        commands[i] = new ReplaceCommand(typeSelection, text);\n      } else {\n        commands[i] = new ReplaceCommand(selection, text);\n      }\n    }\n\n    return new EditOperationResult(0\n    /* Other */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  };\n\n  TypeOperations._distributePasteToCursors = function (selections, text, pasteOnNewLine, multicursorText) {\n    if (pasteOnNewLine) {\n      return null;\n    }\n\n    if (selections.length === 1) {\n      return null;\n    }\n\n    if (multicursorText && multicursorText.length === selections.length) {\n      return multicursorText;\n    } // Remove trailing \\n if present\n\n\n    if (text.charCodeAt(text.length - 1) === 10\n    /* LineFeed */\n    ) {\n        text = text.substr(0, text.length - 1);\n      }\n\n    var lines = text.split(/\\r\\n|\\r|\\n/);\n\n    if (lines.length === selections.length) {\n      return lines;\n    }\n\n    return null;\n  };\n\n  TypeOperations.paste = function (config, model, selections, text, pasteOnNewLine, multicursorText) {\n    var distributedPaste = this._distributePasteToCursors(selections, text, pasteOnNewLine, multicursorText);\n\n    if (distributedPaste) {\n      selections = selections.sort(Range.compareRangesUsingStarts);\n      return this._distributedPaste(config, model, selections, distributedPaste);\n    } else {\n      return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n    }\n  };\n\n  TypeOperations._goodIndentForLine = function (config, model, lineNumber) {\n    var action = null;\n    var indentation = '';\n    var expectedIndentAction = config.autoIndent ? LanguageConfigurationRegistry.getInheritIndentForLine(model, lineNumber, false) : null;\n\n    if (expectedIndentAction) {\n      action = expectedIndentAction.action;\n      indentation = expectedIndentAction.indentation;\n    } else if (lineNumber > 1) {\n      var lastLineNumber = void 0;\n\n      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n        var lineText = model.getLineContent(lastLineNumber);\n        var nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n\n        if (nonWhitespaceIdx >= 0) {\n          break;\n        }\n      }\n\n      if (lastLineNumber < 1) {\n        // No previous line with content found\n        return null;\n      }\n\n      var maxColumn = model.getLineMaxColumn(lastLineNumber);\n      var expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\n\n      if (expectedEnterAction) {\n        indentation = expectedEnterAction.indentation;\n        action = expectedEnterAction.enterAction;\n\n        if (action) {\n          indentation += action.appendText;\n        }\n      }\n    }\n\n    if (action) {\n      if (action === IndentAction.Indent) {\n        indentation = TypeOperations.shiftIndent(config, indentation);\n      }\n\n      if (action === IndentAction.Outdent) {\n        indentation = TypeOperations.unshiftIndent(config, indentation);\n      }\n\n      indentation = config.normalizeIndentation(indentation);\n    }\n\n    if (!indentation) {\n      return null;\n    }\n\n    return indentation;\n  };\n\n  TypeOperations._replaceJumpToNextIndent = function (config, model, selection, insertsAutoWhitespace) {\n    var typeText = '';\n    var position = selection.getStartPosition();\n\n    if (config.insertSpaces) {\n      var visibleColumnFromColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\n      var indentSize = config.indentSize;\n      var spacesCnt = indentSize - visibleColumnFromColumn % indentSize;\n\n      for (var i = 0; i < spacesCnt; i++) {\n        typeText += ' ';\n      }\n    } else {\n      typeText = '\\t';\n    }\n\n    return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n  };\n\n  TypeOperations.tab = function (config, model, selections) {\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n\n      if (selection.isEmpty()) {\n        var lineText = model.getLineContent(selection.startLineNumber);\n\n        if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\n          var goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n\n          goodIndent = goodIndent || '\\t';\n          var possibleTypeText = config.normalizeIndentation(goodIndent);\n\n          if (!strings.startsWith(lineText, possibleTypeText)) {\n            commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n            continue;\n          }\n        }\n\n        commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n      } else {\n        if (selection.startLineNumber === selection.endLineNumber) {\n          var lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n\n          if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n            // This is a single line selection that is not the entire line\n            commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n            continue;\n          }\n        }\n\n        commands[i] = new ShiftCommand(selection, {\n          isUnshift: false,\n          tabSize: config.tabSize,\n          indentSize: config.indentSize,\n          insertSpaces: config.insertSpaces,\n          useTabStops: config.useTabStops\n        });\n      }\n    }\n\n    return commands;\n  };\n\n  TypeOperations.replacePreviousChar = function (prevEditOperationType, config, model, selections, txt, replaceCharCnt) {\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n\n      if (!selection.isEmpty()) {\n        // looks like https://github.com/Microsoft/vscode/issues/2773\n        // where a cursor operation occurred before a canceled composition\n        // => ignore composition\n        commands[i] = null;\n        continue;\n      }\n\n      var pos = selection.getPosition();\n      var startColumn = Math.max(1, pos.column - replaceCharCnt);\n      var range = new Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);\n      commands[i] = new ReplaceCommand(range, txt);\n    }\n\n    return new EditOperationResult(1\n    /* Typing */\n    , commands, {\n      shouldPushStackElementBefore: prevEditOperationType !== 1\n      /* Typing */\n      ,\n      shouldPushStackElementAfter: false\n    });\n  };\n\n  TypeOperations._typeCommand = function (range, text, keepPosition) {\n    if (keepPosition) {\n      return new ReplaceCommandWithoutChangingPosition(range, text, true);\n    } else {\n      return new ReplaceCommand(range, text, true);\n    }\n  };\n\n  TypeOperations._enter = function (config, model, keepPosition, range) {\n    if (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {\n      var lineText_1 = model.getLineContent(range.startLineNumber);\n      var indentation_1 = strings.getLeadingWhitespace(lineText_1).substring(0, range.startColumn - 1);\n      return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation_1), keepPosition);\n    }\n\n    var r = LanguageConfigurationRegistry.getEnterAction(model, range);\n\n    if (r) {\n      var enterAction = r.enterAction;\n      var indentation_2 = r.indentation;\n\n      if (enterAction.indentAction === IndentAction.None) {\n        // Nothing special\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation_2 + enterAction.appendText), keepPosition);\n      } else if (enterAction.indentAction === IndentAction.Indent) {\n        // Indent once\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation_2 + enterAction.appendText), keepPosition);\n      } else if (enterAction.indentAction === IndentAction.IndentOutdent) {\n        // Ultra special\n        var normalIndent = config.normalizeIndentation(indentation_2);\n        var increasedIndent = config.normalizeIndentation(indentation_2 + enterAction.appendText);\n        var typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n\n        if (keepPosition) {\n          return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n        } else {\n          return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n        }\n      } else if (enterAction.indentAction === IndentAction.Outdent) {\n        var actualIndentation = TypeOperations.unshiftIndent(config, indentation_2);\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + enterAction.appendText), keepPosition);\n      }\n    } // no enter rules applied, we should check indentation rules then.\n\n\n    if (!config.autoIndent) {\n      // Nothing special\n      var lineText_2 = model.getLineContent(range.startLineNumber);\n      var indentation_3 = strings.getLeadingWhitespace(lineText_2).substring(0, range.startColumn - 1);\n      return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation_3), keepPosition);\n    }\n\n    var ir = LanguageConfigurationRegistry.getIndentForEnter(model, range, {\n      unshiftIndent: function (indent) {\n        return TypeOperations.unshiftIndent(config, indent);\n      },\n      shiftIndent: function (indent) {\n        return TypeOperations.shiftIndent(config, indent);\n      },\n      normalizeIndentation: function (indent) {\n        return config.normalizeIndentation(indent);\n      }\n    }, config.autoIndent);\n    var lineText = model.getLineContent(range.startLineNumber);\n    var indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\n    if (ir) {\n      var oldEndViewColumn = CursorColumns.visibleColumnFromColumn2(config, model, range.getEndPosition());\n      var oldEndColumn = range.endColumn;\n      var beforeText = '\\n';\n\n      if (indentation !== config.normalizeIndentation(ir.beforeEnter)) {\n        beforeText = config.normalizeIndentation(ir.beforeEnter) + lineText.substring(indentation.length, range.startColumn - 1) + '\\n';\n        range = new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn);\n      }\n\n      var newLineContent = model.getLineContent(range.endLineNumber);\n      var firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n\n      if (firstNonWhitespace >= 0) {\n        range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n      } else {\n        range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n      }\n\n      if (keepPosition) {\n        return new ReplaceCommandWithoutChangingPosition(range, beforeText + config.normalizeIndentation(ir.afterEnter), true);\n      } else {\n        var offset = 0;\n\n        if (oldEndColumn <= firstNonWhitespace + 1) {\n          if (!config.insertSpaces) {\n            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n          }\n\n          offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n        }\n\n        return new ReplaceCommandWithOffsetCursorState(range, beforeText + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n      }\n    } else {\n      return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n  };\n\n  TypeOperations._isAutoIndentType = function (config, model, selections) {\n    if (!config.autoIndent) {\n      return false;\n    }\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  TypeOperations._runAutoIndentType = function (config, model, range, ch) {\n    var currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    var actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(model, range, ch, {\n      shiftIndent: function (indentation) {\n        return TypeOperations.shiftIndent(config, indentation);\n      },\n      unshiftIndent: function (indentation) {\n        return TypeOperations.unshiftIndent(config, indentation);\n      }\n    });\n\n    if (actualIndentation === null) {\n      return null;\n    }\n\n    if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n      var firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n\n      if (firstNonWhitespace === 0) {\n        return TypeOperations._typeCommand(new Range(range.startLineNumber, 0, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n      } else {\n        return TypeOperations._typeCommand(new Range(range.startLineNumber, 0, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n      }\n    }\n\n    return null;\n  };\n\n  TypeOperations._isAutoClosingOvertype = function (config, model, selections, autoClosedCharacters, ch) {\n    if (config.autoClosingOvertype === 'never') {\n      return false;\n    }\n\n    if (!config.autoClosingPairsClose2.has(ch)) {\n      return false;\n    }\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n\n      if (!selection.isEmpty()) {\n        return false;\n      }\n\n      var position = selection.getPosition();\n      var lineText = model.getLineContent(position.lineNumber);\n      var afterCharacter = lineText.charAt(position.column - 1);\n\n      if (afterCharacter !== ch) {\n        return false;\n      } // Must over-type a closing character typed by the editor\n\n\n      if (config.autoClosingOvertype === 'auto') {\n        var found = false;\n\n        for (var j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n          var autoClosedCharacter = autoClosedCharacters[j];\n\n          if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  TypeOperations._runAutoClosingOvertype = function (prevEditOperationType, config, model, selections, ch) {\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n      var position = selection.getPosition();\n      var typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n      commands[i] = new ReplaceCommand(typeSelection, ch);\n    }\n\n    return new EditOperationResult(1\n    /* Typing */\n    , commands, {\n      shouldPushStackElementBefore: prevEditOperationType !== 1\n      /* Typing */\n      ,\n      shouldPushStackElementAfter: false\n    });\n  };\n\n  TypeOperations._isBeforeClosingBrace = function (config, autoClosingPair, characterAfter) {\n    var otherAutoClosingPairs = config.autoClosingPairsClose2.get(characterAfter);\n\n    if (!otherAutoClosingPairs) {\n      return false;\n    }\n\n    var thisBraceIsSymmetric = autoClosingPair.open === autoClosingPair.close;\n\n    for (var _i = 0, otherAutoClosingPairs_1 = otherAutoClosingPairs; _i < otherAutoClosingPairs_1.length; _i++) {\n      var otherAutoClosingPair = otherAutoClosingPairs_1[_i];\n      var otherBraceIsSymmetric = otherAutoClosingPair.open === otherAutoClosingPair.close;\n\n      if (!thisBraceIsSymmetric && otherBraceIsSymmetric) {\n        continue;\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  TypeOperations._findAutoClosingPairOpen = function (config, model, positions, ch) {\n    var autoClosingPairCandidates = config.autoClosingPairsOpen2.get(ch);\n\n    if (!autoClosingPairCandidates) {\n      return null;\n    } // Determine which auto-closing pair it is\n\n\n    var autoClosingPair = null;\n\n    for (var _i = 0, autoClosingPairCandidates_1 = autoClosingPairCandidates; _i < autoClosingPairCandidates_1.length; _i++) {\n      var autoClosingPairCandidate = autoClosingPairCandidates_1[_i];\n\n      if (autoClosingPair === null || autoClosingPairCandidate.open.length > autoClosingPair.open.length) {\n        var candidateIsMatch = true;\n\n        for (var _a = 0, positions_1 = positions; _a < positions_1.length; _a++) {\n          var position = positions_1[_a];\n          var relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - autoClosingPairCandidate.open.length + 1, position.lineNumber, position.column));\n\n          if (relevantText + ch !== autoClosingPairCandidate.open) {\n            candidateIsMatch = false;\n            break;\n          }\n        }\n\n        if (candidateIsMatch) {\n          autoClosingPair = autoClosingPairCandidate;\n        }\n      }\n    }\n\n    return autoClosingPair;\n  };\n\n  TypeOperations._isAutoClosingOpenCharType = function (config, model, selections, ch, insertOpenCharacter) {\n    var chIsQuote = isQuote(ch);\n    var autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;\n\n    if (autoCloseConfig === 'never') {\n      return null;\n    }\n\n    var autoClosingPair = this._findAutoClosingPairOpen(config, model, selections.map(function (s) {\n      return s.getPosition();\n    }), ch);\n\n    if (!autoClosingPair) {\n      return null;\n    }\n\n    var shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n\n      if (!selection.isEmpty()) {\n        return null;\n      }\n\n      var position = selection.getPosition();\n      var lineText = model.getLineContent(position.lineNumber); // Only consider auto closing the pair if a space follows or if another autoclosed pair follows\n\n      if (lineText.length > position.column - 1) {\n        var characterAfter = lineText.charAt(position.column - 1);\n\n        var isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, autoClosingPair, characterAfter);\n\n        if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n          return null;\n        }\n      }\n\n      if (!model.isCheapToTokenize(position.lineNumber)) {\n        // Do not force tokenization\n        return null;\n      } // Do not auto-close ' or \" after a word character\n\n\n      if (autoClosingPair.open.length === 1 && chIsQuote && autoCloseConfig !== 'always') {\n        var wordSeparators = getMapForWordSeparators(config.wordSeparators);\n\n        if (insertOpenCharacter && position.column > 1 && wordSeparators.get(lineText.charCodeAt(position.column - 2)) === 0\n        /* Regular */\n        ) {\n            return null;\n          }\n\n        if (!insertOpenCharacter && position.column > 2 && wordSeparators.get(lineText.charCodeAt(position.column - 3)) === 0\n        /* Regular */\n        ) {\n            return null;\n          }\n      }\n\n      model.forceTokenization(position.lineNumber);\n      var lineTokens = model.getLineTokens(position.lineNumber);\n      var shouldAutoClosePair = false;\n\n      try {\n        shouldAutoClosePair = LanguageConfigurationRegistry.shouldAutoClosePair(autoClosingPair, lineTokens, insertOpenCharacter ? position.column : position.column - 1);\n      } catch (e) {\n        onUnexpectedError(e);\n      }\n\n      if (!shouldAutoClosePair) {\n        return null;\n      }\n    }\n\n    return autoClosingPair;\n  };\n\n  TypeOperations._runAutoClosingOpenCharType = function (prevEditOperationType, config, model, selections, ch, insertOpenCharacter, autoClosingPair) {\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n      commands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, autoClosingPair.close);\n    }\n\n    return new EditOperationResult(1\n    /* Typing */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: false\n    });\n  };\n\n  TypeOperations._shouldSurroundChar = function (config, ch) {\n    if (isQuote(ch)) {\n      return config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined';\n    } else {\n      // Character is a bracket\n      return config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined';\n    }\n  };\n\n  TypeOperations._isSurroundSelectionType = function (config, model, selections, ch) {\n    if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n      return false;\n    }\n\n    var isTypingAQuoteCharacter = isQuote(ch);\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n\n      if (selection.isEmpty()) {\n        return false;\n      }\n\n      var selectionContainsOnlyWhitespace = true;\n\n      for (var lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n        var lineText = model.getLineContent(lineNumber);\n        var startIndex = lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0;\n        var endIndex = lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length;\n        var selectedText = lineText.substring(startIndex, endIndex);\n\n        if (/[^ \\t]/.test(selectedText)) {\n          // this selected text contains something other than whitespace\n          selectionContainsOnlyWhitespace = false;\n          break;\n        }\n      }\n\n      if (selectionContainsOnlyWhitespace) {\n        return false;\n      }\n\n      if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n        var selectionText = model.getValueInRange(selection);\n\n        if (isQuote(selectionText)) {\n          // Typing a quote character on top of another quote character\n          // => disable surround selection type\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  TypeOperations._runSurroundSelectionType = function (prevEditOperationType, config, model, selections, ch) {\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var selection = selections[i];\n      var closeCharacter = config.surroundingPairs[ch];\n      commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n    }\n\n    return new EditOperationResult(0\n    /* Other */\n    , commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  };\n\n  TypeOperations._isTypeInterceptorElectricChar = function (config, model, selections) {\n    if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  TypeOperations._typeInterceptorElectricChar = function (prevEditOperationType, config, model, selection, ch) {\n    if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n      return null;\n    }\n\n    var position = selection.getPosition();\n    model.forceTokenization(position.lineNumber);\n    var lineTokens = model.getLineTokens(position.lineNumber);\n    var electricAction;\n\n    try {\n      electricAction = LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);\n    } catch (e) {\n      onUnexpectedError(e);\n      return null;\n    }\n\n    if (!electricAction) {\n      return null;\n    }\n\n    if (electricAction.matchOpenBracket) {\n      var endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n      var match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {\n        lineNumber: position.lineNumber,\n        column: endColumn\n      });\n\n      if (match) {\n        if (match.startLineNumber === position.lineNumber) {\n          // matched something on the same line => no change in indentation\n          return null;\n        }\n\n        var matchLine = model.getLineContent(match.startLineNumber);\n        var matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n        var newIndentation = config.normalizeIndentation(matchLineIndentation);\n        var lineText = model.getLineContent(position.lineNumber);\n        var lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n        var prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n        var typeText = newIndentation + prefix + ch;\n        var typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n        var command = new ReplaceCommand(typeSelection, typeText);\n        return new EditOperationResult(1\n        /* Typing */\n        , [command], {\n          shouldPushStackElementBefore: false,\n          shouldPushStackElementAfter: true\n        });\n      }\n    }\n\n    return null;\n  };\n  /**\n   * This is very similar with typing, but the character is already in the text buffer!\n   */\n\n\n  TypeOperations.compositionEndWithInterceptors = function (prevEditOperationType, config, model, selections, autoClosedCharacters) {\n    var ch = null; // extract last typed character\n\n    for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {\n      var selection = selections_1[_i];\n\n      if (!selection.isEmpty()) {\n        return null;\n      }\n\n      var position = selection.getPosition();\n      var currentChar = model.getValueInRange(new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column));\n\n      if (ch === null) {\n        ch = currentChar;\n      } else if (ch !== currentChar) {\n        return null;\n      }\n    }\n\n    if (!ch) {\n      return null;\n    }\n\n    if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n      // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n      var commands = selections.map(function (s) {\n        return new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false);\n      });\n      return new EditOperationResult(1\n      /* Typing */\n      , commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n\n    var autoClosingPairOpenCharType = this._isAutoClosingOpenCharType(config, model, selections, ch, false);\n\n    if (autoClosingPairOpenCharType) {\n      return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairOpenCharType);\n    }\n\n    return null;\n  };\n\n  TypeOperations.typeWithInterceptors = function (prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n    if (ch === '\\n') {\n      var commands_1 = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        commands_1[i] = TypeOperations._enter(config, model, false, selections[i]);\n      }\n\n      return new EditOperationResult(1\n      /* Typing */\n      , commands_1, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n\n    if (this._isAutoIndentType(config, model, selections)) {\n      var commands_2 = [];\n      var autoIndentFails = false;\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        commands_2[i] = this._runAutoIndentType(config, model, selections[i], ch);\n\n        if (!commands_2[i]) {\n          autoIndentFails = true;\n          break;\n        }\n      }\n\n      if (!autoIndentFails) {\n        return new EditOperationResult(1\n        /* Typing */\n        , commands_2, {\n          shouldPushStackElementBefore: true,\n          shouldPushStackElementAfter: false\n        });\n      }\n    }\n\n    if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n      return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n    }\n\n    var autoClosingPairOpenCharType = this._isAutoClosingOpenCharType(config, model, selections, ch, true);\n\n    if (autoClosingPairOpenCharType) {\n      return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairOpenCharType);\n    }\n\n    if (this._isSurroundSelectionType(config, model, selections, ch)) {\n      return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n    } // Electric characters make sense only when dealing with a single cursor,\n    // as multiple cursors typing brackets for example would interfer with bracket matching\n\n\n    if (this._isTypeInterceptorElectricChar(config, model, selections)) {\n      var r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n\n      if (r) {\n        return r;\n      }\n    } // A simple character type\n\n\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], ch);\n    }\n\n    var shouldPushStackElementBefore = prevEditOperationType !== 1\n    /* Typing */\n    ;\n\n    if (ch === ' ') {\n      shouldPushStackElementBefore = true;\n    }\n\n    return new EditOperationResult(1\n    /* Typing */\n    , commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBefore,\n      shouldPushStackElementAfter: false\n    });\n  };\n\n  TypeOperations.typeWithoutInterceptors = function (prevEditOperationType, config, model, selections, str) {\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], str);\n    }\n\n    return new EditOperationResult(1\n    /* Typing */\n    , commands, {\n      shouldPushStackElementBefore: prevEditOperationType !== 1\n      /* Typing */\n      ,\n      shouldPushStackElementAfter: false\n    });\n  };\n\n  TypeOperations.lineInsertBefore = function (config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var lineNumber = selections[i].positionLineNumber;\n\n      if (lineNumber === 1) {\n        commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n      } else {\n        lineNumber--;\n        var column = model.getLineMaxColumn(lineNumber);\n        commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n      }\n    }\n\n    return commands;\n  };\n\n  TypeOperations.lineInsertAfter = function (config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      var lineNumber = selections[i].positionLineNumber;\n      var column = model.getLineMaxColumn(lineNumber);\n      commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n    }\n\n    return commands;\n  };\n\n  TypeOperations.lineBreakInsert = function (config, model, selections) {\n    var commands = [];\n\n    for (var i = 0, len = selections.length; i < len; i++) {\n      commands[i] = this._enter(config, model, true, selections[i]);\n    }\n\n    return commands;\n  };\n\n  return TypeOperations;\n}();\n\nexport { TypeOperations };\n\nvar TypeWithAutoClosingCommand =\n/** @class */\nfunction (_super) {\n  __extends(TypeWithAutoClosingCommand, _super);\n\n  function TypeWithAutoClosingCommand(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n    var _this = _super.call(this, selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length) || this;\n\n    _this._openCharacter = openCharacter;\n    _this._closeCharacter = closeCharacter;\n    _this.closeCharacterRange = null;\n    _this.enclosingRange = null;\n    return _this;\n  }\n\n  TypeWithAutoClosingCommand.prototype.computeCursorState = function (model, helper) {\n    var inverseEditOperations = helper.getInverseEditOperations();\n    var range = inverseEditOperations[0].range;\n    this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n    this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n    return _super.prototype.computeCursorState.call(this, model, helper);\n  };\n\n  return TypeWithAutoClosingCommand;\n}(ReplaceCommandWithOffsetCursorState);\n\nexport { TypeWithAutoClosingCommand };","map":null,"metadata":{},"sourceType":"module"}