{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport './quickopen.css';\nimport * as nls from '../../../../nls.js';\nimport * as platform from '../../../common/platform.js';\nimport * as types from '../../../common/types.js';\nimport { Filter, Renderer, DataSource, AccessibilityProvider } from './quickOpenViewer.js';\nimport { InputBox } from '../../../browser/ui/inputbox/inputBox.js';\nimport { Tree } from '../../tree/browser/treeImpl.js';\nimport { ProgressBar } from '../../../browser/ui/progressbar/progressbar.js';\nimport { StandardKeyboardEvent } from '../../../browser/keyboardEvent.js';\nimport { DefaultController } from '../../tree/browser/treeDefaults.js';\nimport * as DOM from '../../../browser/dom.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { Color } from '../../../common/color.js';\nimport { mixin } from '../../../common/objects.js';\nimport { StandardMouseEvent } from '../../../browser/mouseEvent.js';\n\nvar QuickOpenController =\n/** @class */\nfunction (_super) {\n  __extends(QuickOpenController, _super);\n\n  function QuickOpenController() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  QuickOpenController.prototype.onContextMenu = function (tree, element, event) {\n    if (platform.isMacintosh) {\n      return this.onLeftClick(tree, element, event); // https://github.com/Microsoft/vscode/issues/1011\n    }\n\n    return _super.prototype.onContextMenu.call(this, tree, element, event);\n  };\n\n  return QuickOpenController;\n}(DefaultController);\n\nexport { QuickOpenController };\nvar defaultStyles = {\n  background: Color.fromHex('#1E1E1E'),\n  foreground: Color.fromHex('#CCCCCC'),\n  pickerGroupForeground: Color.fromHex('#0097FB'),\n  pickerGroupBorder: Color.fromHex('#3F3F46'),\n  widgetShadow: Color.fromHex('#000000'),\n  progressBarBackground: Color.fromHex('#0E70C0')\n};\nvar DEFAULT_INPUT_ARIA_LABEL = nls.localize('quickOpenAriaLabel', \"Quick picker. Type to narrow down results.\");\n\nvar QuickOpenWidget =\n/** @class */\nfunction (_super) {\n  __extends(QuickOpenWidget, _super);\n\n  function QuickOpenWidget(container, callbacks, options) {\n    var _this = _super.call(this) || this;\n\n    _this.isDisposed = false;\n    _this.container = container;\n    _this.callbacks = callbacks;\n    _this.options = options;\n    _this.styles = options || Object.create(null);\n    mixin(_this.styles, defaultStyles, false);\n    _this.model = null;\n    return _this;\n  }\n\n  QuickOpenWidget.prototype.getModel = function () {\n    return this.model;\n  };\n\n  QuickOpenWidget.prototype.create = function () {\n    var _this = this; // Container\n\n\n    this.element = document.createElement('div');\n    DOM.addClass(this.element, 'monaco-quick-open-widget');\n    this.container.appendChild(this.element);\n\n    this._register(DOM.addDisposableListener(this.element, DOM.EventType.CONTEXT_MENU, function (e) {\n      return DOM.EventHelper.stop(e, true);\n    })); // Do this to fix an issue on Mac where the menu goes into the way\n\n\n    this._register(DOM.addDisposableListener(this.element, DOM.EventType.FOCUS, function (e) {\n      return _this.gainingFocus();\n    }, true));\n\n    this._register(DOM.addDisposableListener(this.element, DOM.EventType.BLUR, function (e) {\n      return _this.loosingFocus(e);\n    }, true));\n\n    this._register(DOM.addDisposableListener(this.element, DOM.EventType.KEY_DOWN, function (e) {\n      var keyboardEvent = new StandardKeyboardEvent(e);\n\n      if (keyboardEvent.keyCode === 9\n      /* Escape */\n      ) {\n          DOM.EventHelper.stop(e, true);\n\n          _this.hide(2\n          /* CANCELED */\n          );\n        } else if (keyboardEvent.keyCode === 2\n      /* Tab */\n      && !keyboardEvent.altKey && !keyboardEvent.ctrlKey && !keyboardEvent.metaKey) {\n        var stops = e.currentTarget.querySelectorAll('input, .monaco-tree, .monaco-tree-row.focused .action-label.icon');\n\n        if (keyboardEvent.shiftKey && keyboardEvent.target === stops[0]) {\n          DOM.EventHelper.stop(e, true);\n          stops[stops.length - 1].focus();\n        } else if (!keyboardEvent.shiftKey && keyboardEvent.target === stops[stops.length - 1]) {\n          DOM.EventHelper.stop(e, true);\n          stops[0].focus();\n        }\n      }\n    })); // Progress Bar\n\n\n    this.progressBar = this._register(new ProgressBar(this.element, {\n      progressBarBackground: this.styles.progressBarBackground\n    }));\n    this.progressBar.hide(); // Input Field\n\n    this.inputContainer = document.createElement('div');\n    DOM.addClass(this.inputContainer, 'quick-open-input');\n    this.element.appendChild(this.inputContainer);\n    this.inputBox = this._register(new InputBox(this.inputContainer, undefined, {\n      placeholder: this.options.inputPlaceHolder || '',\n      ariaLabel: DEFAULT_INPUT_ARIA_LABEL,\n      inputBackground: this.styles.inputBackground,\n      inputForeground: this.styles.inputForeground,\n      inputBorder: this.styles.inputBorder,\n      inputValidationInfoBackground: this.styles.inputValidationInfoBackground,\n      inputValidationInfoForeground: this.styles.inputValidationInfoForeground,\n      inputValidationInfoBorder: this.styles.inputValidationInfoBorder,\n      inputValidationWarningBackground: this.styles.inputValidationWarningBackground,\n      inputValidationWarningForeground: this.styles.inputValidationWarningForeground,\n      inputValidationWarningBorder: this.styles.inputValidationWarningBorder,\n      inputValidationErrorBackground: this.styles.inputValidationErrorBackground,\n      inputValidationErrorForeground: this.styles.inputValidationErrorForeground,\n      inputValidationErrorBorder: this.styles.inputValidationErrorBorder\n    }));\n    this.inputElement = this.inputBox.inputElement;\n    this.inputElement.setAttribute('role', 'combobox');\n    this.inputElement.setAttribute('aria-haspopup', 'false');\n    this.inputElement.setAttribute('aria-autocomplete', 'list');\n\n    this._register(DOM.addDisposableListener(this.inputBox.inputElement, DOM.EventType.INPUT, function (e) {\n      return _this.onType();\n    }));\n\n    this._register(DOM.addDisposableListener(this.inputBox.inputElement, DOM.EventType.KEY_DOWN, function (e) {\n      var keyboardEvent = new StandardKeyboardEvent(e);\n\n      var shouldOpenInBackground = _this.shouldOpenInBackground(keyboardEvent); // Do not handle Tab: It is used to navigate between elements without mouse\n\n\n      if (keyboardEvent.keyCode === 2\n      /* Tab */\n      ) {\n          return;\n        } // Pass tree navigation keys to the tree but leave focus in input field\n      else if (keyboardEvent.keyCode === 18\n        /* DownArrow */\n        || keyboardEvent.keyCode === 16\n        /* UpArrow */\n        || keyboardEvent.keyCode === 12\n        /* PageDown */\n        || keyboardEvent.keyCode === 11\n        /* PageUp */\n        ) {\n            DOM.EventHelper.stop(e, true);\n\n            _this.navigateInTree(keyboardEvent.keyCode, keyboardEvent.shiftKey); // Position cursor at the end of input to allow right arrow (open in background)\n            // to function immediately unless the user has made a selection\n\n\n            if (_this.inputBox.inputElement.selectionStart === _this.inputBox.inputElement.selectionEnd) {\n              _this.inputBox.inputElement.selectionStart = _this.inputBox.value.length;\n            }\n          } // Select element on Enter or on Arrow-Right if we are at the end of the input\n        else if (keyboardEvent.keyCode === 3\n          /* Enter */\n          || shouldOpenInBackground) {\n            DOM.EventHelper.stop(e, true);\n\n            var focus_1 = _this.tree.getFocus();\n\n            if (focus_1) {\n              _this.elementSelected(focus_1, e, shouldOpenInBackground ? 2\n              /* OPEN_IN_BACKGROUND */\n              : 1\n              /* OPEN */\n              );\n            }\n          }\n    })); // Result count for screen readers\n\n\n    this.resultCount = document.createElement('div');\n    DOM.addClass(this.resultCount, 'quick-open-result-count');\n    this.resultCount.setAttribute('aria-live', 'polite');\n    this.resultCount.setAttribute('aria-atomic', 'true');\n    this.element.appendChild(this.resultCount); // Tree\n\n    this.treeContainer = document.createElement('div');\n    DOM.addClass(this.treeContainer, 'quick-open-tree');\n    this.element.appendChild(this.treeContainer);\n\n    var createTree = this.options.treeCreator || function (container, config, opts) {\n      return new Tree(container, config, opts);\n    };\n\n    this.tree = this._register(createTree(this.treeContainer, {\n      dataSource: new DataSource(this),\n      controller: new QuickOpenController({\n        clickBehavior: 1\n        /* ON_MOUSE_UP */\n        ,\n        keyboardSupport: this.options.keyboardSupport\n      }),\n      renderer: this.renderer = new Renderer(this, this.styles),\n      filter: new Filter(this),\n      accessibilityProvider: new AccessibilityProvider(this)\n    }, {\n      twistiePixels: 11,\n      indentPixels: 0,\n      alwaysFocused: true,\n      verticalScrollMode: 3\n      /* Visible */\n      ,\n      horizontalScrollMode: 2\n      /* Hidden */\n      ,\n      ariaLabel: nls.localize('treeAriaLabel', \"Quick Picker\"),\n      keyboardSupport: this.options.keyboardSupport,\n      preventRootFocus: false\n    }));\n    this.treeElement = this.tree.getHTMLElement(); // Handle Focus and Selection event\n\n    this._register(this.tree.onDidChangeFocus(function (event) {\n      _this.elementFocused(event.focus, event);\n    }));\n\n    this._register(this.tree.onDidChangeSelection(function (event) {\n      if (event.selection && event.selection.length > 0) {\n        var mouseEvent = event.payload && event.payload.originalEvent instanceof StandardMouseEvent ? event.payload.originalEvent : undefined;\n        var shouldOpenInBackground = mouseEvent ? _this.shouldOpenInBackground(mouseEvent) : false;\n\n        _this.elementSelected(event.selection[0], event, shouldOpenInBackground ? 2\n        /* OPEN_IN_BACKGROUND */\n        : 1\n        /* OPEN */\n        );\n      }\n    }));\n\n    this._register(DOM.addDisposableListener(this.treeContainer, DOM.EventType.KEY_DOWN, function (e) {\n      var keyboardEvent = new StandardKeyboardEvent(e); // Only handle when in quick navigation mode\n\n      if (!_this.quickNavigateConfiguration) {\n        return;\n      } // Support keyboard navigation in quick navigation mode\n\n\n      if (keyboardEvent.keyCode === 18\n      /* DownArrow */\n      || keyboardEvent.keyCode === 16\n      /* UpArrow */\n      || keyboardEvent.keyCode === 12\n      /* PageDown */\n      || keyboardEvent.keyCode === 11\n      /* PageUp */\n      ) {\n          DOM.EventHelper.stop(e, true);\n\n          _this.navigateInTree(keyboardEvent.keyCode);\n        }\n    }));\n\n    this._register(DOM.addDisposableListener(this.treeContainer, DOM.EventType.KEY_UP, function (e) {\n      var keyboardEvent = new StandardKeyboardEvent(e);\n      var keyCode = keyboardEvent.keyCode; // Only handle when in quick navigation mode\n\n      if (!_this.quickNavigateConfiguration) {\n        return;\n      } // Select element when keys are pressed that signal it\n\n\n      var quickNavKeys = _this.quickNavigateConfiguration.keybindings;\n      var wasTriggerKeyPressed = keyCode === 3\n      /* Enter */\n      || quickNavKeys.some(function (k) {\n        var _a = k.getParts(),\n            firstPart = _a[0],\n            chordPart = _a[1];\n\n        if (chordPart) {\n          return false;\n        }\n\n        if (firstPart.shiftKey && keyCode === 4\n        /* Shift */\n        ) {\n            if (keyboardEvent.ctrlKey || keyboardEvent.altKey || keyboardEvent.metaKey) {\n              return false; // this is an optimistic check for the shift key being used to navigate back in quick open\n            }\n\n            return true;\n          }\n\n        if (firstPart.altKey && keyCode === 6\n        /* Alt */\n        ) {\n            return true;\n          }\n\n        if (firstPart.ctrlKey && keyCode === 5\n        /* Ctrl */\n        ) {\n            return true;\n          }\n\n        if (firstPart.metaKey && keyCode === 57\n        /* Meta */\n        ) {\n            return true;\n          }\n\n        return false;\n      });\n\n      if (wasTriggerKeyPressed) {\n        var focus_2 = _this.tree.getFocus();\n\n        if (focus_2) {\n          _this.elementSelected(focus_2, e);\n        }\n      }\n    })); // Support layout\n\n\n    if (this.layoutDimensions) {\n      this.layout(this.layoutDimensions);\n    }\n\n    this.applyStyles(); // Allows focus to switch to next/previous entry after tab into an actionbar item\n\n    this._register(DOM.addDisposableListener(this.treeContainer, DOM.EventType.KEY_DOWN, function (e) {\n      var keyboardEvent = new StandardKeyboardEvent(e); // Only handle when not in quick navigation mode\n\n      if (_this.quickNavigateConfiguration) {\n        return;\n      }\n\n      if (keyboardEvent.keyCode === 18\n      /* DownArrow */\n      || keyboardEvent.keyCode === 16\n      /* UpArrow */\n      || keyboardEvent.keyCode === 12\n      /* PageDown */\n      || keyboardEvent.keyCode === 11\n      /* PageUp */\n      ) {\n          DOM.EventHelper.stop(e, true);\n\n          _this.navigateInTree(keyboardEvent.keyCode, keyboardEvent.shiftKey);\n\n          _this.treeElement.focus();\n        }\n    }));\n\n    return this.element;\n  };\n\n  QuickOpenWidget.prototype.style = function (styles) {\n    this.styles = styles;\n    this.applyStyles();\n  };\n\n  QuickOpenWidget.prototype.applyStyles = function () {\n    if (this.element) {\n      var foreground = this.styles.foreground ? this.styles.foreground.toString() : null;\n      var background = this.styles.background ? this.styles.background.toString() : null;\n      var borderColor = this.styles.borderColor ? this.styles.borderColor.toString() : null;\n      var widgetShadow = this.styles.widgetShadow ? this.styles.widgetShadow.toString() : null;\n      this.element.style.color = foreground;\n      this.element.style.backgroundColor = background;\n      this.element.style.borderColor = borderColor;\n      this.element.style.borderWidth = borderColor ? '1px' : null;\n      this.element.style.borderStyle = borderColor ? 'solid' : null;\n      this.element.style.boxShadow = widgetShadow ? \"0 5px 8px \" + widgetShadow : null;\n    }\n\n    if (this.progressBar) {\n      this.progressBar.style({\n        progressBarBackground: this.styles.progressBarBackground\n      });\n    }\n\n    if (this.inputBox) {\n      this.inputBox.style({\n        inputBackground: this.styles.inputBackground,\n        inputForeground: this.styles.inputForeground,\n        inputBorder: this.styles.inputBorder,\n        inputValidationInfoBackground: this.styles.inputValidationInfoBackground,\n        inputValidationInfoForeground: this.styles.inputValidationInfoForeground,\n        inputValidationInfoBorder: this.styles.inputValidationInfoBorder,\n        inputValidationWarningBackground: this.styles.inputValidationWarningBackground,\n        inputValidationWarningForeground: this.styles.inputValidationWarningForeground,\n        inputValidationWarningBorder: this.styles.inputValidationWarningBorder,\n        inputValidationErrorBackground: this.styles.inputValidationErrorBackground,\n        inputValidationErrorForeground: this.styles.inputValidationErrorForeground,\n        inputValidationErrorBorder: this.styles.inputValidationErrorBorder\n      });\n    }\n\n    if (this.tree && !this.options.treeCreator) {\n      this.tree.style(this.styles);\n    }\n\n    if (this.renderer) {\n      this.renderer.updateStyles(this.styles);\n    }\n  };\n\n  QuickOpenWidget.prototype.shouldOpenInBackground = function (e) {\n    // Keyboard\n    if (e instanceof StandardKeyboardEvent) {\n      if (e.keyCode !== 17\n      /* RightArrow */\n      ) {\n          return false; // only for right arrow\n        }\n\n      if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) {\n        return false; // no modifiers allowed\n      } // validate the cursor is at the end of the input and there is no selection,\n      // and if not prevent opening in the background such as the selection can be changed\n\n\n      var element = this.inputBox.inputElement;\n      return element.selectionEnd === this.inputBox.value.length && element.selectionStart === element.selectionEnd;\n    } // Mouse\n\n\n    return e.middleButton;\n  };\n\n  QuickOpenWidget.prototype.onType = function () {\n    var value = this.inputBox.value; // Adjust help text as needed if present\n\n    if (this.helpText) {\n      if (value) {\n        DOM.hide(this.helpText);\n      } else {\n        DOM.show(this.helpText);\n      }\n    } // Send to callbacks\n\n\n    this.callbacks.onType(value);\n  };\n\n  QuickOpenWidget.prototype.navigateInTree = function (keyCode, isShift) {\n    var model = this.tree.getInput();\n    var entries = model ? model.entries : [];\n    var oldFocus = this.tree.getFocus(); // Normal Navigation\n\n    switch (keyCode) {\n      case 18\n      /* DownArrow */\n      :\n        this.tree.focusNext();\n        break;\n\n      case 16\n      /* UpArrow */\n      :\n        this.tree.focusPrevious();\n        break;\n\n      case 12\n      /* PageDown */\n      :\n        this.tree.focusNextPage();\n        break;\n\n      case 11\n      /* PageUp */\n      :\n        this.tree.focusPreviousPage();\n        break;\n\n      case 2\n      /* Tab */\n      :\n        if (isShift) {\n          this.tree.focusPrevious();\n        } else {\n          this.tree.focusNext();\n        }\n\n        break;\n    }\n\n    var newFocus = this.tree.getFocus(); // Support cycle-through navigation if focus did not change\n\n    if (entries.length > 1 && oldFocus === newFocus) {\n      // Up from no entry or first entry goes down to last\n      if (keyCode === 16\n      /* UpArrow */\n      || keyCode === 2\n      /* Tab */\n      && isShift) {\n        this.tree.focusLast();\n      } // Down from last entry goes to up to first\n      else if (keyCode === 18\n        /* DownArrow */\n        || keyCode === 2\n        /* Tab */\n        && !isShift) {\n          this.tree.focusFirst();\n        }\n    } // Reveal\n\n\n    newFocus = this.tree.getFocus();\n\n    if (newFocus) {\n      this.tree.reveal(newFocus);\n    }\n  };\n\n  QuickOpenWidget.prototype.elementFocused = function (value, event) {\n    if (!value || !this.isVisible()) {\n      return;\n    } // ARIA\n\n\n    var arivaActiveDescendant = this.treeElement.getAttribute('aria-activedescendant');\n\n    if (arivaActiveDescendant) {\n      this.inputElement.setAttribute('aria-activedescendant', arivaActiveDescendant);\n    } else {\n      this.inputElement.removeAttribute('aria-activedescendant');\n    }\n\n    var context = {\n      event: event,\n      keymods: this.extractKeyMods(event),\n      quickNavigateConfiguration: this.quickNavigateConfiguration\n    };\n    this.model.runner.run(value, 0\n    /* PREVIEW */\n    , context);\n  };\n\n  QuickOpenWidget.prototype.elementSelected = function (value, event, preferredMode) {\n    var hide = true; // Trigger open of element on selection\n\n    if (this.isVisible()) {\n      var mode = preferredMode || 1\n      /* OPEN */\n      ;\n      var context = {\n        event: event,\n        keymods: this.extractKeyMods(event),\n        quickNavigateConfiguration: this.quickNavigateConfiguration\n      };\n      hide = this.model.runner.run(value, mode, context);\n    } // Hide if command was run successfully\n\n\n    if (hide) {\n      this.hide(0\n      /* ELEMENT_SELECTED */\n      );\n    }\n  };\n\n  QuickOpenWidget.prototype.extractKeyMods = function (event) {\n    return {\n      ctrlCmd: event && (event.ctrlKey || event.metaKey || event.payload && event.payload.originalEvent && (event.payload.originalEvent.ctrlKey || event.payload.originalEvent.metaKey)),\n      alt: event && (event.altKey || event.payload && event.payload.originalEvent && event.payload.originalEvent.altKey)\n    };\n  };\n\n  QuickOpenWidget.prototype.show = function (param, options) {\n    this.visible = true;\n    this.isLoosingFocus = false;\n    this.quickNavigateConfiguration = options ? options.quickNavigateConfiguration : undefined; // Adjust UI for quick navigate mode\n\n    if (this.quickNavigateConfiguration) {\n      DOM.hide(this.inputContainer);\n      DOM.show(this.element);\n      this.tree.domFocus();\n    } // Otherwise use normal UI\n    else {\n        DOM.show(this.inputContainer);\n        DOM.show(this.element);\n        this.inputBox.focus();\n      } // Adjust Help text for IE\n\n\n    if (this.helpText) {\n      if (this.quickNavigateConfiguration || types.isString(param)) {\n        DOM.hide(this.helpText);\n      } else {\n        DOM.show(this.helpText);\n      }\n    } // Show based on param\n\n\n    if (types.isString(param)) {\n      this.doShowWithPrefix(param);\n    } else {\n      if (options && options.value) {\n        this.restoreLastInput(options.value);\n      }\n\n      this.doShowWithInput(param, options && options.autoFocus ? options.autoFocus : {});\n    } // Respect selectAll option\n\n\n    if (options && options.inputSelection && !this.quickNavigateConfiguration) {\n      this.inputBox.select(options.inputSelection);\n    }\n\n    if (this.callbacks.onShow) {\n      this.callbacks.onShow();\n    }\n  };\n\n  QuickOpenWidget.prototype.restoreLastInput = function (lastInput) {\n    this.inputBox.value = lastInput;\n    this.inputBox.select();\n    this.callbacks.onType(lastInput);\n  };\n\n  QuickOpenWidget.prototype.doShowWithPrefix = function (prefix) {\n    this.inputBox.value = prefix;\n    this.callbacks.onType(prefix);\n  };\n\n  QuickOpenWidget.prototype.doShowWithInput = function (input, autoFocus) {\n    this.setInput(input, autoFocus);\n  };\n\n  QuickOpenWidget.prototype.setInputAndLayout = function (input, autoFocus) {\n    var _this = this;\n\n    this.treeContainer.style.height = this.getHeight(input) + \"px\";\n    this.tree.setInput(null).then(function () {\n      _this.model = input; // ARIA\n\n      _this.inputElement.setAttribute('aria-haspopup', String(input && input.entries && input.entries.length > 0));\n\n      return _this.tree.setInput(input);\n    }).then(function () {\n      // Indicate entries to tree\n      _this.tree.layout();\n\n      var entries = input ? input.entries.filter(function (e) {\n        return _this.isElementVisible(input, e);\n      }) : [];\n\n      _this.updateResultCount(entries.length); // Handle auto focus\n\n\n      if (entries.length) {\n        _this.autoFocus(input, entries, autoFocus);\n      }\n    });\n  };\n\n  QuickOpenWidget.prototype.isElementVisible = function (input, e) {\n    if (!input.filter) {\n      return true;\n    }\n\n    return input.filter.isVisible(e);\n  };\n\n  QuickOpenWidget.prototype.autoFocus = function (input, entries, autoFocus) {\n    if (autoFocus === void 0) {\n      autoFocus = {};\n    } // First check for auto focus of prefix matches\n\n\n    if (autoFocus.autoFocusPrefixMatch) {\n      var caseSensitiveMatch = void 0;\n      var caseInsensitiveMatch = void 0;\n      var prefix = autoFocus.autoFocusPrefixMatch;\n      var lowerCasePrefix = prefix.toLowerCase();\n\n      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n        var entry = entries_1[_i];\n        var label = input.dataSource.getLabel(entry) || '';\n\n        if (!caseSensitiveMatch && label.indexOf(prefix) === 0) {\n          caseSensitiveMatch = entry;\n        } else if (!caseInsensitiveMatch && label.toLowerCase().indexOf(lowerCasePrefix) === 0) {\n          caseInsensitiveMatch = entry;\n        }\n\n        if (caseSensitiveMatch && caseInsensitiveMatch) {\n          break;\n        }\n      }\n\n      var entryToFocus = caseSensitiveMatch || caseInsensitiveMatch;\n\n      if (entryToFocus) {\n        this.tree.setFocus(entryToFocus);\n        this.tree.reveal(entryToFocus, 0.5);\n        return;\n      }\n    } // Second check for auto focus of first entry\n\n\n    if (autoFocus.autoFocusFirstEntry) {\n      this.tree.focusFirst();\n      this.tree.reveal(this.tree.getFocus());\n    } // Third check for specific index option\n    else if (typeof autoFocus.autoFocusIndex === 'number') {\n        if (entries.length > autoFocus.autoFocusIndex) {\n          this.tree.focusNth(autoFocus.autoFocusIndex);\n          this.tree.reveal(this.tree.getFocus());\n        }\n      } // Check for auto focus of second entry\n      else if (autoFocus.autoFocusSecondEntry) {\n          if (entries.length > 1) {\n            this.tree.focusNth(1);\n          }\n        } // Finally check for auto focus of last entry\n        else if (autoFocus.autoFocusLastEntry) {\n            if (entries.length > 1) {\n              this.tree.focusLast();\n            }\n          }\n  };\n\n  QuickOpenWidget.prototype.getHeight = function (input) {\n    var _this = this;\n\n    var renderer = input.renderer;\n\n    if (!input) {\n      var itemHeight = renderer.getHeight(null);\n      return this.options.minItemsToShow ? this.options.minItemsToShow * itemHeight : 0;\n    }\n\n    var height = 0;\n    var preferredItemsHeight;\n\n    if (this.layoutDimensions && this.layoutDimensions.height) {\n      preferredItemsHeight = (this.layoutDimensions.height - 50\n      /* subtract height of input field (30px) and some spacing (drop shadow) to fit */\n      ) * 0.4\n      /* max 40% of screen */\n      ;\n    }\n\n    if (!preferredItemsHeight || preferredItemsHeight > QuickOpenWidget.MAX_ITEMS_HEIGHT) {\n      preferredItemsHeight = QuickOpenWidget.MAX_ITEMS_HEIGHT;\n    }\n\n    var entries = input.entries.filter(function (e) {\n      return _this.isElementVisible(input, e);\n    });\n    var maxEntries = this.options.maxItemsToShow || entries.length;\n\n    for (var i = 0; i < maxEntries && i < entries.length; i++) {\n      var entryHeight = renderer.getHeight(entries[i]);\n\n      if (height + entryHeight <= preferredItemsHeight) {\n        height += entryHeight;\n      } else {\n        break;\n      }\n    }\n\n    return height;\n  };\n\n  QuickOpenWidget.prototype.updateResultCount = function (count) {\n    this.resultCount.textContent = nls.localize({\n      key: 'quickInput.visibleCount',\n      comment: ['This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers.']\n    }, \"{0} Results\", count);\n  };\n\n  QuickOpenWidget.prototype.hide = function (reason) {\n    if (!this.isVisible()) {\n      return;\n    }\n\n    this.visible = false;\n    DOM.hide(this.element);\n    this.element.blur(); // Clear input field and clear tree\n\n    this.inputBox.value = '';\n    this.tree.setInput(null); // ARIA\n\n    this.inputElement.setAttribute('aria-haspopup', 'false'); // Reset Tree Height\n\n    this.treeContainer.style.height = (this.options.minItemsToShow ? this.options.minItemsToShow * 22 : 0) + \"px\"; // Clear any running Progress\n\n    this.progressBar.stop().hide(); // Clear Focus\n\n    if (this.tree.isDOMFocused()) {\n      this.tree.domBlur();\n    } else if (this.inputBox.hasFocus()) {\n      this.inputBox.blur();\n    } // Callbacks\n\n\n    if (reason === 0\n    /* ELEMENT_SELECTED */\n    ) {\n        this.callbacks.onOk();\n      } else {\n      this.callbacks.onCancel();\n    }\n\n    if (this.callbacks.onHide) {\n      this.callbacks.onHide(reason);\n    }\n  };\n\n  QuickOpenWidget.prototype.setInput = function (input, autoFocus, ariaLabel) {\n    if (!this.isVisible()) {\n      return;\n    } // If the input changes, indicate this to the tree\n\n\n    if (!!this.getInput()) {\n      this.onInputChanging();\n    } // Adapt tree height to entries and apply input\n\n\n    this.setInputAndLayout(input, autoFocus); // Apply ARIA\n\n    if (this.inputBox) {\n      this.inputBox.setAriaLabel(ariaLabel || DEFAULT_INPUT_ARIA_LABEL);\n    }\n  };\n\n  QuickOpenWidget.prototype.onInputChanging = function () {\n    var _this = this;\n\n    if (this.inputChangingTimeoutHandle) {\n      clearTimeout(this.inputChangingTimeoutHandle);\n      this.inputChangingTimeoutHandle = null;\n    } // when the input is changing in quick open, we indicate this as CSS class to the widget\n    // for a certain timeout. this helps reducing some hectic UI updates when input changes quickly\n\n\n    DOM.addClass(this.element, 'content-changing');\n    this.inputChangingTimeoutHandle = setTimeout(function () {\n      DOM.removeClass(_this.element, 'content-changing');\n    }, 500);\n  };\n\n  QuickOpenWidget.prototype.getInput = function () {\n    return this.tree.getInput();\n  };\n\n  QuickOpenWidget.prototype.isVisible = function () {\n    return this.visible;\n  };\n\n  QuickOpenWidget.prototype.layout = function (dimension) {\n    this.layoutDimensions = dimension; // Apply to quick open width (height is dynamic by number of items to show)\n\n    var quickOpenWidth = Math.min(this.layoutDimensions.width * 0.62\n    /* golden cut */\n    , QuickOpenWidget.MAX_WIDTH);\n\n    if (this.element) {\n      // quick open\n      this.element.style.width = quickOpenWidth + \"px\";\n      this.element.style.marginLeft = \"-\" + quickOpenWidth / 2 + \"px\"; // input field\n\n      this.inputContainer.style.width = quickOpenWidth - 12 + \"px\";\n    }\n  };\n\n  QuickOpenWidget.prototype.gainingFocus = function () {\n    this.isLoosingFocus = false;\n  };\n\n  QuickOpenWidget.prototype.loosingFocus = function (e) {\n    var _this = this;\n\n    if (!this.isVisible()) {\n      return;\n    }\n\n    var relatedTarget = e.relatedTarget;\n\n    if (!this.quickNavigateConfiguration && DOM.isAncestor(relatedTarget, this.element)) {\n      return; // user clicked somewhere into quick open widget, do not close thereby\n    }\n\n    this.isLoosingFocus = true;\n    setTimeout(function () {\n      if (!_this.isLoosingFocus || _this.isDisposed) {\n        return;\n      }\n\n      var veto = _this.callbacks.onFocusLost && _this.callbacks.onFocusLost();\n\n      if (!veto) {\n        _this.hide(1\n        /* FOCUS_LOST */\n        );\n      }\n    }, 0);\n  };\n\n  QuickOpenWidget.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.isDisposed = true;\n  };\n\n  QuickOpenWidget.MAX_WIDTH = 600; // Max total width of quick open widget\n\n  QuickOpenWidget.MAX_ITEMS_HEIGHT = 20 * 22; // Max height of item list below input field\n\n  return QuickOpenWidget;\n}(Disposable);\n\nexport { QuickOpenWidget };","map":null,"metadata":{},"sourceType":"module"}